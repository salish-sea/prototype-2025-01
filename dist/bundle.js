/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/color-parse/index.js":
/*!*******************************************!*\
  !*** ./node_modules/color-parse/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var color_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! color-name */ "./node_modules/color-parse/node_modules/color-name/index.js");
/**
 * @module color-parse
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */
//FIXME: use external hue detector
var baseHues = {
	red: 0,
	orange: 60,
	yellow: 120,
	green: 180,
	blue: 240,
	purple: 300
}

/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */
function parse(cstr) {
	var m, parts = [], alpha = 1, space

	//numeric case
	if (typeof cstr === 'number') {
		return { space: 'rgb', values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff], alpha: 1 }
	}
	if (typeof cstr === 'number') return { space: 'rgb', values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff], alpha: 1 }

	cstr = String(cstr).toLowerCase();

	//keyword
	if (color_name__WEBPACK_IMPORTED_MODULE_0__["default"][cstr]) {
		parts = color_name__WEBPACK_IMPORTED_MODULE_0__["default"][cstr].slice()
		space = 'rgb'
	}

	//reserved words
	else if (cstr === 'transparent') {
		alpha = 0
		space = 'rgb'
		parts = [0, 0, 0]
	}

	//hex
	else if (cstr[0] === '#') {
		var base = cstr.slice(1)
		var size = base.length
		var isShort = size <= 4
		alpha = 1

		if (isShort) {
			parts = [
				parseInt(base[0] + base[0], 16),
				parseInt(base[1] + base[1], 16),
				parseInt(base[2] + base[2], 16)
			]
			if (size === 4) {
				alpha = parseInt(base[3] + base[3], 16) / 255
			}
		}
		else {
			parts = [
				parseInt(base[0] + base[1], 16),
				parseInt(base[2] + base[3], 16),
				parseInt(base[4] + base[5], 16)
			]
			if (size === 8) {
				alpha = parseInt(base[6] + base[7], 16) / 255
			}
		}

		if (!parts[0]) parts[0] = 0
		if (!parts[1]) parts[1] = 0
		if (!parts[2]) parts[2] = 0

		space = 'rgb'
	}

	// color space
	else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
		var name = m[1]
		space = name.replace(/a$/, '')
		var dims = space === 'cmyk' ? 4 : space === 'gray' ? 1 : 3
		parts = m[2].trim().split(/\s*[,\/]\s*|\s+/)

		// color(srgb-linear x x x) -> srgb-linear(x x x)
		if (space === 'color') space = parts.shift()

		parts = parts.map(function (x, i) {
			//<percentage>
			if (x[x.length - 1] === '%') {
				x = parseFloat(x) / 100
				// alpha -> 0..1
				if (i === 3) return x
				// rgb -> 0..255
				if (space === 'rgb') return x * 255
				// hsl, hwb H -> 0..100
				if (space[0] === 'h') return x * 100
				// lch, lab L -> 0..100
				if (space[0] === 'l' && !i) return x * 100
				// lab A B -> -125..125
				if (space === 'lab') return x * 125
				// lch C -> 0..150, H -> 0..360
				if (space === 'lch') return i < 2 ? x * 150 : x * 360
				// oklch/oklab L -> 0..1
				if (space[0] === 'o' && !i) return x
				// oklab A B -> -0.4..0.4
				if (space === 'oklab') return x * 0.4
				// oklch C -> 0..0.4, H -> 0..360
				if (space === 'oklch') return i < 2 ? x * 0.4 : x * 360
				// color(xxx) -> 0..1
				return x
			}

			//hue
			if (space[i] === 'h' || (i === 2 && space[space.length - 1] === 'h')) {
				//<base-hue>
				if (baseHues[x] !== undefined) return baseHues[x]
				//<deg>
				if (x.endsWith('deg')) return parseFloat(x)
				//<turn>
				if (x.endsWith('turn')) return parseFloat(x) * 360
				if (x.endsWith('grad')) return parseFloat(x) * 360 / 400
				if (x.endsWith('rad')) return parseFloat(x) * 180 / Math.PI
			}
			if (x === 'none') return 0
			return parseFloat(x)
		});

		alpha = parts.length > dims ? parts.pop() : 1
	}

	//named channels case
	else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
		parts = cstr.match(/([0-9]+)/g).map(function (value) {
			return parseFloat(value)
		})

		space = cstr.match(/([a-z])/ig)?.join('')?.toLowerCase() || 'rgb'
	}

	return {
		space,
		values: parts,
		alpha
	}
}


/***/ }),

/***/ "./node_modules/color-parse/node_modules/color-name/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/color-parse/node_modules/color-name/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	aliceblue: [240, 248, 255],
	antiquewhite: [250, 235, 215],
	aqua: [0, 255, 255],
	aquamarine: [127, 255, 212],
	azure: [240, 255, 255],
	beige: [245, 245, 220],
	bisque: [255, 228, 196],
	black: [0, 0, 0],
	blanchedalmond: [255, 235, 205],
	blue: [0, 0, 255],
	blueviolet: [138, 43, 226],
	brown: [165, 42, 42],
	burlywood: [222, 184, 135],
	cadetblue: [95, 158, 160],
	chartreuse: [127, 255, 0],
	chocolate: [210, 105, 30],
	coral: [255, 127, 80],
	cornflowerblue: [100, 149, 237],
	cornsilk: [255, 248, 220],
	crimson: [220, 20, 60],
	cyan: [0, 255, 255],
	darkblue: [0, 0, 139],
	darkcyan: [0, 139, 139],
	darkgoldenrod: [184, 134, 11],
	darkgray: [169, 169, 169],
	darkgreen: [0, 100, 0],
	darkgrey: [169, 169, 169],
	darkkhaki: [189, 183, 107],
	darkmagenta: [139, 0, 139],
	darkolivegreen: [85, 107, 47],
	darkorange: [255, 140, 0],
	darkorchid: [153, 50, 204],
	darkred: [139, 0, 0],
	darksalmon: [233, 150, 122],
	darkseagreen: [143, 188, 143],
	darkslateblue: [72, 61, 139],
	darkslategray: [47, 79, 79],
	darkslategrey: [47, 79, 79],
	darkturquoise: [0, 206, 209],
	darkviolet: [148, 0, 211],
	deeppink: [255, 20, 147],
	deepskyblue: [0, 191, 255],
	dimgray: [105, 105, 105],
	dimgrey: [105, 105, 105],
	dodgerblue: [30, 144, 255],
	firebrick: [178, 34, 34],
	floralwhite: [255, 250, 240],
	forestgreen: [34, 139, 34],
	fuchsia: [255, 0, 255],
	gainsboro: [220, 220, 220],
	ghostwhite: [248, 248, 255],
	gold: [255, 215, 0],
	goldenrod: [218, 165, 32],
	gray: [128, 128, 128],
	green: [0, 128, 0],
	greenyellow: [173, 255, 47],
	grey: [128, 128, 128],
	honeydew: [240, 255, 240],
	hotpink: [255, 105, 180],
	indianred: [205, 92, 92],
	indigo: [75, 0, 130],
	ivory: [255, 255, 240],
	khaki: [240, 230, 140],
	lavender: [230, 230, 250],
	lavenderblush: [255, 240, 245],
	lawngreen: [124, 252, 0],
	lemonchiffon: [255, 250, 205],
	lightblue: [173, 216, 230],
	lightcoral: [240, 128, 128],
	lightcyan: [224, 255, 255],
	lightgoldenrodyellow: [250, 250, 210],
	lightgray: [211, 211, 211],
	lightgreen: [144, 238, 144],
	lightgrey: [211, 211, 211],
	lightpink: [255, 182, 193],
	lightsalmon: [255, 160, 122],
	lightseagreen: [32, 178, 170],
	lightskyblue: [135, 206, 250],
	lightslategray: [119, 136, 153],
	lightslategrey: [119, 136, 153],
	lightsteelblue: [176, 196, 222],
	lightyellow: [255, 255, 224],
	lime: [0, 255, 0],
	limegreen: [50, 205, 50],
	linen: [250, 240, 230],
	magenta: [255, 0, 255],
	maroon: [128, 0, 0],
	mediumaquamarine: [102, 205, 170],
	mediumblue: [0, 0, 205],
	mediumorchid: [186, 85, 211],
	mediumpurple: [147, 112, 219],
	mediumseagreen: [60, 179, 113],
	mediumslateblue: [123, 104, 238],
	mediumspringgreen: [0, 250, 154],
	mediumturquoise: [72, 209, 204],
	mediumvioletred: [199, 21, 133],
	midnightblue: [25, 25, 112],
	mintcream: [245, 255, 250],
	mistyrose: [255, 228, 225],
	moccasin: [255, 228, 181],
	navajowhite: [255, 222, 173],
	navy: [0, 0, 128],
	oldlace: [253, 245, 230],
	olive: [128, 128, 0],
	olivedrab: [107, 142, 35],
	orange: [255, 165, 0],
	orangered: [255, 69, 0],
	orchid: [218, 112, 214],
	palegoldenrod: [238, 232, 170],
	palegreen: [152, 251, 152],
	paleturquoise: [175, 238, 238],
	palevioletred: [219, 112, 147],
	papayawhip: [255, 239, 213],
	peachpuff: [255, 218, 185],
	peru: [205, 133, 63],
	pink: [255, 192, 203],
	plum: [221, 160, 221],
	powderblue: [176, 224, 230],
	purple: [128, 0, 128],
	rebeccapurple: [102, 51, 153],
	red: [255, 0, 0],
	rosybrown: [188, 143, 143],
	royalblue: [65, 105, 225],
	saddlebrown: [139, 69, 19],
	salmon: [250, 128, 114],
	sandybrown: [244, 164, 96],
	seagreen: [46, 139, 87],
	seashell: [255, 245, 238],
	sienna: [160, 82, 45],
	silver: [192, 192, 192],
	skyblue: [135, 206, 235],
	slateblue: [106, 90, 205],
	slategray: [112, 128, 144],
	slategrey: [112, 128, 144],
	snow: [255, 250, 250],
	springgreen: [0, 255, 127],
	steelblue: [70, 130, 180],
	tan: [210, 180, 140],
	teal: [0, 128, 128],
	thistle: [216, 191, 216],
	tomato: [255, 99, 71],
	turquoise: [64, 224, 208],
	violet: [238, 130, 238],
	wheat: [245, 222, 179],
	white: [255, 255, 255],
	whitesmoke: [245, 245, 245],
	yellow: [255, 255, 0],
	yellowgreen: [154, 205, 50]
});


/***/ }),

/***/ "./node_modules/color-rgba/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-rgba/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rgba)
/* harmony export */ });
/* harmony import */ var color_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! color-parse */ "./node_modules/color-parse/index.js");
/* harmony import */ var color_space_rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! color-space/rgb.js */ "./node_modules/color-space/rgb.js");
/* harmony import */ var color_space_hsl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! color-space/hsl.js */ "./node_modules/color-space/hsl.js");
/** @module  color-rgba */




function rgba(color) {
	// template literals
	if (Array.isArray(color) && color.raw) color = String.raw(...arguments)
	if (color instanceof Number) color = +color

	var values, i, l

	//attempt to parse non-array arguments
	var parsed = (0,color_parse__WEBPACK_IMPORTED_MODULE_0__["default"])(color)

	if (!parsed.space) return []

	const min = parsed.space[0] === 'h' ? color_space_hsl_js__WEBPACK_IMPORTED_MODULE_2__["default"].min : color_space_rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"].min
	const max = parsed.space[0] === 'h' ? color_space_hsl_js__WEBPACK_IMPORTED_MODULE_2__["default"].max : color_space_rgb_js__WEBPACK_IMPORTED_MODULE_1__["default"].max

	values = Array(3)
	values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0])
	values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1])
	values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2])

	if (parsed.space[0] === 'h') {
		values = color_space_hsl_js__WEBPACK_IMPORTED_MODULE_2__["default"].rgb(values)
	}

	values.push(Math.min(Math.max(parsed.alpha, 0), 1))

	return values
}


/***/ }),

/***/ "./node_modules/color-space/hsl.js":
/*!*****************************************!*\
  !*** ./node_modules/color-space/hsl.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/color-space/rgb.js");
/**
 * @module color-space/hsl
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	name: 'hsl',
	min: [0,0,0],
	max: [360,100,100],
	channel: ['hue', 'saturation', 'lightness'],
	alias: ['HSL'],

	rgb: function(hsl) {
		var h = hsl[0]/360, s = hsl[1]/100, l = hsl[2]/100, t1, t2, t3, rgb, val, i=0;

		if (s === 0) return val = l * 255, [val, val, val];

		t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (;i<3;) {
			t3 = h + 1 / 3 * - (i - 1);
			t3 < 0 ? t3++ : t3 > 1 && t3--;
			val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 :
			2 * t3 < 1 ? t2 :
			3 * t3 < 2 ?  t1 + (t2 - t1) * (2 / 3 - t3) * 6 :
			t1;
			rgb[i++] = val * 255;
		}

		return rgb;
	}
});


//extend rgb
_rgb_js__WEBPACK_IMPORTED_MODULE_0__["default"].hsl = function(rgb) {
	var r = rgb[0]/255,
			g = rgb[1]/255,
			b = rgb[2]/255,
			min = Math.min(r, g, b),
			max = Math.max(r, g, b),
			delta = max - min,
			h, s, l;

	if (max === min) {
		h = 0;
	}
	else if (r === max) {
		h = (g - b) / delta;
	}
	else if (g === max) {
		h = 2 + (b - r) / delta;
	}
	else if (b === max) {
		h = 4 + (r - g)/ delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	}
	else if (l <= 0.5) {
		s = delta / (max + min);
	}
	else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};


/***/ }),

/***/ "./node_modules/color-space/lchuv.js":
/*!*******************************************!*\
  !*** ./node_modules/color-space/lchuv.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _luv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./luv.js */ "./node_modules/color-space/luv.js");
/* harmony import */ var _xyz_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xyz.js */ "./node_modules/color-space/xyz.js");
/**
 * Cylindrical CIE LUV
 *
 * @module color-space/lchuv
 */



//cylindrical luv
var lchuv = {
	name: 'lchuv',
	channel: ['lightness', 'chroma', 'hue'],
	alias: ['LCHuv', 'cielchuv'],
	min: [0,0,0],
	max: [100,100,360],

	luv: function(luv){
		var l = luv[0],
		c = luv[1],
		h = luv[2],
		u, v, hr;

		hr = h / 360 * 2 * Math.PI;
		u = c * Math.cos(hr);
		v = c * Math.sin(hr);
		return [l, u, v];
	},

	xyz: function(arg) {
		return _luv_js__WEBPACK_IMPORTED_MODULE_0__["default"].xyz(lchuv.luv(arg));
	}
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lchuv);

_luv_js__WEBPACK_IMPORTED_MODULE_0__["default"].lchuv = function(luv){
	var l = luv[0], u = luv[1], v = luv[2];

	var c = Math.sqrt(u*u + v*v);
	var hr = Math.atan2(v,u);
	var h = hr * 360 / 2 / Math.PI;
	if (h < 0) {
		h += 360;
	}

	return [l,c,h]
};

_xyz_js__WEBPACK_IMPORTED_MODULE_1__["default"].lchuv = function(arg){
  return _luv_js__WEBPACK_IMPORTED_MODULE_0__["default"].lchuv(_xyz_js__WEBPACK_IMPORTED_MODULE_1__["default"].luv(arg));
};


/***/ }),

/***/ "./node_modules/color-space/luv.js":
/*!*****************************************!*\
  !*** ./node_modules/color-space/luv.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _xyz_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xyz.js */ "./node_modules/color-space/xyz.js");
/**
 * CIE LUV (C'est la vie)
 *
 * @module color-space/luv
 */
 

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	name: 'luv',
	//NOTE: luv has no rigidly defined limits
	//easyrgb fails to get proper coords
	//boronine states no rigid limits
	//colorMine refers this ones:
	min: [0,-134,-140],
	max: [100,224,122],
	channel: ['lightness', 'u', 'v'],
	alias: ['LUV', 'cieluv', 'cie1976'],

	xyz: function(arg, i, o){
		var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
		l = arg[0], u = arg[1], v = arg[2];

		if (l === 0) return [0,0,0];

		//get constants
		//var e = 0.008856451679035631; //(6/29)^3
		var k = 0.0011070564598794539; //(3/29)^3

		//get illuminant/observer
		i = i || 'D65';
		o = o || 2;

		xn = _xyz_js__WEBPACK_IMPORTED_MODULE_0__["default"].whitepoint[o][i][0];
		yn = _xyz_js__WEBPACK_IMPORTED_MODULE_0__["default"].whitepoint[o][i][1];
		zn = _xyz_js__WEBPACK_IMPORTED_MODULE_0__["default"].whitepoint[o][i][2];

		un = (4 * xn) / (xn + (15 * yn) + (3 * zn));
		vn = (9 * yn) / (xn + (15 * yn) + (3 * zn));
		// un = 0.19783000664283;
		// vn = 0.46831999493879;


		_u = u / (13 * l) + un || 0;
		_v = v / (13 * l) + vn || 0;

		y = l > 8 ? yn * Math.pow( (l + 16) / 116 , 3) : yn * l * k;

		//wikipedia method
		x = y * 9 * _u / (4 * _v) || 0;
		z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;

		//boronine method
		//https://github.com/boronine/husl/blob/master/husl.coffee#L201
		// x = 0 - (9 * y * _u) / ((_u - 4) * _v - _u * _v);
		// z = (9 * y - (15 * _v * y) - (_v * x)) / (3 * _v);

		return [x, y, z];
	}
});

// http://www.brucelindbloom.com/index.html?Equations.html
// https://github.com/boronine/husl/blob/master/husl.coffee
//i - illuminant
//o - observer
_xyz_js__WEBPACK_IMPORTED_MODULE_0__["default"].luv = function(arg, i, o) {
	var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;

	//get constants
	var e = 0.008856451679035631; //(6/29)^3
	var k = 903.2962962962961; //(29/3)^3

	//get illuminant/observer coords
	i = i || 'D65';
	o = o || 2;

	xn = _xyz_js__WEBPACK_IMPORTED_MODULE_0__["default"].whitepoint[o][i][0];
	yn = _xyz_js__WEBPACK_IMPORTED_MODULE_0__["default"].whitepoint[o][i][1];
	zn = _xyz_js__WEBPACK_IMPORTED_MODULE_0__["default"].whitepoint[o][i][2];

	un = (4 * xn) / (xn + (15 * yn) + (3 * zn));
	vn = (9 * yn) / (xn + (15 * yn) + (3 * zn));


	x = arg[0], y = arg[1], z = arg[2];


	_u = (4 * x) / (x + (15 * y) + (3 * z)) || 0;
	_v = (9 * y) / (x + (15 * y) + (3 * z)) || 0;

	var yr = y/yn;

	l = yr <= e ? k * yr : 116 * Math.pow(yr, 1/3) - 16;

	u = 13 * l * (_u - un);
	v = 13 * l * (_v - vn);

	return [l, u, v];
};


/***/ }),

/***/ "./node_modules/color-space/rgb.js":
/*!*****************************************!*\
  !*** ./node_modules/color-space/rgb.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	name: 'rgb',
	min: [0,0,0],
	max: [255,255,255],
	channel: ['red', 'green', 'blue'],
	alias: ['RGB']
});


/***/ }),

/***/ "./node_modules/color-space/xyz.js":
/*!*****************************************!*\
  !*** ./node_modules/color-space/xyz.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/color-space/rgb.js");
/**
 * CIE XYZ
 *
 * @module  color-space/xyz
 */


var xyz = {
	name: 'xyz',
	min: [0,0,0],
	channel: ['X','Y','Z'],
	alias: ['XYZ', 'ciexyz', 'cie1931']
};


/**
 * Whitepoint reference values with observer/illuminant
 *
 * http://en.wikipedia.org/wiki/Standard_illuminant
 */
xyz.whitepoint = {
	//1931 2°
	2: {
		//incadescent
		A:[109.85, 100, 35.585],
		// B:[],
		C: [98.074, 100, 118.232],
		D50: [96.422, 100, 82.521],
		D55: [95.682, 100, 92.149],
		//daylight
		D65: [95.045592705167, 100, 108.9057750759878],
		D75: [94.972, 100, 122.638],
		//flourescent
		// F1: [],
		F2: [99.187, 100, 67.395],
		// F3: [],
		// F4: [],
		// F5: [],
		// F6:[],
		F7: [95.044, 100, 108.755],
		// F8: [],
		// F9: [],
		// F10: [],
		F11: [100.966, 100, 64.370],
		// F12: [],
		E: [100,100,100]
	},

	//1964  10°
	10: {
		//incadescent
		A:[111.144, 100, 35.200],
		C: [97.285, 100, 116.145],
		D50: [96.720, 100, 81.427],
		D55: [95.799, 100, 90.926],
		//daylight
		D65: [94.811, 100, 107.304],
		D75: [94.416, 100, 120.641],
		//flourescent
		F2: [103.280, 100, 69.026],
		F7: [95.792, 100, 107.687],
		F11: [103.866, 100, 65.627],
		E: [100,100,100]
	}
};


/**
 * Top values are the whitepoint’s top values, default are D65
 */
xyz.max = xyz.whitepoint[2].D65;


/**
 * Transform xyz to rgb
 *
 * @param {Array} xyz Array of xyz values
 *
 * @return {Array} RGB values
 */
xyz.rgb = function (_xyz, white) {
	//FIXME: make sure we have to divide like this. Probably we have to replace matrix as well then
	white = white || xyz.whitepoint[2].E;

	var x = _xyz[0] / white[0],
		y = _xyz[1] / white[1],
		z = _xyz[2] / white[2],
		r, g, b;

	// assume sRGB
	// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
	r = (x * 3.240969941904521) + (y * -1.537383177570093) + (z * -0.498610760293);
	g = (x * -0.96924363628087) + (y * 1.87596750150772) + (z * 0.041555057407175);
	b = (x * 0.055630079696993) + (y * -0.20397695888897) + (z * 1.056971514242878);

	r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r = (r * 12.92);

	g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g = (g * 12.92);

	b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b = (b * 12.92);

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
}



/**
 * RGB to XYZ
 *
 * @param {Array} rgb RGB channels
 *
 * @return {Array} XYZ channels
 */
_rgb_js__WEBPACK_IMPORTED_MODULE_0__["default"].xyz = function(rgb, white) {
	var r = rgb[0] / 255,
			g = rgb[1] / 255,
			b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.41239079926595) + (g * 0.35758433938387) + (b * 0.18048078840183);
	var y = (r * 0.21263900587151) + (g * 0.71516867876775) + (b * 0.072192315360733);
	var z = (r * 0.019330818715591) + (g * 0.11919477979462) + (b * 0.95053215224966);

	white = white || xyz.whitepoint[2].E;

	return [x * white[0], y * white[1], z * white[2]];
};



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (xyz);


/***/ }),

/***/ "./node_modules/ol/Collection.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Collection.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CollectionEvent: () => (/* binding */ CollectionEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/Collection
 */




/**
 * @enum {string}
 * @private
 */
const Property = {
  LENGTH: 'length',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */
class CollectionEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(type, element, index) {
    super(type);

    /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */
    this.element = element;

    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */
    this.index = index;
  }
}

/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
class Collection extends _Object_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(array, options) {
    super();

    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {CollectionOnSignature<T, void>}
     */
    this.un;

    options = options || {};

    /**
     * @private
     * @type {boolean}
     */
    this.unique_ = !!options.unique;

    /**
     * @private
     * @type {!Array<T>}
     */
    this.array_ = array ? array : [];

    if (this.unique_) {
      for (let i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }

    this.updateLength_();
  }

  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    while (this.getLength() > 0) {
      this.pop();
    }
  }

  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(arr) {
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  }

  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(f) {
    const array = this.array_;
    for (let i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  }

  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }

  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(index) {
    return this.array_[index];
  }

  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Property.LENGTH);
  }

  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(index, elem) {
    if (index < 0 || index > this.getLength()) {
      throw new Error('Index out of bounds: ' + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, elem, index),
    );
  }

  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }

  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    const n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  }

  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(elem) {
    const arr = this.array_;
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return undefined;
  }

  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(index) {
    if (index < 0 || index >= this.getLength()) {
      return undefined;
    }
    const prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */ (
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, prev, index)
      ),
    );
    return prev;
  }

  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(index, elem) {
    const n = this.getLength();
    if (index >= n) {
      this.insertAt(index, elem);
      return;
    }
    if (index < 0) {
      throw new Error('Index out of bounds: ' + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    const prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */ (
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, prev, index)
      ),
    );
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */ (
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, elem, index)
      ),
    );
  }

  /**
   * @private
   */
  updateLength_() {
    this.set(Property.LENGTH, this.array_.length);
  }

  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(elem, except) {
    for (let i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== except) {
        throw new Error('Duplicate item added to a unique collection');
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Collection);


/***/ }),

/***/ "./node_modules/ol/CollectionEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/CollectionEventType.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove',
});


/***/ }),

/***/ "./node_modules/ol/DataTile.js":
/*!*************************************!*\
  !*** ./node_modules/ol/DataTile.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asArrayLike: () => (/* binding */ asArrayLike),
/* harmony export */   asImageLike: () => (/* binding */ asImageLike),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   disposedError: () => (/* binding */ disposedError),
/* harmony export */   toArray: () => (/* binding */ toArray)
/* harmony export */ });
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/DataTile
 */




/**
 * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike
 */

/**
 * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike
 */

/**
 * Data that can be used with a DataTile.
 * @typedef {ArrayLike|ImageLike} Data
 */

/**
 * @param {Data} data Tile data.
 * @return {ImageLike|null} The image-like data.
 */
function asImageLike(data) {
  return data instanceof Image ||
    data instanceof HTMLCanvasElement ||
    data instanceof HTMLVideoElement ||
    data instanceof ImageBitmap
    ? data
    : null;
}

/**
 * @param {Data} data Tile data.
 * @return {ArrayLike|null} The array-like data.
 */
function asArrayLike(data) {
  return data instanceof Uint8Array ||
    data instanceof Uint8ClampedArray ||
    data instanceof Float32Array ||
    data instanceof DataView
    ? data
    : null;
}

/**
 * This is set as the cancellation reason when a tile is disposed.
 */
const disposedError = new Error('disposed');

/**
 * @type {CanvasRenderingContext2D|null}
 */
let sharedContext = null;

/**
 * @param {ImageLike} image The image.
 * @return {Uint8ClampedArray} The data.
 */
function toArray(image) {
  if (!sharedContext) {
    sharedContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(
      image.width,
      image.height,
      undefined,
      {willReadFrequently: true},
    );
  }
  const canvas = sharedContext.canvas;
  const width = image.width;
  if (canvas.width !== width) {
    canvas.width = width;
  }
  const height = image.height;
  if (canvas.height !== height) {
    canvas.height = height;
  }
  sharedContext.clearRect(0, 0, width, height);
  sharedContext.drawImage(image, 0, 0);
  return sharedContext.getImageData(0, 0, width, height).data;
}

/**
 * @type {import('./size.js').Size}
 */
const defaultSize = [256, 256];

/**
 * @typedef {Object} Options
 * @property {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,
 * the promise should not resolve until the image is loaded.
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {import('./size.js').Size} [size=[256, 256]] Tile size.
 * @property {AbortController} [controller] An abort controller.
 * @api
 */

class DataTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} options Tile options.
   */
  constructor(options) {
    const state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE;

    super(options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate,
    });

    /**
     * @type {function(): Promise<Data>}
     * @private
     */
    this.loader_ = options.loader;

    /**
     * @type {Data}
     * @private
     */
    this.data_ = null;

    /**
     * @type {Error}
     * @private
     */
    this.error_ = null;

    /**
     * @type {import('./size.js').Size|null}
     * @private
     */
    this.size_ = options.size || null;

    /**
     * @type {AbortController|null}
     * @private
     */
    this.controller_ = options.controller || null;
  }

  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_) {
      return this.size_;
    }
    const imageData = asImageLike(this.data_);
    if (imageData) {
      return [imageData.width, imageData.height];
    }
    return defaultSize;
  }

  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }

  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }

  /**
   * Load the tile data.
   * @api
   * @override
   */
  load() {
    if (this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE && this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      return;
    }
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
    this.changed();

    const self = this;
    this.loader_()
      .then(function (data) {
        self.data_ = data;
        self.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
        self.changed();
      })
      .catch(function (error) {
        self.error_ = error;
        self.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
        self.changed();
      });
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.controller_) {
      this.controller_.abort(disposedError);
      this.controller_ = null;
    }
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTile);


/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
class Disposable {
  constructor() {
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    this.disposed = false;
  }

  /**
   * Clean up.
   */
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }

  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Disposable);


/***/ }),

/***/ "./node_modules/ol/Image.js":
/*!**********************************!*\
  !*** ./node_modules/ol/Image.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   decodeFallback: () => (/* binding */ decodeFallback),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   listenImage: () => (/* binding */ listenImage),
/* harmony export */   load: () => (/* binding */ load)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/Image
 */







/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(import("./Image.js").default, string): void} LoadFunction
 * @api
 */

/**
 * @typedef {Object} ImageObject
 * @property {import("./extent.js").Extent} [extent] Extent, if different from the requested one.
 * @property {import("./resolution.js").ResolutionLike} [resolution] Resolution, if different from the requested one.
 * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
 * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */

/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import("./DataTile.js").ImageLike image}, an
 * {@link import("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} Loader
 * @api
 */

/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import("./Image.js").ImageObject image object}.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} ImageObjectPromiseLoader
 */

class ImageWrapper extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */
  constructor(extent, resolution, pixelRatio, stateOrLoader) {
    super();

    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|Array<number>|undefined}
     */
    this.resolution = resolution;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    this.state =
      typeof stateOrLoader === 'function' ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : stateOrLoader;

    /**
     * @private
     * @type {import('./DataTile.js').ImageLike|null}
     */
    this.image_ = null;

    /**
     * @protected
     * @type {import("./Image.js").Loader}
     */
    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;
  }

  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  }

  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }

  /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_;
  }

  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }

  /**
   * @return {number|Array<number>} Resolution.
   */
  getResolution() {
    return /** @type {number} */ (this.resolution);
  }

  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      if (this.loader) {
        this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
        this.changed();
        const resolution = this.getResolution();
        const requestResolution = Array.isArray(resolution)
          ? resolution[0]
          : resolution;
        (0,_functions_js__WEBPACK_IMPORTED_MODULE_3__.toPromise)(() =>
          this.loader(
            this.getExtent(),
            requestResolution,
            this.getPixelRatio(),
          ),
        )
          .then((image) => {
            if ('image' in image) {
              this.image_ = image.image;
            }
            if ('extent' in image) {
              this.extent = image.extent;
            }
            if ('resolution' in image) {
              this.resolution = image.resolution;
            }
            if ('pixelRatio' in image) {
              this.pixelRatio_ = image.pixelRatio;
            }
            if (
              image instanceof HTMLImageElement ||
              image instanceof ImageBitmap ||
              image instanceof HTMLCanvasElement ||
              image instanceof HTMLVideoElement
            ) {
              this.image_ = image;
            }
            this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
          })
          .catch((error) => {
            this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
            console.error(error); // eslint-disable-line no-console
          })
          .finally(() => this.changed());
      }
    }
  }

  /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */
  setImage(image) {
    this.image_ = image;
  }

  /**
   * @param {number|Array<number>} resolution Resolution.
   */
  setResolution(resolution) {
    this.resolution = resolution;
  }
}

/**
 * @param {import('./DataTile.js').ImageLike} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */
function listenImage(image, loadHandler, errorHandler) {
  const img = /** @type {HTMLImageElement} */ (image);
  let listening = true;
  let decoding = false;
  let loaded = false;

  const listenerKeys = [
    (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOAD, function () {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    }),
  ];

  if (img.src && _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE) {
    decoding = true;
    img
      .decode()
      .then(function () {
        if (listening) {
          loadHandler();
        }
      })
      .catch(function (error) {
        if (listening) {
          if (loaded) {
            loadHandler();
          } else {
            errorHandler();
          }
        }
      });
  } else {
    listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR, errorHandler));
  }

  return function unlisten() {
    listening = false;
    listenerKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
  };
}

/**
 * Loads an image.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 * @api
 */
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error('Image load error'));
    }
    function unlisten() {
      image.removeEventListener('load', handleLoad);
      image.removeEventListener('error', handleError);
    }
    image.addEventListener('load', handleLoad);
    image.addEventListener('error', handleError);
    if (src) {
      image.src = src;
    }
  });
}

/**
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 */
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE
    ? new Promise((resolve, reject) =>
        image
          .decode()
          .then(() => resolve(image))
          .catch((e) =>
            image.complete && image.width ? resolve(image) : reject(e),
          ),
      )
    : load(image);
}

/**
 * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns
 * the loaded image otherwise.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an
 * `HTMLImageElement` if `createImageBitmap()` is not supported.
 * @api
 */
function decode(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE && _has_js__WEBPACK_IMPORTED_MODULE_5__.CREATE_IMAGE_BITMAP
    ? image
        .decode()
        .then(() => createImageBitmap(image))
        .catch((e) => {
          if (image.complete && image.width) {
            return image;
          }
          throw e;
        })
    : decodeFallback(image);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageWrapper);


/***/ }),

/***/ "./node_modules/ol/ImageState.js":
/*!***************************************!*\
  !*** ./node_modules/ol/ImageState.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
});


/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/Image.js");
/**
 * @module ol/ImageTile
 */





class ImageTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    this.src_ = src;

    this.key = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {?function():void}
     */
    this.unlisten_ = null;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;
  }

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }

  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }

  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = /** @type {HTMLImageElement} */ (this.image_);
    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   * @api
   * @override
   */
  load() {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = (0,_Image_js__WEBPACK_IMPORTED_MODULE_2__.listenImage)(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this),
      );
    }
  }

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }

  /**
   * @override
   */
  disposeInternal() {
    this.unlistenImage_();
    this.image_ = null;
    super.disposeInternal();
  }
}

/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  const ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageTile);


/***/ }),

/***/ "./node_modules/ol/Kinetic.js":
/*!************************************!*\
  !*** ./node_modules/ol/Kinetic.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
class Kinetic {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    /**
     * @private
     * @type {number}
     */
    this.decay_ = decay;

    /**
     * @private
     * @type {number}
     */
    this.minVelocity_ = minVelocity;

    /**
     * @private
     * @type {number}
     */
    this.delay_ = delay;

    /**
     * @private
     * @type {Array<number>}
     */
    this.points_ = [];

    /**
     * @private
     * @type {number}
     */
    this.angle_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.initialVelocity_ = 0;
  }

  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }

  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      // at least 2 points are required (i.e. there must be at least 6 elements
      // in the array)
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      // the last tracked point is too old, which means that the user stopped
      // panning before releasing the map
      return false;
    }

    // get the first point which still falls into the delay time
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }

    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    // we don't want a duration of 0 (divide by zero)
    // we also make sure the user panned for a duration of at least one frame
    // (1/60s) to compute sane displacement values
    if (duration < 1000 / 60) {
      return false;
    }

    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }

  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }

  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Kinetic);


/***/ }),

/***/ "./node_modules/ol/Map.js":
/*!********************************!*\
  !*** ./node_modules/ol/Map.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./renderer/Composite.js */ "./node_modules/ol/renderer/Composite.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layer/Group.js */ "./node_modules/ol/layer/Group.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./MapBrowserEventHandler.js */ "./node_modules/ol/MapBrowserEventHandler.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MapProperty.js */ "./node_modules/ol/MapProperty.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TileQueue.js */ "./node_modules/ol/TileQueue.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./View.js */ "./node_modules/ol/View.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _control_defaults_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./control/defaults.js */ "./node_modules/ol/control/defaults.js");
/* harmony import */ var _interaction_defaults_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/defaults.js */ "./node_modules/ol/interaction/defaults.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _console_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./console.js */ "./node_modules/ol/console.js");
/**
 * @module ol/Map
 */

































/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {Object<string, import("rbush").default<import('./render/canvas/Executor.js').DeclutterEntry>>|null} declutter
 * Declutter trees by declutter group.
 * When null, no decluttering is needed because no layers have decluttering enabled.
 * @property {null|import("./extent.js").Extent} extent Extent (in view projection coordinates).
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */

/**
 * @typedef {function(Map, FrameState): any} PostRenderFunction
 */

/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */

/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */

/**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
 */

/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/defaults.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction/defaults.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
 *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
 *  `tabindex` atribute must be set on the custom element's host element.
 * **Note:** CSS `transform` support for the target element is limited to `scale`.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 */
function removeLayerMapProperty(layer) {
  if (layer instanceof _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {Map} map Map.
 */
function setLayerMapProperty(layer, map) {
  if (layer instanceof _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}

/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map.js';
 *     import View from 'ol/View.js';
 *     import TileLayer from 'ol/layer/Tile.js';
 *     import OSM from 'ol/source/OSM.js';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */
class Map extends _Object_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();

    options = options || {};

    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {MapEventHandler<void>}
     */
    this.un;

    const optionsInternal = createOptionsInternal(options);

    /**
     * @private
     * @type {boolean}
     */
    this.renderComplete_ = false;

    /**
     * @private
     * @type {boolean}
     */
    this.loaded_ = true;

    /** @private */
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);

    /**
     * @type {number}
     * @private
     */
    this.maxTilesLoading_ =
      options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ =
      options.pixelRatio !== undefined
        ? options.pixelRatio
        : _has_js__WEBPACK_IMPORTED_MODULE_4__.DEVICE_PIXEL_RATIO;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    this.postRenderTimeoutHandle_;

    /**
     * @private
     * @type {number|undefined}
     */
    this.animationDelayKey_;

    /**
     * @private
     */
    this.animationDelay_ = this.animationDelay_.bind(this);

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.coordinateToPixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.create)();

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.pixelToCoordinateTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.create)();

    /**
     * @private
     * @type {number}
     */
    this.frameIndex_ = 0;

    /**
     * @private
     * @type {?FrameState}
     */
    this.frameState_ = null;

    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */
    this.previousExtent_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewPropertyListenerKey_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewChangeListenerKey_ = null;

    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    this.layerGroupPropertyListenerKeys_ = null;

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.viewport_ = document.createElement('div');
    this.viewport_.className =
      'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
    this.viewport_.style.position = 'relative';
    this.viewport_.style.overflow = 'hidden';
    this.viewport_.style.width = '100%';
    this.viewport_.style.height = '100%';

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainer_ = document.createElement('div');
    this.overlayContainer_.style.position = 'absolute';
    this.overlayContainer_.style.zIndex = '0';
    this.overlayContainer_.style.width = '100%';
    this.overlayContainer_.style.height = '100%';
    this.overlayContainer_.style.pointerEvents = 'none';
    this.overlayContainer_.className = 'ol-overlaycontainer';
    this.viewport_.appendChild(this.overlayContainer_);

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainerStopEvent_ = document.createElement('div');
    this.overlayContainerStopEvent_.style.position = 'absolute';
    this.overlayContainerStopEvent_.style.zIndex = '0';
    this.overlayContainerStopEvent_.style.width = '100%';
    this.overlayContainerStopEvent_.style.height = '100%';
    this.overlayContainerStopEvent_.style.pointerEvents = 'none';
    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
    this.viewport_.appendChild(this.overlayContainerStopEvent_);

    /**
     * @private
     * @type {MapBrowserEventHandler}
     */
    this.mapBrowserEventHandler_ = null;

    /**
     * @private
     * @type {number}
     */
    this.moveTolerance_ = options.moveTolerance;

    /**
     * @private
     * @type {HTMLElement|Document}
     */
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    this.targetChangeHandlerKeys_ = null;

    /**
     * @private
     * @type {HTMLElement|null}
     */
    this.targetElement_ = null;

    /**
     * @private
     * @type {ResizeObserver}
     */
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());

    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */
    this.controls = optionsInternal.controls || (0,_control_defaults_js__WEBPACK_IMPORTED_MODULE_6__.defaults)();

    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */
    this.interactions =
      optionsInternal.interactions ||
      (0,_interaction_defaults_js__WEBPACK_IMPORTED_MODULE_7__.defaults)({
        onFocusOnly: true,
      });

    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */
    this.overlays_ = optionsInternal.overlays;

    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */
    this.overlayIdIndex_ = {};

    /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */
    this.renderer_ = null;

    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */
    this.postRenderFunctions_ = [];

    /**
     * @private
     * @type {TileQueue}
     */
    this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_8__["default"](
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this),
    );

    this.addChangeListener(
      _MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP,
      this.handleLayerGroupChanged_,
    );
    this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW, this.handleViewChanged_);
    this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].SIZE, this.handleSizeChanged_);
    this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET, this.handleTargetChanged_);

    // setProperties will trigger the rendering of the map if the map
    // is "defined" already.
    this.setProperties(optionsInternal.values);

    const map = this;
    if (options.view && !(options.view instanceof _View_js__WEBPACK_IMPORTED_MODULE_10__["default"])) {
      options.view.then(function (viewOptions) {
        map.setView(new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"](viewOptions));
      });
    }

    this.controls.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      },
    );

    this.controls.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      },
    );

    this.interactions.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      },
    );

    this.interactions.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      },
    );

    this.overlays_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      },
    );

    this.overlays_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== undefined) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      },
    );

    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      },
    );

    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      },
    );

    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }

  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }

  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }

  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }

  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }

  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }

  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }

  /**
   *
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }

  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== undefined ? options : {};
    const hitTolerance =
      options.hitTolerance !== undefined ? options.hitTolerance : 0;
    const layerFilter =
      options.layerFilter !== undefined ? options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_12__.TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null,
    );
  }

  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function (feature) {
        features.push(feature);
      },
      options,
    );
    return features;
  }

  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function (layer) {
        if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }

  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== undefined ? options : {};
    const layerFilter =
      options.layerFilter !== undefined ? options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_12__.TRUE;
    const hitTolerance =
      options.hitTolerance !== undefined ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null,
    );
  }

  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }

  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }

  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition =
      //FIXME Are we really calling this with a TouchEvent anywhere?
      'changedTouches' in event
        ? /** @type {TouchEvent} */ (event).changedTouches[0]
        : /** @type {MouseEvent} */ (event);

    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY,
    ];
  }

  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return /** @type {HTMLElement|string|undefined} */ (
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET)
    );
  }

  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }

  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection(),
    );
  }

  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
  }

  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }

  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }

  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  }

  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }

  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return /** @type {LayerGroup} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP));
  }

  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"]) {
      group.setLayers(layers);
      return;
    }

    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }

  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }

  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }

  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
      coordinate,
      this.getView().getProjection(),
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }

  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2),
    );
  }

  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }

  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return /** @type {import("./size.js").Size|undefined} */ (
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].SIZE)
    );
  }

  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return /** @type {View} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW));
  }

  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }

  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }

  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }

  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }

  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
    return (0,_TileQueue_js__WEBPACK_IMPORTED_MODULE_8__.getTilePriority)(
      this.frameState_,
      tile,
      tileSourceKey,
      tileCenter,
      tileResolution,
    );
  }

  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_14__["default"](type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }

  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }
    const originalEvent = /** @type {PointerEvent} */ (
      mapBrowserEvent.originalEvent
    );
    const eventType = originalEvent.type;
    if (
      eventType === _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINTERDOWN ||
      eventType === _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].WHEEL ||
      eventType === _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].KEYDOWN
    ) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode
        ? this.viewport_.getRootNode()
        : doc;
      const target = /** @type {Node} */ (originalEvent.target);

      const currentDoc =
        rootNode instanceof ShadowRoot
          ? rootNode.host === target
            ? rootNode.host.ownerDocument
            : rootNode
          : rootNode === doc
            ? doc.documentElement
            : rootNode;
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) ||
        // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !currentDoc.contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (
          interaction.getMap() !== this ||
          !interaction.getActive() ||
          !this.getTargetElement()
        ) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }

  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;

    // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].ANIMATING] || hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }

    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_) {
        if (this.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            _render_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RENDERCOMPLETE,
            frameState,
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADEND, this, frameState),
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADSTART, this, frameState),
        );
      }
    }

    const postRenderFunctions = this.postRenderFunctions_;
    if (frameState) {
      for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
        postRenderFunctions[i](this, frameState);
      }
    }
    postRenderFunctions.length = 0;
  }

  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }

    this.render();
  }

  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey)(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CONTEXTMENU,
        this.boundHandleBrowserEvent_,
      );
      this.viewport_.removeEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].WHEEL,
        this.boundHandleBrowserEvent_,
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      this.viewport_.remove();
    }

    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(undefined);
    }

    // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.

    const target = this.getTarget();
    const targetElement =
      typeof target === 'string' ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = undefined;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_22__["default"](this);
      }

      this.mapBrowserEventHandler_ = new _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_23__["default"](
        this,
        this.moveTolerance_,
      );
      for (const key in _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_24__["default"]) {
        this.mapBrowserEventHandler_.addEventListener(
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_24__["default"][key],
          this.handleMapBrowserEvent.bind(this),
        );
      }
      this.viewport_.addEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false,
      );
      this.viewport_.addEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].WHEEL,
        this.boundHandleBrowserEvent_,
        _has_js__WEBPACK_IMPORTED_MODULE_4__.PASSIVE_EVENT_LISTENERS ? {passive: false} : false,
      );

      let keyboardEventTarget;
      if (!this.keyboardEventTarget_) {
        // check if map target is in shadowDOM, if yes use host element as target
        const targetRoot = targetElement.getRootNode();
        const targetCandidate =
          targetRoot instanceof ShadowRoot ? targetRoot.host : targetElement;
        keyboardEventTarget = targetCandidate;
      } else {
        keyboardEventTarget = this.keyboardEventTarget_;
      }

      this.targetChangeHandlerKeys_ = [
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
          keyboardEventTarget,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].KEYDOWN,
          this.handleBrowserEvent,
          this,
        ),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
          keyboardEventTarget,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].KEYPRESS,
          this.handleBrowserEvent,
          this,
        ),
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }

    this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  }

  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }

  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }

  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey)(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey)(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_(this.getSize());

      this.viewPropertyListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
        view,
        _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_25__["default"].PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this,
      );
      this.viewChangeListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
        view,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGE,
        this.handleViewPropertyChanged_,
        this,
      );

      view.resolveConstraints(0);
    }
    this.render();
  }

  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__.GroupEvent('addlayer', layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_25__["default"].PROPERTYCHANGE, this.render, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGE, this.render, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, 'addlayer', this.handleLayerAdd_, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, 'removelayer', this.handleLayerRemove_, this),
      ];
    }
    this.render();
  }

  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }

  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = undefined;
    this.renderFrame_(Date.now());
  }

  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }

  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }

  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }

  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }

  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }

  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }

  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }

  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }

  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    /** @type {?FrameState} */
    let frameState = null;
    if (size !== undefined && (0,_size_js__WEBPACK_IMPORTED_MODULE_26__.hasArea)(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : undefined,
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: (0,_extent_js__WEBPACK_IMPORTED_MODULE_27__.getForViewAndSize)(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size,
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {},
        mapId: (0,_util_js__WEBPACK_IMPORTED_MODULE_28__.getUid)(this),
        renderTargets: {},
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation)
          ? viewState.rotation
          : viewState.nextRotation;

        frameState.nextExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_27__.getForViewAndSize)(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size,
        );
      }
    }

    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions,
      );

      if (previousFrameState) {
        const moveStart =
          !this.previousExtent_ ||
          (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_27__.isEmpty)(this.previousExtent_) &&
            !(0,_extent_js__WEBPACK_IMPORTED_MODULE_27__.equals)(frameState.extent, this.previousExtent_));
        if (moveStart) {
          this.dispatchEvent(
            new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].MOVESTART, this, previousFrameState),
          );
          this.previousExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_27__.createOrUpdateEmpty)(this.previousExtent_);
        }
      }

      const idle =
        this.previousExtent_ &&
        !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].ANIMATING] &&
        !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].INTERACTING] &&
        !(0,_extent_js__WEBPACK_IMPORTED_MODULE_27__.equals)(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(
          new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].MOVEEND, this, frameState),
        );
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_27__.clone)(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].POSTRENDER, this, frameState));

    this.renderComplete_ =
      (this.hasListener(_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADSTART) ||
        this.hasListener(_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADEND) ||
        this.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RENDERCOMPLETE)) &&
      !this.tileQueue_.getTilesLoading() &&
      !this.tileQueue_.getCount() &&
      !this.getLoadingOrNotReady();

    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = undefined;
        this.handlePostRender();
      }, 0);
    }
  }

  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__.GroupEvent('removelayer', oldLayerGroup));
    }
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP, layerGroup);
  }

  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].SIZE, size);
  }

  /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET, target);
  }

  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof _View_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
      this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW, view);
      return;
    }
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW, new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"]());

    const map = this;
    view.then(function (viewOptions) {
      map.setView(new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"](viewOptions));
    });
  }

  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();

    let size = undefined;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width =
        targetElement.offsetWidth -
        parseFloat(computedStyle['borderLeftWidth']) -
        parseFloat(computedStyle['paddingLeft']) -
        parseFloat(computedStyle['paddingRight']) -
        parseFloat(computedStyle['borderRightWidth']);
      const height =
        targetElement.offsetHeight -
        parseFloat(computedStyle['borderTopWidth']) -
        parseFloat(computedStyle['paddingTop']) -
        parseFloat(computedStyle['paddingBottom']) -
        parseFloat(computedStyle['borderBottomWidth']);
      if (!isNaN(width) && !isNaN(height)) {
        size = [Math.max(0, width), Math.max(0, height)];
        if (
          !(0,_size_js__WEBPACK_IMPORTED_MODULE_26__.hasArea)(size) &&
          !!(
            targetElement.offsetWidth ||
            targetElement.offsetHeight ||
            targetElement.getClientRects().length
          )
        ) {
          (0,_console_js__WEBPACK_IMPORTED_MODULE_29__.warn)(
            "No map visible because the map container's width or height are 0.",
          );
        }
      }
    }

    const oldSize = this.getSize();
    if (size && (!oldSize || !(0,_array_js__WEBPACK_IMPORTED_MODULE_30__.equals)(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_(size);
    }
  }

  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(size) {
    const view = this.getView();
    if (view) {
      view.setViewportSize(size);
    }
  }
}

/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */
function createOptionsInternal(options) {
  /**
   * @type {HTMLElement|Document}
   */
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget =
      typeof options.keyboardEventTarget === 'string'
        ? document.getElementById(options.keyboardEventTarget)
        : options.keyboardEventTarget;
  }

  /**
   * @type {Object<string, *>}
   */
  const values = {};

  const layerGroup =
    options.layers &&
    typeof (/** @type {?} */ (options.layers).getLayers) === 'function'
      ? /** @type {LayerGroup} */ (options.layers)
      : new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          layers:
            /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */ (
              options.layers
            ),
        });
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP] = layerGroup;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET] = options.target;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW] =
    options.view instanceof _View_js__WEBPACK_IMPORTED_MODULE_10__["default"] ? options.view : new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"]();

  /** @type {Collection<import("./control/Control.js").default>} */
  let controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"](options.controls.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_31__.assert)(
        typeof (/** @type {?} */ (options.controls).getArray) === 'function',
        'Expected `controls` to be an array or an `ol/Collection.js`',
      );
      controls = options.controls;
    }
  }

  /** @type {Collection<import("./interaction/Interaction").default>} */
  let interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"](options.interactions.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_31__.assert)(
        typeof (/** @type {?} */ (options.interactions).getArray) ===
          'function',
        'Expected `interactions` to be an array or an `ol/Collection.js`',
      );
      interactions = options.interactions;
    }
  }

  /** @type {Collection<import("./Overlay.js").default>} */
  let overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"](options.overlays.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_31__.assert)(
        typeof (/** @type {?} */ (options.overlays).getArray) === 'function',
        'Expected `overlays` to be an array or an `ol/Collection.js`',
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values,
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Map);


/***/ }),

/***/ "./node_modules/ol/MapBrowserEvent.js":
/*!********************************************!*\
  !*** ./node_modules/ol/MapBrowserEvent.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/**
 * @module ol/MapBrowserEvent
 */


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */
class MapBrowserEvent extends _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);

    /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */
    this.originalEvent = originalEvent;

    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     * @private
     */
    this.pixel_ = null;

    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     * @private
     */
    this.coordinate_ = null;

    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */
    this.dragging = dragging !== undefined ? dragging : false;

    /**
     * @type {Array<PointerEvent>|undefined}
     */
    this.activePointers = activePointers;
  }

  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }

  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }

  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */
  preventDefault() {
    super.preventDefault();
    if ('preventDefault' in this.originalEvent) {
      /** @type {UIEvent} */ (this.originalEvent).preventDefault();
    }
  }

  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */
  stopPropagation() {
    super.stopPropagation();
    if ('stopPropagation' in this.originalEvent) {
      /** @type {UIEvent} */ (this.originalEvent).stopPropagation();
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapBrowserEvent);


/***/ }),

/***/ "./node_modules/ol/MapBrowserEventHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventHandler.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/MapBrowserEventHandler
 */









class MapBrowserEventHandler extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);

    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */
    this.map_ = map;

    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    this.clickTimeoutId_;

    /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */
    this.emulateClicks_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.dragging_ = false;

    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */
    this.dragListenerKeys_ = [];

    /**
     * @type {number}
     * @private
     */
    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;

    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */
    this.down_ = null;

    const element = this.map_.getViewport();

    /**
     * @type {Array<PointerEvent>}
     * @private
     */
    this.activePointers_ = [];

    /**
     * @type {!Object<number, Event>}
     * @private
     */
    this.trackedTouches_ = {};

    /**
     * @private
     */
    this.element_ = element;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.pointerdownListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
      element,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN,
      this.handlePointerDown_,
      this,
    );

    /**
     * @type {PointerEvent}
     * @private
     */
    this.originalPointerMoveEvent_;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.relayedListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
      element,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE,
      this.relayMoveEvent_,
      this,
    );

    /**
     * @private
     */
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);

    this.element_.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOUCHMOVE,
      this.boundHandleTouchMove_,
      _has_js__WEBPACK_IMPORTED_MODULE_4__.PASSIVE_EVENT_LISTENERS ? {passive: false} : false,
    );
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLICK,
      this.map_,
      pointerEvent,
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = undefined;
      newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].DBLCLICK,
        this.map_,
        pointerEvent,
      );
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = undefined;
        const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].SINGLECLICK,
          this.map_,
          pointerEvent,
        );
        this.dispatchEvent(newEvent);
      }, 250);
    }
  }

  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;

    if (
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP ||
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERCANCEL
    ) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          // Some platforms assign a new pointerId when the target changes.
          // If this happens, delete one tracked pointer. If there is more
          // than one tracked pointer for the old target, it will be cleared
          // by subsequent POINTERUP events from other pointers.
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERDOWN ||
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERMOVE
    ) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP,
      this.map_,
      pointerEvent,
      undefined,
      undefined,
      this.activePointers_,
    );
    this.dispatchEvent(newEvent);

    // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.preventDefault().
    if (
      this.emulateClicks_ &&
      !newEvent.defaultPrevented &&
      !this.dragging_ &&
      this.isMouseActionButton_(pointerEvent)
    ) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERDOWN,
      this.map_,
      pointerEvent,
      undefined,
      undefined,
      this.activePointers_,
    );
    this.dispatchEvent(newEvent);

    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, 'target', {
      writable: false,
      value: pointerEvent.target,
    });

    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
          doc,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERMOVE,
          this.handlePointerMove_,
          this,
        ),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(doc, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
          this.element_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERCANCEL,
          this.handlePointerUp_,
          this,
        ),
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
            this.element_.getRootNode(),
            _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP,
            this.handlePointerUp_,
            this,
          ),
        );
      }
    }
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        undefined,
        this.activePointers_,
      );
      this.dispatchEvent(newEvent);
    }
  }

  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging,
      ),
    );
  }

  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
    // may not be initialized yet when we get here on a platform without native pointer events,
    // when elm-pep is used as pointer events polyfill.
    const originalEvent = this.originalPointerMoveEvent_;
    if (
      (!originalEvent || originalEvent.defaultPrevented) &&
      (typeof event.cancelable !== 'boolean' || event.cancelable === true)
    ) {
      event.preventDefault();
    }
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return (
      this.dragging_ ||
      Math.abs(pointerEvent.clientX - this.down_.clientX) >
        this.moveTolerance_ ||
      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_
    );
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOUCHMOVE,
      this.boundHandleTouchMove_,
    );

    if (this.pointerdownListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey);
    this.dragListenerKeys_.length = 0;

    this.element_ = null;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapBrowserEventHandler);


/***/ }),

/***/ "./node_modules/ol/MapBrowserEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventType.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/MapBrowserEventType
 */


/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',

  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel',
});

/***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */


/***/ }),

/***/ "./node_modules/ol/MapEvent.js":
/*!*************************************!*\
  !*** ./node_modules/ol/MapEvent.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/MapEvent
 */


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */
class MapEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);

    /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */
    this.map = map;

    /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */
    this.frameState = frameState !== undefined ? frameState : null;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapEvent);


/***/ }),

/***/ "./node_modules/ol/MapEventType.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/MapEventType.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend',

  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: 'loadstart',

  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: 'loadend',
});

/***
 * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
 */


/***/ }),

/***/ "./node_modules/ol/MapProperty.js":
/*!****************************************!*\
  !*** ./node_modules/ol/MapProperty.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view',
});


/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectEvent: () => (/* binding */ ObjectEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/Object
 */






/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
class ObjectEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(type, key, oldValue) {
    super(type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    this.oldValue = oldValue;
  }
}

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
class BaseObject extends _Observable_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(values) {
    super();

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {ObjectOnSignature<void>}
     */
    this.un;

    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(this);

    /**
     * @private
     * @type {Object<string, *>|null}
     */
    this.values_ = null;

    if (values !== undefined) {
      this.setProperties(values);
    }
  }

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }

  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return (this.values_ && Object.keys(this.values_)) || [];
  }

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return (this.values_ && Object.assign({}, this.values_)) || {};
  }

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }

  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }

  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }

  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }

  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }

  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(key, value, silent) {
    const values = this.values_ || (this.values_ = {});
    if (silent) {
      values[key] = value;
    } else {
      const oldValue = values[key];
      values[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }

  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(values, silent) {
    for (const key in values) {
      this.set(key, values[key], silent);
    }
  }

  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }

  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseObject);


/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange',
});

/**
 * @typedef {'propertychange'} Types
 */


/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unByKey: () => (/* binding */ unByKey)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/Observable
 */




/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */

/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */

/**
 * @typedef {'change'|'error'} EventTypes
 */

/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
class Observable extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    this.on =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (
        this.onInternal
      );

    this.once =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (
        this.onceInternal
      );

    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);

    /**
     * @private
     * @type {number}
     */
    this.revision_ = 0;
  }

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  }

  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }

  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, type[i], listener);
      }
      return keys;
    }
    return (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, /** @type {string} */ (type), listener);
  }

  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listenOnce)(this, type[i], listener);
      }
    } else {
      key = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listenOnce)(this, /** @type {string} */ (type), listener);
    }
    /** @type {Object} */ (listener).ol_key = key;
    return key;
  }

  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(type, listener) {
    const key = /** @type {Object} */ (listener).ol_key;
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
}

/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.on;

/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.once;

/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */
Observable.prototype.un;

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(key[i]);
    }
  } else {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(/** @type {import("./events.js").EventsKey} */ (key));
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Observable);


/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/Tile
 */






/**
 * A function that takes a {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState.js';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
class Tile extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();

    options = options ? options : {};

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {import("./TileState.js").default}
     */
    this.state = state;

    /**
     * A key assigned to the tile. This is used in conjunction with a source key
     * to determine if a cached version of this tile may be used by the renderer.
     * @type {string}
     */
    this.key = '';

    /**
     * The duration for the opacity transition.
     * @private
     * @type {number}
     */
    this.transition_ =
      options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @private
     * @type {Object<string, number>}
     */
    this.transitionStarts_ = {};

    /**
     * @type {boolean}
     */
    this.interpolate = !!options.interpolate;
  }

  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  }

  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY);
    }
  }

  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + '/' + this.tileCoord;
  }

  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }

  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }

  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR && this.state > state) {
      throw new Error('Tile load sequence violation');
    }
    this.state = state;
    this.changed();
  }

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  }

  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }

    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    const delta = time - start + 1000 / 60; // avoid rendering at 0
    if (delta >= this.transition_) {
      return 1;
    }
    return (0,_easing_js__WEBPACK_IMPORTED_MODULE_4__.easeIn)(delta / this.transition_);
  }

  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }

  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }

  /**
   * @override
   */
  disposeInternal() {
    this.release();
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tile);


/***/ }),

/***/ "./node_modules/ol/TileQueue.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileQueue.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getTilePriority: () => (/* binding */ getTilePriority)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/**
 * @module ol/TileQueue
 */




/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */

class TileQueue extends _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function (element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function (element) {
        return /** @type {import("./Tile.js").default} */ (element[0]).getKey();
      },
    );

    /** @private */
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);

    /**
     * @private
     * @type {function(): ?}
     */
    this.tileChangeCallback_ = tileChangeCallback;

    /**
     * @private
     * @type {number}
     */
    this.tilesLoading_ = 0;

    /**
     * @private
     * @type {!Object<string,boolean>}
     */
    this.tilesLoadingKeys_ = {};
  }

  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile = element[0];
      tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }

  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }

  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = /** @type {import("./Tile.js").default} */ (event.target);
    const state = tile.getState();
    if (
      state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
      state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR ||
      state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY
    ) {
      if (state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
        tile.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }

  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    while (
      this.tilesLoading_ < maxTotalLoading &&
      newLoads < maxNewLoads &&
      this.getCount() > 0
    ) {
      /**
       * @type {import("./Tile.js").default}
       */
      const tile = this.dequeue()[0];
      const tileKey = tile.getKey();
      const state = tile.getState();
      if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileQueue);

/**
 * @param {import('./Map.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */
function getTilePriority(
  frameState,
  tile,
  tileSourceKey,
  tileCenter,
  tileResolution,
) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__.DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__.DROP;
  }
  // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels between
  // the center of the tile and the center of the viewport.  The factor of 65536
  // means that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return (
    65536 * Math.log(tileResolution) +
    Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution
  );
}


/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
class TileRange {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    /**
     * @type {number}
     */
    this.minX = minX;

    /**
     * @type {number}
     */
    this.maxX = maxX;

    /**
     * @type {number}
     */
    this.minY = minY;

    /**
     * @type {number}
     */
    this.maxY = maxY;
  }

  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return (
      this.minX <= tileRange.minX &&
      tileRange.maxX <= this.maxX &&
      this.minY <= tileRange.minY &&
      tileRange.maxY <= this.maxY
    );
  }

  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return (
      this.minX == tileRange.minX &&
      this.minY == tileRange.minY &&
      this.maxX == tileRange.maxX &&
      this.maxY == tileRange.maxY
    );
  }

  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }

  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }

  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }

  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return (
      this.minX <= tileRange.maxX &&
      this.maxX >= tileRange.minX &&
      this.minY <= tileRange.maxY &&
      this.maxY >= tileRange.minY
    );
  }
}

/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileRange);


/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4,
});


/***/ }),

/***/ "./node_modules/ol/View.js":
/*!*********************************!*\
  !*** ./node_modules/ol/View.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCenterConstraint: () => (/* binding */ createCenterConstraint),
/* harmony export */   createResolutionConstraint: () => (/* binding */ createResolutionConstraint),
/* harmony export */   createRotationConstraint: () => (/* binding */ createRotationConstraint),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isNoopAnimation: () => (/* binding */ isNoopAnimation)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ViewProperty.js */ "./node_modules/ol/ViewProperty.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./centerconstraint.js */ "./node_modules/ol/centerconstraint.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resolutionconstraint.js */ "./node_modules/ol/resolutionconstraint.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/**
 * @module ol/View
 */

















/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */

/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */

/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to
 * fit the extent into. Defaults to the size of the map the view is associated with.
 * If no map or multiple maps are connected to the view, provide the desired box size
 * (e.g. `map.getSize()`).
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */

/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */

/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center (in view projection coordinates).
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */

/**
 * Like {@link import("./Map.js").FrameState}, but just `viewState` and `extent`.
 * @typedef {Object} ViewStateLayerStateExtent
 * @property {State} viewState View state.
 * @property {import("./extent.js").Extent} extent Extent (in user projection coordinates).
 * @property {Array<import("./layer/Layer.js").State>} [layerStatesArray] Layer states.
 */

/**
 * Default min zoom level for the map view.
 * @type {number}
 */
const DEFAULT_MIN_ZOOM = 0;

/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */

/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */
class View extends _Object_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(options) {
    super();

    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {ViewOnSignature<void>}
     */
    this.un;

    options = Object.assign({}, options);

    /**
     * @private
     * @type {Array<number>}
     */
    this.hints_ = [0, 0];

    /**
     * @private
     * @type {Array<Array<Animation>>}
     */
    this.animations_ = [];

    /**
     * @private
     * @type {number|undefined}
     */
    this.updateAnimationKey_;

    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */
    this.projection_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');

    /**
     * @private
     * @type {import("./size.js").Size}
     */
    this.viewportSize_ = [100, 100];

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    this.targetCenter_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.targetResolution_;

    /**
     * @private
     * @type {number|undefined}
     */
    this.targetRotation_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */
    this.nextCenter_ = null;

    /**
     * @private
     * @type {number}
     */
    this.nextResolution_;

    /**
     * @private
     * @type {number}
     */
    this.nextRotation_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    this.cancelAnchor_ = undefined;

    if (options.projection) {
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.disableCoordinateWarning)();
    }
    if (options.center) {
      options.center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(options.extent, this.projection_);
    }

    this.applyOptions_(options);
  }

  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in _ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      delete properties[key];
    }
    this.setProperties(properties, true);

    const resolutionConstraintInfo = createResolutionConstraint(options);

    /**
     * @private
     * @type {number}
     */
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;

    /**
     * @private
     * @type {number}
     */
    this.minResolution_ = resolutionConstraintInfo.minResolution;

    /**
     * @private
     * @type {number}
     */
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

    /**
     * @private
     * @type {Array<number>|undefined}
     */
    this.resolutions_ = options.resolutions;

    /**
     * @type {Array<number>|undefined}
     * @private
     */
    this.padding_ = options.padding;

    /**
     * @private
     * @type {number}
     */
    this.minZoom_ = resolutionConstraintInfo.minZoom;

    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);

    /**
     * @private
     * @type {Constraints}
     */
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint,
    };

    this.setRotation(options.rotation !== undefined ? options.rotation : 0);
    this.setCenterInternal(
      options.center !== undefined ? options.center : null,
    );
    if (options.resolution !== undefined) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== undefined) {
      this.setZoom(options.zoom);
    }
  }

  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenterInternal();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX =
        (resolution / 2) *
        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY =
        (resolution / 2) *
        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }

  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();

    // preserve resolution (or zoom)
    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }

    // preserve center
    options.center = this.getCenterInternal();

    // preserve rotation
    options.rotation = this.getRotation();

    return Object.assign({}, options, newOptions);
  }

  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i = 0; i < args.length; ++i) {
      let options = arguments[i];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
          options.center,
          this.getProjection(),
        );
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
          options.anchor,
          this.getProjection(),
        );
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  }

  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (
      animationCount > 1 &&
      typeof arguments[animationCount - 1] === 'function'
    ) {
      callback = arguments[animationCount - 1];
      --animationCount;
    }

    let i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      // if view properties are not yet set, shortcut to the final state
      const state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }

    let start = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i < animationCount; ++i) {
      const options = /** @type {AnimationOptions} */ (arguments[i]);

      const animation = {
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing_js__WEBPACK_IMPORTED_MODULE_3__.inAndOut,
        callback: callback,
      };

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        const delta =
          (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }

      // check if animation is a no-op
      if (isNoopAnimation(animation)) {
        animation.complete = true;
        // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, 1);
    this.updateAnimations_();
  }

  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING] > 0;
  }

  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING] > 0;
  }

  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING]);
    let anchor;
    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
      const series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j = 0, jj = series.length; j < jj; ++j) {
          const animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }

  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now = Date.now();
    let more = false;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const series = this.animations_[i];
      let seriesComplete = true;
      for (let j = 0, jj = series.length; j < jj; ++j) {
        const animation = series[j];
        if (animation.complete) {
          continue;
        }
        const elapsed = now - animation.start;
        let fraction =
          animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x = x0 + progress * (x1 - x0);
          const y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution =
            progress === 1
              ? animation.targetResolution
              : animation.sourceResolution +
                progress *
                  (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(
              resolution,
              0,
              size,
              true,
            );
            this.targetCenter_ = this.calculateCenterZoom(
              constrainedResolution,
              animation.anchor,
            );
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (
          animation.sourceRotation !== undefined &&
          animation.targetRotation !== undefined
        ) {
          const rotation =
            progress === 1
              ? (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) -
                Math.PI
              : animation.sourceRotation +
                progress *
                  (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(
              rotation,
              true,
            );
            this.targetCenter_ = this.calculateCenterRotate(
              constrainedRotation,
              animation.anchor,
            );
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    // prune completed series
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this),
      );
    }
  }

  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.rotate)(center, rotation - this.getRotation());
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.add)(center, anchor);
    }
    return center;
  }

  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== undefined && currentResolution !== undefined) {
      const x =
        anchor[0] -
        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;
      const y =
        anchor[1] -
        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;
      center = [x, y];
    }
    return center;
  }

  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(rotation) {
    const size = this.viewportSize_;
    if (rotation) {
      const w = size[0];
      const h = size[1];
      return [
        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),
      ];
    }
    return size;
  }

  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(size) {
    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }

  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(center, this.getProjection());
  }

  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return /** @type {import("./coordinate.js").Coordinate|undefined} */ (
      this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER)
    );
  }

  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }

  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get('constrainResolution');
  }

  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(hints) {
    if (hints !== undefined) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }

  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(size) {
    const extent = this.calculateExtentInternal(size);
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, this.getProjection());
  }

  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(size) {
    size = size || this.getViewportSizeMinusPadding_();
    const center = /** @type {!import("./coordinate.js").Coordinate} */ (
      this.getCenterInternal()
    );
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(center, 'The view center is not defined');
    const resolution = /** @type {!number} */ (this.getResolution());
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(resolution !== undefined, 'The view resolution is not defined');
    const rotation = /** @type {!number} */ (this.getRotation());
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(rotation !== undefined, 'The view rotation is not defined');

    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getForViewAndSize)(center, resolution, rotation, size);
  }

  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }

  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }

  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return /** @type {number} */ (
      this.getZoomForResolution(this.minResolution_)
    );
  }

  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));
  }

  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return /** @type {number} */ (
      this.getZoomForResolution(this.maxResolution_)
    );
  }

  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));
  }

  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));
  }

  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }

  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return /** @type {number|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION));
  }

  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }

  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(extent, size) {
    return this.getResolutionForExtentInternal(
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(extent, this.getProjection()),
      size,
    );
  }

  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(extent, size) {
    size = size || this.getViewportSizeMinusPadding_();
    const xResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(extent) / size[0];
    const yResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(extent) / size[1];
    return Math.max(xResolution, yResolution);
  }

  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function (value) {
        const resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  }

  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return /** @type {number} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION));
  }

  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function (resolution) {
        const value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  }

  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(rotation) {
    let size = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2],
      ];
    }
    return size;
  }

  /**
   * @return {State} View state.
   */
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = /** @type {import("./coordinate.js").Coordinate} */ (
      this.getCenterInternal()
    );
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(
        center,
        this.getViewportSize_(),
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation,
      );
    }
    return {
      center: center.slice(0),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: rotation,
      zoom: this.getZoom(),
    };
  }

  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent(),
    };
  }

  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }

  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(resolution) {
    let offset = this.minZoom_ || 0;
    let max, zoomFactor;
    if (this.resolutions_) {
      const nearest = (0,_array_js__WEBPACK_IMPORTED_MODULE_9__.linearFindNearest)(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  }

  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(zoom) {
    if (this.resolutions_?.length) {
      if (this.resolutions_.length === 1) {
        return this.resolutions_[0];
      }
      const baseLevel = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(
        Math.floor(zoom),
        0,
        this.resolutions_.length - 2,
      );
      const zoomFactor =
        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return (
        this.resolutions_[baseLevel] /
        Math.pow(zoomFactor, (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(zoom - baseLevel, 0, 1))
      );
    }
    return (
      this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)
    );
  }

  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(geometryOrExtent, options) {
    /** @type {import("./geom/SimpleGeometry.js").default} */
    let geometry;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(
      Array.isArray(geometryOrExtent) ||
        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===
          'function',
      'Invalid extent or geometry provided as `geometry`',
    );
    if (Array.isArray(geometryOrExtent)) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(
        !(0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.isEmpty)(geometryOrExtent),
        'Cannot fit empty extent provided as `geometry`',
      );
      const extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(geometryOrExtent, this.getProjection());
      geometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__.fromExtent)(extent);
    } else if (geometryOrExtent.getType() === 'Circle') {
      const extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(
        geometryOrExtent.getExtent(),
        this.getProjection(),
      );
      geometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__.fromExtent)(extent);
      geometry.rotate(this.getRotation(), (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(extent));
    } else {
      const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
      if (userProjection) {
        geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ (
          geometryOrExtent
            .clone()
            .transform(userProjection, this.getProjection())
        );
      } else {
        geometry = geometryOrExtent;
      }
    }

    this.fitInternal(geometry, options);
  }

  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = +Infinity;
    let minRotY = +Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i = 0, ii = coords.length; i < ii; i += stride) {
      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }

  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(geometry, options) {
    options = options || {};
    let size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    const padding =
      options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== undefined ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }

    const rotatedExtent = this.rotatedExtentForGeometry(geometry);

    // calculate resolution
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2],
    ]);
    resolution = isNaN(resolution)
      ? minResolution
      : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);

    // calculate center
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(rotatedExtent);
    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;
    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : _functions_js__WEBPACK_IMPORTED_MODULE_11__.VOID;

    if (options.duration !== undefined) {
      this.animateInternal(
        {
          resolution: resolution,
          center: center,
          duration: options.duration,
          easing: options.easing,
        },
        callback,
      );
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }

  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(coordinate, size, position) {
    this.centerOnInternal(
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinate, this.getProjection()),
      size,
      position,
    );
  }

  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(coordinate, size, position) {
    this.setCenterInternal(
      calculateCenterOn(
        coordinate,
        size,
        position,
        this.getResolution(),
        this.getRotation(),
      ),
    );
  }

  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(center, resolution, rotation, size) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(
        center,
        size,
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation,
      );
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1],
      ];
    }
    return centerShift;
  }

  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== undefined;
  }

  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(deltaCoordinates) {
    const center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1],
    ]);
  }

  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1],
    ]);
  }

  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(ratio, anchor) {
    anchor = anchor && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }

  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(
      this.targetResolution_ * ratio,
      0,
      size,
      isMoving,
    );

    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }

    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }

  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }

  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }

  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(
      this.targetRotation_ + delta,
      isMoving,
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }

  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(center) {
    this.setCenterInternal(
      center ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(center, this.getProjection()) : center,
    );
  }

  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }

  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }

  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }

  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }

  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }

  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving =
      this.getAnimating() || this.getInteracting() || forceMoving;

    // compute rotation
    const newRotation = this.constraints_.rotation(
      this.targetRotation_,
      isMoving,
    );
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      0,
      size,
      isMoving,
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      isMoving,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size,
      ),
    );

    if (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION) !== newRotation) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION, newRotation);
    }
    if (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION) !== newResolution) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION, newResolution);
      this.set('zoom', this.getZoom(), true);
    }
    if (
      !newCenter ||
      !this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER) ||
      !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER), newCenter)
    ) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER, newCenter);
    }

    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = undefined;
  }

  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(duration, resolutionDirection, anchor) {
    duration = duration !== undefined ? duration : 200;
    const direction = resolutionDirection || 0;

    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      direction,
      size,
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      false,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size,
      ),
    );

    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }

    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
    this.cancelAnchor_ = undefined;

    if (
      this.getResolution() !== newResolution ||
      this.getRotation() !== newRotation ||
      !this.getCenterInternal() ||
      !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(this.getCenterInternal(), newCenter)
    ) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }

      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration: duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__.easeOut,
        anchor: anchor,
      });
    }
  }

  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0);

    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING, 1);
  }

  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(duration, resolutionDirection, anchor) {
    anchor = anchor && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(anchor, this.getProjection());
    this.endInteractionInternal(duration, resolutionDirection, anchor);
  }

  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(duration, resolutionDirection, anchor) {
    if (!this.getInteracting()) {
      return;
    }
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING, -1);
    this.resolveConstraints(duration, resolutionDirection, anchor);
  }

  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(targetCenter, targetResolution) {
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      targetCenter,
      targetResolution || this.getResolution(),
      size,
    );
  }

  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(targetZoom, direction) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(
      this.getConstrainedResolution(targetRes, direction),
    );
  }

  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(targetResolution, direction) {
    direction = direction || 0;
    const size = this.getViewportSize_(this.getRotation());

    return this.constraints_.resolution(targetResolution, direction, size);
  }
}

/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */
function animationCallback(callback, returnValue) {
  setTimeout(function () {
    callback(returnValue);
  }, 0);
}

/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */
function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    const smooth =
      options.smoothExtentConstraint !== undefined
        ? options.smoothExtentConstraint
        : true;
    return (0,_centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
  }

  const projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return (0,_centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__.createExtent)(extent, false, false);
  }

  return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__.none;
}

/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;

  let minZoom =
    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;

  let maxZoom =
    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;

  const zoomFactor =
    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;

  const multiWorld =
    options.multiWorld !== undefined ? options.multiWorld : false;

  const smooth =
    options.smoothResolutionConstraint !== undefined
      ? options.smoothResolutionConstraint
      : true;

  const showFullExtent =
    options.showFullExtent !== undefined ? options.showFullExtent : false;

  const projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }

  if (options.resolutions !== undefined) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution =
      resolutions[maxZoom] !== undefined
        ? resolutions[maxZoom]
        : resolutions[resolutions.length - 1];

    if (options.constrainResolution) {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createSnapToResolutions)(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent,
      );
    } else {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createMinMaxResolution)(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent,
      );
    }
  } else {
    // calculate the default min and max resolution
    const size = !projExtent
      ? // use an extent that can fit the whole world if need be
        (360 * _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()
      : Math.max((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(projExtent), (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(projExtent));

    const defaultMaxResolution =
      size / _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);

    const defaultMinResolution =
      defaultMaxResolution /
      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom =
      minZoom +
      Math.floor(
        Math.log(maxResolution / minResolution) / Math.log(zoomFactor),
      );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    if (options.constrainResolution) {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createSnapToPower)(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent,
      );
    } else {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createMinMaxResolution)(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent,
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor,
  };
}

/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */
function createRotationConstraint(options) {
  const enableRotation =
    options.enableRotation !== undefined ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return (0,_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createSnapToZero)();
    }
    if (constrainRotation === false) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.none;
    }
    if (typeof constrainRotation === 'number') {
      return (0,_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createSnapToN)(constrainRotation);
    }
    return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.none;
  }
  return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.disable;
}

/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}

/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  // calculate rotated position
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;

  // go back to original angle
  sinAngle = -sinAngle; // go back to original rotation
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;

  return [centerX, centerY];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);


/***/ }),

/***/ "./node_modules/ol/ViewHint.js":
/*!*************************************!*\
  !*** ./node_modules/ol/ViewHint.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ANIMATING: 0,
  INTERACTING: 1,
});


/***/ }),

/***/ "./node_modules/ol/ViewProperty.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/ViewProperty.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation',
});


/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascending: () => (/* binding */ ascending),
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   descending: () => (/* binding */ descending),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   isSorted: () => (/* binding */ isSorted),
/* harmony export */   linearFindNearest: () => (/* binding */ linearFindNearest),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   reverseSubArray: () => (/* binding */ reverseSubArray),
/* harmony export */   stableSort: () => (/* binding */ stableSort)
/* harmony export */ });
/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + ((high - low) >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}

/**
 * Compare function sorting arrays in ascending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}

/**
 * Compare function sorting arrays in descending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second.
 */
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */

/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }

  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }

  if (typeof direction === 'function') {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }

  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }

  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }

  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}

/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  const i = arr.indexOf(obj);
  const found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}

/**
 * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
  const length = arr.length;
  const tmp = Array(arr.length);
  let i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index: i, value: arr[i]};
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}

/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || (strict && res === 0));
  });
}


/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}


/***/ }),

/***/ "./node_modules/ol/centerconstraint.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/centerconstraint.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createExtent: () => (/* binding */ createExtent),
/* harmony export */   none: () => (/* binding */ none)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/centerconstraint
 */


/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return undefined;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;

      // note: when zooming out of bounds, min and max values for x and y may
      // end up inverted (min > max); this has to be accounted for
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }

      let x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(center[0], minX, maxX);
      let y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(center[1], minY, maxY);

      // during an interaction, allow some overscroll
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x +=
          -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +
          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y +=
          -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +
          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }

      return [x, y];
    }
  );
}

/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */
function none(center) {
  return center;
}


/***/ }),

/***/ "./node_modules/ol/color.js":
/*!**********************************!*\
  !*** ./node_modules/ol/color.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NO_COLOR: () => (/* binding */ NO_COLOR),
/* harmony export */   asArray: () => (/* binding */ asArray),
/* harmony export */   asString: () => (/* binding */ asString),
/* harmony export */   fromString: () => (/* binding */ fromString),
/* harmony export */   isStringColor: () => (/* binding */ isStringColor),
/* harmony export */   lchaToRgba: () => (/* binding */ lchaToRgba),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   rgbaToLcha: () => (/* binding */ rgbaToLcha),
/* harmony export */   toString: () => (/* binding */ toString),
/* harmony export */   withAlpha: () => (/* binding */ withAlpha)
/* harmony export */ });
/* harmony import */ var color_space_lchuv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! color-space/lchuv.js */ "./node_modules/color-space/lchuv.js");
/* harmony import */ var color_rgba__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! color-rgba */ "./node_modules/color-rgba/index.js");
/* harmony import */ var color_space_rgb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! color-space/rgb.js */ "./node_modules/color-space/rgb.js");
/* harmony import */ var color_space_xyz_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! color-space/xyz.js */ "./node_modules/color-space/xyz.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/color
 */






/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */

/**
 * Color to indicate that no color should be rendered. This is meant to be used for per-reference
 * comparisons only.
 * @type {Color}
 */
const NO_COLOR = [NaN, NaN, NaN, 0];

/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
  if (typeof color === 'string') {
    return color;
  }
  return toString(color);
}

/**
 * @type {number}
 */
const MAX_CACHE_SIZE = 1024;

/**
 * We maintain a small cache of parsed strings.  Whenever the cache grows too large,
 * we delete an arbitrary set of the entries.
 *
 * @type {Object<string, Color>}
 */
const cache = {};

/**
 * @type {number}
 */
let cacheSize = 0;

/**
 * @param {Color} color A color that may or may not have an alpha channel.
 * @return {Color} The input color with an alpha channel.  If the input color has
 * an alpha channel, the input color will be returned unchanged.  Otherwise, a new
 * array will be returned with the input color and an alpha channel of 1.
 */
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}

/**
 * @param {Color} color RGBA color.
 * @return {Color} LCHuv color with alpha.
 */
function rgbaToLcha(color) {
  const output = color_space_xyz_js__WEBPACK_IMPORTED_MODULE_3__["default"].lchuv(color_space_rgb_js__WEBPACK_IMPORTED_MODULE_2__["default"].xyz(color));
  output[3] = color[3];
  return output;
}

/**
 * @param {Color} color LCHuv color with alpha.
 * @return {Color} RGBA color.
 */
function lchaToRgba(color) {
  const output = color_space_xyz_js__WEBPACK_IMPORTED_MODULE_3__["default"].rgb(color_space_lchuv_js__WEBPACK_IMPORTED_MODULE_0__["default"].xyz(color));
  output[3] = color[3];
  return output;
}

/**
 * @param {string} s String.
 * @return {Color} Color.
 */
function fromString(s) {
  if (s === 'none') {
    return NO_COLOR;
  }
  if (cache.hasOwnProperty(s)) {
    return cache[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key in cache) {
      if ((i++ & 3) === 0) {
        delete cache[key];
        --cacheSize;
      }
    }
  }

  const color = (0,color_rgba__WEBPACK_IMPORTED_MODULE_1__["default"])(s);
  if (color.length !== 4) {
    throw new Error('failed to parse "' + s + '" as color');
  }
  for (const c of color) {
    if (isNaN(c)) {
      throw new Error('failed to parse "' + s + '" as color');
    }
  }
  normalize(color);
  cache[s] = color;
  ++cacheSize;
  return color;
}

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}

/**
 * Exported for the tests.
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
function normalize(color) {
  color[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)((color[0] + 0.5) | 0, 0, 255);
  color[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)((color[1] + 0.5) | 0, 0, 255);
  color[2] = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)((color[2] + 0.5) | 0, 0, 255);
  color[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(color[3], 0, 1);
  return color;
}

/**
 * @param {Color} color Color.
 * @return {string} String.
 */
function toString(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = (r + 0.5) | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = (g + 0.5) | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = (b + 0.5) | 0;
  }
  const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */
function isStringColor(s) {
  try {
    fromString(s);
    return true;
  } catch (_) {
    return false;
  }
}


/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/*!**************************************!*\
  !*** ./node_modules/ol/colorlike.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asColorLike: () => (/* binding */ asColorLike)
/* harmony export */ });
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _style_IconImage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style/IconImage.js */ "./node_modules/ol/style/IconImage.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style/IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/colorlike
 */






/**
 * @typedef {Object} PatternDescriptor
 * @property {string} src Pattern image URL
 * @property {import("./color.js").Color|string} [color] Color to tint the pattern with.
 * @property {import("./size.js").Size} [size] Size of the desired slice from the pattern image.
 * Use this together with `offset` when the pattern image is a sprite sheet.
 * @property {import("./size.js").Size} [offset] Offset of the desired slice from the pattern image.
 * Use this together with `size` when the pattern image is a sprite sheet.
 */

/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, [CanvasPattern](https://developer.mozilla.org/en-US/docs/Web/API/CanvasPattern),
 * or [CanvasGradient](https://developer.mozilla.org/en-US/docs/Web/API/CanvasGradient). The origin for
 * patterns and gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike|PatternDescriptor|null} color Color.
 * @return {ColorLike|null} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.toString)(color);
  }
  if (typeof color === 'object' && 'src' in color) {
    return asCanvasPattern(color);
  }
  return color;
}

/**
 * @param {PatternDescriptor} pattern Pattern descriptor.
 * @return {CanvasPattern|null} Canvas pattern or null if the pattern referenced in the
 * PatternDescriptor was not found in the icon image cache.
 */
function asCanvasPattern(pattern) {
  if (!pattern.offset || !pattern.size) {
    return _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_1__.shared.getPattern(pattern.src, 'anonymous', pattern.color);
  }

  const cacheKey = pattern.src + ':' + pattern.offset;

  const canvasPattern = _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_1__.shared.getPattern(
    cacheKey,
    undefined,
    pattern.color,
  );
  if (canvasPattern) {
    return canvasPattern;
  }

  const iconImage = _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_1__.shared.get(pattern.src, 'anonymous', null);
  if (iconImage.getImageState() !== _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
    return null;
  }
  const patternCanvasContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(
    pattern.size[0],
    pattern.size[1],
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern.offset[0],
    pattern.offset[1],
    pattern.size[0],
    pattern.size[1],
    0,
    0,
    pattern.size[0],
    pattern.size[1],
  );
  (0,_style_IconImage_js__WEBPACK_IMPORTED_MODULE_4__.get)(
    patternCanvasContext.canvas,
    cacheKey,
    undefined,
    _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED,
    pattern.color,
    true,
  );
  return _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_1__.shared.getPattern(cacheKey, undefined, pattern.color);
}


/***/ }),

/***/ "./node_modules/ol/console.js":
/*!************************************!*\
  !*** ./node_modules/ol/console.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   setLevel: () => (/* binding */ setLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/**
 * @module ol/console
 */

/**
 * @typedef {'info'|'warn'|'error'|'none'} Level
 */

/**
 * @type {Object<Level, number>}
 */
const levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4,
};

/**
 * @type {number}
 */
let level = levels.info;

/**
 * Set the logging level.  By default, the level is set to 'info' and all
 * messages will be logged.  Set to 'warn' to only display warnings and errors.
 * Set to 'error' to only display errors.  Set to 'none' to silence all messages.
 *
 * @param {Level} l The new level.
 */
function setLevel(l) {
  level = levels[l];
}

/**
 * @param  {...any} args Arguments to log
 */
function log(...args) {
  if (level > levels.info) {
    return;
  }
  console.log(...args); // eslint-disable-line no-console
}

/**
 * @param  {...any} args Arguments to log
 */
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args); // eslint-disable-line no-console
}

/**
 * @param  {...any} args Arguments to log
 */
function error(...args) {
  if (level > levels.error) {
    return;
  }
  console.error(...args); // eslint-disable-line no-console
}


/***/ }),

/***/ "./node_modules/ol/control/Attribution.js":
/*!************************************************!*\
  !*** ./node_modules/ol/control/Attribution.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/control/Attribution
 */







/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {string|Array<string>|undefined} [attributions] Optional attribution(s) that will always be
 * displayed regardless of the layers rendered
 */

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
class Attribution extends _Control_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      element: document.createElement('div'),
      render: options.render,
      target: options.target,
    });

    /**
     * @private
     * @type {HTMLElement}
     */
    this.ulElement_ = document.createElement('ul');

    /**
     * @private
     * @type {boolean}
     */
    this.collapsed_ =
      options.collapsed !== undefined ? options.collapsed : true;

    /**
     * @private
     * @type {boolean}
     */
    this.userCollapsed_ = this.collapsed_;

    /**
     * @private
     * @type {boolean}
     */
    this.overrideCollapsible_ = options.collapsible !== undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.collapsible_ =
      options.collapsible !== undefined ? options.collapsible : true;

    if (!this.collapsible_) {
      this.collapsed_ = false;
    }

    /**
     * @private
     * @type {string | Array<string> | undefined}
     */
    this.attributions_ = options.attributions;

    const className =
      options.className !== undefined ? options.className : 'ol-attribution';

    const tipLabel =
      options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

    const expandClassName =
      options.expandClassName !== undefined
        ? options.expandClassName
        : className + '-expand';

    const collapseLabel =
      options.collapseLabel !== undefined ? options.collapseLabel : '\u203A';

    const collapseClassName =
      options.collapseClassName !== undefined
        ? options.collapseClassName
        : className + '-collapse';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.collapseLabel_ = document.createElement('span');
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }

    const label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.label_ = document.createElement('span');
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }

    const activeLabel =
      this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.toggleButton_ = document.createElement('button');
    this.toggleButton_.setAttribute('type', 'button');
    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);

    this.toggleButton_.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this),
      false,
    );

    const cssClasses =
      className +
      ' ' +
      _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_UNSELECTABLE +
      ' ' +
      _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_CONTROL +
      (this.collapsed_ && this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_COLLAPSED : '') +
      (this.collapsible_ ? '' : ' ol-uncollapsible');
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);

    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */
    this.renderedAttributions_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;
  }

  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const layers = this.getMap().getAllLayers();
    const visibleAttributions = new Set(
      layers.flatMap((layer) => layer.getAttributions(frameState)),
    );
    if (this.attributions_ !== undefined) {
      Array.isArray(this.attributions_)
        ? this.attributions_.forEach((item) => visibleAttributions.add(item))
        : visibleAttributions.add(this.attributions_);
    }

    if (!this.overrideCollapsible_) {
      const collapsible = !layers.some(
        (layer) => layer.getSource()?.getAttributionsCollapsible() === false,
      );
      this.setCollapsible(collapsible);
    }
    return Array.from(visibleAttributions);
  }

  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    const attributions = await Promise.all(
      this.collectSourceAttributions_(frameState).map((attribution) =>
        (0,_functions_js__WEBPACK_IMPORTED_MODULE_3__.toPromise)(() => attribution),
      ),
    );

    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if ((0,_array_js__WEBPACK_IMPORTED_MODULE_4__.equals)(attributions, this.renderedAttributions_)) {
      return;
    }

    (0,_dom_js__WEBPACK_IMPORTED_MODULE_5__.removeChildren)(this.ulElement_);

    // append the attributions
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement('li');
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  }

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }

  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_COLLAPSED);
    if (this.collapsed_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_5__.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_5__.replaceNode)(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
  }

  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }

  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }

  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }

  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }

  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Attribution);


/***/ }),

/***/ "./node_modules/ol/control/Control.js":
/*!********************************************!*\
  !*** ./node_modules/ol/control/Control.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/control/Control
 */





/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
class Control extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Control options.
   */
  constructor(options) {
    super();

    const element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = 'auto';
    }

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.element = element ? element : null;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.target_ = null;

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    this.map_ = null;

    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */
    this.listenerKeys = [];

    if (options.render) {
      this.render = options.render;
    }

    if (options.target) {
      this.setTarget(options.target);
    }
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.element?.remove();
    super.disposeInternal();
  }

  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }

  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.map_) {
      this.element?.remove();
    }
    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      const target = this.target_ ?? map.getOverlayContainerStopEvent();
      if (this.element) {
        target.appendChild(this.element);
      }
      if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID) {
        this.listenerKeys.push(
          (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POSTRENDER, this.render, this),
        );
      }
      map.render();
    }
  }

  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(mapEvent) {}

  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(target) {
    this.target_ =
      typeof target === 'string' ? document.getElementById(target) : target;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Control);


/***/ }),

/***/ "./node_modules/ol/control/Rotate.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/control/Rotate.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/control/Rotate
 */





/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
class Rotate extends _Control_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      element: document.createElement('div'),
      render: options.render,
      target: options.target,
    });

    const className =
      options.className !== undefined ? options.className : 'ol-rotate';

    const label = options.label !== undefined ? options.label : '\u21E7';

    const compassClassName =
      options.compassClassName !== undefined
        ? options.compassClassName
        : 'ol-compass';

    /**
     * @type {HTMLElement}
     * @private
     */
    this.label_ = null;

    if (typeof label === 'string') {
      this.label_ = document.createElement('span');
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }

    const tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

    const button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(this.label_);

    button.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this),
      false,
    );

    const cssClasses =
      className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);

    /**
     * @private
     */
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @type {boolean}
     * @private
     */
    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    if (this.autoHide_) {
      this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
    }
  }

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }

  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== undefined) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__.easeOut,
        });
      } else {
        view.setRotation(0);
      }
    }
  }

  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform = 'rotate(' + rotation + 'rad)';
      if (this.autoHide_) {
        const contains = this.element.classList.contains(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
        if (!contains && rotation === 0) {
          this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
        } else if (contains && rotation !== 0) {
          this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform;
    }
    this.rotation_ = rotation;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rotate);


/***/ }),

/***/ "./node_modules/ol/control/Zoom.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/Zoom.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/control/Zoom
 */





/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
class Zoom extends _Control_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      element: document.createElement('div'),
      target: options.target,
    });

    const className =
      options.className !== undefined ? options.className : 'ol-zoom';

    const delta = options.delta !== undefined ? options.delta : 1;

    const zoomInClassName =
      options.zoomInClassName !== undefined
        ? options.zoomInClassName
        : className + '-in';

    const zoomOutClassName =
      options.zoomOutClassName !== undefined
        ? options.zoomOutClassName
        : className + '-out';

    const zoomInLabel =
      options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    const zoomOutLabel =
      options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2013';

    const zoomInTipLabel =
      options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
    const zoomOutTipLabel =
      options.zoomOutTipLabel !== undefined
        ? options.zoomOutTipLabel
        : 'Zoom out';

    const inElement = document.createElement('button');
    inElement.className = zoomInClassName;
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === 'string'
        ? document.createTextNode(zoomInLabel)
        : zoomInLabel,
    );

    inElement.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this, delta),
      false,
    );

    const outElement = document.createElement('button');
    outElement.className = zoomOutClassName;
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === 'string'
        ? document.createTextNode(zoomOutLabel)
        : zoomOutLabel,
    );

    outElement.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this, -delta),
      false,
    );

    const cssClasses =
      className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }

  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== undefined) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__.easeOut,
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Zoom);


/***/ }),

/***/ "./node_modules/ol/control/defaults.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/control/defaults.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaults: () => (/* binding */ defaults)
/* harmony export */ });
/* harmony import */ var _Attribution_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Attribution.js */ "./node_modules/ol/control/Attribution.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Rotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rotate.js */ "./node_modules/ol/control/Rotate.js");
/* harmony import */ var _Zoom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Zoom.js */ "./node_modules/ol/control/Zoom.js");
/**
 * @module ol/control/defaults
 */





/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 */

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [options] Options for the default controls.
 * @return {Collection<import("./Control.js").default>} A collection of controls
 * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
 * @api
 */
function defaults(options) {
  options = options ? options : {};

  /** @type {Collection<import("./Control.js").default>} */
  const controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  const zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new _Zoom_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.zoomOptions));
  }

  const rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new _Rotate_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.rotateOptions));
  }

  const attributionControl =
    options.attribution !== undefined ? options.attribution : true;
  if (attributionControl) {
    controls.push(new _Attribution_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.attributionOptions));
  }

  return controls;
}


/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   closestOnCircle: () => (/* binding */ closestOnCircle),
/* harmony export */   closestOnSegment: () => (/* binding */ closestOnSegment),
/* harmony export */   createStringXY: () => (/* binding */ createStringXY),
/* harmony export */   degreesToStringHDMS: () => (/* binding */ degreesToStringHDMS),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   getWorldsAway: () => (/* binding */ getWorldsAway),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredDistanceToSegment: () => (/* binding */ squaredDistanceToSegment),
/* harmony export */   toStringHDMS: () => (/* binding */ toStringHDMS),
/* harmony export */   toStringXY: () => (/* binding */ toStringXY),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/coordinate
 */




/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}

/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  const r = circle.getRadius();
  const center = circle.getCenter();
  const x0 = center[0];
  const y0 = center[1];
  const x1 = coordinate[0];
  const y1 = coordinate[1];

  let dx = x1 - x0;
  const dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  const d = Math.sqrt(dx * dx + dy * dy);

  const x = x0 + (r * dx) / d;
  const y = y0 + (r * dy) / d;

  return [x, y];
}

/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  const x0 = coordinate[0];
  const y0 = coordinate[1];
  const start = segment[0];
  const end = segment[1];
  const x1 = start[0];
  const y1 = start[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const along =
    dx === 0 && dy === 0
      ? 0
      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  let x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}

/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}

/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
  const normalizedDegrees = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.modulo)(degrees + 180, 360) - 180;
  const x = Math.abs(3600 * normalizedDegrees);
  const decimals = fractionDigits || 0;

  let deg = Math.floor(x / 3600);
  let min = Math.floor((x - deg * 3600) / 60);
  let sec = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toFixed)(x - deg * 3600 - min * 60, decimals);

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  let hdms = deg + '\u00b0';
  if (min !== 0 || sec !== 0) {
    hdms += ' ' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(min, 2) + '\u2032';
  }
  if (sec !== 0) {
    hdms += ' ' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(sec, 2, decimals) + '\u2033';
  }
  if (normalizedDegrees !== 0) {
    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
  }

  return hdms;
}

/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template
      .replace('{x}', coordinate[0].toFixed(fractionDigits))
      .replace('{y}', coordinate[1].toFixed(fractionDigits));
  }
  return '';
}

/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  let equals = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}

/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}

/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  const dx = coord1[0] - coord2[0];
  const dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}

/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}

/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, fractionDigits) {
  if (coordinate) {
    return (
      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +
      ' ' +
      degreesToStringHDMS('EW', coordinate[0], fractionDigits)
    );
  }
  return '';
}

/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, '{x}, {y}', fractionDigits);
}

/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */
function wrapX(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (
    projection.canWrapX() &&
    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])
  ) {
    sourceExtentWidth = sourceExtentWidth || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth,
    );
  }
  return worldsAway;
}


/***/ }),

/***/ "./node_modules/ol/css.js":
/*!********************************!*\
  !*** ./node_modules/ol/css.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CLASS_COLLAPSED: () => (/* binding */ CLASS_COLLAPSED),
/* harmony export */   CLASS_CONTROL: () => (/* binding */ CLASS_CONTROL),
/* harmony export */   CLASS_HIDDEN: () => (/* binding */ CLASS_HIDDEN),
/* harmony export */   CLASS_SELECTABLE: () => (/* binding */ CLASS_SELECTABLE),
/* harmony export */   CLASS_UNSELECTABLE: () => (/* binding */ CLASS_UNSELECTABLE),
/* harmony export */   CLASS_UNSUPPORTED: () => (/* binding */ CLASS_UNSUPPORTED),
/* harmony export */   getFontParameters: () => (/* binding */ getFontParameters)
/* harmony export */ });
/**
 * @module ol/css
 */

/**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
const CLASS_HIDDEN = 'ol-hidden';

/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
const CLASS_SELECTABLE = 'ol-selectable';

/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
const CLASS_UNSELECTABLE = 'ol-unselectable';

/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
const CLASS_UNSUPPORTED = 'ol-unsupported';

/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
const CLASS_CONTROL = 'ol-control';

/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
const CLASS_COLLAPSED = 'ol-collapsed';

/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */
const fontRegEx = new RegExp(
  [
    '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
    '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
    '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
    '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
    '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
  ].join(''),
  'i',
);
/** @type {Array<'style'|'variant'|'weight'|'size'|'lineHeight'|'family'>} */
const fontRegExMatchIndex = [
  'style',
  'variant',
  'weight',
  'size',
  'lineHeight',
  'family',
];

/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters|null} The font parameters (or null if the input spec is invalid).
 */
const getFontParameters = function (fontSpec) {
  const match = fontSpec.match(fontRegEx);
  if (!match) {
    return null;
  }
  const style = /** @type {FontParameters} */ ({
    lineHeight: 'normal',
    size: '1.2em',
    style: 'normal',
    weight: 'normal',
    variant: 'normal',
  });
  for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    const value = match[i + 1];
    if (value !== undefined) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }
  style.families = style.family.split(/,\s?/);
  return style;
};


/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCanvasContext2D: () => (/* binding */ createCanvasContext2D),
/* harmony export */   getSharedCanvasContext2D: () => (/* binding */ getSharedCanvasContext2D),
/* harmony export */   outerHeight: () => (/* binding */ outerHeight),
/* harmony export */   outerWidth: () => (/* binding */ outerWidth),
/* harmony export */   releaseCanvas: () => (/* binding */ releaseCanvas),
/* harmony export */   removeChildren: () => (/* binding */ removeChildren),
/* harmony export */   replaceChildren: () => (/* binding */ replaceChildren),
/* harmony export */   replaceNode: () => (/* binding */ replaceNode)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");


/**
 * @module ol/dom
 */

//FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(width, height, canvasPool, settings) {
  /** @type {HTMLCanvasElement|OffscreenCanvas} */
  let canvas;
  if (canvasPool && canvasPool.length) {
    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());
  } else if (_has_js__WEBPACK_IMPORTED_MODULE_0__.WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement('canvas');
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  //FIXME Allow OffscreenCanvasRenderingContext2D as return type
  return /** @type {CanvasRenderingContext2D} */ (
    canvas.getContext('2d', settings)
  );
}

/** @type {CanvasRenderingContext2D} */
let sharedCanvasContext;

/**
 * @return {CanvasRenderingContext2D} Shared canvas context.
 */
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}

/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  let width = element.offsetWidth;
  const style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  let height = element.offsetHeight;
  const style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.lastChild.remove();
  }
}

/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;

  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];

    // check if our work is done
    if (!oldChild && !newChild) {
      break;
    }

    // check if children match
    if (oldChild === newChild) {
      continue;
    }

    // check if a new child needs to be added
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }

    // check if an old child needs to be removed
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }

    // reorder
    node.insertBefore(newChild, oldChild);
  }
}


/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   easeIn: () => (/* binding */ easeIn),
/* harmony export */   easeOut: () => (/* binding */ easeOut),
/* harmony export */   inAndOut: () => (/* binding */ inAndOut),
/* harmony export */   linear: () => (/* binding */ linear),
/* harmony export */   upAndDown: () => (/* binding */ upAndDown)
/* harmony export */ });
/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}

/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}

/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}

/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  }
  return 1 - inAndOut(2 * (t - 0.5));
}


/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listen: () => (/* binding */ listen),
/* harmony export */   listenOnce: () => (/* binding */ listenOnce),
/* harmony export */   unlistenByKey: () => (/* binding */ unlistenByKey)
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events
 */


/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, thisArg, once) {
  if (once) {
    const originalListener = listener;
    /**
     * @this {typeof target}
     */
    listener = function () {
      target.removeEventListener(type, listener);
      originalListener.apply(thisArg ?? this, arguments);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target: target,
    type: type,
    listener: listener,
  };
  target.addEventListener(type, listener);
  return eventsKey;
}

/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}

/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.clear)(key);
  }
}


/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   preventDefault: () => (/* binding */ preventDefault),
/* harmony export */   stopPropagation: () => (/* binding */ stopPropagation)
/* harmony export */ });
/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
class BaseEvent {
  /**
   * @param {string} type Type.
   */
  constructor(type) {
    /**
     * @type {boolean}
     */
    this.propagationStopped;

    /**
     * @type {boolean}
     */
    this.defaultPrevented;

    /**
     * The event type.
     * @type {string}
     * @api
     */
    this.type = type;

    /**
     * The event target.
     * @type {Object}
     * @api
     */
    this.target = null;
  }

  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = true;
  }

  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
}

/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}

/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseEvent);


/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',

  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',

  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel',
});


/***/ }),

/***/ "./node_modules/ol/events/Key.js":
/*!***************************************!*\
  !*** ./node_modules/ol/events/Key.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/events/Key
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  LEFT: 'ArrowLeft',
  UP: 'ArrowUp',
  RIGHT: 'ArrowRight',
  DOWN: 'ArrowDown',
});


/***/ }),

/***/ "./node_modules/ol/events/Target.js":
/*!******************************************!*\
  !*** ./node_modules/ol/events/Target.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events/Target
 */





/**
 * @typedef {EventTarget|Target} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
class Target extends _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(target) {
    super();

    /**
     * @private
     * @type {*}
     */
    this.eventTarget_ = target;

    /**
     * @private
     * @type {Object<string, number>|null}
     */
    this.pendingRemovals_ = null;

    /**
     * @private
     * @type {Object<string, number>|null}
     */
    this.dispatching_ = null;

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>|null}
     */
    this.listeners_ = null;
  }

  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }

  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(event) {
    const isString = typeof event === 'string';
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }

    const evt = isString ? new _Event_js__WEBPACK_IMPORTED_MODULE_1__["default"](event) : /** @type {Event} */ (event);
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals =
      this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ('handleEvent' in listeners[i]) {
        propagate = /** @type {import("../events.js").ListenerObject} */ (
          listeners[i]
        ).handleEvent(evt);
      } else {
        propagate = /** @type {import("../events.js").ListenerFunction} */ (
          listeners[i]
        ).call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.clear)(this.listeners_);
  }

  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(type) {
    return (this.listeners_ && this.listeners_[type]) || undefined;
  }

  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type
      ? type in this.listeners_
      : Object.keys(this.listeners_).length > 0;
  }

  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(type, listener) {
    if (!this.listeners_) {
      return;
    }
    const listeners = this.listeners_[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      if (this.pendingRemovals_ && type in this.pendingRemovals_) {
        // make listener a no-op, and remove later in #dispatchEvent()
        listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID;
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Target);


/***/ }),

/***/ "./node_modules/ol/events/condition.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/condition.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   altKeyOnly: () => (/* binding */ altKeyOnly),
/* harmony export */   altShiftKeysOnly: () => (/* binding */ altShiftKeysOnly),
/* harmony export */   always: () => (/* binding */ always),
/* harmony export */   click: () => (/* binding */ click),
/* harmony export */   doubleClick: () => (/* binding */ doubleClick),
/* harmony export */   focus: () => (/* binding */ focus),
/* harmony export */   focusWithTabindex: () => (/* binding */ focusWithTabindex),
/* harmony export */   mouseActionButton: () => (/* binding */ mouseActionButton),
/* harmony export */   mouseOnly: () => (/* binding */ mouseOnly),
/* harmony export */   never: () => (/* binding */ never),
/* harmony export */   noModifierKeys: () => (/* binding */ noModifierKeys),
/* harmony export */   penOnly: () => (/* binding */ penOnly),
/* harmony export */   platformModifierKey: () => (/* binding */ platformModifierKey),
/* harmony export */   platformModifierKeyOnly: () => (/* binding */ platformModifierKeyOnly),
/* harmony export */   pointerMove: () => (/* binding */ pointerMove),
/* harmony export */   primaryAction: () => (/* binding */ primaryAction),
/* harmony export */   shiftKeyOnly: () => (/* binding */ shiftKeyOnly),
/* harmony export */   singleClick: () => (/* binding */ singleClick),
/* harmony export */   targetNotEditable: () => (/* binding */ targetNotEditable),
/* harmony export */   touchOnly: () => (/* binding */ touchOnly)
/* harmony export */ });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/events/condition
 */





/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */

/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */
function all(var_args) {
  const conditions = arguments;
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */
  return function (event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}

/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
const altKeyOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    !originalEvent.shiftKey
  );
};

/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
const altShiftKeysOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    originalEvent.shiftKey
  );
};

/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */
const focus = function (event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const activeElement = event.map.getOwnerDocument().activeElement;

  return rootNode instanceof ShadowRoot
    ? rootNode.host.contains(activeElement)
    : targetElement.contains(activeElement);
};

/**
 * Return `true` if the map has the focus or no 'tabindex' attribute set.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map container has the focus or no 'tabindex' attribute.
 */
const focusWithTabindex = function (event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const tabIndexCandidate =
    rootNode instanceof ShadowRoot ? rootNode.host : targetElement;

  return tabIndexCandidate.hasAttribute('tabindex') ? focus(event) : true;
};

/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */
const always = _functions_js__WEBPACK_IMPORTED_MODULE_0__.TRUE;

/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
const click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK;
};

/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
const mouseActionButton = function (mapBrowserEvent) {
  const originalEvent = /** @type {MouseEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return originalEvent.button == 0 && !(_has_js__WEBPACK_IMPORTED_MODULE_2__.WEBKIT && _has_js__WEBPACK_IMPORTED_MODULE_2__.MAC && originalEvent.ctrlKey);
};

/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */
const never = _functions_js__WEBPACK_IMPORTED_MODULE_0__.FALSE;

/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
const pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};

/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
const singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SINGLECLICK;
};

/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
const doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK;
};

/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
const noModifierKeys = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    !originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    !originalEvent.shiftKey
  );
};

/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
const platformModifierKeyOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    !originalEvent.altKey &&
    (_has_js__WEBPACK_IMPORTED_MODULE_2__.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&
    !originalEvent.shiftKey
  );
};

/**
 * Return `true` if the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the platform modifier key is pressed.
 * @api
 */
const platformModifierKey = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return _has_js__WEBPACK_IMPORTED_MODULE_2__.MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};

/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
const shiftKeyOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    !originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    originalEvent.shiftKey
  );
};

/**
 * Return `true` if the target element is not editable, i.e. not an `input`,
 * `select`, or `textarea` element and no `contenteditable` attribute is
 * set or inherited, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
const targetNotEditable = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  const tagName = /** @type {Element} */ (originalEvent.target).tagName;
  return (
    tagName !== 'INPUT' &&
    tagName !== 'SELECT' &&
    tagName !== 'TEXTAREA' &&
    // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable
  );
};

/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
const mouseOnly = function (mapBrowserEvent) {
  const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvent !== undefined,
    'mapBrowserEvent must originate from a pointer event',
  );
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvent.pointerType == 'mouse';
};

/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */
const touchOnly = function (mapBrowserEvent) {
  const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvt !== undefined,
    'mapBrowserEvent must originate from a pointer event',
  );
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvt.pointerType === 'touch';
};

/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */
const penOnly = function (mapBrowserEvent) {
  const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvt !== undefined,
    'mapBrowserEvent must originate from a pointer event',
  );
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvt.pointerType === 'pen';
};

/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See https://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
const primaryAction = function (mapBrowserEvent) {
  const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvent !== undefined,
    'mapBrowserEvent must originate from a pointer event',
  );
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};


/***/ }),

/***/ "./node_modules/ol/expr/cpu.js":
/*!*************************************!*\
  !*** ./node_modules/ol/expr/cpu.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildExpression: () => (/* binding */ buildExpression),
/* harmony export */   newEvaluationContext: () => (/* binding */ newEvaluationContext)
/* harmony export */ });
/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ "./node_modules/ol/expr/expression.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/expr/cpu
 */




/**
 * @fileoverview This module includes functions to build expressions for evaluation on the CPU.
 * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded
 * expression and returns an instance of one of the expression classes.  The compiling step takes
 * the expression instance and returns a function that can be evaluated in to return a literal
 * value.  The evaluator function should do as little allocation and work as possible.
 */

/**
 * @typedef {Object} EvaluationContext
 * @property {Object} properties The values for properties used in 'get' expressions.
 * @property {Object} variables The values for variables used in 'var' expressions.
 * @property {number} resolution The map resolution.
 * @property {string|number|null} featureId The feature id.
 * @property {string} geometryType Geometry type of the current object.
 */

/**
 * @return {EvaluationContext} A new evaluation context.
 */
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: '',
  };
}

/**
 * @typedef {function(EvaluationContext):import("./expression.js").LiteralValue} ExpressionEvaluator
 */

/**
 * @typedef {function(EvaluationContext):boolean} BooleanEvaluator
 */

/**
 * @typedef {function(EvaluationContext):number} NumberEvaluator
 */

/**
 * @typedef {function(EvaluationContext):string} StringEvaluator
 */

/**
 * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator
 */

/**
 * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator
 */

/**
 * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator
 */

/**
 * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator
 */

/**
 * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator
 */

/**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The expression evaluator.
 */
function buildExpression(encoded, type, context) {
  const expression = (0,_expression_js__WEBPACK_IMPORTED_MODULE_0__.parse)(encoded, type, context);
  return compileExpression(expression, context);
}

/**
 * @param {import("./expression.js").Expression} expression The expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileExpression(expression, context) {
  if (expression instanceof _expression_js__WEBPACK_IMPORTED_MODULE_0__.LiteralExpression) {
    // convert colors to array if possible
    if (expression.type === _expression_js__WEBPACK_IMPORTED_MODULE_0__.ColorType && typeof expression.value === 'string') {
      const colorValue = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.fromString)(expression.value);
      return function () {
        return colorValue;
      };
    }
    return function () {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Number:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.String:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Coalesce: {
      return compileAssertionExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Get:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Var:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Has: {
      return compileAccessorExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Id: {
      return (context) => context.featureId;
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GeometryType: {
      return (context) => context.geometryType;
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Concat: {
      const args = expression.args.map((e) => compileExpression(e, context));
      return (context) =>
        ''.concat(...args.map((arg) => arg(context).toString()));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Resolution: {
      return (context) => context.resolution;
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Any:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.All:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Between:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.In:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Equal:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.NotEqual:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThan:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThanOrEqualTo:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThan:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Multiply:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Divide:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Add:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Subtract:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Clamp:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Mod:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Pow:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Abs:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Floor:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Ceil:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Round:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sin:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Cos:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Atan:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Case: {
      return compileCaseExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Interpolate: {
      return compileInterpolateExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.ToString: {
      return compileConvertExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
    // TODO: unimplemented
    // Ops.Zoom
    // Ops.Time
    // Ops.Array
    // Ops.Color
    // Ops.Band
    // Ops.Palette
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;

  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Coalesce: {
      return (context) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context);
          if (typeof value !== 'undefined' && value !== null) {
            return value;
          }
        }
        throw new Error('Expected one of the values to be non-null');
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Number:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.String: {
      return (context) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileAccessorExpression(expression, context) {
  const nameExpression = /** @type {LiteralExpression} */ (expression.args[0]);
  const name = /** @type {string} */ (nameExpression.value);
  switch (expression.operator) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Get: {
      return (context) => {
        const args = expression.args;
        let value = context.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = /** @type {LiteralExpression} */ (args[i]);
          const key = /** @type {string|number} */ (keyExpression.value);
          value = value[key];
        }
        return value;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Var: {
      return (context) => context.variables[name];
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Has: {
      return (context) => {
        const args = expression.args;
        if (!(name in context.properties)) {
          return false;
        }
        let value = context.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = /** @type {LiteralExpression} */ (args[i]);
          const key = /** @type {string|number} */ (keyExpression.value);
          if (!value || !Object.hasOwn(value, key)) {
            return false;
          }
          value = value[key];
        }
        return true;
      };
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Equal: {
      return (context) => left(context) === right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.NotEqual: {
      return (context) => left(context) !== right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThan: {
      return (context) => left(context) < right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThanOrEqualTo: {
      return (context) => left(context) <= right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThan: {
      return (context) => left(context) > right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThanOrEqualTo: {
      return (context) => left(context) >= right(context);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;

  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Any: {
      return (context) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context)) {
            return true;
          }
        }
        return false;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.All: {
      return (context) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context)) {
            return false;
          }
        }
        return true;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Between: {
      return (context) => {
        const value = args[0](context);
        const min = args[1](context);
        const max = args[2](context);
        return value >= min && value <= max;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.In: {
      return (context) => {
        const value = args[0](context);
        for (let i = 1; i < length; ++i) {
          if (value === args[i](context)) {
            return true;
          }
        }
        return false;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Not: {
      return (context) => !args[0](context);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {NumberEvaluator} The evaluator function.
 */
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;

  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Multiply: {
      return (context) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context);
        }
        return value;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Divide: {
      return (context) => args[0](context) / args[1](context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Add: {
      return (context) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context);
        }
        return value;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Subtract: {
      return (context) => args[0](context) - args[1](context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Clamp: {
      return (context) => {
        const value = args[0](context);
        const min = args[1](context);
        if (value < min) {
          return min;
        }
        const max = args[2](context);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Mod: {
      return (context) => args[0](context) % args[1](context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Pow: {
      return (context) => Math.pow(args[0](context), args[1](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Abs: {
      return (context) => Math.abs(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Floor: {
      return (context) => Math.floor(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Ceil: {
      return (context) => Math.ceil(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Round: {
      return (context) => Math.round(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sin: {
      return (context) => Math.sin(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Cos: {
      return (context) => Math.cos(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Atan: {
      if (length === 2) {
        return (context) => Math.atan2(args[0](context), args[1](context));
      }
      return (context) => Math.atan(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sqrt: {
      return (context) => Math.sqrt(args[0](context));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileCaseExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context) => {
    for (let i = 0; i < length - 1; i += 2) {
      const condition = args[i](context);
      if (condition) {
        return args[i + 1](context);
      }
    }
    return args[length - 1](context);
  };
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context) => {
    const value = args[0](context);
    for (let i = 1; i < length; i += 2) {
      if (value === args[i](context)) {
        return args[i + 1](context);
      }
    }
    return args[length - 1](context);
  };
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context) => {
    const base = args[0](context);
    const value = args[1](context);

    let previousInput;
    let previousOutput;
    for (let i = 2; i < length; i += 2) {
      const input = args[i](context);
      let output = args[i + 1](context);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.withAlpha)(output);
      }
      if (input >= value) {
        if (i === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output,
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output,
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileConvertExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;

  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.ToString: {
      return (context) => {
        const value = args[0](context);
        if (expression.args[0].type === _expression_js__WEBPACK_IMPORTED_MODULE_0__.ColorType) {
          return (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.toString)(value);
        }
        return value.toString();
      };
    }
    default: {
      throw new Error(`Unsupported convert operator ${op}`);
    }
  }
}

/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {number} output1 The first output value.
 * @param {number} input2 The second input value.
 * @param {number} output2 The second output value.
 * @return {number} The interpolated value.
 */
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor =
    base === 1
      ? along / delta
      : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}

/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {import('../color.js').Color} rgba1 The first output value.
 * @param {number} input2 The second input value.
 * @param {import('../color.js').Color} rgba2 The second output value.
 * @return {import('../color.js').Color} The interpolated color.
 */
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.rgbaToLcha)(rgba1);
  const lcha2 = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.rgbaToLcha)(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }

  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3]),
  ];
  return (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.normalize)((0,_color_js__WEBPACK_IMPORTED_MODULE_1__.lchaToRgba)(lcha));
}


/***/ }),

/***/ "./node_modules/ol/expr/expression.js":
/*!********************************************!*\
  !*** ./node_modules/ol/expr/expression.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnyType: () => (/* binding */ AnyType),
/* harmony export */   BooleanType: () => (/* binding */ BooleanType),
/* harmony export */   CallExpression: () => (/* binding */ CallExpression),
/* harmony export */   ColorType: () => (/* binding */ ColorType),
/* harmony export */   LiteralExpression: () => (/* binding */ LiteralExpression),
/* harmony export */   NoneType: () => (/* binding */ NoneType),
/* harmony export */   NumberArrayType: () => (/* binding */ NumberArrayType),
/* harmony export */   NumberType: () => (/* binding */ NumberType),
/* harmony export */   Ops: () => (/* binding */ Ops),
/* harmony export */   SizeType: () => (/* binding */ SizeType),
/* harmony export */   StringType: () => (/* binding */ StringType),
/* harmony export */   computeGeometryType: () => (/* binding */ computeGeometryType),
/* harmony export */   includesType: () => (/* binding */ includesType),
/* harmony export */   isType: () => (/* binding */ isType),
/* harmony export */   newParsingContext: () => (/* binding */ newParsingContext),
/* harmony export */   overlapsType: () => (/* binding */ overlapsType),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   typeName: () => (/* binding */ typeName)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/expr/expression
 */




/**
 * @fileoverview This module includes types and functions for parsing array encoded expressions.
 * The result of parsing an encoded expression is one of the specific expression classes.
 * During parsing, information is added to the parsing context about the data accessed by the
 * expression.
 */

/**
 * Base type used for literal style parameters; can be a number literal or the output of an operator,
 * which in turns takes {@link import("./expression.js").ExpressionValue} arguments.
 *
 * See below for details on the available operators (with notes for those that are WebGL or Canvas only).
 *
 * * Reading operators:
 *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
 *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
 *     are in the 0..1 range. {@link import("../source/TileImage.js").default} sources have 4 bands: red,
 *     green, blue and alpha. {@link import("../source/DataTile.js").default} sources can have any number
 *     of bands, depending on the underlying data source and
 *     {@link import("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
 *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).
 *   * `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.
 *   * `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a
 *     feature property. The result is `undefined` when there is nothing at the specified key or index.
 *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'
 *     `Multi*` values are returned as their singular equivalent
 *     `Circle` geometries are returned as 'Polygon'
 *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).
 *   * `['resolution']` returns the current resolution
 *   * `['time']` The time in seconds since the creation of the layer (WebGL only).
 *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined
 *   * `['zoom']` The current zoom level (WebGL only).
 *   * `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line
 *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.
 *      Please note that the M component will be linearly interpolated between the two points composing a segment.
 *
 * * Math operators:
 *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)
 *   * `['/', value1, value2]` divides `value1` by `value2`
 *   * `['+', value1, value2, ...]` adds the values
 *   * `['-', value1, value2]` subtracts `value2` from `value1`
 *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`
 *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
 *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
 *   * `['abs', value1]` returns the absolute value of `value1`
 *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`
 *   * `['round', value1]` returns the nearest integer to `value1`
 *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
 *   * `['sin', value1]` returns the sine of `value1`
 *   * `['cos', value1]` returns the cosine of `value1`
 *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
 *   * `['sqrt', value1]` returns the square root of `value1`
 *
 * * Transform operators:
 *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
 *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
 *     All conditions should be `boolean`, output and fallback can be any kind.
 *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
 *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
 *     returns the `fallback` value.
 *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
 *     `fallback` values must be of the same type, and can be of any kind.
 *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
 *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
 *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
 *     of 1 is equivalent to `['linear']`.
 *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
 *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
 *     between `output1` and `outputN`.
 *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.
 *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`
 *     (Canvas only).
 *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.
 *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`
 *     (Canvas only).
 *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.
 *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`
 *     (Canvas only).
 *
 * * Logical operators:
 *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
 *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
 *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
 *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
 *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
 *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
 *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
 *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
 *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
 *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,
 *     `false` otherwise.
 *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
 *     (inclusively), or `false` otherwise.
 *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and
 *     `false` otherwise.
 *     This operator has the following limitations:
 *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)
 *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an
 *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:
 *     `['literal', ['abc', 'def', 'ghi']]`
 *
 * * Conversion operators:
 *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
 *     values can currently only be 2, 3 or 4 (WebGL only).
 *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;
 *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).
 *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.
 *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
 *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
 *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
 *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
 *     in the 0-255 range and a in the 0-1 range) (WebGL only).
 *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is "true" or "false".
 *     If the input is a number, it is converted to a string as specified by the "NumberToString" algorithm of the ECMAScript
 *     Language Specification. If the input is a color, it is converted to a string of the form "rgba(r,g,b,a)". (Canvas only)
 *
 * Values can either be literals or another operator, as they will be evaluated recursively.
 * Literal values can be of the following types:
 * * `boolean`
 * * `number`
 * * `number[]` (number arrays can only have a length of 2, 3 or 4)
 * * `string`
 * * {@link module:ol/color~Color}
 *
 * @typedef {Array<*>|import("../color.js").Color|string|number|boolean} ExpressionValue
 * @api
 */

let numTypes = 0;
const NoneType = 0;
const BooleanType = 1 << numTypes++;
const NumberType = 1 << numTypes++;
const StringType = 1 << numTypes++;
const ColorType = 1 << numTypes++;
const NumberArrayType = 1 << numTypes++;
const SizeType = 1 << numTypes++;
const AnyType = Math.pow(2, numTypes) - 1;

const typeNames = {
  [BooleanType]: 'boolean',
  [NumberType]: 'number',
  [StringType]: 'string',
  [ColorType]: 'color',
  [NumberArrayType]: 'number[]',
  [SizeType]: 'size',
};

const namedTypes = Object.keys(typeNames).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_0__.ascending);

/**
 * @param {number} type The type.
 * @return {boolean} The type is one of the specific types (not any or a union type).
 */
function isSpecific(type) {
  return type in typeNames;
}

/**
 * Get a string representation for a type.
 * @param {number} type The type.
 * @return {string} The type name.
 */
function typeName(type) {
  const names = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names.push(typeNames[namedType]);
    }
  }
  if (names.length === 0) {
    return 'untyped';
  }
  if (names.length < 3) {
    return names.join(' or ');
  }
  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];
}

/**
 * @param {number} broad The broad type.
 * @param {number} specific The specific type.
 * @return {boolean} The broad type includes the specific type.
 */
function includesType(broad, specific) {
  return (broad & specific) === specific;
}

/**
 * @param {number} oneType One type.
 * @param {number} otherType Another type.
 * @return {boolean} The set of types overlap (share a common specific type)
 */
function overlapsType(oneType, otherType) {
  return !!(oneType & otherType);
}

/**
 * @param {number} type The type.
 * @param {number} expected The expected type.
 * @return {boolean} The given type is exactly the expected type.
 */
function isType(type, expected) {
  return type === expected;
}

/**
 * @typedef {boolean|number|string|Array<number>} LiteralValue
 */

class LiteralExpression {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(type, value) {
    if (!isSpecific(type)) {
      throw new Error(
        `literal expressions must have a specific type, got ${typeName(type)}`,
      );
    }
    this.type = type;
    this.value = value;
  }
}

class CallExpression {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(type, operator, ...args) {
    this.type = type;
    this.operator = operator;
    this.args = args;
  }
}

/**
 * @typedef {LiteralExpression|CallExpression} Expression
 */

/**
 * @typedef {Object} ParsingContext
 * @property {Set<string>} variables Variables referenced with the 'var' operator.
 * @property {Set<string>} properties Properties referenced with the 'get' operator.
 * @property {boolean} featureId The style uses the feature id.
 * @property {boolean} geometryType The style uses the feature geometry type.
 */

/**
 * @return {ParsingContext} A new parsing context.
 */
function newParsingContext() {
  return {
    variables: new Set(),
    properties: new Set(),
    featureId: false,
    geometryType: false,
  };
}

/**
 * @typedef {LiteralValue|Array} EncodedExpression
 */

/**
 * @param {EncodedExpression} encoded The encoded expression.
 * @param {number} expectedType The expected type.
 * @param {ParsingContext} context The parsing context.
 * @return {Expression} The parsed expression result.
 */
function parse(encoded, expectedType, context) {
  switch (typeof encoded) {
    case 'boolean': {
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded ? 'true' : 'false');
      }
      if (!includesType(expectedType, BooleanType)) {
        throw new Error(
          `got a boolean, but expected ${typeName(expectedType)}`,
        );
      }
      return new LiteralExpression(BooleanType, encoded);
    }
    case 'number': {
      if (isType(expectedType, SizeType)) {
        return new LiteralExpression(SizeType, (0,_size_js__WEBPACK_IMPORTED_MODULE_1__.toSize)(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded.toString());
      }
      if (!includesType(expectedType, NumberType)) {
        throw new Error(`got a number, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(NumberType, encoded);
    }
    case 'string': {
      if (isType(expectedType, ColorType)) {
        return new LiteralExpression(ColorType, (0,_color_js__WEBPACK_IMPORTED_MODULE_2__.fromString)(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (!includesType(expectedType, StringType)) {
        throw new Error(`got a string, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(StringType, encoded);
    }
    default: {
      // pass
    }
  }

  if (!Array.isArray(encoded)) {
    throw new Error('expression must be an array or a primitive value');
  }

  if (encoded.length === 0) {
    throw new Error('empty expression');
  }

  if (typeof encoded[0] === 'string') {
    return parseCallExpression(encoded, expectedType, context);
  }

  for (const item of encoded) {
    if (typeof item !== 'number') {
      throw new Error('expected an array of numbers');
    }
  }

  if (isType(expectedType, SizeType)) {
    if (encoded.length !== 2) {
      throw new Error(
        `expected an array of two values for a size, got ${encoded.length}`,
      );
    }
    return new LiteralExpression(SizeType, encoded);
  }

  if (isType(expectedType, ColorType)) {
    if (encoded.length === 3) {
      return new LiteralExpression(ColorType, [...encoded, 1]);
    }
    if (encoded.length === 4) {
      return new LiteralExpression(ColorType, encoded);
    }
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${encoded.length}`,
    );
  }

  if (!includesType(expectedType, NumberArrayType)) {
    throw new Error(
      `got an array of numbers, but expected ${typeName(expectedType)}`,
    );
  }

  return new LiteralExpression(NumberArrayType, encoded);
}

/**
 * @type {Object<string, string>}
 */
const Ops = {
  Get: 'get',
  Var: 'var',
  Concat: 'concat',
  GeometryType: 'geometry-type',
  LineMetric: 'line-metric',
  Any: 'any',
  All: 'all',
  Not: '!',
  Resolution: 'resolution',
  Zoom: 'zoom',
  Time: 'time',
  Equal: '==',
  NotEqual: '!=',
  GreaterThan: '>',
  GreaterThanOrEqualTo: '>=',
  LessThan: '<',
  LessThanOrEqualTo: '<=',
  Multiply: '*',
  Divide: '/',
  Add: '+',
  Subtract: '-',
  Clamp: 'clamp',
  Mod: '%',
  Pow: '^',
  Abs: 'abs',
  Floor: 'floor',
  Ceil: 'ceil',
  Round: 'round',
  Sin: 'sin',
  Cos: 'cos',
  Atan: 'atan',
  Sqrt: 'sqrt',
  Match: 'match',
  Between: 'between',
  Interpolate: 'interpolate',
  Coalesce: 'coalesce',
  Case: 'case',
  In: 'in',
  Number: 'number',
  String: 'string',
  Array: 'array',
  Color: 'color',
  Id: 'id',
  Band: 'band',
  Palette: 'palette',
  ToString: 'to-string',
  Has: 'has',
};

/**
 * @typedef {function(Array, number, ParsingContext):Expression} Parser
 *
 * Second argument is the expected type.
 */

/**
 * @type {Object<string, Parser>}
 */
const parsers = {
  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),
  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),
  [Ops.Concat]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(StringType),
  ),
  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),
  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),
  [Ops.Resolution]: createCallExpressionParser(withNoArgs),
  [Ops.Zoom]: createCallExpressionParser(withNoArgs),
  [Ops.Time]: createCallExpressionParser(withNoArgs),
  [Ops.Any]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType),
  ),
  [Ops.All]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType),
  ),
  [Ops.Not]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType),
  ),
  [Ops.Equal]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType),
  ),
  [Ops.NotEqual]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType),
  ),
  [Ops.GreaterThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.LessThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.LessThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.Multiply]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType,
  ),
  [Ops.Coalesce]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType,
  ),
  [Ops.Divide]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.Add]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(NumberType),
  ),
  [Ops.Subtract]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.Clamp]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType),
  ),
  [Ops.Mod]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.Pow]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.Abs]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType),
  ),
  [Ops.Floor]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType),
  ),
  [Ops.Ceil]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType),
  ),
  [Ops.Round]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType),
  ),
  [Ops.Sin]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType),
  ),
  [Ops.Cos]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType),
  ),
  [Ops.Atan]: createCallExpressionParser(
    hasArgsCount(1, 2),
    withArgsOfType(NumberType),
  ),
  [Ops.Sqrt]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType),
  ),
  [Ops.Match]: createCallExpressionParser(
    hasArgsCount(4, Infinity),
    hasEvenArgs,
    withMatchArgs,
  ),
  [Ops.Between]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType),
  ),
  [Ops.Interpolate]: createCallExpressionParser(
    hasArgsCount(6, Infinity),
    hasEvenArgs,
    withInterpolateArgs,
  ),
  [Ops.Case]: createCallExpressionParser(
    hasArgsCount(3, Infinity),
    hasOddArgs,
    withCaseArgs,
  ),
  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),
  [Ops.Number]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType),
  ),
  [Ops.String]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType),
  ),
  [Ops.Array]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(NumberType),
  ),
  [Ops.Color]: createCallExpressionParser(
    hasArgsCount(1, 4),
    withArgsOfType(NumberType),
  ),
  [Ops.Band]: createCallExpressionParser(
    hasArgsCount(1, 3),
    withArgsOfType(NumberType),
  ),
  [Ops.Palette]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withPaletteArgs,
  ),
  [Ops.ToString]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType | NumberType | StringType | ColorType),
  ),
};

/**
 * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator
 *
 * An argument validator applies various checks to an encoded expression arguments and
 * returns the parsed arguments if any.  The second argument is the return type of the call expression.
 */

/**
 * @type ArgValidator
 */
function withGetArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const args = new Array(argsCount);
  for (let i = 0; i < argsCount; ++i) {
    const key = encoded[i + 1];
    switch (typeof key) {
      case 'number': {
        args[i] = new LiteralExpression(NumberType, key);
        break;
      }
      case 'string': {
        args[i] = new LiteralExpression(StringType, key);
        break;
      }
      default: {
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${key}`,
        );
      }
    }
    if (i === 0) {
      context.properties.add(String(key));
    }
  }
  return args;
}

/**
 * @type ArgValidator
 */
function withVarArgs(encoded, returnType, context) {
  const name = encoded[1];
  if (typeof name !== 'string') {
    throw new Error('expected a string argument for var operation');
  }
  context.variables.add(name);

  return [new LiteralExpression(StringType, name)];
}

/**
 * @type ArgValidator
 */
function usesFeatureId(encoded, returnType, context) {
  context.featureId = true;
}

/**
 * @type ArgValidator
 */
function usesGeometryType(encoded, returnType, context) {
  context.geometryType = true;
}

/**
 * @type ArgValidator
 */
function withNoArgs(encoded, returnType, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`expected no arguments for ${operation} operation`);
  }
  return [];
}

/**
 * @param {number} minArgs The minimum number of arguments.
 * @param {number} maxArgs The maximum number of arguments.
 * @return {ArgValidator} The argument validator
 */
function hasArgsCount(minArgs, maxArgs) {
  return function (encoded, returnType, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? '' : 's';
        throw new Error(
          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range =
        maxArgs === Infinity
          ? `${minArgs} or more`
          : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `expected ${range} arguments for ${operation}, got ${argCount}`,
      );
    }
  };
}

/**
 * @type {ArgValidator}
 */
function withArgsOfReturnType(encoded, returnType, context) {
  const argCount = encoded.length - 1;
  /**
   * @type {Array<Expression>}
   */
  const args = new Array(argCount);
  for (let i = 0; i < argCount; ++i) {
    const expression = parse(encoded[i + 1], returnType, context);
    args[i] = expression;
  }
  return args;
}

/**
 * @param {number} argType The argument type.
 * @return {ArgValidator} The argument validator
 */
function withArgsOfType(argType) {
  return function (encoded, returnType, context) {
    const argCount = encoded.length - 1;
    /**
     * @type {Array<Expression>}
     */
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse(encoded[i + 1], argType, context);
      args[i] = expression;
    }
    return args;
  };
}

/**
 * @type {ArgValidator}
 */
function hasOddArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `expected an odd number of arguments for ${operation}, got ${argCount} instead`,
    );
  }
}

/**
 * @type {ArgValidator}
 */
function hasEvenArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`,
    );
  }
}

/**
 * @type ArgValidator
 */
function withMatchArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;

  const inputType = StringType | NumberType | BooleanType;

  const input = parse(encoded[1], inputType, context);

  const fallback = parse(encoded[encoded.length - 1], returnType, context);

  const args = new Array(argsCount - 2);
  for (let i = 0; i < argsCount - 2; i += 2) {
    try {
      const match = parse(encoded[i + 2], input.type, context);
      args[i] = match;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of match expression: ${err.message}`,
      );
    }
    try {
      const output = parse(encoded[i + 3], fallback.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} of match expression: ${err.message}`,
      );
    }
  }

  return [input, ...args, fallback];
}

/**
 * @type ArgValidator
 */
function withInterpolateArgs(encoded, returnType, context) {
  const interpolationType = encoded[1];
  /**
   * @type {number}
   */
  let base;
  switch (interpolationType[0]) {
    case 'linear':
      base = 1;
      break;
    case 'exponential':
      const b = interpolationType[1];
      if (typeof b !== 'number' || b <= 0) {
        throw new Error(
          `expected a number base for exponential interpolation` +
            `, got ${JSON.stringify(b)} instead`,
        );
      }
      base = b;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(interpolationType)}`,
      );
  }

  const interpolation = new LiteralExpression(NumberType, base);

  let input;
  try {
    input = parse(encoded[2], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${err.message}`,
    );
  }

  const args = new Array(encoded.length - 3);
  for (let i = 0; i < args.length; i += 2) {
    try {
      const stop = parse(encoded[i + 3], NumberType, context);
      args[i] = stop;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`,
      );
    }
    try {
      const output = parse(encoded[i + 4], returnType, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`,
      );
    }
  }

  return [interpolation, input, ...args];
}

/**
 * @type ArgValidator
 */
function withCaseArgs(encoded, returnType, context) {
  const fallback = parse(encoded[encoded.length - 1], returnType, context);

  const args = new Array(encoded.length - 1);
  for (let i = 0; i < args.length - 1; i += 2) {
    try {
      const condition = parse(encoded[i + 1], BooleanType, context);
      args[i] = condition;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i} of case expression: ${err.message}`,
      );
    }
    try {
      const output = parse(encoded[i + 2], fallback.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of case expression: ${err.message}`,
      );
    }
  }

  args[args.length - 1] = fallback;
  return args;
}

/**
 * @type ArgValidator
 */
function withInArgs(encoded, returnType, context) {
  let haystack = encoded[2];
  if (!Array.isArray(haystack)) {
    throw new Error(
      `the second argument for the "in" operator must be an array`,
    );
  }
  /**
   * @type {number}
   */
  let needleType;
  if (typeof haystack[0] === 'string') {
    if (haystack[0] !== 'literal') {
      throw new Error(
        `for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions`,
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `failed to parse "in" expression: the literal operator must be followed by an array`,
      );
    }
    haystack = haystack[1];
    needleType = StringType;
  } else {
    needleType = NumberType;
  }

  const args = new Array(haystack.length);
  for (let i = 0; i < args.length; i++) {
    try {
      const arg = parse(haystack[i], needleType, context);
      args[i] = arg;
    } catch (err) {
      throw new Error(
        `failed to parse haystack item ${i} for "in" expression: ${err.message}`,
      );
    }
  }

  const needle = parse(encoded[1], needleType, context);
  return [needle, ...args];
}

/**
 * @type ArgValidator
 */
function withPaletteArgs(encoded, returnType, context) {
  let index;
  try {
    index = parse(encoded[1], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse first argument in palette expression: ${err.message}`,
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error('the second argument of palette must be an array');
  }
  const parsedColors = new Array(colors.length);
  for (let i = 0; i < parsedColors.length; i++) {
    let color;
    try {
      color = parse(colors[i], ColorType, context);
    } catch (err) {
      throw new Error(
        `failed to parse color at index ${i} in palette expression: ${err.message}`,
      );
    }
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `the palette color at index ${i} must be a literal value`,
      );
    }
    parsedColors[i] = color;
  }
  return [index, ...parsedColors];
}

/**
 * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected
 * to return the parsed arguments.
 * @return {Parser} The parser.
 */
function createCallExpressionParser(...validators) {
  return function (encoded, returnType, context) {
    const operator = encoded[0];

    /**
     * @type {Array<Expression>}
     */
    let args;
    for (let i = 0; i < validators.length; i++) {
      const parsed = validators[i](encoded, returnType, context);
      if (i == validators.length - 1) {
        if (!parsed) {
          throw new Error(
            'expected last argument validator to return the parsed args',
          );
        }
        args = parsed;
      }
    }
    return new CallExpression(returnType, operator, ...args);
  };
}

/**
 * @param {Array} encoded The encoded expression.
 * @param {number} returnType The expected return type of the call expression.
 * @param {ParsingContext} context The parsing context.
 * @return {Expression} The parsed expression.
 */
function parseCallExpression(encoded, returnType, context) {
  const operator = encoded[0];

  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`unknown operator: ${operator}`);
  }
  return parser(encoded, returnType, context);
}

/**
 * Returns a simplified geometry type suited for the `geometry-type` operator
 * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object
 * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found
 */
function computeGeometryType(geometry) {
  if (!geometry) {
    return '';
  }
  const type = geometry.getType();
  switch (type) {
    case 'Point':
    case 'LineString':
    case 'Polygon':
      return type;
    case 'MultiPoint':
    case 'MultiLineString':
    case 'MultiPolygon':
      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));
    case 'Circle':
      return 'Polygon';
    case 'GeometryCollection':
      return computeGeometryType(
        /** @type {import("../geom/GeometryCollection.js").default} */ (
          geometry
        ).getGeometries()[0],
      );
    default:
      return '';
  }
}


/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyTransform: () => (/* binding */ applyTransform),
/* harmony export */   approximatelyEquals: () => (/* binding */ approximatelyEquals),
/* harmony export */   boundingExtent: () => (/* binding */ boundingExtent),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   closestSquaredDistanceXY: () => (/* binding */ closestSquaredDistanceXY),
/* harmony export */   containsCoordinate: () => (/* binding */ containsCoordinate),
/* harmony export */   containsExtent: () => (/* binding */ containsExtent),
/* harmony export */   containsXY: () => (/* binding */ containsXY),
/* harmony export */   coordinateRelationship: () => (/* binding */ coordinateRelationship),
/* harmony export */   createEmpty: () => (/* binding */ createEmpty),
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   createOrUpdateEmpty: () => (/* binding */ createOrUpdateEmpty),
/* harmony export */   createOrUpdateFromCoordinate: () => (/* binding */ createOrUpdateFromCoordinate),
/* harmony export */   createOrUpdateFromCoordinates: () => (/* binding */ createOrUpdateFromCoordinates),
/* harmony export */   createOrUpdateFromFlatCoordinates: () => (/* binding */ createOrUpdateFromFlatCoordinates),
/* harmony export */   createOrUpdateFromRings: () => (/* binding */ createOrUpdateFromRings),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   extendCoordinate: () => (/* binding */ extendCoordinate),
/* harmony export */   extendCoordinates: () => (/* binding */ extendCoordinates),
/* harmony export */   extendFlatCoordinates: () => (/* binding */ extendFlatCoordinates),
/* harmony export */   extendRings: () => (/* binding */ extendRings),
/* harmony export */   extendXY: () => (/* binding */ extendXY),
/* harmony export */   forEachCorner: () => (/* binding */ forEachCorner),
/* harmony export */   getArea: () => (/* binding */ getArea),
/* harmony export */   getBottomLeft: () => (/* binding */ getBottomLeft),
/* harmony export */   getBottomRight: () => (/* binding */ getBottomRight),
/* harmony export */   getCenter: () => (/* binding */ getCenter),
/* harmony export */   getCorner: () => (/* binding */ getCorner),
/* harmony export */   getEnlargedArea: () => (/* binding */ getEnlargedArea),
/* harmony export */   getForViewAndSize: () => (/* binding */ getForViewAndSize),
/* harmony export */   getHeight: () => (/* binding */ getHeight),
/* harmony export */   getIntersection: () => (/* binding */ getIntersection),
/* harmony export */   getIntersectionArea: () => (/* binding */ getIntersectionArea),
/* harmony export */   getMargin: () => (/* binding */ getMargin),
/* harmony export */   getRotatedViewport: () => (/* binding */ getRotatedViewport),
/* harmony export */   getSize: () => (/* binding */ getSize),
/* harmony export */   getTopLeft: () => (/* binding */ getTopLeft),
/* harmony export */   getTopRight: () => (/* binding */ getTopRight),
/* harmony export */   getWidth: () => (/* binding */ getWidth),
/* harmony export */   intersects: () => (/* binding */ intersects),
/* harmony export */   intersectsSegment: () => (/* binding */ intersectsSegment),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   returnOrUpdate: () => (/* binding */ returnOrUpdate),
/* harmony export */   scaleFromCenter: () => (/* binding */ scaleFromCenter),
/* harmony export */   wrapAndSliceX: () => (/* binding */ wrapAndSliceX),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/**
 * @module ol/extent
 */


/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}

/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value,
  ];
}

/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return (
    extent1[0] <= extent2[0] &&
    extent2[2] <= extent1[2] &&
    extent1[1] <= extent2[1] &&
    extent2[3] <= extent1[3]
  );
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}

/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN;
  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE;
  }
  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING;
  }
  return relationship;
}

/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}

/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}

/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}

/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendCoordinates(extent, coordinates);
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(
  flatCoordinates,
  offset,
  end,
  stride,
  dest,
) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendRings(extent, rings);
}

/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return (
    extent1[0] == extent2[0] &&
    extent1[2] == extent2[2] &&
    extent1[1] == extent2[1] &&
    extent1[3] == extent2[3]
  );
}

/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */
function approximatelyEquals(extent1, extent2, tolerance) {
  return (
    Math.abs(extent1[0] - extent2[0]) < tolerance &&
    Math.abs(extent1[2] - extent2[2]) < tolerance &&
    Math.abs(extent1[1] - extent2[1]) < tolerance &&
    Math.abs(extent1[3] - extent2[3]) < tolerance
  );
}

/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}

/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(
  extent,
  flatCoordinates,
  offset,
  end,
  stride,
) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
  for (let i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}

/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  let area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}

/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}

/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}

/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}

/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  let coordinate;
  if (corner === 'bottom-left') {
    coordinate = getBottomLeft(extent);
  } else if (corner === 'bottom-right') {
    coordinate = getBottomRight(extent);
  } else if (corner === 'top-left') {
    coordinate = getTopLeft(extent);
  } else if (corner === 'top-right') {
    coordinate = getTopRight(extent);
  } else {
    throw new Error('Invalid corner');
  }
  return coordinate;
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  const minX = Math.min(extent1[0], extent2[0]);
  const minY = Math.min(extent1[1], extent2[1]);
  const maxX = Math.max(extent1[2], extent2[2]);
  const maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size,
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest,
  );
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = (resolution * size[0]) / 2;
  const dy = (resolution * size[1]) / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos,
  ];
}

/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  const intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}

/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}

/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}

/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}

/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}

/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}

/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}

/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return (
    extent1[0] <= extent2[2] &&
    extent1[2] >= extent2[0] &&
    extent1[1] <= extent2[3] &&
    extent1[3] >= extent2[1]
  );
}

/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}

/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  let intersects = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (
    startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING ||
    endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING
  ) {
    intersects = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT)
    ) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW)
    ) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT)
    ) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
}

/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates.push(
        extent[0] + (width * i) / stops,
        extent[1],
        extent[2],
        extent[1] + (height * i) / stops,
        extent[2] - (width * i) / stops,
        extent[3],
        extent[0],
        extent[3] - (height * i) / stops,
      );
    }
  } else {
    coordinates = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3],
    ];
  }
  transformFn(coordinates, coordinates, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates.length; i < l; i += 2) {
    xs.push(coordinates[i]);
    ys.push(coordinates[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}

/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (
    projection.canWrapX() &&
    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])
  ) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth,
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}

/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @param {boolean} [multiWorld] Return all worlds
 * @return {Array<Extent>} The extent within the real world extent.
 */
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();

    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }

    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);

    if (getWidth(extent) > worldWidth && !multiWorld) {
      // the extent wraps around on itself
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]],
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],
      ];
    }
  }

  return [extent];
}


/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16,
});


/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FALSE: () => (/* binding */ FALSE),
/* harmony export */   TRUE: () => (/* binding */ TRUE),
/* harmony export */   VOID: () => (/* binding */ VOID),
/* harmony export */   memoizeOne: () => (/* binding */ memoizeOne),
/* harmony export */   toPromise: () => (/* binding */ toPromise)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/**
 * @module ol/functions
 */



/**
 * Always returns true.
 * @return {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @return {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() {}

/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */
function memoizeOne(fn) {
  /** @type {ReturnType} */
  let lastResult;

  /** @type {Array<any>|undefined} */
  let lastArgs;

  let lastThis;

  /**
   * @this {*} Only need to know if `this` changed, don't care what type
   * @return {ReturnType} Memoized value
   */
  return function () {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!lastArgs || this !== lastThis || !(0,_array_js__WEBPACK_IMPORTED_MODULE_0__.equals)(nextArgs, lastArgs)) {
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}

/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}


/***/ }),

/***/ "./node_modules/ol/geom/Geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/Geometry.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/Geometry
 */








/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */

/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */

/**
 * @type {import("../transform.js").Transform}
 */
const tmpTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
class Geometry extends _Object_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createEmpty)();

    /**
     * @private
     * @type {number}
     */
    this.extentRevision_ = -1;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryRevision = 0;

    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    this.simplifyTransformedInternal = (0,_functions_js__WEBPACK_IMPORTED_MODULE_4__.memoizeOne)(
      (revision, squaredTolerance, transform) => {
        if (!transform) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        const clone = this.clone();
        clone.applyTransform(transform);
        return clone.getSimplifiedGeometry(squaredTolerance);
      },
    );
  }

  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform,
    );
  }

  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }

  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }

  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }

  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent = this.computeExtent(this.extent_);
      if (isNaN(extent[0]) || isNaN(extent[1])) {
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdateEmpty)(extent);
      }
      this.extentRevision_ = this.getRevision();
    }
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.returnOrUpdate)(this.extent_, extent);
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }

  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(transformFn) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    const sourceProj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(source);
    const transformFn =
      sourceProj.getUnits() == 'tile-pixels'
        ? function (inCoordinates, outCoordinates, stride) {
            const pixelExtent = sourceProj.getExtent();
            const projectedExtent = sourceProj.getWorldExtent();
            const scale = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(projectedExtent) / (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(pixelExtent);
            (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(
              tmpTransform,
              projectedExtent[0],
              projectedExtent[3],
              scale,
              -scale,
              0,
              0,
              0,
            );
            const transformed = (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__.transform2D)(
              inCoordinates,
              0,
              inCoordinates.length,
              stride,
              tmpTransform,
              outCoordinates,
            );
            const projTransform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination);
            if (projTransform) {
              return projTransform(transformed, transformed, stride);
            }
            return transformed;
          }
        : (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Geometry);


/***/ }),

/***/ "./node_modules/ol/geom/LinearRing.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LinearRing.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/**
 * @module ol/geom/LinearRing
 */








/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
class LinearRing extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates),
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */ (
          coordinates
        ),
        layout,
      );
    }
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   * @override
   */
  clone() {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.maxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0,
        ),
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.assignClosestPoint)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance,
    );
  }

  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_3__.linearRing)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
    );
  }

  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
    );
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    /** @type {Array<number>} */
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_5__.douglasPeucker)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0,
    );
    return new LinearRing(simplifiedFlatCoordinates, 'XY');
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return 'LinearRing';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return false;
  }

  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__.deflateCoordinates)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LinearRing);


/***/ }),

/***/ "./node_modules/ol/geom/Point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/Point.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Point
 */





/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
class Point extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();
    this.setCoordinates(coordinates, layout);
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   * @override
   */
  clone() {
    const point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.squaredDistance)(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1],
    );
    if (squaredDistance < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }

  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return 'Point';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }

  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__.deflateCoordinate)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Point);


/***/ }),

/***/ "./node_modules/ol/geom/Polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/geom/Polygon.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circular: () => (/* binding */ circular),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fromCircle: () => (/* binding */ fromCircle),
/* harmony export */   fromExtent: () => (/* binding */ fromExtent),
/* harmony export */   makeRegular: () => (/* binding */ makeRegular)
/* harmony export */ });
/* harmony import */ var _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LinearRing.js */ "./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../sphere.js */ "./node_modules/ol/sphere.js");
/**
 * @module ol/geom/Polygon
 */

















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
class Polygon extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(coordinates, layout, ends) {
    super();

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointRevision_ = -1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    this.flatInteriorPoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.orientedFlatCoordinates_ = null;

    if (layout !== undefined && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates),
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (
          coordinates
        ),
        layout,
      );
    }
  }

  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   * @override
   */
  clone() {
    const polygon = new Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice(),
    );
    polygon.applyProperties(this);
    return polygon;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.arrayMaxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0,
        ),
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestArrayPoint)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance,
    );
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(x, y) {
    return (0,_flat_contains_js__WEBPACK_IMPORTED_MODULE_4__.linearRingsContainsXY)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y,
    );
  }

  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_5__.linearRings)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
    );
  }

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
  }

  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }

  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(this.getExtent());
      this.flatInteriorPoint_ = (0,_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__.getInteriorPointOfArray)(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0,
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return /** @type {import("../coordinate.js").Coordinate} */ (
      this.flatInteriorPoint_
    );
  }

  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new _Point_js__WEBPACK_IMPORTED_MODULE_9__["default"](this.getFlatInteriorPoint(), 'XYM');
  }

  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }

  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index],
      ),
      this.layout,
    );
  }

  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing = new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](
        flatCoordinates.slice(offset, end),
        layout,
      );
      linearRings.push(linearRing);
      offset = end;
    }
    return linearRings;
  }

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if ((0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRings)(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride,
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    /** @type {Array<number>} */
    const simplifiedFlatCoordinates = [];
    /** @type {Array<number>} */
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__.quantizeArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds,
    );
    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return 'Polygon';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_12__.intersectsLinearRingArray)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent,
    );
  }

  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_13__.deflateCoordinatesArray)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
      this.ends_,
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polygon);

/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, n, sphereRadius) {
  n = n ? n : 32;
  /** @type {Array<number>} */
  const flatCoordinates = [];
  for (let i = 0; i < n; ++i) {
    (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(
      flatCoordinates,
      (0,_sphere_js__WEBPACK_IMPORTED_MODULE_14__.offset)(center, radius, (2 * Math.PI * i) / n, sphereRadius),
    );
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
  if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(extent)) {
    throw new Error('Cannot create polygon from empty extent');
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY,
  ];
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, sides, angle) {
  sides = sides ? sides : 32;
  const stride = circle.getStride();
  const layout = circle.getLayout();
  const center = circle.getCenter();
  const arrayLength = stride * (sides + 1);
  const flatCoordinates = new Array(arrayLength);
  for (let i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (let j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  const ends = [flatCoordinates.length];
  const polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle);
  return polygon;
}

/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */
function makeRegular(polygon, center, radius, angle) {
  const flatCoordinates = polygon.getFlatCoordinates();
  const stride = polygon.getStride();
  const sides = flatCoordinates.length / stride - 1;
  const startAngle = angle ? angle : 0;
  for (let i = 0; i <= sides; ++i) {
    const offset = i * stride;
    const angle = startAngle + ((0,_math_js__WEBPACK_IMPORTED_MODULE_15__.modulo)(i, sides) * 2 * Math.PI) / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }
  polygon.changed();
}


/***/ }),

/***/ "./node_modules/ol/geom/SimpleGeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/SimpleGeometry.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getLayoutForStride: () => (/* binding */ getLayoutForStride),
/* harmony export */   getStrideForLayout: () => (/* binding */ getStrideForLayout),
/* harmony export */   transformGeom2D: () => (/* binding */ transformGeom2D)
/* harmony export */ });
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/SimpleGeometry
 */





/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
class SimpleGeometry extends _Geometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */
    this.layout = 'XY';

    /**
     * @protected
     * @type {number}
     */
    this.stride = 2;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.flatCoordinates;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdateFromFlatCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent,
    );
  }

  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }

  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }

  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride,
    );
  }

  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }

  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @override
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.
    if (
      squaredTolerance < 0 ||
      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)
    ) {
      return this;
    }

    const simplifiedGeometry =
      this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    // Simplification did not actually remove any coordinates.  We now know
    // that any calls to getSimplifiedGeometry with a squaredTolerance less
    // than or equal to the current squaredTolerance will also not have any
    // effect.  This allows us to short circuit simplification (saving CPU
    // cycles) and prevents the cache of simplified geometries from filling
    // up with useless identical copies of this geometry (saving memory).
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }

  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }

  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }

  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(coordinates, layout) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(layout, coordinates, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = 'XY';
          this.stride = 2;
          return;
        }
        coordinates = /** @type {Array<unknown>} */ (coordinates[0]);
      }
      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(
        this.flatCoordinates,
        this.flatCoordinates,
        this.layout.startsWith('XYZ') ? 3 : 2,
        this.stride,
      );
      this.changed();
    }
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates,
      );
      this.changed();
    }
  }

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(sx, sy, anchor) {
    if (sy === undefined) {
      sy = sx;
    }
    if (!anchor) {
      anchor = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.scale)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates,
      );
      this.changed();
    }
  }

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.translate)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates,
      );
      this.changed();
    }
  }
}

/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = 'XY';
  } else if (stride == 3) {
    layout = 'XYZ';
  } else if (stride == 4) {
    layout = 'XYZM';
  }
  return /** @type {import("./Geometry.js").GeometryLayout} */ (layout);
}

/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  let stride;
  if (layout == 'XY') {
    stride = 2;
  } else if (layout == 'XYZ' || layout == 'XYM') {
    stride = 3;
  } else if (layout == 'XYZM') {
    stride = 4;
  }
  return /** @type {number} */ (stride);
}

/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform,
    dest,
  );
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SimpleGeometry);


/***/ }),

/***/ "./node_modules/ol/geom/flat/area.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRing: () => (/* binding */ linearRing),
/* harmony export */   linearRings: () => (/* binding */ linearRings),
/* harmony export */   linearRingss: () => (/* binding */ linearRingss)
/* harmony export */ });
/**
 * @module ol/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  const x0 = flatCoordinates[end - stride];
  const y0 = flatCoordinates[end - stride + 1];
  let dx1 = 0;
  let dy1 = 0;
  for (; offset < end; offset += stride) {
    const dx2 = flatCoordinates[offset] - x0;
    const dy2 = flatCoordinates[offset + 1] - y0;
    twiceArea += dy1 * dx2 - dx1 * dy2;
    dx1 = dx2;
    dy1 = dy2;
  }
  return twiceArea / 2;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  let area = 0;
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/closest.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/closest.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayMaxSquaredDelta: () => (/* binding */ arrayMaxSquaredDelta),
/* harmony export */   assignClosestArrayPoint: () => (/* binding */ assignClosestArrayPoint),
/* harmony export */   assignClosestMultiArrayPoint: () => (/* binding */ assignClosestMultiArrayPoint),
/* harmony export */   assignClosestPoint: () => (/* binding */ assignClosestPoint),
/* harmony export */   maxSquaredDelta: () => (/* binding */ maxSquaredDelta),
/* harmony export */   multiArrayMaxSquaredDelta: () => (/* binding */ multiArrayMaxSquaredDelta)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/closest
 */


/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(
  flatCoordinates,
  offset1,
  offset2,
  stride,
  x,
  y,
  closestPoint,
) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t,
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}

/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(
  flatCoordinates,
  offset,
  ends,
  stride,
  max,
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(
  flatCoordinates,
  offset,
  endss,
  stride,
  max,
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(
  flatCoordinates,
  offset,
  end,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint,
) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1],
    );
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint,
    );
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index +=
        stride *
        Math.max(
          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /
            maxDelta) |
            0,
          1,
        );
    }
  }
  if (isRing) {
    // Check the closing segment.
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint,
    );
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(
  flatCoordinates,
  offset,
  ends,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint,
) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint,
    );
    offset = end;
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(
  flatCoordinates,
  offset,
  endss,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint,
) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset,
      ends,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint,
    );
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/contains.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/contains.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRingContainsExtent: () => (/* binding */ linearRingContainsExtent),
/* harmony export */   linearRingContainsXY: () => (/* binding */ linearRingContainsXY),
/* harmony export */   linearRingsContainsXY: () => (/* binding */ linearRingsContainsXY),
/* harmony export */   linearRingssContainsXY: () => (/* binding */ linearRingssContainsXY)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/contains
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(
  flatCoordinates,
  offset,
  end,
  stride,
  extent,
) {
  const outside = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.forEachCorner)(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function (coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1],
      );
    },
  );
  return !outside;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(
  flatCoordinates,
  offset,
  end,
  stride,
  x,
  y,
) {
  // https://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(
  flatCoordinates,
  offset,
  ends,
  stride,
  x,
  y,
) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (
      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)
    ) {
      return false;
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(
  flatCoordinates,
  offset,
  endss,
  stride,
  x,
  y,
) {
  if (endss.length === 0) {
    return false;
  }
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deflateCoordinate: () => (/* binding */ deflateCoordinate),
/* harmony export */   deflateCoordinates: () => (/* binding */ deflateCoordinates),
/* harmony export */   deflateCoordinatesArray: () => (/* binding */ deflateCoordinatesArray),
/* harmony export */   deflateMultiCoordinatesArray: () => (/* binding */ deflateMultiCoordinatesArray)
/* harmony export */ });
/**
 * @module ol/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(
  flatCoordinates,
  offset,
  coordinates,
  stride,
) {
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    const coordinate = coordinates[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(
  flatCoordinates,
  offset,
  coordinatess,
  stride,
  ends,
) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride,
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(
  flatCoordinates,
  offset,
  coordinatesss,
  stride,
  endss,
) {
  endss = endss ? endss : [];
  let i = 0;
  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset,
      coordinatesss[j],
      stride,
      endss[i],
    );
    if (ends.length === 0) {
      ends[0] = offset;
    }
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/inflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/inflate.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inflateCoordinates: () => (/* binding */ inflateCoordinates),
/* harmony export */   inflateCoordinatesArray: () => (/* binding */ inflateCoordinatesArray),
/* harmony export */   inflateMultiCoordinatesArray: () => (/* binding */ inflateMultiCoordinatesArray)
/* harmony export */ });
/**
 * @module ol/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(
  flatCoordinates,
  offset,
  end,
  stride,
  coordinates,
) {
  coordinates = coordinates !== undefined ? coordinates : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  coordinatess,
) {
  coordinatess = coordinatess !== undefined ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i],
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  coordinatesss,
) {
  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] =
      ends.length === 1 && ends[0] === offset
        ? []
        : inflateCoordinatesArray(
            flatCoordinates,
            offset,
            ends,
            stride,
            coordinatesss[i],
          );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/interiorpoint.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/interiorpoint.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getInteriorPointOfArray: () => (/* binding */ getInteriorPointOfArray),
/* harmony export */   getInteriorPointsOfMultiArray: () => (/* binding */ getInteriorPointsOfMultiArray)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/interiorpoint
 */



/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  flatCenters,
  flatCentersOffset,
  dest,
) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */
  const intersections = [];
  // Calculate intersections with the horizontal line
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__.ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_1__.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  flatCenters,
) {
  /** @type {Array<number>} */
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints,
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/intersectsextent.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/geom/flat/intersectsextent.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   intersectsLineString: () => (/* binding */ intersectsLineString),
/* harmony export */   intersectsLineStringArray: () => (/* binding */ intersectsLineStringArray),
/* harmony export */   intersectsLinearRing: () => (/* binding */ intersectsLinearRing),
/* harmony export */   intersectsLinearRingArray: () => (/* binding */ intersectsLinearRingArray),
/* harmony export */   intersectsLinearRingMultiArray: () => (/* binding */ intersectsLinearRingMultiArray)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/intersectsextent
 */




/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(
  flatCoordinates,
  offset,
  end,
  stride,
  extent,
) {
  const coordinatesExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.extendFlatCoordinates)(
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)(),
    flatCoordinates,
    offset,
    end,
    stride,
  );
  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(extent, coordinatesExtent)) {
    return false;
  }
  if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.containsExtent)(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return (0,_segments_js__WEBPACK_IMPORTED_MODULE_1__.forEach)(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function (point1, point2) {
      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersectsSegment)(extent, point1, point2);
    },
  );
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  extent,
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    if (
      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)
    ) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(
  flatCoordinates,
  offset,
  end,
  stride,
  extent,
) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[0],
      extent[1],
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[0],
      extent[3],
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[2],
      extent[1],
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[2],
      extent[3],
    )
  ) {
    return true;
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  extent,
) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (
      (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsExtent)(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent,
      )
    ) {
      if (
        !intersectsLineString(
          flatCoordinates,
          ends[i - 1],
          ends[i],
          stride,
          extent,
        )
      ) {
        return false;
      }
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  extent,
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (
      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)
    ) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/orient.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/orient.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inflateEnds: () => (/* binding */ inflateEnds),
/* harmony export */   linearRingIsClockwise: () => (/* binding */ linearRingIsClockwise),
/* harmony export */   linearRingsAreOriented: () => (/* binding */ linearRingsAreOriented),
/* harmony export */   linearRingssAreOriented: () => (/* binding */ linearRingssAreOriented),
/* harmony export */   orientLinearRings: () => (/* binding */ orientLinearRings),
/* harmony export */   orientLinearRingsArray: () => (/* binding */ orientLinearRingsArray)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/ol/geom/flat/reverse.js");
/**
 * @module ol/geom/flat/orient
 */


/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean|undefined} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // https://stackoverflow.com/q/1165647/clockwise-method#1165943
  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? undefined : edge > 0;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(
  flatCoordinates,
  offset,
  ends,
  stride,
  right,
) {
  right = right !== undefined ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride,
    );
    if (i === 0) {
      if ((right && isClockwise) || (!right && !isClockwise)) {
        return false;
      }
    } else {
      if ((right && !isClockwise) || (!right && isClockwise)) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingssAreOriented(
  flatCoordinates,
  offset,
  endss,
  stride,
  right,
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }
  return true;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(
  flatCoordinates,
  offset,
  ends,
  stride,
  right,
) {
  right = right !== undefined ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride,
    );
    const reverse =
      i === 0
        ? (right && isClockwise) || (!right && !isClockwise)
        : (right && !isClockwise) || (!right && isClockwise);
    if (reverse) {
      (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__.coordinates)(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  right,
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(
      flatCoordinates,
      offset,
      endss[i],
      stride,
      right,
    );
  }
  return offset;
}

/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to construct a MultiPolygon
 */
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    // classifies an array of rings into polygons with outer rings and holes
    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === undefined) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset = end;
  }
  return endss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/reverse.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/reverse.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coordinates: () => (/* binding */ coordinates)
/* harmony export */ });
/**
 * @module ol/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/segments.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/segments.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forEach: () => (/* binding */ forEach)
/* harmony export */ });
/**
 * @module ol/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride),
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/simplify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/simplify.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   douglasPeucker: () => (/* binding */ douglasPeucker),
/* harmony export */   douglasPeuckerArray: () => (/* binding */ douglasPeuckerArray),
/* harmony export */   douglasPeuckerMultiArray: () => (/* binding */ douglasPeuckerMultiArray),
/* harmony export */   quantize: () => (/* binding */ quantize),
/* harmony export */   quantizeArray: () => (/* binding */ quantizeArray),
/* harmony export */   quantizeMultiArray: () => (/* binding */ quantizeMultiArray),
/* harmony export */   radialDistance: () => (/* binding */ radialDistance),
/* harmony export */   simplifyLineString: () => (/* binding */ simplifyLineString),
/* harmony export */   snap: () => (/* binding */ snap)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  highQuality,
  simplifiedFlatCoordinates,
) {
  simplifiedFlatCoordinates =
    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0,
    );
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates,
    offset,
    end,
    stride,
    squaredTolerance,
    simplifiedFlatCoordinates,
    0,
  );
  return simplifiedFlatCoordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array<number>} */
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredSegmentDistance)(x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEnds,
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEndss,
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    /** @type {Array<number>} */
    const simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds,
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2 = x1;
  let y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}

/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}

/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(
  flatCoordinates,
  offset,
  end,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    // snap the next coordinate (P3)
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if (
      dx1 * dy2 == dy1 * dx2 &&
      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))
    ) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEnds,
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEndss,
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    /** @type {Array<number>} */
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds,
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   transform2D: () => (/* binding */ transform2D),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/**
 * @module ol/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [destinationStride] Stride of destination coordinates; if unspecified, assumed to be 2.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(
  flatCoordinates,
  offset,
  end,
  stride,
  transform,
  dest,
  destinationStride,
) {
  dest = dest ? dest : [];
  destinationStride = destinationStride ? destinationStride : 2;
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];

    for (let k = 2; k < destinationStride; k++) {
      dest[i++] = flatCoordinates[j + k];
    }
  }

  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(
  flatCoordinates,
  offset,
  end,
  stride,
  angle,
  anchor,
  dest,
) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(
  flatCoordinates,
  offset,
  end,
  stride,
  sx,
  sy,
  anchor,
  dest,
) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(
  flatCoordinates,
  offset,
  end,
  stride,
  deltaX,
  deltaY,
  dest,
) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATE_IMAGE_BITMAP: () => (/* binding */ CREATE_IMAGE_BITMAP),
/* harmony export */   DEVICE_PIXEL_RATIO: () => (/* binding */ DEVICE_PIXEL_RATIO),
/* harmony export */   FIREFOX: () => (/* binding */ FIREFOX),
/* harmony export */   IMAGE_DECODE: () => (/* binding */ IMAGE_DECODE),
/* harmony export */   MAC: () => (/* binding */ MAC),
/* harmony export */   PASSIVE_EVENT_LISTENERS: () => (/* binding */ PASSIVE_EVENT_LISTENERS),
/* harmony export */   SAFARI: () => (/* binding */ SAFARI),
/* harmony export */   SAFARI_BUG_237906: () => (/* binding */ SAFARI_BUG_237906),
/* harmony export */   WEBKIT: () => (/* binding */ WEBKIT),
/* harmony export */   WORKER_OFFSCREEN_CANVAS: () => (/* binding */ WORKER_OFFSCREEN_CANVAS)
/* harmony export */ });
/**
 * @module ol/has
 */

const ua =
  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
    ? navigator.userAgent.toLowerCase()
    : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
const FIREFOX = ua.includes('firefox');

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
const SAFARI = ua.includes('safari') && !ua.includes('chrom');

/**
 * https://bugs.webkit.org/show_bug.cgi?id=237906
 * @type {boolean}
 */
const SAFARI_BUG_237906 =
  SAFARI &&
  (ua.includes('version/15.4') ||
    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
const WEBKIT = ua.includes('webkit') && !ua.includes('edge');

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
const MAC = ua.includes('macintosh');

/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
const DEVICE_PIXEL_RATIO =
  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;

/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */
const WORKER_OFFSCREEN_CANVAS =
  typeof WorkerGlobalScope !== 'undefined' &&
  typeof OffscreenCanvas !== 'undefined' &&
  self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */
const IMAGE_DECODE =
  typeof Image !== 'undefined' && Image.prototype.decode;

/**
 * createImageBitmap() is supported.
 * @type {boolean}
 */
const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';

/**
 * @type {boolean}
 */
const PASSIVE_EVENT_LISTENERS = (function () {
  let passive = false;
  try {
    const options = Object.defineProperty({}, 'passive', {
      get: function () {
        passive = true;
      },
    });

    // @ts-ignore Ignore invalid event type '_'
    window.addEventListener('_', null, options);
    // @ts-ignore Ignore invalid event type '_'
    window.removeEventListener('_', null, options);
  } catch (error) {
    // passive not supported
  }
  return passive;
})();


/***/ }),

/***/ "./node_modules/ol/interaction/DoubleClickZoom.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/interaction/DoubleClickZoom.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/**
 * @module ol/interaction/DoubleClickZoom
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
class DoubleClickZoom extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK) {
      const browserEvent = /** @type {MouseEvent} */ (
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.zoomByDelta)(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DoubleClickZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/DragBox.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragBox.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DragBoxEvent: () => (/* binding */ DragBoxEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _render_Box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/Box.js */ "./node_modules/ol/render/Box.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box





/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */

/**
 * @enum {string}
 */
const DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend',

  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: 'boxcancel',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
class DragBoxEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = coordinate;

    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */
class DragBox extends _Pointer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {DragBoxOnSignature<void>}
     */
    this.un;

    options = options ?? {};

    /**
     * @type {import("../render/Box.js").default}
     * @private
     */
    this.box_ = new _render_Box_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.className || 'ol-dragbox');

    /**
     * @type {number}
     * @private
     */
    this.minArea_ = options.minArea ?? 64;

    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.startPixel_ = null;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ?? _events_condition_js__WEBPACK_IMPORTED_MODULE_3__.mouseActionButton;

    /**
     * @private
     * @type {EndCondition}
     */
    this.boxEndCondition_ =
      options.boxEndCondition ?? this.defaultBoxEndCondition;
  }

  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }

  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return;
    }

    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent,
      ),
    );
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return false;
    }

    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel,
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent,
      ),
    );

    this.box_.setMap(null);
    this.startPixel_ = null;

    return false;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent,
        ),
      );
      return true;
    }
    return false;
  }

  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {}

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(active) {
    if (!active) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null),
        );
        this.startPixel_ = null;
      }
    }

    super.setActive(active);
  }

  /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */
  setMap(map) {
    const oldMap = this.getMap();

    if (oldMap) {
      this.box_.setMap(null);

      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null),
        );
        this.startPixel_ = null;
      }
    }

    super.setMap(map);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragBox);


/***/ }),

/***/ "./node_modules/ol/interaction/DragPan.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragPan.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/**
 * @module ol/interaction/DragPan
 */






/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
class DragPan extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE,
    });

    options = options ? options : {};

    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */
    this.kinetic_ = options.kinetic;

    /**
     * @type {import("../pixel.js").Pixel}
     */
    this.lastCentroid = null;

    /**
     * @type {number}
     * @private
     */
    this.lastPointersCount_;

    /**
     * @type {boolean}
     * @private
     */
    this.panning_ = false;

    const condition = options.condition
      ? options.condition
      : (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.noModifierKeys, _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.primaryAction);

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.onFocusOnly
      ? (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.focusWithTabindex, condition)
      : condition;

    /**
     * @private
     * @type {boolean}
     */
    this.noKinetic_ = false;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid = map.getEventPixel((0,_Pointer_js__WEBPACK_IMPORTED_MODULE_0__.centroid)(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid[0], centroid[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid[0],
          centroid[1] - this.lastCentroid[1],
        ];
        const map = mapBrowserEvent.map;
        const view = map.getView();
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.scale)(delta, view.getResolution());
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger down, tiny drag, second finger down
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle),
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__.easeOut,
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger up, tiny drag, second finger up
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      // stop any current animation
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      // No kinetic as soon as more than one pointer on the screen is
      // detected. This is to prevent nasty pans after pinch.
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragPan);


/***/ }),

/***/ "./node_modules/ol/interaction/DragRotate.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotate.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/**
 * @module ol/interaction/DragRotate
 */





/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes a
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
class DragRotate extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE,
    });

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.altShiftKeysOnly;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_3__.disable) {
      return;
    }
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== undefined) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if (
      (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseActionButton)(mapBrowserEvent) &&
      this.condition_(mapBrowserEvent)
    ) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragRotate);


/***/ }),

/***/ "./node_modules/ol/interaction/DragZoom.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/DragZoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/DragZoom
 */




/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with a {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
class DragZoom extends _DragBox_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.shiftKeyOnly;

    super({
      condition: condition,
      className: options.className || 'ol-dragzoom',
      minArea: options.minArea,
    });

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 200;

    /**
     * @private
     * @type {boolean}
     */
    this.out_ = options.out !== undefined ? options.out : false;
  }

  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = /** @type {!import("../View.js").default} */ (map.getView());
    let geometry = this.getGeometry();

    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }

    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.easeOut,
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/Interaction.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/Interaction.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   pan: () => (/* binding */ pan),
/* harmony export */   zoomByDelta: () => (/* binding */ zoomByDelta)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/interaction/Interaction
 */




/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */

/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
class Interaction extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();

    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {InteractionOnSignature<void>}
     */
    this.un;

    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    this.map_ = null;

    this.setActive(true);
  }

  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].ACTIVE));
  }

  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].ACTIVE, active);
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
}

/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [duration] Duration.
 */
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== undefined ? duration : 250,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.linear,
      center: view.getConstrainedCenter(center),
    });
  }
}

/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
 * @param {number} [duration] Duration.
 */
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();

  if (currentZoom === undefined) {
    return;
  }

  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);

  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor: anchor,
    duration: duration !== undefined ? duration : 250,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.easeOut,
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Interaction);


/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardPan.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardPan.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _events_Key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Key.js */ "./node_modules/ol/events/Key.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/**
 * @module ol/interaction/KeyboardPan
 */






/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
class KeyboardPan extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options || {};

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultCondition_ = function (mapBrowserEvent) {
      return (
        (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.noModifierKeys)(mapBrowserEvent) && (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.targetNotEditable)(mapBrowserEvent)
      );
    };

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ =
      options.condition !== undefined
        ? options.condition
        : this.defaultCondition_;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

    /**
     * @private
     * @type {number}
     */
    this.pixelDelta_ =
      options.pixelDelta !== undefined ? options.pixelDelta : 128;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].KEYDOWN) {
      const keyEvent = /** @type {KeyboardEvent} */ (
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (
        this.condition_(mapBrowserEvent) &&
        (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].DOWN ||
          key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].LEFT ||
          key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].RIGHT ||
          key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].UP)
      ) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0,
          deltaY = 0;
        if (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_4__.rotate)(delta, view.getRotation());
        (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.pan)(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyboardPan);


/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardZoom.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardZoom.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/KeyboardZoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. The default condition is
 * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that
 * the platform modifier key isn't pressed
 * (!{@link module:ol/events/condition.platformModifierKey}).
 * @property {number} [delta=1] The zoom level delta on each key press.
 */

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
class KeyboardZoom extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition
      ? options.condition
      : function (mapBrowserEvent) {
          return (
            !(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.platformModifierKey)(mapBrowserEvent) &&
            (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.targetNotEditable)(mapBrowserEvent)
          );
        };

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (
      mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].KEYDOWN ||
      mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].KEYPRESS
    ) {
      const keyEvent = /** @type {KeyboardEvent} */ (
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {
        const map = mapBrowserEvent.map;
        const delta = key === '+' ? this.delta_ : -this.delta_;
        const view = map.getView();
        (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.zoomByDelta)(view, delta, undefined, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyboardZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/MouseWheelZoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/interaction/MouseWheelZoom.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/MouseWheelZoom
 */






/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
class MouseWheelZoom extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super(
      /** @type {import("./Interaction.js").InteractionOptions} */ (options),
    );

    /**
     * @private
     * @type {number}
     */
    this.totalDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.lastDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @private
     * @type {number}
     */
    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

    /**
     * @private
     * @type {boolean}
     */
    this.useAnchor_ =
      options.useAnchor !== undefined ? options.useAnchor : true;

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ =
      options.constrainResolution !== undefined
        ? options.constrainResolution
        : false;

    const condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.always;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.onFocusOnly
      ? (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.focusWithTabindex, condition)
      : condition;

    /**
     * @private
     * @type {?import("../pixel.js").Pixel}
     */
    this.lastAnchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.startTime_ = undefined;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    this.timeoutId_;

    /**
     * @private
     * @type {Mode|undefined}
     */
    this.mode_ = undefined;

    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @private
     * @type {number}
     */
    this.trackpadEventGap_ = 400;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    this.trackpadTimeoutId_;

    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */
    this.deltaPerZoom_ = 300;
  }

  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = undefined;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      undefined,
      this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,
    );
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].WHEEL) {
      return true;
    }

    const map = mapBrowserEvent.map;
    const wheelEvent = /** @type {WheelEvent} */ (
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();

    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.pixel;
    }

    // Delta normalisation inspired by
    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
    let delta;
    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].WHEEL) {
      delta = wheelEvent.deltaY;
      if (_has_js__WEBPACK_IMPORTED_MODULE_3__.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= _has_js__WEBPACK_IMPORTED_MODULE_3__.DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }

    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;

    const now = Date.now();

    if (this.startTime_ === undefined) {
      this.startTime_ = now;
    }

    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';
    }

    const view = map.getView();
    if (
      this.mode_ === 'trackpad' &&
      !(view.getConstrainResolution() || this.constrainResolution_)
    ) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_,
      );
      view.adjustZoom(
        -delta / this.deltaPerZoom_,
        this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,
      );
      this.startTime_ = now;
      return false;
    }

    this.totalDelta_ += delta;

    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft,
    );

    return false;
  }

  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta =
      -(0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(
        this.totalDelta_,
        -this.maxDelta_ * this.deltaPerZoom_,
        this.maxDelta_ * this.deltaPerZoom_,
      ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      // view has a zoom constraint, zoom by 1
      delta = delta ? (delta > 0 ? 1 : -1) : 0;
    }
    (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.zoomByDelta)(
      view,
      delta,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,
      this.duration_,
    );

    this.mode_ = undefined;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  }

  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MouseWheelZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/PinchRotate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/PinchRotate.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/**
 * @module ol/interaction/PinchRotate
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
class PinchRotate extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const pointerOptions = /** @type {import("./Pointer.js").Options} */ (
      options
    );

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE;
    }

    super(pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.rotating_ = false;

    /**
     * @private
     * @type {number}
     */
    this.rotationDelta_ = 0.0;

    /**
     * @private
     * @type {number}
     */
    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0.0;

    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];

    // angle between touches
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX,
    );

    if (this.lastAngle_ !== undefined) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;

    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_2__.disable) {
      return;
    }

    // rotate anchor point.
    // FIXME: should be the intersection point between the lines:
    //     touch0,touch1 and previousTouch0,previousTouch1
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel((0,_Pointer_js__WEBPACK_IMPORTED_MODULE_0__.centroid)(this.targetPointers)),
    );

    // rotate
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = undefined;
      this.rotating_ = false;
      this.rotationDelta_ = 0.0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PinchRotate);


/***/ }),

/***/ "./node_modules/ol/interaction/PinchZoom.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/PinchZoom.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/interaction/PinchZoom
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
class PinchZoom extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const pointerOptions = /** @type {import("./Pointer.js").Options} */ (
      options
    );

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE;
    }

    super(pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastDistance_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 1;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1.0;

    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;

    // distance between touches
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (this.lastDistance_ !== undefined) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;

    const map = mapBrowserEvent.map;
    const view = map.getView();

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    }

    // scale anchor point.
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel((0,_Pointer_js__WEBPACK_IMPORTED_MODULE_0__.centroid)(this.targetPointers)),
    );

    // scale, bypass the resolution constraint
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PinchZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/Pointer.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/Pointer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   centroid: () => (/* binding */ centroid),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/**
 * @module ol/interaction/Pointer
 */



/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
class PointerInteraction extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super(
      /** @type {import("./Interaction.js").InteractionOptions} */ (options),
    );

    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }

    /**
     * @type {boolean}
     * @protected
     */
    this.handlingDownUpSequence = false;

    /**
     * @type {Array<PointerEvent>}
     * @protected
     */
    this.targetPointers = [];
  }

  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {}

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }

    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        // prevent page scrolling during dragging
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence =
          handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }

  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {}

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }

  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
}

/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {{clientX: number, clientY: number}} Centroid pixel.
 */
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return {clientX: clientX / length, clientY: clientY / length};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PointerInteraction);


/***/ }),

/***/ "./node_modules/ol/interaction/Property.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/Property.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ACTIVE: 'active',
});


/***/ }),

/***/ "./node_modules/ol/interaction/defaults.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/defaults.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaults: () => (/* binding */ defaults)
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DoubleClickZoom.js */ "./node_modules/ol/interaction/DoubleClickZoom.js");
/* harmony import */ var _DragPan_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DragPan.js */ "./node_modules/ol/interaction/DragPan.js");
/* harmony import */ var _DragRotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DragRotate.js */ "./node_modules/ol/interaction/DragRotate.js");
/* harmony import */ var _DragZoom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DragZoom.js */ "./node_modules/ol/interaction/DragZoom.js");
/* harmony import */ var _KeyboardPan_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./KeyboardPan.js */ "./node_modules/ol/interaction/KeyboardPan.js");
/* harmony import */ var _KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./KeyboardZoom.js */ "./node_modules/ol/interaction/KeyboardZoom.js");
/* harmony import */ var _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Kinetic.js */ "./node_modules/ol/Kinetic.js");
/* harmony import */ var _MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MouseWheelZoom.js */ "./node_modules/ol/interaction/MouseWheelZoom.js");
/* harmony import */ var _PinchRotate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PinchRotate.js */ "./node_modules/ol/interaction/PinchRotate.js");
/* harmony import */ var _PinchZoom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PinchZoom.js */ "./node_modules/ol/interaction/PinchZoom.js");
/**
 * @module ol/interaction/defaults
 */












/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [options] Defaults options.
 * @return {Collection<import("./Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(options) {
  options = options ? options : {};

  /** @type {Collection<import("./Interaction.js").default>} */
  const interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  const kinetic = new _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__["default"](-0.005, 0.05, 100);

  const altShiftDragRotate =
    options.altShiftDragRotate !== undefined
      ? options.altShiftDragRotate
      : true;
  if (altShiftDragRotate) {
    interactions.push(new _DragRotate_js__WEBPACK_IMPORTED_MODULE_2__["default"]());
  }

  const doubleClickZoom =
    options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new _DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        delta: options.zoomDelta,
        duration: options.zoomDuration,
      }),
    );
  }

  const dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new _DragPan_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        onFocusOnly: options.onFocusOnly,
        kinetic: kinetic,
      }),
    );
  }

  const pinchRotate =
    options.pinchRotate !== undefined ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new _PinchRotate_js__WEBPACK_IMPORTED_MODULE_5__["default"]());
  }

  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new _PinchZoom_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
        duration: options.zoomDuration,
      }),
    );
  }

  const keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new _KeyboardPan_js__WEBPACK_IMPORTED_MODULE_7__["default"]());
    interactions.push(
      new _KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
        delta: options.zoomDelta,
        duration: options.zoomDuration,
      }),
    );
  }

  const mouseWheelZoom =
    options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new _MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration,
      }),
    );
  }

  const shiftDragZoom =
    options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new _DragZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
        duration: options.zoomDuration,
      }),
    );
  }

  return interactions;
}


/***/ }),

/***/ "./node_modules/ol/layer/Base.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Base.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/layer/Base
 */






/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */

/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
class BaseLayer extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Layer options.
   */
  constructor(options) {
    super();

    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {BaseLayerOnSignature<void>}
     */
    this.un;

    /**
     * @type {BackgroundColor|false}
     * @private
     */
    this.background_ = options.background;

    /**
     * @type {Object<string, *>}
     */
    const properties = Object.assign({}, options);
    if (typeof options.properties === 'object') {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }

    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY] =
      options.opacity !== undefined ? options.opacity : 1;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(
      typeof properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY] === 'number',
      'Layer opacity must be a number',
    );

    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE] =
      options.visible !== undefined ? options.visible : true;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX] = options.zIndex;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION] =
      options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION] =
      options.minResolution !== undefined ? options.minResolution : 0;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM] =
      options.minZoom !== undefined ? options.minZoom : -Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM] =
      options.maxZoom !== undefined ? options.maxZoom : Infinity;

    /**
     * @type {string}
     * @private
     */
    this.className_ =
      properties.className !== undefined ? properties.className : 'ol-layer';
    delete properties.className;

    this.setProperties(properties);

    /**
     * @type {import("./Layer.js").State}
     * @private
     */
    this.state_ = null;
  }

  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }

  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }

  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(managed) {
    /** @type {import("./Layer.js").State} */
    const state =
      this.state_ ||
      /** @type {?} */ ({
        layer: this,
        managed: managed === undefined ? true : managed,
      });
    const zIndex = this.getZIndex();
    state.opacity = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;

    return state;
  }

  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  }

  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  }

  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return /** @type {import("../extent.js").Extent|undefined} */ (
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT)
    );
  }

  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION));
  }

  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION));
  }

  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM));
  }

  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM));
  }

  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY));
  }

  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  }

  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE));
  }

  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return /** @type {number|undefined} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX));
  }

  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }

  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(extent) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT, extent);
  }

  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(maxResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION, maxResolution);
  }

  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(minResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION, minResolution);
  }

  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(maxZoom) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM, maxZoom);
  }

  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(minZoom) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM, minZoom);
  }

  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(opacity) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof opacity === 'number', 'Layer opacity must be a number');
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY, opacity);
  }

  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(visible) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE, visible);
  }

  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(zindex) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX, zindex);
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseLayer);


/***/ }),

/***/ "./node_modules/ol/layer/BaseTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/BaseTile.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileProperty.js */ "./node_modules/ol/layer/TileProperty.js");
/**
 * @module ol/layer/BaseTile
 */



/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */

/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render
 * two zoom levels worth of tiles.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */
class BaseTileLayer extends _Layer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    const cacheSize = options.cacheSize;
    delete options.cacheSize;

    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {BaseTileLayerOnSignature<void>}
     */
    this.un;

    /**
     * @type {number|undefined}
     * @private
     */
    this.cacheSize_ = cacheSize;

    this.setPreload(options.preload !== undefined ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== undefined
        ? options.useInterimTilesOnError
        : true,
    );
  }

  /**
   * @return {number|undefined} The suggested cache size
   * @protected
   */
  getCacheSize() {
    return this.cacheSize_;
  }

  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return /** @type {number} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD));
  }

  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD, preload);
  }

  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return /** @type {boolean} */ (
      this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR)
    );
  }

  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }

  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(pixel) {
    return super.getData(pixel);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTileLayer);


/***/ }),

/***/ "./node_modules/ol/layer/BaseVector.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/layer/BaseVector.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/canvas/style.js */ "./node_modules/ol/render/canvas/style.js");
/**
 * @module ol/layer/BaseVector
 */





/***
 * @template T
 * @typedef {T extends import("../source/Vector.js").default<infer U extends import("../Feature.js").FeatureLike> ? U : never} ExtractedFeatureType
 */

/**
 * @template {import('../Feature').FeatureLike} FeatureType
 * @template {import("../source/Vector.js").default<FeatureType>|import("../source/VectorTile.js").default<FeatureType>} VectorSourceType<FeatureType>
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable
 * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the
 * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the
 * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct
 * layers or groups of layers separately, use different truthy values for `declutter`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
const Property = {
  RENDER_ORDER: 'renderOrder',
};

/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import('../Feature').FeatureLike} FeatureType
 * @template {import("../source/Vector.js").default<FeatureType>|import("../source/VectorTile.js").default<FeatureType>} VectorSourceType<FeatureType>
 * @extends {Layer<VectorSourceType, RendererType>}
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @api
 */
class BaseVectorLayer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);

    /**
     * @private
     * @type {string}
     */
    this.declutter_ = options.declutter ? String(options.declutter) : undefined;

    /**
     * @type {number}
     * @private
     */
    this.renderBuffer_ =
      options.renderBuffer !== undefined ? options.renderBuffer : 100;

    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike}
     * @private
     */
    this.style_ = null;

    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */
    this.styleFunction_ = undefined;

    this.setStyle(options.style);

    /**
     * @type {boolean}
     * @private
     */
    this.updateWhileAnimating_ =
      options.updateWhileAnimating !== undefined
        ? options.updateWhileAnimating
        : false;

    /**
     * @type {boolean}
     * @private
     */
    this.updateWhileInteracting_ =
      options.updateWhileInteracting !== undefined
        ? options.updateWhileInteracting
        : false;
  }

  /**
   * @return {string} Declutter group.
   * @override
   */
  getDeclutter() {
    return this.declutter_;
  }

  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }

  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }

  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return /** @type {import("../render.js").OrderFunction|null|undefined} */ (
      this.get(Property.RENDER_ORDER)
    );
  }

  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }

  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }

  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }

  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }

  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */
  renderDeclutter(frameState, layerState) {
    const declutterGroup = this.getDeclutter();
    if (declutterGroup in frameState.declutter === false) {
      frameState.declutter[declutterGroup] = new rbush__WEBPACK_IMPORTED_MODULE_0__["default"](9);
    }
    this.getRenderer().renderDeclutter(frameState, layerState);
  }

  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  }

  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(style) {
    this.style_ = style === undefined ? _style_Style_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultStyle : style;
    const styleLike = toStyleLike(style);
    this.styleFunction_ =
      style === null ? undefined : (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_2__.toFunction)(styleLike);
    this.changed();
  }

  /**
   * @param {boolean|string|number} declutter Declutter images and text.
   * @api
   */
  setDeclutter(declutter) {
    this.declutter_ = declutter ? String(declutter) : undefined;
    this.changed();
  }
}

/**
 * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat
 * styles, and arrays of rules are converted into style functions.
 *
 * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
 * @return {import("../style/Style.js").StyleLike|null} The style.
 */
function toStyleLike(style) {
  if (style === undefined) {
    return _style_Style_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === 'function') {
    return style;
  }
  if (style instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    return style;
  }
  if (!Array.isArray(style)) {
    return (0,_render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__.flatStylesToStyleFunction)([style]);
  }
  if (style.length === 0) {
    return [];
  }

  const length = style.length;
  const first = style[0];

  if (first instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    /**
     * @type {Array<Style>}
     */
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"])) {
        throw new Error('Expected a list of style instances');
      }
      styles[i] = candidate;
    }
    return styles;
  }

  if ('style' in first) {
    /**
     * @type Array<import("../style/flat.js").Rule>
     */
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!('style' in candidate)) {
        throw new Error('Expected a list of rules with a style property');
      }
      rules[i] = candidate;
    }
    return (0,_render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__.rulesToStyleFunction)(rules);
  }

  const flatStyles =
    /** @type {Array<import("../style/flat.js").FlatStyle>} */ (style);
  return (0,_render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__.flatStylesToStyleFunction)(flatStyles);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseVectorLayer);


/***/ }),

/***/ "./node_modules/ol/layer/Group.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Group.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GroupEvent: () => (/* binding */ GroupEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/layer/Group
 */












/**
 * @typedef {'addlayer'|'removelayer'} GroupEventType
 */

/**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */
class GroupEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);

    /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */
    this.layer = layer;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
const Property = {
  LAYERS: 'layers',
};

/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
class LayerGroup extends _Base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = /** @type {Options} */ (Object.assign({}, options));
    delete baseOptions.layers;

    let layers = options.layers;

    super(baseOptions);

    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {GroupOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.layersListenerKeys_ = [];

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.listenerKeys_ = {};

    this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_2__["default"](layers.slice(), {unique: true});
      } else {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
          typeof (/** @type {?} */ (layers).getArray) === 'function',
          'Expected `layers` to be an array or a `Collection`',
        );
      }
    } else {
      layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_2__["default"](undefined, {unique: true});
    }

    this.setLayers(layers);
  }

  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }

  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    this.layersListenerKeys_.length = 0;

    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].ADD, this.handleLayersAdd_, this),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(
        layers,
        _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].REMOVE,
        this.handleLayersRemove_,
        this,
      ),
    );

    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    }
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_6__.clear)(this.listenerKeys_);

    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent('addlayer', layer));
    }
    this.changed();
  }

  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(
        layer,
        _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PROPERTYCHANGE,
        this.handleLayerChange_,
        this,
      ),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE, this.handleLayerChange_, this),
    ];

    if (layer instanceof LayerGroup) {
      listenerKeys.push(
        (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, 'addlayer', this.handleLayerGroupAdd_, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, 'removelayer', this.handleLayerGroupRemove_, this),
      );
    }

    this.listenerKeys_[(0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(layer)] = listenerKeys;
  }

  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent('addlayer', event.layer));
  }

  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent('removelayer', event.layer));
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent('addlayer', layer));
    this.changed();
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(layer);
    this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent('removelayer', layer));
    this.changed();
  }

  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return /** @type {!Collection<import("./Base.js").default>} */ (
      this.get(Property.LAYERS)
    );
  }

  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
      }
    }

    this.set(Property.LAYERS, layers);
  }

  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array !== undefined ? array : [];
    this.getLayers().forEach(function (layer) {
      layer.getLayersArray(array);
    });
    return array;
  }

  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(dest) {
    const states = dest !== undefined ? dest : [];
    const pos = states.length;

    this.getLayers().forEach(function (layer) {
      layer.getLayerStatesArray(states);
    });

    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === undefined) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution,
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution,
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getIntersection)(
            layerState.extent,
            ownLayerState.extent,
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === undefined) {
        layerState.zIndex = defaultZIndex;
      }
    }

    return states;
  }

  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    return 'ready';
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerGroup);


/***/ }),

/***/ "./node_modules/ol/layer/Layer.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Layer.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   inView: () => (/* binding */ inView)
/* harmony export */ });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../View.js */ "./node_modules/ol/View.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/layer/Layer
 */









/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */

/**
 * @typedef {'sourceready'|'change:source'} LayerEventType
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     LayerEventType, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|LayerEventType|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */

/**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */

/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 * A `sourceready` event is fired when the layer's source is ready.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @fires import("../events/Event.js").BaseEvent#sourceready
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */
class Layer extends _Base_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;

    super(baseOptions);

    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {LayerOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapPrecomposeKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapRenderKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.sourceChangeKey_ = null;

    /**
     * @private
     * @type {RendererType}
     */
    this.renderer_ = null;

    /**
     * @private
     * @type {boolean}
     */
    this.sourceReady_ = false;

    /**
     * @protected
     * @type {boolean}
     */
    this.rendered = false;

    // Overwrite default render method with a custom one
    if (options.render) {
      this.render = options.render;
    }

    if (options.map) {
      this.setMap(options.map);
    }

    this.addChangeListener(
      _Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE,
      this.handleSourcePropertyChange_,
    );

    const source = options.source
      ? /** @type {SourceType} */ (options.source)
      : null;
    this.setSource(source);
  }

  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }

  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }

  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return /** @type {SourceType} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE)) || null;
  }

  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }

  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const source = this.getSource();
    return !source ? 'undefined' : source.getState();
  }

  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent('sourceready');
  }

  /**
   * @private
   */
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(
        source,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE,
        this.handleSourceChange_,
        this,
      );
      if (source.getState() === 'ready') {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent('sourceready');
        }, 0);
      }
    }
    this.changed();
  }

  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }

  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }

  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(view) {
    let frameState;
    const map = this.getMapInternal();
    if (!view && map) {
      view = map.getView();
    }
    if (view instanceof _View_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
      frameState = {
        viewState: view.getState(),
        extent: view.calculateExtent(),
      };
    } else {
      frameState = view;
    }
    if (!frameState.layerStatesArray && map) {
      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
    }
    let layerState;
    if (frameState.layerStatesArray) {
      layerState = frameState.layerStatesArray.find(
        (layerState) => layerState.layer === this,
      );
      if (!layerState) {
        return false;
      }
    } else {
      layerState = this.getLayerState();
    }

    const layerExtent = this.getExtent();

    return (
      inView(layerState, frameState.viewState) &&
      (!layerExtent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.intersects)(layerExtent, frameState.extent))
    );
  }

  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(view) {
    if (!this.isVisible(view)) {
      return [];
    }
    const getAttributions = this.getSource()?.getAttributions();
    if (!getAttributions) {
      return [];
    }
    const frameState =
      view instanceof _View_js__WEBPACK_IMPORTED_MODULE_4__["default"] ? view.getViewStateAndExtent() : view;
    let attributions = getAttributions(frameState);
    if (!Array.isArray(attributions)) {
      attributions = [attributions];
    }
    return attributions;
  }

  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(frameState, target) {
    const layerRenderer = this.getRenderer();

    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
    return null;
  }

  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = false;
  }

  /** @return {string} Declutter */
  getDeclutter() {
    return undefined;
  }

  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(frameState, layerState) {}

  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(frameState) {
    const layerRenderer = this.getRenderer();
    if (!layerRenderer) {
      return;
    }
    layerRenderer.renderDeferred(frameState);
  }

  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(map) {
    if (!map) {
      this.unrender();
    }
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAP, map);
  }

  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAP);
  }

  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.mapPrecomposeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(
        map,
        _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE,
        this.handlePrecompose_,
        this,
      );
      this.mapRenderKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, map.render, map);
      this.changed();
    }
  }

  /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */
  handlePrecompose_(renderEvent) {
    const layerStatesArray =
      /** @type {import("../render/Event.js").default} */ (renderEvent)
        .frameState.layerStatesArray;
    const layerState = this.getLayerState(false);
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(
      !layerStatesArray.some(
        (arrayLayerState) => arrayLayerState.layer === layerState.layer,
      ),
      'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.',
    );
    layerStatesArray.push(layerState);
  }

  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(source) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE, source);
  }

  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }

  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }

  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }

  /**
   * This will clear the renderer so that a new one can be created next time it is needed
   */
  clearRenderer() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.clearRenderer();
    this.setSource(null);
    super.disposeInternal();
  }
}

/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (
    resolution < layerState.minResolution ||
    resolution >= layerState.maxResolution
  ) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Layer);


/***/ }),

/***/ "./node_modules/ol/layer/Property.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/Property.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  MAX_ZOOM: 'maxZoom',
  MIN_ZOOM: 'minZoom',
  SOURCE: 'source',
  MAP: 'map',
});


/***/ }),

/***/ "./node_modules/ol/layer/Tile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Tile.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseTile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTile.js */ "./node_modules/ol/layer/BaseTile.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/canvas/TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/**
 * @module ol/layer/Tile
 */



/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} [TileSourceType=import("../source/Tile.js").default]
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */
class TileLayer extends _BaseTile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }

  /**
   * @override
   */
  createRenderer() {
    return new _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this, {
      cacheSize: this.getCacheSize(),
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileLayer);


/***/ }),

/***/ "./node_modules/ol/layer/TileProperty.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/layer/TileProperty.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',
});


/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   modulo: () => (/* binding */ modulo),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   solveLinearSystem: () => (/* binding */ solveLinearSystem),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredSegmentDistance: () => (/* binding */ squaredSegmentDistance),
/* harmony export */   toDegrees: () => (/* binding */ toDegrees),
/* harmony export */   toFixed: () => (/* binding */ toFixed),
/* harmony export */   toRadians: () => (/* binding */ toRadians),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
/**
 * @module ol/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>|null} The resulting vector.
 */
function solveLinearSystem(mat) {
  const n = mat.length;

  for (let i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return (angleInRadians * 180) / Math.PI;
}

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return (angleInDegrees * Math.PI) / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}

/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */
function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}

/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}

/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}

/**
 * Wraps a number between some minimum and maximum values.
 * @param {number} n The number to wrap.
 * @param {number} min The minimum of the range (inclusive).
 * @param {number} max The maximum of the range (exclusive).
 * @return {number} The wrapped number.
 */
function wrap(n, min, max) {
  if (n >= min && n < max) {
    return n;
  }
  const range = max - min;
  return ((((n - min) % range) + range) % range) + min;
}


/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty)
/* harmony export */ });
/**
 * @module ol/obj
 */

/**
 * Removes all properties from an object.
 * @param {Object<string, unknown>} object The object to clear.
 */
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}


/***/ }),

/***/ "./node_modules/ol/pointer/EventType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/pointer/EventType.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel',
});


/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   METERS_PER_UNIT: () => (/* reexport safe */ _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__.METERS_PER_UNIT),
/* harmony export */   Projection: () => (/* reexport safe */ _proj_Projection_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   addCommon: () => (/* binding */ addCommon),
/* harmony export */   addCoordinateTransforms: () => (/* binding */ addCoordinateTransforms),
/* harmony export */   addEquivalentProjections: () => (/* binding */ addEquivalentProjections),
/* harmony export */   addEquivalentTransforms: () => (/* binding */ addEquivalentTransforms),
/* harmony export */   addProjection: () => (/* binding */ addProjection),
/* harmony export */   addProjections: () => (/* binding */ addProjections),
/* harmony export */   clearAllProjections: () => (/* binding */ clearAllProjections),
/* harmony export */   clearUserProjection: () => (/* binding */ clearUserProjection),
/* harmony export */   cloneTransform: () => (/* binding */ cloneTransform),
/* harmony export */   createProjection: () => (/* binding */ createProjection),
/* harmony export */   createSafeCoordinateTransform: () => (/* binding */ createSafeCoordinateTransform),
/* harmony export */   createTransformFromCoordinateTransform: () => (/* binding */ createTransformFromCoordinateTransform),
/* harmony export */   disableCoordinateWarning: () => (/* binding */ disableCoordinateWarning),
/* harmony export */   equivalent: () => (/* binding */ equivalent),
/* harmony export */   fromLonLat: () => (/* binding */ fromLonLat),
/* harmony export */   fromUserCoordinate: () => (/* binding */ fromUserCoordinate),
/* harmony export */   fromUserExtent: () => (/* binding */ fromUserExtent),
/* harmony export */   fromUserResolution: () => (/* binding */ fromUserResolution),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   getPointResolution: () => (/* binding */ getPointResolution),
/* harmony export */   getTransform: () => (/* binding */ getTransform),
/* harmony export */   getTransformFromProjections: () => (/* binding */ getTransformFromProjections),
/* harmony export */   getUserProjection: () => (/* binding */ getUserProjection),
/* harmony export */   identityTransform: () => (/* binding */ identityTransform),
/* harmony export */   setUserProjection: () => (/* binding */ setUserProjection),
/* harmony export */   toLonLat: () => (/* binding */ toLonLat),
/* harmony export */   toUserCoordinate: () => (/* binding */ toUserCoordinate),
/* harmony export */   toUserExtent: () => (/* binding */ toUserExtent),
/* harmony export */   toUserResolution: () => (/* binding */ toUserResolution),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   transformExtent: () => (/* binding */ transformExtent),
/* harmony export */   transformWithProjections: () => (/* binding */ transformWithProjections),
/* harmony export */   useGeographic: () => (/* binding */ useGeographic)
/* harmony export */ });
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _proj_utm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj/utm.js */ "./node_modules/ol/proj/utm.js");
/* harmony import */ var _console_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./console.js */ "./node_modules/ol/console.js");
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */













/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * @typedef {Object} Transforms
 * @property {TransformFunction} forward The forward transform (from geographic).
 * @property {TransformFunction} inverse The inverse transform (to geographic).
 */

/**
 * @type {Array<function(Projection): Transforms|null>}
 */
const transformFactories = [_proj_utm_js__WEBPACK_IMPORTED_MODULE_0__.makeTransforms];

/**
 * @type {Array<function(string): Projection|null>}
 */
const projectionFactories = [_proj_utm_js__WEBPACK_IMPORTED_MODULE_0__.makeProjection];

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @callback TransformFunction
 * @param {Array<number>} input
 * @param {Array<number>} [output]
 * @param {number} [dimension]
 * @param {number} [stride]
 * @return {Array<number>}
 *
 * @api
 */





let showCoordinateWarning = true;

/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */
function disableCoordinateWarning(disable) {
  const hide = disable === undefined ? true : disable;
  showCoordinateWarning = !hide;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, output) {
  if (output !== undefined) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, output) {
  if (output !== undefined && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection.getCode(), projection);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.add)(projection, projection, cloneTransform);
}

/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  if (!(typeof projectionLike === 'string')) {
    return projectionLike;
  }
  const projection = (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_3__.get)(projectionLike);
  if (projection) {
    return projection;
  }
  for (const makeProjection of projectionFactories) {
    const projection = makeProjection(projectionLike);
    if (projection) {
      return projection;
    }
  }
  return null;
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, units) {
  projection = get(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution =
          (pointResolution * metersPerUnit) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__.METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if ((projUnits == 'degrees' && !units) || units == 'degrees') {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      const toEPSG4326 = getTransformFromProjections(
        projection,
        get('EPSG:4326'),
      );
      if (!toEPSG4326 && projUnits !== 'degrees') {
        // no transform is available
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2,
        ];
        vertices = toEPSG4326(vertices, vertices, 2);
        const width = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_5__.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_5__.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units
        ? _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__.METERS_PER_UNIT[units]
        : projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.add)(source, destination, cloneTransform);
      }
    });
  });
}

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(
  projections1,
  projections2,
  forwardTransform,
  inverseTransform,
) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.add)(projection1, projection2, forwardTransform);
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.add)(projection2, projection1, inverseTransform);
    });
  });
}

/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_3__.clear)();
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.clear)();
}

/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  }
  if (typeof projection === 'string') {
    return get(projection);
  }
  return /** @type {Projection} */ (projection);
}

/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    function (input, output, dimension, stride) {
      const length = input.length;
      dimension = dimension !== undefined ? dimension : 2;
      stride = stride ?? dimension;
      output = output !== undefined ? output : new Array(length);
      for (let i = 0; i < length; i += stride) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = stride; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get(source);
  const destProj = get(destination);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.add)(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward),
  );
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.add)(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse),
  );
}

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    'EPSG:4326',
    projection !== undefined ? projection : 'EPSG:3857',
  );
}

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, projection) {
  const lonLat = transform(
    coordinate,
    projection !== undefined ? projection : 'EPSG:3857',
    'EPSG:4326',
  );
  const lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.modulo)(lon + 180, 360) - 180;
  }
  return lonLat;
}

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} source Source Projection object.
 * @param {Projection} destination Destination Projection
 *     object.
 * @return {TransformFunction|null} Transform function.
 */
function getTransformFromProjections(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  let transformFunc = (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.get)(sourceCode, destinationCode);
  if (transformFunc) {
    return transformFunc;
  }

  /**
   * @type {Transforms|null}
   */
  let sourceTransforms = null;

  /**
   * @type {Transforms|null}
   */
  let destinationTransforms = null;

  // lazily add projections if we have supported transforms
  for (const makeTransforms of transformFactories) {
    if (!sourceTransforms) {
      sourceTransforms = makeTransforms(source);
    }
    if (!destinationTransforms) {
      destinationTransforms = makeTransforms(destination);
    }
  }

  if (!sourceTransforms && !destinationTransforms) {
    return null;
  }

  const intermediateCode = 'EPSG:4326';
  if (!destinationTransforms) {
    const toDestination = (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.get)(intermediateCode, destinationCode);
    if (toDestination) {
      transformFunc = composeTransformFuncs(
        sourceTransforms.inverse,
        toDestination,
      );
    }
  } else if (!sourceTransforms) {
    const fromSource = (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.get)(sourceCode, intermediateCode);
    if (fromSource) {
      transformFunc = composeTransformFuncs(
        fromSource,
        destinationTransforms.forward,
      );
    }
  } else {
    transformFunc = composeTransformFuncs(
      sourceTransforms.inverse,
      destinationTransforms.forward,
    );
  }

  if (transformFunc) {
    addProjection(source);
    addProjection(destination);
    (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_4__.add)(source, destination, transformFunc);
  }

  return transformFunc;
}

/**
 * @param {TransformFunction} t1 The first transform function.
 * @param {TransformFunction} t2 The second transform function.
 * @return {TransformFunction} The composed transform function.
 */
function composeTransformFuncs(t1, t2) {
  return function (input, output, dimensions, stride) {
    output = t1(input, output, dimensions, stride);
    return t2(output, output, dimensions, stride);
  };
}

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  const sourceProjection = get(source);
  const destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original). If there
 * is no available transform between the two projection, the function will throw
 * an error.
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  if (!transformFunc) {
    const sourceCode = get(source).getCode();
    const destinationCode = get(destination).getCode();
    throw new Error(
      `No transform available between ${sourceCode} and ${destinationCode}`,
    );
  }
  return transformFunc(coordinate, undefined, coordinate.length);
}

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return (0,_extent_js__WEBPACK_IMPORTED_MODULE_7__.applyTransform)(extent, transformFunc, undefined, stops);
}

/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(
  point,
  sourceProjection,
  destinationProjection,
) {
  const transformFunc = getTransformFromProjections(
    sourceProjection,
    destinationProjection,
  );
  return transformFunc(point);
}

/**
 * @type {Projection|null}
 */
let userProjection = null;

/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */
function setUserProjection(projection) {
  userProjection = get(projection);
}

/**
 * Clear the user projection if set.
 * @api
 */
function clearUserProjection() {
  userProjection = null;
}

/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */
function getUserProjection() {
  return userProjection;
}

/**
 * Use geographic coordinates (WGS-84 datum) in API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @api
 */
function useGeographic() {
  setUserProjection('EPSG:4326');
}

/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}

/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (
      showCoordinateWarning &&
      !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_8__.equals)(coordinate, [0, 0]) &&
      coordinate[0] >= -180 &&
      coordinate[0] <= 180 &&
      coordinate[1] >= -90 &&
      coordinate[1] <= 90
    ) {
      showCoordinateWarning = false;
      (0,_console_js__WEBPACK_IMPORTED_MODULE_9__.warn)(
        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.',
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}

/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}

/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit
    ? (resolution * sourceMetersPerUnit) / userMetersPerUnit
    : resolution;
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */
function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }
  const destMetersPerUnit = get(destProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return destMetersPerUnit && userMetersPerUnit
    ? (resolution * userMetersPerUnit) / destMetersPerUnit
    : resolution;
}

/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destination).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destination).
 */
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
  return function (coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_7__.getWidth)(sourceExtent);
      coord = coord.slice(0);
      worldsAway = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_8__.getWorldsAway)(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        // Move x to the real world
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform(coord);
    } else {
      transformed = transform(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      // Move transformed coordinate back to the offset world
      transformed[0] += worldsAway * (0,_extent_js__WEBPACK_IMPORTED_MODULE_7__.getWidth)(destProj.getExtent());
    }
    return transformed;
  };
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_11__.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(
    _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_11__.PROJECTIONS,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_10__.fromEPSG4326,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_10__.toEPSG4326,
  );
}

addCommon();


/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/Projection
 */


/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */

/**
 * @classdesc
 * In most cases, you should not need to create instances of this class.
 * Instead, where projection information is required, you can use a string
 * projection code or identifier (e.g. `EPSG:4326`) instead of a projection
 * instance.
 *
 * The library includes support for transforming coordinates between the following
 * projections:
 *
 *  * WGS 84 / Geographic - Using codes `EPSG:4326`, `CRS:84`, `urn:ogc:def:crs:EPSG:6.6:4326`,
 *    `urn:ogc:def:crs:OGC:1.3:CRS84`, `urn:ogc:def:crs:OGC:2:84`, `http://www.opengis.net/gml/srs/epsg.xml#4326`,
 *    or `urn:x-ogc:def:crs:EPSG:4326`
 *  * WGS 84 / Spherical Mercator - Using codes `EPSG:3857`, `EPSG:102100`, `EPSG:102113`, `EPSG:900913`,
 *    `urn:ogc:def:crs:EPSG:6.18:3:3857`, or `http://www.opengis.net/gml/srs/epsg.xml#3857`
 *  * WGS 84 / UTM zones - Using codes `EPSG:32601` through `EPSG:32660` for northern zones
 *    and `EPSG:32701` through `EPSG:32760` for southern zones. Note that the built-in UTM transforms
 *    are lower accuracy (with errors on the order of 0.1 m) than those that you might get in a
 *    library like [proj4js](https://github.com/proj4js/proj4js).
 *
 * For additional projection support, or to use higher accuracy transforms than the built-in ones, you can use
 * the [proj4js](https://github.com/proj4js/proj4js) library. With `proj4js`, after adding any new projection
 * definitions, call the {@link module:ol/proj/proj4.register} function.
 *
 * You can use the {@link module:ol/proj.get} function to retrieve a projection instance
 * for one of the registered projections.
 *
 * @api
 */
class Projection {
  /**
   * @param {Options} options Projection options.
   */
  constructor(options) {
    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;

    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */
    this.units_ = /** @type {import("./Units.js").Units} */ (options.units);

    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = options.extent !== undefined ? options.extent : null;

    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.worldExtent_ =
      options.worldExtent !== undefined ? options.worldExtent : null;

    /**
     * @private
     * @type {string}
     */
    this.axisOrientation_ =
      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

    /**
     * @private
     * @type {boolean}
     */
    this.global_ = options.global !== undefined ? options.global : false;

    /**
     * @private
     * @type {boolean}
     */
    this.canWrapX_ = !!(this.global_ && this.extent_);

    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */
    this.getPointResolutionFunc_ = options.getPointResolution;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.defaultTileGrid_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.metersPerUnit_ = options.metersPerUnit;
  }

  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }

  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }

  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }

  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }

  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[this.units_];
  }

  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }

  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }

  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }

  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  }

  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }

  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }

  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }

  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }

  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }

  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Projection);


/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),
/* harmony export */   fromCode: () => (/* binding */ fromCode)
/* harmony export */ });
/**
 * @module ol/proj/Units
 */

/**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */

/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */
const unitByCode = {
  '9001': 'm',
  '9002': 'ft',
  '9003': 'us-ft',
  '9101': 'radians',
  '9102': 'degrees',
};

/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */
function fromCode(code) {
  return unitByCode[code];
}

/**
 * @typedef {Object} MetersPerUnitLookup
 * @property {number} radians Radians
 * @property {number} degrees Degrees
 * @property {number} ft  Feet
 * @property {number} m Meters
 * @property {number} us-ft US feet
 */

/**
 * Meters per unit lookup table.
 * @const
 * @type {MetersPerUnitLookup}
 * @api
 */
const METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  'radians': 6370997 / (2 * Math.PI),
  'degrees': (2 * Math.PI * 6370997) / 360,
  'ft': 0.3048,
  'm': 1,
  'us-ft': 1200 / 3937,
};


/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTENT: () => (/* binding */ EXTENT),
/* harmony export */   HALF_SIZE: () => (/* binding */ HALF_SIZE),
/* harmony export */   MAX_SAFE_Y: () => (/* binding */ MAX_SAFE_Y),
/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),
/* harmony export */   RADIUS: () => (/* binding */ RADIUS),
/* harmony export */   WORLD_EXTENT: () => (/* binding */ WORLD_EXTENT),
/* harmony export */   fromEPSG4326: () => (/* binding */ fromEPSG4326),
/* harmony export */   toEPSG4326: () => (/* binding */ toEPSG4326)
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/**
 * @module ol/proj/epsg3857
 */


/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
const RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
const HALF_SIZE = Math.PI * RADIUS;

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
const WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */
const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
class EPSG3857Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} code Code.
   */
  constructor(code) {
    super({
      code: code,
      units: 'm',
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function (resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      },
    });
  }
}

/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
const PROJECTIONS = [
  new EPSG3857Projection('EPSG:3857'),
  new EPSG3857Projection('EPSG:102100'),
  new EPSG3857Projection('EPSG:102113'),
  new EPSG3857Projection('EPSG:900913'),
  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
];

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @param {number} [stride] Stride (default is `dimension`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = (HALF_SIZE * input[i]) / 180;
    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @param {number} [stride] Stride (default is `dimension`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = (180 * input[i]) / HALF_SIZE;
    output[i + 1] =
      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
  }
  return output;
}


/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTENT: () => (/* binding */ EXTENT),
/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),
/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),
/* harmony export */   RADIUS: () => (/* binding */ RADIUS)
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/**
 * @module ol/proj/epsg4326
 */


/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
const RADIUS = 6378137;

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
const EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
class EPSG4326Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(code, axisOrientation) {
    super({
      code: code,
      units: 'degrees',
      extent: EXTENT,
      axisOrientation: axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT,
    });
  }
}

/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
const PROJECTIONS = [
  new EPSG4326Projection('CRS:84'),
  new EPSG4326Projection('EPSG:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),
];


/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   get: () => (/* binding */ get)
/* harmony export */ });
/**
 * @module ol/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
let cache = {};

/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default|null} The projection (if cached).
 */
function get(code) {
  return (
    cache[code] ||
    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] ||
    null
  );
}

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}


/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   remove: () => (/* binding */ remove)
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/proj/transforms
 */


/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
let transforms = {};

/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  const transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|null} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    return transforms[sourceCode][destinationCode];
  }
  return null;
}


/***/ }),

/***/ "./node_modules/ol/proj/utm.js":
/*!*************************************!*\
  !*** ./node_modules/ol/proj/utm.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeProjection: () => (/* binding */ makeProjection),
/* harmony export */   makeTransforms: () => (/* binding */ makeTransforms),
/* harmony export */   zoneFromCode: () => (/* binding */ zoneFromCode)
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/proj/utm
 */

/**
 * Adapted from https://github.com/Turbo87/utm
 * Copyright (c) 2012-2017 Tobias Bieniek
 *
 * The functions here provide approximate transforms to and from UTM.
 * They are not appropriate for use beyond the validity extend of a UTM
 * zone, and the accuracy of the transform decreases toward the zone
 * edges.
 */




/**
 * @typedef {Object} UTMZone
 * @property {number} number The zone number (1 - 60).
 * @property {boolean} north The northern hemisphere.
 */

const K0 = 0.9996;

const E = 0.00669438;
const E2 = E * E;
const E3 = E2 * E;
const E_P2 = E / (1 - E);

const SQRT_E = Math.sqrt(1 - E);
const _E = (1 - SQRT_E) / (1 + SQRT_E);
const _E2 = _E * _E;
const _E3 = _E2 * _E;
const _E4 = _E3 * _E;
const _E5 = _E4 * _E;

const M1 = 1 - E / 4 - (3 * E2) / 64 - (5 * E3) / 256;
const M2 = (3 * E) / 8 + (3 * E2) / 32 + (45 * E3) / 1024;
const M3 = (15 * E2) / 256 + (45 * E3) / 1024;
const M4 = (35 * E3) / 3072;

const P2 = (3 / 2) * _E - (27 / 32) * _E3 + (269 / 512) * _E5;
const P3 = (21 / 16) * _E2 - (55 / 32) * _E4;
const P4 = (151 / 96) * _E3 - (417 / 128) * _E5;
const P5 = (1097 / 512) * _E4;

const R = 6378137;

/**
 * @param {number} easting Easting value of coordinate.
 * @param {number} northing Northing value of coordinate.
 * @param {UTMZone} zone The UTM zone.
 * @return {import("../coordinate.js").Coordinate} The transformed coordinate.
 */
function toLonLat(easting, northing, zone) {
  const x = easting - 500000;
  const y = zone.north ? northing : northing - 10000000;

  const m = y / K0;
  const mu = m / (R * M1);

  const pRad =
    mu +
    P2 * Math.sin(2 * mu) +
    P3 * Math.sin(4 * mu) +
    P4 * Math.sin(6 * mu) +
    P5 * Math.sin(8 * mu);

  const pSin = Math.sin(pRad);
  const pSin2 = pSin * pSin;

  const pCos = Math.cos(pRad);

  const pTan = pSin / pCos;
  const pTan2 = pTan * pTan;
  const pTan4 = pTan2 * pTan2;

  const epSin = 1 - E * pSin2;
  const epSinSqrt = Math.sqrt(1 - E * pSin2);

  const n = R / epSinSqrt;
  const r = (1 - E) / epSin;

  const c = E_P2 * pCos ** 2;
  const c2 = c * c;

  const d = x / (n * K0);
  const d2 = d * d;
  const d3 = d2 * d;
  const d4 = d3 * d;
  const d5 = d4 * d;
  const d6 = d5 * d;

  const latitude =
    pRad -
    (pTan / r) *
      (d2 / 2 - (d4 / 24) * (5 + 3 * pTan2 + 10 * c - 4 * c2 - 9 * E_P2)) +
    (d6 / 720) * (61 + 90 * pTan2 + 298 * c + 45 * pTan4 - 252 * E_P2 - 3 * c2);

  let longitude =
    (d -
      (d3 / 6) * (1 + 2 * pTan2 + c) +
      (d5 / 120) * (5 - 2 * c + 28 * pTan2 - 3 * c2 + 8 * E_P2 + 24 * pTan4)) /
    pCos;

  longitude = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(
    longitude + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(zoneToCentralLongitude(zone.number)),
    -Math.PI,
    Math.PI,
  );

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(longitude), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(latitude)];
}

const MIN_LATITUDE = -80;
const MAX_LATITUDE = 84;
const MIN_LONGITUDE = -180;
const MAX_LONGITUDE = 180;

/**
 * @param {number} longitude The longitude.
 * @param {number} latitude The latitude.
 * @param {UTMZone} zone The UTM zone.
 * @return {import('../coordinate.js').Coordinate} The UTM coordinate.
 */
function fromLonLat(longitude, latitude, zone) {
  longitude = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(longitude, MIN_LONGITUDE, MAX_LONGITUDE);

  if (latitude < MIN_LATITUDE) {
    latitude = MIN_LATITUDE;
  } else if (latitude > MAX_LATITUDE) {
    latitude = MAX_LATITUDE;
  }

  const latRad = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(latitude);
  const latSin = Math.sin(latRad);
  const latCos = Math.cos(latRad);

  const latTan = latSin / latCos;
  const latTan2 = latTan * latTan;
  const latTan4 = latTan2 * latTan2;

  const lonRad = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(longitude);
  const centralLon = zoneToCentralLongitude(zone.number);
  const centralLonRad = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(centralLon);

  const n = R / Math.sqrt(1 - E * latSin ** 2);
  const c = E_P2 * latCos ** 2;

  const a = latCos * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(lonRad - centralLonRad, -Math.PI, Math.PI);
  const a2 = a * a;
  const a3 = a2 * a;
  const a4 = a3 * a;
  const a5 = a4 * a;
  const a6 = a5 * a;

  const m =
    R *
    (M1 * latRad -
      M2 * Math.sin(2 * latRad) +
      M3 * Math.sin(4 * latRad) -
      M4 * Math.sin(6 * latRad));

  const easting =
    K0 *
      n *
      (a +
        (a3 / 6) * (1 - latTan2 + c) +
        (a5 / 120) * (5 - 18 * latTan2 + latTan4 + 72 * c - 58 * E_P2)) +
    500000;

  let northing =
    K0 *
    (m +
      n *
        latTan *
        (a2 / 2 +
          (a4 / 24) * (5 - latTan2 + 9 * c + 4 * c ** 2) +
          (a6 / 720) * (61 - 58 * latTan2 + latTan4 + 600 * c - 330 * E_P2)));

  if (!zone.north) {
    northing += 10000000;
  }

  return [easting, northing];
}

/**
 * @param {number} zone The zone number.
 * @return {number} The central longitude in degrees.
 */
function zoneToCentralLongitude(zone) {
  return (zone - 1) * 6 - 180 + 3;
}

/**
 * @type {Array<RegExp>}
 */
const epsgRegExes = [
  /^EPSG:(\d+)$/,
  /^urn:ogc:def:crs:EPSG::(\d+)$/,
  /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/,
];

/**
 * @param {string} code The projection code.
 * @return {UTMZone|null} The UTM zone info (or null if not UTM).
 */
function zoneFromCode(code) {
  let epsgId = 0;
  for (const re of epsgRegExes) {
    const match = code.match(re);
    if (match) {
      epsgId = parseInt(match[1]);
      break;
    }
  }
  if (!epsgId) {
    return null;
  }

  let number = 0;
  let north = false;
  if (epsgId > 32700 && epsgId < 32761) {
    number = epsgId - 32700;
  } else if (epsgId > 32600 && epsgId < 32661) {
    north = true;
    number = epsgId - 32600;
  }
  if (!number) {
    return null;
  }

  return {number, north};
}

/**
 * @param {function(number, number, UTMZone): import('../coordinate.js').Coordinate} transformer The transformer.
 * @param {UTMZone} zone The UTM zone.
 * @return {import('../proj.js').TransformFunction} The transform function.
 */
function makeTransformFunction(transformer, zone) {
  return function (input, output, dimension, stride) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    stride = stride ?? dimension;
    if (!output) {
      if (dimension > 2) {
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }
    for (let i = 0; i < length; i += stride) {
      const x = input[i];
      const y = input[i + 1];
      const coord = transformer(x, y, zone);
      output[i] = coord[0];
      output[i + 1] = coord[1];
    }
    return output;
  };
}

/**
 * @param {string} code The projection code.
 * @return {import('./Projection.js').default|null} A projection or null if unable to create one.
 */
function makeProjection(code) {
  const zone = zoneFromCode(code);
  if (!zone) {
    return null;
  }
  return new _Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]({code, units: 'm'});
}

/**
 * @param {import('./Projection.js').default} projection The projection.
 * @return {import('../proj.js').Transforms|null} The transforms lookup or null if unable to handle projection.
 */
function makeTransforms(projection) {
  const zone = zoneFromCode(projection.getCode());
  if (!zone) {
    return null;
  }

  return {
    forward: makeTransformFunction(fromLonLat, zone),
    inverse: makeTransformFunction(toLonLat, zone),
  };
}


/***/ }),

/***/ "./node_modules/ol/render/Box.js":
/*!***************************************!*\
  !*** ./node_modules/ol/render/Box.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/**
 * @module ol/render/Box
 */




class RenderBox extends _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();

    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */
    this.geometry_ = null;

    /**
     * @type {HTMLDivElement}
     * @private
     */
    this.element_ = document.createElement('div');
    this.element_.style.position = 'absolute';
    this.element_.style.pointerEvents = 'auto';
    this.element_.className = 'ol-box ' + className;

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    this.map_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.startPixel_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.endPixel_ = null;
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setMap(null);
  }

  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = 'px';
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }

  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = 'inherit';
      style.top = 'inherit';
      style.width = 'inherit';
      style.height = 'inherit';
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }

  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }

  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_) {
      return;
    }

    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]],
    ];
    const coordinates = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_,
    );
    // close the polygon
    coordinates[4] = coordinates[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__["default"]([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  }

  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RenderBox);


/***/ }),

/***/ "./node_modules/ol/render/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/Event.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/render/Event
 */



class RenderEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(type, inversePixelTransform, frameState, context) {
    super(type);

    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */
    this.inversePixelTransform = inversePixelTransform;

    /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */
    this.frameState = frameState;

    /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */
    this.context = context;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RenderEvent);


/***/ }),

/***/ "./node_modules/ol/render/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/render/EventType.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: 'prerender',

  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete',
});

/**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */

/**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */


/***/ }),

/***/ "./node_modules/ol/render/canvas.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/canvas.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkedFonts: () => (/* binding */ checkedFonts),
/* harmony export */   defaultFillStyle: () => (/* binding */ defaultFillStyle),
/* harmony export */   defaultFont: () => (/* binding */ defaultFont),
/* harmony export */   defaultLineCap: () => (/* binding */ defaultLineCap),
/* harmony export */   defaultLineDash: () => (/* binding */ defaultLineDash),
/* harmony export */   defaultLineDashOffset: () => (/* binding */ defaultLineDashOffset),
/* harmony export */   defaultLineJoin: () => (/* binding */ defaultLineJoin),
/* harmony export */   defaultLineWidth: () => (/* binding */ defaultLineWidth),
/* harmony export */   defaultMiterLimit: () => (/* binding */ defaultMiterLimit),
/* harmony export */   defaultPadding: () => (/* binding */ defaultPadding),
/* harmony export */   defaultStrokeStyle: () => (/* binding */ defaultStrokeStyle),
/* harmony export */   defaultTextAlign: () => (/* binding */ defaultTextAlign),
/* harmony export */   defaultTextBaseline: () => (/* binding */ defaultTextBaseline),
/* harmony export */   drawImageOrLabel: () => (/* binding */ drawImageOrLabel),
/* harmony export */   getTextDimensions: () => (/* binding */ getTextDimensions),
/* harmony export */   measureAndCacheTextWidth: () => (/* binding */ measureAndCacheTextWidth),
/* harmony export */   measureTextHeight: () => (/* binding */ measureTextHeight),
/* harmony export */   measureTextWidth: () => (/* binding */ measureTextWidth),
/* harmony export */   registerFont: () => (/* binding */ registerFont),
/* harmony export */   rotateAtOffset: () => (/* binding */ rotateAtOffset),
/* harmony export */   textHeights: () => (/* binding */ textHeights)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/**
 * @module ol/render/canvas
 */






/**
 * @typedef {'Circle' | 'Image' | 'LineString' | 'Polygon' | 'Text' | 'Default'} BuilderType
 */

/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle FillStyle.
 */

/**
 * @typedef Label
 * @property {number} width Width.
 * @property {number} height Height.
 * @property {Array<string|number>} contextInstructions ContextInstructions.
 */

/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle] Current FillStyle.
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle] Current StrokeStyle.
 * @property {CanvasLineCap} [currentLineCap] Current LineCap.
 * @property {Array<number>} currentLineDash Current LineDash.
 * @property {number} [currentLineDashOffset] Current LineDashOffset.
 * @property {CanvasLineJoin} [currentLineJoin] Current LineJoin.
 * @property {number} [currentLineWidth] Current LineWidth.
 * @property {number} [currentMiterLimit] Current MiterLimit.
 * @property {number} [lastStroke] Last stroke.
 * @property {import("../colorlike.js").ColorLike} [fillStyle] FillStyle.
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {CanvasLineCap} [lineCap] LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} [lineDashOffset] LineDashOffset.
 * @property {CanvasLineJoin} [lineJoin] LineJoin.
 * @property {number} [lineWidth] LineWidth.
 * @property {number} [miterLimit] MiterLimit.
 * @property {number} [fillPatternScale] Fill pattern scale.
 */

/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} lineWidth LineWidth.
 * @property {number} miterLimit MiterLimit.
 * @property {import("../colorlike.js").ColorLike} strokeStyle StrokeStyle.
 */

/**
 * @typedef {Object} TextState
 * @property {string} font Font.
 * @property {CanvasTextAlign} [textAlign] TextAlign.
 * @property {number} [repeat] Repeat.
 * @property {import("../style/Text.js").TextJustify} [justify] Justify.
 * @property {CanvasTextBaseline} textBaseline TextBaseline.
 * @property {import("../style/Text.js").TextPlacement} [placement] Placement.
 * @property {number} [maxAngle] MaxAngle.
 * @property {boolean} [overflow] Overflow.
 * @property {import("../style/Fill.js").default} [backgroundFill] BackgroundFill.
 * @property {import("../style/Stroke.js").default} [backgroundStroke] BackgroundStroke.
 * @property {import("../size.js").Size} [scale] Scale.
 * @property {Array<number>} [padding] Padding.
 */

/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */

/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */

/**
 * @const
 * @type {string}
 */
const defaultFont = '10px sans-serif';

/**
 * @const
 * @type {string}
 */
const defaultFillStyle = '#000';

/**
 * @const
 * @type {CanvasLineCap}
 */
const defaultLineCap = 'round';

/**
 * @const
 * @type {Array<number>}
 */
const defaultLineDash = [];

/**
 * @const
 * @type {number}
 */
const defaultLineDashOffset = 0;

/**
 * @const
 * @type {CanvasLineJoin}
 */
const defaultLineJoin = 'round';

/**
 * @const
 * @type {number}
 */
const defaultMiterLimit = 10;

/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */
const defaultStrokeStyle = '#000';

/**
 * @const
 * @type {CanvasTextAlign}
 */
const defaultTextAlign = 'center';

/**
 * @const
 * @type {CanvasTextBaseline}
 */
const defaultTextBaseline = 'middle';

/**
 * @const
 * @type {Array<number>}
 */
const defaultPadding = [0, 0, 0, 0];

/**
 * @const
 * @type {number}
 */
const defaultLineWidth = 1;

/**
 * @type {BaseObject}
 */
const checkedFonts = new _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

/**
 * @type {CanvasRenderingContext2D}
 */
let measureContext = null;

/**
 * @type {string}
 */
let measureFont;

/**
 * @type {!Object<string, number>}
 */
const textHeights = {};

/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
const registerFont = (function () {
  const retries = 100;
  const size = '32px ';
  const referenceFonts = ['monospace', 'serif'];
  const len = referenceFonts.length;
  const text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  let interval, referenceWidth;

  /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    let available = true;
    for (let i = 0; i < len; ++i) {
      const referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(
        fontStyle + ' ' + fontWeight + ' ' + size + referenceFont,
        text,
      );
      if (fontFamily != referenceFont) {
        const width = measureTextWidth(
          fontStyle +
            ' ' +
            fontWeight +
            ' ' +
            size +
            fontFamily +
            ',' +
            referenceFont,
          text,
        );
        // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }

  function check() {
    let done = true;
    const fonts = checkedFonts.getKeys();
    for (let i = 0, ii = fonts.length; i < ii; ++i) {
      const font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        const [style, weight, family] = font.split('\n');
        if (isAvailable(style, weight, family)) {
          (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.clear)(textHeights);
          // Make sure that loaded fonts are picked up by Safari
          measureContext = null;
          measureFont = undefined;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    const font = (0,_css_js__WEBPACK_IMPORTED_MODULE_2__.getFontParameters)(fontSpec);
    if (!font) {
      return;
    }
    const families = font.families;
    for (let i = 0, ii = families.length; i < ii; ++i) {
      const family = families[i];
      const key = font.style + '\n' + font.weight + '\n' + family;
      if (checkedFonts.get(key) === undefined) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
})();

/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */
const measureTextHeight = (function () {
  /**
   * @type {HTMLDivElement}
   */
  let measureElement;
  return function (fontSpec) {
    let height = textHeights[fontSpec];
    if (height == undefined) {
      if (_has_js__WEBPACK_IMPORTED_MODULE_3__.WORKER_OFFSCREEN_CANVAS) {
        const font = (0,_css_js__WEBPACK_IMPORTED_MODULE_2__.getFontParameters)(fontSpec);
        const metrics = measureText(fontSpec, 'Žg');
        const lineHeight = isNaN(Number(font.lineHeight))
          ? 1.2
          : Number(font.lineHeight);
        height =
          lineHeight *
          (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement('div');
          measureElement.innerHTML = 'M';
          measureElement.style.minHeight = '0';
          measureElement.style.maxHeight = 'none';
          measureElement.style.height = 'auto';
          measureElement.style.padding = '0';
          measureElement.style.border = 'none';
          measureElement.style.position = 'absolute';
          measureElement.style.display = 'block';
          measureElement.style.left = '-99999px';
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
})();

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */
function measureText(font, text) {
  if (!measureContext) {
    measureContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.createCanvasContext2D)(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}

/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */
function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }
  const width = text
    .split('\n')
    .reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache[text] = width;
  return width;
}

/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
    const text = chunks[i];
    if (text === '\n' || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      lineHeight = 0;
      continue;
    }
    const font = chunks[i + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return {width, height, widths, heights, lineWidths};
}

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}

/**
 * @param {CanvasRenderingContext2D|import("../render/canvas/ZIndexContext.js").ZIndexContextProxy} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */
function drawImageOrLabel(
  context,
  transform,
  opacity,
  labelOrImage,
  originX,
  originY,
  w,
  h,
  x,
  y,
  scale,
) {
  context.save();

  if (opacity !== 1) {
    if (context.globalAlpha === undefined) {
      context.globalAlpha = (context) => (context.globalAlpha *= opacity);
    } else {
      context.globalAlpha *= opacity;
    }
  }
  if (transform) {
    context.transform.apply(context, transform);
  }

  if (/** @type {*} */ (labelOrImage).contextInstructions) {
    // label
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    executeLabelInstructions(/** @type {Label} */ (labelOrImage), context);
  } else if (scale[0] < 0 || scale[1] < 0) {
    // flipped image
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (
        labelOrImage
      ),
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h,
    );
  } else {
    // if image not flipped translate and scale can be avoided
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (
        labelOrImage
      ),
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale[0],
      h * scale[1],
    );
  }

  context.restore();
}

/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(
        context,
        contextInstructions[i + 1],
      );
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}


/***/ }),

/***/ "./node_modules/ol/render/canvas/ZIndexContext.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/render/canvas/ZIndexContext.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/render/canvas/ZIndexContext
 */



/** @typedef {CanvasRenderingContext2D & {globalAlpha: any}} ZIndexContextProxy */

/**
 * @extends {CanvasRenderingContext2D}
 */
class ZIndexContext {
  constructor() {
    /**
     * @private
     * @type {Array<Array<*>>}
     */
    this.instructions_ = [];
    /**
     * @type {number}
     */
    this.zIndex = 0;
    /**
     * @private
     * @type {number}
     */
    this.offset_ = 0;

    /**
     * @private
     * @type {ZIndexContextProxy}
     */
    this.context_ = /** @type {ZIndexContextProxy} */ (
      new Proxy((0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.getSharedCanvasContext2D)(), {
        get: (target, property) => {
          if (
            typeof (/** @type {*} */ ((0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.getSharedCanvasContext2D)())[property]) !==
            'function'
          ) {
            // we only accept calling functions on the proxy, not accessing properties
            return undefined;
          }
          if (!this.instructions_[this.zIndex + this.offset_]) {
            this.instructions_[this.zIndex + this.offset_] = [];
          }
          this.instructions_[this.zIndex + this.offset_].push(property);
          return this.pushMethodArgs_;
        },
        set: (target, property, value) => {
          if (!this.instructions_[this.zIndex + this.offset_]) {
            this.instructions_[this.zIndex + this.offset_] = [];
          }
          this.instructions_[this.zIndex + this.offset_].push(property, value);
          return true;
        },
      })
    );
  }

  /**
   * @private
   * @param {...*} args Args.
   * @return {ZIndexContext} This.
   */
  pushMethodArgs_ = (...args) => {
    this.instructions_[this.zIndex + this.offset_].push(args);
    return this;
  };

  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(render) {
    this.instructions_[this.zIndex + this.offset_].push(render);
  }

  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(context) {
    this.instructions_.forEach((instructionsAtIndex) => {
      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {
        const property = instructionsAtIndex[i];
        if (typeof property === 'function') {
          property(context);
          continue;
        }
        const instructionAtIndex = instructionsAtIndex[++i];
        if (typeof (/** @type {*} */ (context)[property]) === 'function') {
          /** @type {*} */ (context)[property](...instructionAtIndex);
        } else {
          if (typeof instructionAtIndex === 'function') {
            /** @type {*} */ (context)[property] = instructionAtIndex(context);
            continue;
          }
          /** @type {*} */ (context)[property] = instructionAtIndex;
        }
      }
    });
  }

  clear() {
    this.instructions_.length = 0;
    this.zIndex = 0;
    this.offset_ = 0;
  }

  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length;
    this.zIndex = 0;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ZIndexContext);


/***/ }),

/***/ "./node_modules/ol/render/canvas/style.js":
/*!************************************************!*\
  !*** ./node_modules/ol/render/canvas/style.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildRuleSet: () => (/* binding */ buildRuleSet),
/* harmony export */   buildStyle: () => (/* binding */ buildStyle),
/* harmony export */   flatStylesToStyleFunction: () => (/* binding */ flatStylesToStyleFunction),
/* harmony export */   rulesToStyleFunction: () => (/* binding */ rulesToStyleFunction)
/* harmony export */ });
/* harmony import */ var _style_Circle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../style/Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _style_Fill_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../style/Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _style_Icon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../style/Icon.js */ "./node_modules/ol/style/Icon.js");
/* harmony import */ var _style_RegularShape_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../style/RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/* harmony import */ var _style_Stroke_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../style/Stroke.js */ "./node_modules/ol/style/Stroke.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _style_Text_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../style/Text.js */ "./node_modules/ol/style/Text.js");
/* harmony import */ var _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../expr/expression.js */ "./node_modules/ol/expr/expression.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../expr/cpu.js */ "./node_modules/ol/expr/cpu.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/render/canvas/style
 */














/**
 * @fileoverview This module includes functions to build styles for the canvas renderer.  Building
 * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression
 * and returns an instance of one of the expression classes.  The compiling step takes the
 * expression instance and returns a function that can be evaluated to return a literal value.  The
 * evaluator function should do as little allocation and work as possible.
 */

/**
 * @typedef {import("../../style/flat.js").FlatStyle} FlatStyle
 */

/**
 * @typedef {import("../../expr/expression.js").EncodedExpression} EncodedExpression
 */

/**
 * @typedef {import("../../expr/expression.js").ParsingContext} ParsingContext
 */

/**
 * @typedef {import("../../expr/expression.js").CallExpression} CallExpression
 */

/**
 * @typedef {import("../../expr/cpu.js").EvaluationContext} EvaluationContext
 */

/**
 * @typedef {import("../../expr/cpu.js").ExpressionEvaluator} ExpressionEvaluator
 */

/**
 * @param {EvaluationContext} context The evaluation context.
 * @return {boolean} Always true.
 */
function always(context) {
  return true;
}

/**
 * This function adapts a rule evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
function rulesToStyleFunction(rules) {
  const parsingContext = (0,_expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.newParsingContext)();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.newEvaluationContext)();
  return function (feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== undefined) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    if (parsingContext.geometryType) {
      evaluationContext.geometryType = (0,_expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.computeGeometryType)(
        feature.getGeometry(),
      );
    }
    return evaluator(evaluationContext);
  };
}

/**
 * This function adapts a style evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = (0,_expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.newParsingContext)();
  const length = flatStyles.length;

  /**
   * @type {Array<StyleEvaluator>}
   */
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.newEvaluationContext)();

  /**
   * @type {Array<Style>}
   */
  const styles = new Array(length);

  return function (feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== undefined) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i = 0; i < length; ++i) {
      const style = evaluators[i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}

/**
 * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator
 */

/**
 * @typedef {Object} CompiledRule
 * @property {ExpressionEvaluator} filter The compiled filter evaluator.
 * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.
 */

/**
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @param {ParsingContext} context The parsing context.
 * @return {RuleSetEvaluator} The evaluator function.
 */
function buildRuleSet(rules, context) {
  const length = rules.length;

  /**
   * @type {Array<CompiledRule>}
   */
  const compiledRules = new Array(length);

  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter =
      'filter' in rule
        ? (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(rule.filter, _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.BooleanType, context)
        : always;

    /**
     * @type {Array<StyleEvaluator>}
     */
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }

    compiledRules[i] = {filter, styles};
  }

  return function (context) {
    /**
     * @type {Array<Style>}
     */
    const styles = [];

    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }

    return styles;
  };
}

/**
 * @typedef {function(EvaluationContext):Style|null} StyleEvaluator
 */

/**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @param {ParsingContext} context The parsing context.
 * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by
 * this function will be reused between invocations.
 */
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, '', context);
  const evaluateStroke = buildStroke(flatStyle, '', context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);

  if (
    !evaluateFill &&
    !evaluateStroke &&
    !evaluateText &&
    !evaluateImage &&
    !(0,_obj_js__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(flatStyle)
  ) {
    // assume this is a user error
    // would be nice to check the properties and suggest "did you mean..."
    throw new Error(
      'No fill, stroke, point, or text symbolizer properties in style: ' +
        JSON.stringify(flatStyle),
    );
  }

  const style = new _style_Style_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
  return function (context) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}

/**
 * @typedef {function(EvaluationContext):Fill|null} FillEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {FillEvaluator?} A function that evaluates to a fill.
 */
function buildFill(flatStyle, prefix, context) {
  let evaluateColor;
  if (prefix + 'fill-pattern-src' in flatStyle) {
    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);
  } else {
    if (flatStyle[prefix + 'fill-color'] === 'none') {
      // avoids hit detection
      return (context) => null;
    }

    evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + 'fill-color',
      context,
    );
  }
  if (!evaluateColor) {
    return null;
  }

  const fill = new _style_Fill_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
  return function (context) {
    const color = evaluateColor(context);
    if (color === _color_js__WEBPACK_IMPORTED_MODULE_5__.NO_COLOR) {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}

/**
 * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {StrokeEvaluator?} A function the evaluates to a stroke.
 */
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + 'stroke-width',
    context,
  );

  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + 'stroke-color',
    context,
  );

  if (!evaluateWidth && !evaluateColor) {
    return null;
  }

  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + 'stroke-line-cap',
    context,
  );

  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + 'stroke-line-join',
    context,
  );

  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + 'stroke-line-dash',
    context,
  );

  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + 'stroke-line-dash-offset',
    context,
  );

  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + 'stroke-miter-limit',
    context,
  );

  const stroke = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_6__["default"]();
  return function (context) {
    if (evaluateColor) {
      const color = evaluateColor(context);
      if (color === _color_js__WEBPACK_IMPORTED_MODULE_5__.NO_COLOR) {
        return null;
      }
      stroke.setColor(color);
    }

    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context));
    }

    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context);
      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {
        throw new Error('Expected butt, round, or square line cap');
      }
      stroke.setLineCap(lineCap);
    }

    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context);
      if (
        lineJoin !== 'bevel' &&
        lineJoin !== 'round' &&
        lineJoin !== 'miter'
      ) {
        throw new Error('Expected bevel, round, or miter line join');
      }
      stroke.setLineJoin(lineJoin);
    }

    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context));
    }

    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context));
    }

    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context));
    }

    return stroke;
  };
}

/**
 * @typedef {function(EvaluationContext):Text} TextEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {TextEvaluator?} A function that evaluates to a text symbolizer.
 */
function buildText(flatStyle, context) {
  const prefix = 'text-';

  // Currently, an Array<string> may be used for rich text support.  This doesn't
  // work with our expression syntax where arrays of strings are interpreted as
  // call expressions.  To support rich text, we could add a 'strings' operator
  // where all the following arguments would be string values.
  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);
  if (!evaluateValue) {
    return null;
  }

  const evaluateFill = buildFill(flatStyle, prefix, context);

  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + 'background-',
    context,
  );

  const evaluateStroke = buildStroke(flatStyle, prefix, context);

  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + 'background-',
    context,
  );

  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);

  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + 'max-angle',
    context,
  );

  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + 'offset-x',
    context,
  );

  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + 'offset-y',
    context,
  );

  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + 'overflow',
    context,
  );

  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + 'placement',
    context,
  );

  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);

  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);

  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context,
  );

  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context,
  );

  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);

  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + 'justify',
    context,
  );

  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + 'baseline',
    context,
  );

  const evaluateKeepUpright = booleanEvaluator(
    flatStyle,
    prefix + 'keep-upright',
    context,
  );

  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + 'padding',
    context,
  );

  // The following properties are not currently settable
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + 'declutter-mode',
  );

  const text = new _style_Text_js__WEBPACK_IMPORTED_MODULE_7__["default"]({declutterMode});

  return function (context) {
    text.setText(evaluateValue(context));

    if (evaluateFill) {
      text.setFill(evaluateFill(context));
    }

    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context));
    }

    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context));
    }

    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context));
    }

    if (evaluateFont) {
      text.setFont(evaluateFont(context));
    }

    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context));
    }

    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context));
    }

    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context));
    }

    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context));
    }

    if (evaluatePlacement) {
      const placement = evaluatePlacement(context);
      if (placement !== 'point' && placement !== 'line') {
        throw new Error('Expected point or line for text-placement');
      }
      text.setPlacement(placement);
    }

    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context));
    }

    if (evaluateScale) {
      text.setScale(evaluateScale(context));
    }

    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context));
    }

    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context));
    }

    if (evaluateAlign) {
      const textAlign = evaluateAlign(context);
      if (
        textAlign !== 'left' &&
        textAlign !== 'center' &&
        textAlign !== 'right' &&
        textAlign !== 'end' &&
        textAlign !== 'start'
      ) {
        throw new Error(
          'Expected left, right, center, start, or end for text-align',
        );
      }
      text.setTextAlign(textAlign);
    }

    if (evaluateJustify) {
      const justify = evaluateJustify(context);
      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {
        throw new Error('Expected left, right, or center for text-justify');
      }
      text.setJustify(justify);
    }

    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context);
      if (
        textBaseline !== 'bottom' &&
        textBaseline !== 'top' &&
        textBaseline !== 'middle' &&
        textBaseline !== 'alphabetic' &&
        textBaseline !== 'hanging'
      ) {
        throw new Error(
          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline',
        );
      }
      text.setTextBaseline(textBaseline);
    }

    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context));
    }

    if (evaluateKeepUpright) {
      text.setKeepUpright(evaluateKeepUpright(context));
    }

    return text;
  };
}

/**
 * @typedef {function(EvaluationContext):import("../../style/Image.js").default} ImageEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.
 */
function buildImage(flatStyle, context) {
  if ('icon-src' in flatStyle) {
    return buildIcon(flatStyle, context);
  }

  if ('shape-points' in flatStyle) {
    return buildShape(flatStyle, context);
  }

  if ('circle-radius' in flatStyle) {
    return buildCircle(flatStyle, context);
  }

  return null;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an image symbolizer.
 */
function buildIcon(flatStyle, context) {
  const prefix = 'icon-';

  // required property
  const srcName = prefix + 'src';
  const src = requireString(flatStyle[srcName], srcName);

  // settable properties
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + 'anchor',
    context,
  );

  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);

  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + 'opacity',
    context,
  );

  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + 'displacement',
    context,
  );

  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context,
  );

  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context,
  );

  // the remaining symbolizer properties are not currently settable
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + 'anchor-x-units',
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + 'anchor-y-units',
  );
  const color = optionalColorLike(flatStyle, prefix + 'color');
  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');
  const offset = optionalNumberArray(flatStyle, prefix + 'offset');
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');
  const width = optionalNumber(flatStyle, prefix + 'width');
  const height = optionalNumber(flatStyle, prefix + 'height');
  const size = optionalSize(flatStyle, prefix + 'size');
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + 'declutter-mode',
  );

  const icon = new _style_Icon_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode,
  });

  return function (context) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context));
    }

    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context));
    }

    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context));
    }

    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context));
    }

    if (evaluateScale) {
      icon.setScale(evaluateScale(context));
    }

    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context));
    }
    return icon;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.
 */
function buildShape(flatStyle, context) {
  const prefix = 'shape-';

  // required property
  const pointsName = prefix + 'points';
  const radiusName = prefix + 'radius';
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const radius = requireNumber(flatStyle[radiusName], radiusName);

  // settable properties
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + 'displacement',
    context,
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context,
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context,
  );

  // the remaining properties are not currently settable
  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');
  const angle = optionalNumber(flatStyle, prefix + 'angle');
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + 'declutter-mode',
  );

  const shape = new _style_RegularShape_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
    points,
    radius,
    radius2,
    angle,
    declutterMode,
  });

  return function (context) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context));
    }

    return shape;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.
 */
function buildCircle(flatStyle, context) {
  const prefix = 'circle-';

  // settable properties
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + 'displacement',
    context,
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context,
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context,
  );

  // the remaining properties are not currently settable
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + 'declutter-mode',
  );

  const circle = new _style_Circle_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
    radius: 5, // this is arbitrary, but required - the evaluated radius is used below
    declutterMode,
  });

  return function (context) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context));
    }

    return circle;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.
 */
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return undefined;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberType, context);
  return function (context) {
    return requireNumber(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.
 */
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.StringType, context);
  return function (context) {
    return requireString(evaluator(context), name);
  };
}

function patternEvaluator(flatStyle, prefix, context) {
  const srcEvaluator = stringEvaluator(
    flatStyle,
    prefix + 'pattern-src',
    context,
  );
  const offsetEvaluator = sizeEvaluator(
    flatStyle,
    prefix + 'pattern-offset',
    context,
  );
  const patternSizeEvaluator = sizeEvaluator(
    flatStyle,
    prefix + 'pattern-size',
    context,
  );
  const colorEvaluator = colorLikeEvaluator(
    flatStyle,
    prefix + 'color',
    context,
  );
  return function (context) {
    return {
      src: srcEvaluator(context),
      offset: offsetEvaluator && offsetEvaluator(context),
      size: patternSizeEvaluator && patternSizeEvaluator(context),
      color: colorEvaluator && colorEvaluator(context),
    };
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.
 */
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.BooleanType, context);
  return function (context) {
    const value = evaluator(context);
    if (typeof value !== 'boolean') {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.
 */
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.ColorType, context);
  return function (context) {
    return requireColorLike(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.
 */
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberArrayType, context);
  return function (context) {
    return requireNumberArray(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.
 */
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberArrayType, context);
  return function (context) {
    const array = requireNumberArray(evaluator(context), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.
 */
function sizeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberArrayType, context);
  return function (context) {
    return requireSize(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.
 */
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(
    flatStyle[name],
    _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberArrayType | _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberType,
    context,
  );
  return function (context) {
    return requireSizeLike(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {number|undefined} A number or undefined.
 */
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === undefined) {
    return undefined;
  }
  if (typeof value !== 'number') {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../size.js").Size|undefined} A size or undefined.
 */
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded === 'number') {
    return (0,_size_js__WEBPACK_IMPORTED_MODULE_11__.toSize)(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (
    encoded.length !== 2 ||
    typeof encoded[0] !== 'number' ||
    typeof encoded[1] !== 'number'
  ) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|undefined} A string or undefined.
 */
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded !== 'string') {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconOrigin|undefined} An icon origin or undefined.
 */
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (
    encoded !== 'bottom-left' &&
    encoded !== 'bottom-right' &&
    encoded !== 'top-left' &&
    encoded !== 'top-right'
  ) {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`,
    );
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconAnchorUnits|undefined} Icon anchor units or undefined.
 */
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (encoded !== 'pixels' && encoded !== 'fraction') {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {Array<number>|undefined} An array of numbers or undefined.
 */
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  return requireNumberArray(encoded, property);
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.
 */
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded !== 'string') {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|Array<number>|undefined} A string or an array of color values or undefined.
 */
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  return requireColorLike(encoded, property);
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>} An array of numbers.
 */
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== 'number') {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {string} A string.
 */
function requireString(value, property) {
  if (typeof value !== 'string') {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number} A number.
 */
function requireNumber(value, property) {
  if (typeof value !== 'number') {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>|string} A color.
 */
function requireColorLike(value, property) {
  if (typeof value === 'string') {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>} A number or an array of two numbers.
 */
function requireSize(value, property) {
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number|Array<number>} A number or an array of two numbers.
 */
function requireSizeLike(value, property) {
  if (typeof value === 'number') {
    return value;
  }
  return requireSize(value, property);
}


/***/ }),

/***/ "./node_modules/ol/renderer/Composite.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/renderer/Composite.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../layer/BaseVector.js */ "./node_modules/ol/layer/BaseVector.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Map.js */ "./node_modules/ol/renderer/Map.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/renderer/Composite
 */











/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
class CompositeMapRenderer extends _Map_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);

    /**
     * @private
     * @type {import("../events.js").EventsKey}
     */
    this.fontChangeListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
      _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.checkedFonts,
      _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE,
      map.redrawText,
      map,
    );

    /**
     * @private
     * @type {HTMLDivElement}
     */
    this.element_ = document.createElement('div');
    const style = this.element_.style;
    style.position = 'absolute';
    style.width = '100%';
    style.height = '100%';
    style.zIndex = '0';

    this.element_.className = _css_js__WEBPACK_IMPORTED_MODULE_4__.CLASS_UNSELECTABLE + ' ol-layers';

    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);

    /**
     * @private
     * @type {Array<HTMLElement>}
     */
    this.children_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;
  }

  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, undefined, frameState);
      map.dispatchEvent(event);
    }
  }

  /**
   * @override
   */
  disposeInternal() {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.fontChangeListenerKey_);
    this.element_.remove();
    super.disposeInternal();
  }

  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE, frameState);

    const layerStatesArray = frameState.layerStatesArray.sort(
      (a, b) => a.zIndex - b.zIndex,
    );
    const declutter = layerStatesArray.some(
      (layerState) =>
        layerState.layer instanceof _layer_BaseVector_js__WEBPACK_IMPORTED_MODULE_7__["default"] &&
        layerState.layer.getDeclutter(),
    );
    if (declutter) {
      // Some layers need decluttering, turn on deferred rendering hint
      frameState.declutter = {};
    }
    const viewState = frameState.viewState;

    this.children_.length = 0;

    const renderedLayerStates = [];
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;

      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (
        !(0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_8__.inView)(layerState, viewState) ||
        (sourceState != 'ready' && sourceState != 'undefined')
      ) {
        layer.unrender();
        continue;
      }

      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }

      renderedLayerStates.push(layerState);
    }

    this.declutter(frameState, renderedLayerStates);

    (0,_dom_js__WEBPACK_IMPORTED_MODULE_9__.replaceChildren)(this.element_, this.children_);

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.element_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleExpireIconCache(frameState);
  }

  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(frameState, layerStates) {
    if (!frameState.declutter) {
      return;
    }
    for (let i = layerStates.length - 1; i >= 0; --i) {
      const layerState = layerStates[i];
      const layer = layerState.layer;
      if (layer.getDeclutter()) {
        layer.renderDeclutter(frameState, layerState);
      }
    }
    layerStates.forEach((layerState) =>
      layerState.layer.renderDeferred(frameState),
    );
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CompositeMapRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/renderer/Layer.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/renderer/Layer
 */





const maxStaleKeys = 5;

/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
class LayerRenderer extends _Observable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super();

    /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */
    this.ready = true;

    /** @private */
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);

    /**
     * @private
     * @type {LayerType}
     */
    this.layer_ = layer;

    /**
     * @type {Array<string>}
     * @private
     */
    this.staleKeys_ = new Array();

    /**
     * @type {number}
     * @protected
     */
    this.maxStaleKeys = maxStaleKeys;
  }

  /**
   * @return {Array<string>} Get the list of stale keys.
   */
  getStaleKeys() {
    return this.staleKeys_;
  }

  /**
   * @param {string} key The new stale key.
   */
  prependStaleKey(key) {
    this.staleKeys_.unshift(key);
    if (this.staleKeys_.length > this.maxStaleKeys) {
      this.staleKeys_.length = this.maxStaleKeys;
    }
  }

  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    return null;
  }

  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(frameState, target) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    callback,
    matches,
  ) {
    return undefined;
  }

  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }

  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {}

  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(event) {
    const image = /** @type {import("../Image.js").default} */ (event.target);
    if (
      image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
      image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR
    ) {
      this.renderIfReadyAndVisible();
    }
  }

  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(image) {
    let imageState = image.getState();
    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      image.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  }

  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {
      layer.changed();
    }
  }

  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(frameState) {}

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/Map.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/renderer/Map.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/**
 * @module ol/renderer/Map
 */









/**
 * @template T
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 */

/**
 * @abstract
 */
class MapRenderer extends _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();

    /**
     * @private
     * @type {import("../Map.js").default}
     */
    this.map_ = map;
  }

  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1],
    );

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
  }

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    checkWrapped,
    callback,
    thisArg,
    layerFilter,
    thisArg2,
  ) {
    let result;
    const viewState = frameState.viewState;

    /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }

    const projection = viewState.projection;

    const translatedCoordinate = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.wrapX)(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getWidth)(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }

    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;

    const matches = /** @type {Array<HitMatch<T>>} */ ([]);
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (
          layer.hasRenderer() &&
          (0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_5__.inView)(layerState, viewState) &&
          layerFilter.call(thisArg2, layer)
        ) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates = source.getWrapX()
              ? translatedCoordinate
              : coordinate;
            const callback = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed,
            );
            tmpCoord[0] = coordinates[0] + offsets[i][0];
            tmpCoord[1] = coordinates[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback,
              matches,
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return undefined;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => (m.distanceSq += i * order));
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return (result = m.callback(m.feature, m.layer, m.geometry));
    });
    return result;
  }

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    checkWrapped,
    layerFilter,
    thisArg,
  ) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      _functions_js__WEBPACK_IMPORTED_MODULE_6__.TRUE,
      this,
      layerFilter,
      thisArg,
    );

    return hasFeature !== undefined;
  }

  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }

  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (_style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__.shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
}

/**
 * @param {import("../Map.js").default} map Map.
 * @param {import("../Map.js").FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
  _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__.shared.expire();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Layer.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Layer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canvasPool: () => (/* binding */ canvasPool),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Layer.js */ "./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_ZIndexContext_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/canvas/ZIndexContext.js */ "./node_modules/ol/render/canvas/ZIndexContext.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/renderer/canvas/Layer
 */










/**
 * @type {Array<HTMLCanvasElement>}
 */
const canvasPool = [];

/**
 * @type {CanvasRenderingContext2D}
 */
let pixelContext = null;

function createPixelContext() {
  pixelContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(1, 1, undefined, {
    willReadFrequently: true,
  });
}

/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
class CanvasLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super(layer);

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.container = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedResolution;

    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.tempTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.pixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.inversePixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * @type {CanvasRenderingContext2D}
     */
    this.context = null;

    /**
     * @private
     * @type {ZIndexContext}
     */
    this.deferredContext_ = null;

    /**
     * @type {boolean}
     */
    this.containerReused = false;

    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */
    this.frameState = null;
  }

  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);

    let data;
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      pixelContext = null;
      return null;
    }
    return data;
  }

  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === 'function') {
      background = background(frameState.viewState.resolution);
    }
    return background || undefined;
  }

  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(target, transform, backgroundColor) {
    const layerClassName = this.getLayer().getClassName();
    let container, context;
    if (
      target &&
      target.className === layerClassName &&
      (!backgroundColor ||
        (target &&
          target.style.backgroundColor &&
          (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.equals)(
            (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(target.style.backgroundColor),
            (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(backgroundColor),
          )))
    ) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext('2d');
      }
    }
    if (context && context.canvas.style.transform === transform) {
      // Container of the previous layer renderer can be used.
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      // Previously reused container cannot be used any more.
      this.container = null;
      this.context = null;
      this.containerReused = false;
    } else if (this.container) {
      this.container.style.backgroundColor = null;
    }
    if (!this.container) {
      container = document.createElement('div');
      container.className = layerClassName;
      let style = container.style;
      style.position = 'absolute';
      style.width = '100%';
      style.height = '100%';
      context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)();
      const canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = 'absolute';
      style.left = '0';
      style.transformOrigin = 'top left';
      this.container = container;
      this.context = context;
    }
    if (
      !this.containerReused &&
      backgroundColor &&
      !this.container.style.backgroundColor
    ) {
      this.container.style.backgroundColor = backgroundColor;
    }
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(context, frameState, extent) {
    const topLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getTopLeft)(extent);
    const topRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getTopRight)(extent);
    const bottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getBottomRight)(extent);
    const bottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getBottomLeft)(extent);

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, bottomLeft);

    const inverted = this.inversePixelTransform;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, bottomLeft);

    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  }

  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(frameState, target) {
    const extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const width = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getWidth)(extent) / resolution) * pixelRatio);
    const height = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getHeight)(extent) / resolution) * pixelRatio);
    // set forward and inverse pixel transforms
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2,
    );
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.makeInverse)(this.inversePixelTransform, this.pixelTransform);

    const canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.toString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));

    if (!this.containerReused) {
      const canvas = this.context.canvas;
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      } else {
        this.context.clearRect(0, 0, width, height);
      }
      if (canvasTransform !== canvas.style.transform) {
        canvas.style.transform = canvasTransform;
      }
    }
  }

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        type,
        this.inversePixelTransform,
        frameState,
        context,
      );
      layer.dispatchEvent(event);
    }
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(context, frameState) {
    this.frameState = frameState;
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRERENDER, context, frameState);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(context, frameState) {
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, context, frameState);
  }

  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(frameState) {}

  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(frameState) {
    if (frameState.declutter && !this.deferredContext_) {
      this.deferredContext_ = new _render_canvas_ZIndexContext_js__WEBPACK_IMPORTED_MODULE_8__["default"]();
    }
    return frameState.declutter
      ? this.deferredContext_.getContext()
      : this.context;
  }

  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(frameState) {
    if (!frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(
      _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRERENDER,
      this.context,
      frameState,
    );
    if (frameState.declutter && this.deferredContext_) {
      this.deferredContext_.draw(this.context);
      this.deferredContext_.clear();
    }
    this.renderDeferredInternal(frameState);
    this.dispatchRenderEvent_(
      _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER,
      this.context,
      frameState,
    );
  }

  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(
    center,
    resolution,
    rotation,
    pixelRatio,
    width,
    height,
    offsetX,
  ) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
      this.tempTransform,
      dx1,
      dy1,
      sx,
      sy,
      -rotation,
      dx2,
      dy2,
    );
  }

  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/TileLayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/TileLayer.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _DataTile_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../DataTile.js */ "./node_modules/ol/DataTile.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _reproj_DataTile_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../reproj/DataTile.js */ "./node_modules/ol/reproj/DataTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/renderer/canvas/TileLayer
 */
















/**
 * @param {string} sourceKey The source key.
 * @param {number} z The tile z level.
 * @param {number} x The tile x level.
 * @param {number} y The tile y level.
 * @return {string} The cache key.
 */
function getCacheKey(sourceKey, z, x, y) {
  return `${sourceKey},${(0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.getKeyZXY)(z, x, y)}`;
}

/**
 * @typedef {Object<number, Set<import("../../Tile.js").default>>} TileLookup
 */

/**
 * Add a tile to the lookup.
 * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
 * @param {import("../../Tile.js").default} tile A tile.
 * @param {number} z The zoom level.
 * @return {boolean} The tile was added to the lookup.
 */
function addTileToLookup(tilesByZ, tile, z) {
  if (!(z in tilesByZ)) {
    tilesByZ[z] = new Set([tile]);
    return true;
  }
  const set = tilesByZ[z];
  const existing = set.has(tile);
  if (!existing) {
    set.add(tile);
  }
  return !existing;
}

/**
 * Remove a tile from the lookup.
 * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
 * @param {import("../../Tile.js").default} tile A tile.
 * @param {number} z The zoom level.
 * @return {boolean} The tile was removed from the lookup.
 */
function removeTileFromLookup(tilesByZ, tile, z) {
  const set = tilesByZ[z];
  if (set) {
    return set.delete(tile);
  }
  return false;
}

/**
 * @param {import("../../Map.js").FrameState} frameState Frame state.
 * @param {import("../../extent.js").Extent} extent The frame extent.
 * @return {import("../../extent.js").Extent} Frame extent intersected with layer extents.
 */
function getRenderExtent(frameState, extent) {
  const layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(
      extent,
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, frameState.viewState.projection),
    );
  }
  const source = /** @type {import("../../source/Tile.js").default} */ (
    layerState.layer.getRenderSource()
  );
  if (!source.getWrapX()) {
    const gridExtent = source
      .getTileGridForProjection(frameState.viewState.projection)
      .getExtent();
    if (gridExtent) {
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(extent, gridExtent);
    }
  }
  return extent;
}

/**
 * @typedef {Object} Options
 * @property {number} [cacheSize=512] The cache size.
 */

/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */
class CanvasTileLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} [options] Options.
   */
  constructor(tileLayer, options) {
    super(tileLayer);

    options = options || {};

    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */
    this.extentChanged = true;

    /**
     * The last call to `renderFrame` was completed with all tiles loaded
     * @type {boolean}
     */
    this.renderComplete = false;

    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */
    this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedPixelRatio;

    /**
     * @protected
     * @type {import("../../proj/Projection.js").default|null}
     */
    this.renderedProjection = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedRevision;

    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    this.renderedTiles = [];

    /**
     * @private
     * @type {string}
     */
    this.renderedSourceKey_;

    /**
     * @private
     * @type {number}
     */
    this.renderedSourceRevision_;

    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    this.tempExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    this.tempTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_4__["default"](0, 0, 0, 0);

    /**
     * @type {import("../../tilecoord.js").TileCoord}
     * @private
     */
    this.tempTileCoord_ = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(0, 0, 0);

    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;

    /**
     * @type {import("../../structs/LRUCache.js").default<import("../../Tile.js").default>}
     * @private
     */
    this.tileCache_ = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_5__["default"](cacheSize);

    this.maxStaleKeys = cacheSize * 0.5;
  }

  /**
   * @return {LRUCache} Tile cache.
   */
  getTileCache() {
    return this.tileCache_;
  }

  /**
   * Get a tile from the cache or create one if needed.
   *
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getOrCreateTile(z, x, y, frameState) {
    const tileCache = this.tileCache_;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);

    /** @type {import("../../Tile.js").default} */
    let tile;

    if (tileCache.containsKey(cacheKey)) {
      tile = tileCache.get(cacheKey);
    } else {
      tile = tileSource.getTile(
        z,
        x,
        y,
        frameState.pixelRatio,
        frameState.viewState.projection,
      );
      if (!tile) {
        return null;
      }
      tileCache.set(cacheKey, tile);
    }
    return tile;
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getTile(z, x, y, frameState) {
    const tile = this.getOrCreateTile(z, x, y, frameState);
    if (!tile) {
      return null;
    }
    return tile;
  }

  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }

    const layer = this.getLayer();
    const coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_6__.apply)(
      frameState.pixelToCoordinateTransform,
      pixel.slice(),
    );

    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(layerExtent, coordinate)) {
        return null;
      }
    }

    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);

    for (
      let z = tileGrid.getZForResolution(viewState.resolution);
      z >= tileGrid.getMinZoom();
      --z
    ) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);
      if (!tile || tile.getState() !== _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADED) {
        continue;
      }

      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_8__.toSize)(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);

      /**
       * @type {import('../../DataTile.js').ImageLike}
       */
      let image;
      if (tile instanceof _ImageTile_js__WEBPACK_IMPORTED_MODULE_9__["default"] || tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
        image = tile.getImage();
      } else if (tile instanceof _DataTile_js__WEBPACK_IMPORTED_MODULE_11__["default"]) {
        image = (0,_DataTile_js__WEBPACK_IMPORTED_MODULE_11__.asImageLike)(tile.getData());
        if (!image) {
          continue;
        }
      } else {
        continue;
      }

      const col = Math.floor(
        tilePixelRatio *
          ((coordinate[0] - tileOrigin[0]) / tileResolution -
            tileCoord[1] * tileSize[0]),
      );

      const row = Math.floor(
        tilePixelRatio *
          ((tileOrigin[1] - coordinate[1]) / tileResolution -
            tileCoord[2] * tileSize[1]),
      );

      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection),
      );

      return this.getImageData(image, col + gutter, row + gutter);
    }

    return null;
  }

  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(frameState) {
    if (!this.renderedProjection) {
      this.renderedProjection = frameState.viewState.projection;
    } else if (frameState.viewState.projection !== this.renderedProjection) {
      this.tileCache_.clear();
      this.renderedProjection = frameState.viewState.projection;
    }

    const source = this.getLayer().getSource();
    if (!source) {
      return false;
    }
    const sourceRevision = source.getRevision();
    if (!this.renderedRevision_) {
      this.renderedRevision_ = sourceRevision;
    } else if (this.renderedRevision_ !== sourceRevision) {
      this.renderedRevision_ = sourceRevision;
      if (this.renderedSourceKey_ === source.getKey()) {
        this.tileCache_.clear();
      }
    }
    return true;
  }

  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {
    const viewState = frameState.viewState;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getRenderSource();
    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);

    const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }

    const wantedTiles = frameState.wantedTiles[tileSourceKey];

    const map = tileLayer.getMapInternal();
    const minZ = Math.max(
      initialZ - preload,
      tileGrid.getMinZoom(),
      tileGrid.getZForResolution(
        Math.min(
          tileLayer.getMaxResolution(),
          map
            ? map
                .getView()
                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))
            : tileGrid.getResolution(0),
        ),
        tileSource.zDirection,
      ),
    );
    for (let z = initialZ; z >= minZ; --z) {
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        extent,
        z,
        this.tempTileRange_,
      );

      const tileResolution = tileGrid.getResolution(z);

      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
          const tile = this.getTile(z, x, y, frameState);
          if (!tile) {
            continue;
          }
          const added = addTileToLookup(tilesByZ, tile, z);
          if (!added) {
            continue;
          }

          const tileQueueKey = tile.getKey();
          wantedTiles[tileQueueKey] = true;

          if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              const tileCoord = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(z, x, y, this.tempTileCoord_);
              frameState.tileQueue.enqueue([
                tile,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution,
              ]);
            }
          }
        }
      }
    }
  }

  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findStaleTile_(tileCoord, tilesByZ) {
    const tileCache = this.tileCache_;
    const z = tileCoord[0];
    const x = tileCoord[1];
    const y = tileCoord[2];
    const staleKeys = this.getStaleKeys();
    for (let i = 0; i < staleKeys.length; ++i) {
      const cacheKey = getCacheKey(staleKeys[i], z, x, y);
      if (tileCache.containsKey(cacheKey)) {
        const tile = tileCache.get(cacheKey);
        if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADED) {
          tile.endTransition((0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(this));
          addTileToLookup(tilesByZ, tile, z);
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {
    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(
      tileCoord,
      altZ,
      this.tempTileRange_,
    );

    if (!tileRange) {
      return false;
    }

    let covered = true;
    const tileCache = this.tileCache_;
    const source = this.getLayer().getRenderSource();
    const sourceKey = source.getKey();
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        const cacheKey = getCacheKey(sourceKey, altZ, x, y);
        let loaded = false;
        if (tileCache.containsKey(cacheKey)) {
          const tile = tileCache.get(cacheKey);
          if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADED) {
            addTileToLookup(tilesByZ, tile, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }

  /**
   * Render the layer.
   *
   * The frame rendering logic has three parts:
   *
   *  1. Enqueue tiles
   *  2. Find alt tiles for those that are not yet loaded
   *  3. Render loaded tiles
   *
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(frameState, target) {
    let allTilesIdle = true;
    this.renderComplete = true;

    /**
     * TODO:
     *  * maybe skip transition when not fully opaque
     *  * decide if this.renderComplete is useful
     */

    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const pixelRatio = frameState.pixelRatio;

    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);

    const sourceKey = tileSource.getKey();
    if (!this.renderedSourceKey_) {
      this.renderedSourceKey_ = sourceKey;
    } else if (this.renderedSourceKey_ !== sourceKey) {
      this.prependStaleKey(this.renderedSourceKey_);
      this.renderedSourceKey_ = sourceKey;
    }

    let frameExtent = frameState.extent;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

    this.prepareContainer(frameState, target);

    // desired dimensions of the canvas in pixels
    const width = this.context.canvas.width;
    const height = this.context.canvas.height;

    const layerExtent =
      layerState.extent && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection);
    if (layerExtent) {
      frameExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(
        frameExtent,
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection),
      );
    }

    const dx = (tileResolution * width) / 2 / tilePixelRatio;
    const dy = (tileResolution * height) / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy,
    ];

    /**
     * @type {TileLookup}
     */
    const tilesByZ = {};

    this.renderedTiles.length = 0;

    /**
     * Part 1: Enqueue tiles
     */

    const preload = tileLayer.getPreload();
    if (frameState.nextExtent) {
      const targetZ = tileGrid.getZForResolution(
        viewState.nextResolution,
        tileSource.zDirection,
      );
      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);
    }

    const renderExtent = getRenderExtent(frameState, frameExtent);
    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);
    if (preload > 0) {
      setTimeout(() => {
        this.enqueueTiles(
          frameState,
          renderExtent,
          z - 1,
          tilesByZ,
          preload - 1,
        );
      }, 0);
    }

    if (!(z in tilesByZ)) {
      return this.container;
    }

    /**
     * Part 2: Find alt tiles for those that are not yet loaded
     */

    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(this);
    const time = frameState.time;

    // look for cached tiles to use if a target tile is not ready
    for (const tile of tilesByZ[z]) {
      const tileState = tile.getState();
      if (
        (tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_10__["default"] || tile instanceof _reproj_DataTile_js__WEBPACK_IMPORTED_MODULE_13__["default"]) &&
        tileState === _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].EMPTY
      ) {
        continue;
      }
      const tileCoord = tile.tileCoord;

      if (tileState === _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADED) {
        const alpha = tile.getAlpha(uid, time);
        if (alpha === 1) {
          // no need to look for alt tiles
          tile.endTransition(uid);
          continue;
        }
      }
      if (tileState !== _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].IDLE) {
        allTilesIdle = false;
      }
      if (tileState !== _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].ERROR) {
        this.renderComplete = false;
      }

      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);
      if (hasStaleTile) {
        // use the stale tile before the new tile's transition has completed
        removeTileFromLookup(tilesByZ, tile, z);
        frameState.animate = true;
        continue;
      }

      // first look for child tiles (at z + 1)
      const coveredByChildren = this.findAltTiles_(
        tileGrid,
        tileCoord,
        z + 1,
        tilesByZ,
      );

      if (coveredByChildren) {
        continue;
      }

      // next look for parent tiles
      const minZoom = tileGrid.getMinZoom();
      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {
        const coveredByParent = this.findAltTiles_(
          tileGrid,
          tileCoord,
          parentZ,
          tilesByZ,
        );

        if (coveredByParent) {
          break;
        }
      }
    }

    /**
     * Part 3: Render loaded tiles
     */

    const canvasScale =
      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;

    const context = this.getRenderContext(frameState);

    // set scale transform for calculating tile positions on the canvas
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_6__.compose)(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2,
    );

    if (layerState.extent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }

    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }

    this.preRender(context, frameState);

    /** @type {Array<number>} */
    const zs = Object.keys(tilesByZ).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_14__.ascending);

    let currentClip;
    const clips = [];
    const clipZs = [];
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection,
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(canvasExtent),
        currentZ,
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = (0,_transform_js__WEBPACK_IMPORTED_MODULE_6__.apply)(this.tempTransform, [
        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /
          tileResolution,
        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /
          tileResolution,
      ]);
      const tileGutter =
        tilePixelRatio * tileSource.getGutterForProjection(projection);
      for (const tile of tilesByZ[currentZ]) {
        if (tile.getState() !== _TileState_js__WEBPACK_IMPORTED_MODULE_7__["default"].LOADED) {
          continue;
        }
        const tileCoord = tile.tileCoord;

        // Calculate integer positions and sizes so that tiles align
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);
        const x = Math.round(origin[0] - xIndex * dx);
        const y = Math.round(origin[1] - yIndex * dy);
        const w = nextX - x;
        const h = nextY - y;
        const transition = zs.length === 1;

        let contextSaved = false;

        // Clip mask for regions in this tile that already filled by a higher z tile
        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
        for (let i = 0, ii = clips.length; i < ii; ++i) {
          if (!transition && currentZ < clipZs[i]) {
            const clip = clips[i];
            if (
              (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(
                [x, y, x + w, y + h],
                [clip[0], clip[3], clip[4], clip[7]],
              )
            ) {
              if (!contextSaved) {
                context.save();
                contextSaved = true;
              }
              context.beginPath();
              // counter-clockwise (outer ring) for current tile
              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]);
              // clockwise (inner ring) for higher z tile
              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
        }
        clips.push(currentClip);
        clipZs.push(currentZ);

        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);
        if (contextSaved) {
          context.restore();
        }
        this.renderedTiles.unshift(tile);

        // TODO: decide if this is necessary
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged =
      !this.renderedExtent_ || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.equals)(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;

    this.postRender(this.context, frameState);

    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;

    if (this.renderComplete) {
      /**
       * @param {import("../../Map.js").default} map Map.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      const postRenderFunction = (map, frameState) => {
        const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(tileSource);
        const wantedTiles = frameState.wantedTiles[tileSourceKey];
        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;
        this.updateCacheSize(tilesCount);
        this.tileCache_.expireCache();
      };

      frameState.postRenderFunctions.push(postRenderFunction);
    }
    if (!this.renderComplete && !allTilesIdle) {
      frameState.animate = true;
    }

    return this.container;
  }

  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   */
  updateCacheSize(tileCount) {
    this.tileCache_.highWaterMark = Math.max(
      this.tileCache_.highWaterMark,
      tileCount * 2,
    );
  }

  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @protected
   */
  drawTile(tile, frameState, x, y, w, h, gutter, transition) {
    let image;
    if (tile instanceof _DataTile_js__WEBPACK_IMPORTED_MODULE_11__["default"]) {
      image = (0,_DataTile_js__WEBPACK_IMPORTED_MODULE_11__.asImageLike)(tile.getData());
      if (!image) {
        throw new Error('Rendering array data is not yet supported');
      }
    } else {
      image = this.getTileImage(
        /** @type {import("../../ImageTile.js").default} */ (tile),
      );
    }
    if (!image) {
      return;
    }
    const context = this.getRenderContext(frameState);
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha =
      layerState.opacity *
      (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== context.globalAlpha;
    if (alphaChanged) {
      context.save();
      context.globalAlpha = alpha;
    }
    context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h,
    );

    if (alphaChanged) {
      context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }

  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }

  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile) {
    return tile.getImage();
  }

  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile) {
    // FIXME should we use tilesToDrawByZ instead?
    const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.getUid)(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasTileLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateSourceExtentResolution: () => (/* binding */ calculateSourceExtentResolution),
/* harmony export */   calculateSourceResolution: () => (/* binding */ calculateSourceResolution),
/* harmony export */   canvasPool: () => (/* binding */ canvasPool),
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/reproj
 */





let brokenDiagonalRendering_;

/**
 * @type {Array<HTMLCanvasElement>}
 */
const canvasPool = [];

/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}

/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */
function verifyBrokenDiagonalRendering(data, offset) {
  // the values ought to be close to the rgba(210, 0, 0, 0.75)
  return (
    Math.abs(data[offset * 4] - 210) > 2 ||
    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2
  );
}

/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === undefined) {
    const ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(6, 6, canvasPool);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ =
      verifyBrokenDiagonalRendering(data, 0) ||
      verifyBrokenDiagonalRendering(data, 4) ||
      verifyBrokenDiagonalRendering(data, 8);
    (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.releaseCanvas)(ctx);
    canvasPool.push(ctx.canvas);
  }

  return brokenDiagonalRendering_;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(
  sourceProj,
  targetProj,
  targetCenter,
  targetResolution,
) {
  const sourceCenter = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform)(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  let sourceResolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(
    targetProj,
    targetResolution,
    targetCenter,
  );

  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(sourceExtent, sourceCenter)) {
    const compensationFactor =
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(sourceProj, sourceResolution, sourceCenter) /
      sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceExtentResolution(
  sourceProj,
  targetProj,
  targetExtent,
  targetResolution,
) {
  const targetCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution,
  );

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.forEachCorner)(targetExtent, function (corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution,
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }

  return sourceResolution;
}

/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {import("./extent.js").Extent} [clipExtent] Clip extent.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.
 * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(
  width,
  height,
  pixelRatio,
  sourceResolution,
  sourceExtent,
  targetResolution,
  targetExtent,
  triangulation,
  sources,
  gutter,
  renderEdges,
  interpolate,
  drawSingle,
  clipExtent,
) {
  const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool,
  );

  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }

  context.globalCompositeOperation = 'lighter';

  const sourceDataExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.extend)(sourceDataExtent, src.extent);
  });

  let stitchContext;
  const stitchScale = pixelRatio / sourceResolution;
  // Round up Float32 scale values to prevent interpolation in Firefox.
  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;

  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
      Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(sourceDataExtent) * stitchScale),
      Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(sourceDataExtent) * stitchScale),
      canvasPool,
    );

    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    if (sourceExtent && clipExtent) {
      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;
      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;
      const width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(sourceExtent) * stitchScale;
      const height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(sourceExtent) * stitchScale;
      stitchContext.rect(xPos, yPos, width, height);
      stitchContext.clip();
    }

    sources.forEach(function (src, i, arr) {
      // This test should never fail -- but it does. Need to find a fix the upstream condition
      if (src.image.width > 0 && src.image.height > 0) {
        if (src.clipExtent) {
          stitchContext.save();
          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          const width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(src.clipExtent) * stitchScale;
          const height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(src.clipExtent) * stitchScale;
          stitchContext.rect(
            interpolate ? xPos : Math.round(xPos),
            interpolate ? yPos : Math.round(yPos),
            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),
            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),
          );
          stitchContext.clip();
        }

        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        const srcWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(src.extent) * stitchScale;
        const srcHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(src.extent) * stitchScale;
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate
            ? srcWidth
            : Math.round(xPos + srcWidth) - Math.round(xPos),
          interpolate
            ? srcHeight
            : Math.round(yPos + srcHeight) - Math.round(yPos),
        );

        if (src.clipExtent) {
          stitchContext.restore();
        }
      }
    });
  }
  const targetTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0],
      y0 = source[0][1];
    let x1 = source[1][0],
      y1 = source[1][1];
    let x2 = source[2][0],
      y2 = source[2][1];
    // Make sure that everything is on pixel boundaries
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution,
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution,
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution,
    );

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0],
    ];
    const affineCoefs = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.solveLinearSystem)(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();

    if (isBrokenDiagonalRendering() || !interpolate) {
      // Make sure that all lines are horizontal or vertical
      context.moveTo(u1, v1);
      // This is the diagonal line. Do it in 4 steps
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        // Go horizontally
        context.lineTo(
          u1 + pixelRound(((step + 1) * ud) / steps),
          v1 + pixelRound((step * vd) / (steps - 1)),
        );
        // Go vertically
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound(((step + 1) * ud) / steps),
            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),
          );
        }
      }
      // We are almost at u0r, v0r
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }

    context.clip();

    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0,
    );

    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY,
    );

    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(inverseScale, -inverseScale);
    } else {
      const source = sources[0];
      const extent = source.extent;
      image = source.image;
      context.scale(
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(extent) / image.width,
        -(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(extent) / image.height,
      );
    }

    context.drawImage(image, 0, 0);
    context.restore();
  });

  if (stitchContext) {
    (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.releaseCanvas)(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }

  if (renderEdges) {
    context.save();

    context.globalCompositeOperation = 'source-over';
    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}


/***/ }),

/***/ "./node_modules/ol/reproj/DataTile.js":
/*!********************************************!*\
  !*** ./node_modules/ol/reproj/DataTile.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _DataTile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DataTile.js */ "./node_modules/ol/DataTile.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _glreproj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./glreproj.js */ "./node_modules/ol/reproj/glreproj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/reproj/DataTile
 */













/**
 * @typedef {function(number, number, number, number) : import("../DataTile.js").default} TileGetter
 */

/**
 * @typedef {Object} TileOffset
 * @property {DataTile} tile Tile.
 * @property {number} offset Offset.
 */

/**
 * @typedef {Object} Options
 * @property {import("../proj/Projection.js").default} sourceProj Source projection.
 * @property {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
 * @property {import("../proj/Projection.js").default} targetProj Target projection.
 * @property {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
 * @property {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
 * @property {import("../tilecoord.js").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.
 * @property {number} pixelRatio Pixel ratio.
 * @property {number} gutter Gutter of the source tiles.
 * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {number} [errorThreshold] Acceptable reprojection error (in px).
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {import("../transform.js").Transform} [transformMatrix] Source transform matrix.
 * @property {boolean} [renderEdges] Render reprojection edges.
 */

/**
 * @classdesc
 * Class encapsulating single reprojected data tile.
 * See {@link module:ol/source/DataTile~DataTileSource}.
 *
 */
class ReprojDataTile extends _DataTile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Tile options.
   */
  constructor(options) {
    super({
      tileCoord: options.tileCoord,
      loader: () => Promise.resolve(new Uint8ClampedArray(4)),
      interpolate: options.interpolate,
      transition: options.transition,
    });

    /**
     * @private
     * @type {boolean | Array<number>}
     */
    this.renderEdges_ =
      options.renderEdges !== undefined ? options.renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = options.pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = options.gutter;

    /**
     * @type {import("../DataTile.js").Data}
     * @private
     */
    this.reprojData_ = null;

    /**
     * @type {Error}
     * @private
     */
    this.reprojError_ = null;

    /**
     * @type {import('../size.js').Size}
     * @private
     */
    this.reprojSize_ = undefined;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.sourceTileGrid_ = options.sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.targetTileGrid_ = options.targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;

    /**
     * @private
     * @type {!Array<TileOffset>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    const sourceProj = options.sourceProj;
    const sourceProjExtent = sourceProj.getExtent();
    const sourceTileGridExtent = options.sourceTileGrid.getExtent();

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.clipExtent_ = sourceProj.canWrapX()
      ? sourceTileGridExtent
        ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(sourceProjExtent, sourceTileGridExtent)
        : sourceProjExtent
      : sourceTileGridExtent;

    const targetExtent = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_,
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();

    const limitedTargetExtent = maxTargetExtent
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(targetExtent, maxTargetExtent)
      : targetExtent;

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }

    const targetResolution = this.targetTileGrid_.getResolution(
      this.wrappedTileCoord_[0],
    );

    const targetProj = options.targetProj;
    const sourceResolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.calculateSourceExtentResolution)(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution,
    );

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    const errorThresholdInPixels =
      options.errorThreshold !== undefined
        ? options.errorThreshold
        : _common_js__WEBPACK_IMPORTED_MODULE_4__.ERROR_THRESHOLD;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution,
      options.transformMatrix,
    );

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3],
        );
        sourceExtent[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3],
        );
      } else {
        sourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getArea)(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,
        );
      }

      const sourceExtents = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.wrapAndSliceX)(
        sourceExtent.slice(),
        sourceProj,
        true,
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_,
        );
        const getTile = options.getTileFunction;
        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);
            if (tile) {
              const offset = worldsAway * worldWidth;
              this.sourceTiles_.push({tile, offset});
            }
          }
        }
        ++worldsAway;
      });

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      }
    }
  }

  /**
   * Get the tile size.
   * @return {import('../size.js').Size} Tile size.
   * @override
   */
  getSize() {
    return this.reprojSize_;
  }

  /**
   * Get the data for the tile.
   * @return {import("../DataTile.js").Data} Tile data.
   * @override
   */
  getData() {
    return this.reprojData_;
  }

  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @override
   */
  getError() {
    return this.reprojError_;
  }

  /**
   * @private
   */
  reproject_() {
    const dataSources = [];
    let imageLike = false;
    this.sourceTiles_.forEach((source) => {
      const tile = source.tile;
      if (!tile || tile.getState() !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        return;
      }
      const size = tile.getSize();
      const gutter = this.gutter_;
      /**
       * @type {import("../DataTile.js").ArrayLike}
       */
      let tileData;
      const arrayData = (0,_DataTile_js__WEBPACK_IMPORTED_MODULE_0__.asArrayLike)(tile.getData());
      if (arrayData) {
        tileData = arrayData;
      } else {
        imageLike = true;
        tileData = (0,_DataTile_js__WEBPACK_IMPORTED_MODULE_0__.toArray)((0,_DataTile_js__WEBPACK_IMPORTED_MODULE_0__.asImageLike)(tile.getData()));
      }
      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];
      const isFloat = tileData instanceof Float32Array;
      const pixelCount = pixelSize[0] * pixelSize[1];
      const DataType = isFloat ? Float32Array : Uint8ClampedArray;
      const tileDataR = new DataType(tileData.buffer);
      const bytesPerElement = DataType.BYTES_PER_ELEMENT;
      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;
      const bytesPerRow = tileDataR.byteLength / pixelSize[1];
      const bandCount = Math.floor(
        bytesPerRow / bytesPerElement / pixelSize[0],
      );
      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
      extent[0] += source.offset;
      extent[2] += source.offset;
      const clipExtent = this.clipExtent_?.slice();
      if (clipExtent) {
        clipExtent[0] += source.offset;
        clipExtent[2] += source.offset;
      }
      dataSources.push({
        extent: extent,
        clipExtent: clipExtent,
        data: tileDataR,
        dataType: DataType,
        bytesPerPixel: bytesPerPixel,
        pixelSize: pixelSize,
        bandCount: bandCount,
      });
    });
    this.sourceTiles_.length = 0;

    if (dataSources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
      this.changed();
      return;
    }

    const z = this.wrappedTileCoord_[0];
    const size = this.targetTileGrid_.getTileSize(z);
    const targetWidth = typeof size === 'number' ? size : size[0];
    const targetHeight = typeof size === 'number' ? size : size[1];
    const outWidth = targetWidth * this.pixelRatio_;
    const outHeight = targetHeight * this.pixelRatio_;
    const targetResolution = this.targetTileGrid_.getResolution(z);
    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

    const targetExtent = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_,
    );

    const bandCount = dataSources[0].bandCount;
    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);

    const gl = (0,_glreproj_js__WEBPACK_IMPORTED_MODULE_7__.createCanvasContextWebGL)(outWidth, outHeight, _glreproj_js__WEBPACK_IMPORTED_MODULE_7__.canvasGLPool, {
      premultipliedAlpha: false,
      antialias: false,
    });

    let willInterpolate;
    const format = gl.RGBA;
    let textureType;
    if (dataSources[0].dataType == Float32Array) {
      textureType = gl.FLOAT;
      gl.getExtension('WEBGL_color_buffer_float');
      gl.getExtension('OES_texture_float');
      gl.getExtension('EXT_float_blend');
      const extension = gl.getExtension('OES_texture_float_linear');
      const canInterpolate = extension !== null;
      willInterpolate = canInterpolate && this.interpolate;
    } else {
      textureType = gl.UNSIGNED_BYTE;
      willInterpolate = this.interpolate;
    }

    const BANDS_PR_REPROJ = 4;
    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);
    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {
      const sources = [];
      for (let i = 0, len = dataSources.length; i < len; ++i) {
        const dataSource = dataSources[i];

        const pixelSize = dataSource.pixelSize;
        const width = pixelSize[0];
        const height = pixelSize[1];

        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);
        const dataS = dataSource.data;
        let offset = reproj * BANDS_PR_REPROJ;
        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {
          data[j] = dataS[offset];
          data[j + 1] = dataS[offset + 1];
          data[j + 2] = dataS[offset + 2];
          data[j + 3] = dataS[offset + 3];
          offset += bandCount;
        }

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        if (willInterpolate) {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          format,
          width,
          height,
          0,
          format,
          textureType,
          data,
        );

        sources.push({
          extent: dataSource.extent,
          clipExtent: dataSource.clipExtent,
          texture: texture,
          width: width,
          height: height,
        });
      }

      const {framebuffer, width, height} = (0,_glreproj_js__WEBPACK_IMPORTED_MODULE_7__.render)(
        gl,
        targetWidth,
        targetHeight,
        this.pixelRatio_,
        sourceResolution,
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        textureType,
        this.renderEdges_,
        willInterpolate,
      );

      // The texture is always RGBA.
      const rows = width;
      const cols = height * BANDS_PR_REPROJ;
      const data = new dataSources[0].dataType(rows * cols);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);

      let offset = reproj * BANDS_PR_REPROJ;
      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {
        // The data read by `readPixels` is flipped in the y-axis so flip it again.
        const flipY = (rows - 1 - ((i / cols) | 0)) * cols + (i % cols);
        dataR[offset] = data[flipY];
        dataR[offset + 1] = data[flipY + 1];
        dataR[offset + 2] = data[flipY + 2];
        dataR[offset + 3] = data[flipY + 3];
        offset += bandCount;
      }
    }

    (0,_glreproj_js__WEBPACK_IMPORTED_MODULE_7__.releaseGLCanvas)(gl);
    _glreproj_js__WEBPACK_IMPORTED_MODULE_7__.canvasGLPool.push(gl.canvas);

    if (imageLike) {
      const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_8__.createCanvasContext2D)(targetWidth, targetHeight);
      const imageData = new ImageData(dataR, targetWidth);
      context.putImageData(imageData, 0, 0);
      this.reprojData_ = context.canvas;
    } else {
      this.reprojData_ = dataR;
    }
    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
    this.changed();
  }

  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE && this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      return;
    }
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
    this.changed();

    let leftToLoad = 0;

    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(({tile}) => {
      const state = tile.getState();
      if (state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE && state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
        return;
      }
      leftToLoad++;

      const sourceListenKey = (0,_events_js__WEBPACK_IMPORTED_MODULE_9__.listen)(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CHANGE, () => {
        const state = tile.getState();
        if (
          state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
          state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR ||
          state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY
        ) {
          (0,_events_js__WEBPACK_IMPORTED_MODULE_9__.unlistenByKey)(sourceListenKey);
          leftToLoad--;
          if (leftToLoad === 0) {
            this.unlistenSources_();
            this.reproject_();
          }
        }
      });
      this.sourcesListenerKeys_.push(sourceListenKey);
    });

    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    } else {
      this.sourceTiles_.forEach(function ({tile}) {
        const state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
          tile.load();
        }
      });
    }
  }

  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_9__.unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReprojDataTile);


/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/reproj/Tile
 */












/**
 * @typedef {function(number, number, number, number) : (import("../ImageTile.js").default)} FunctionType
 */

/**
 * @typedef {Object} TileOffset
 * @property {import("../ImageTile.js").default} tile Tile.
 * @property {number} offset Offset.
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
class ReprojTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(
    sourceProj,
    sourceTileGrid,
    targetProj,
    targetTileGrid,
    tileCoord,
    wrappedTileCoord,
    pixelRatio,
    gutter,
    getTileFunction,
    errorThreshold,
    renderEdges,
    options,
  ) {
    super(tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE, options);

    /**
     * @private
     * @type {boolean}
     */
    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array<TileOffset>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.clipExtent_ = sourceProj.canWrapX()
      ? sourceProj.getExtent()
      : undefined;

    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_,
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();

    const limitedTargetExtent = maxTargetExtent
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(targetExtent, maxTargetExtent)
      : targetExtent;

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }

    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0],
    );

    const sourceResolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.calculateSourceExtentResolution)(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution,
    );

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    const errorThresholdInPixels =
      errorThreshold !== undefined ? errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_4__.ERROR_THRESHOLD;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution,
    );

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3],
        );
        sourceExtent[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3],
        );
      } else {
        sourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getArea)(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,
        );
      }

      const sourceExtents = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.wrapAndSliceX)(
        sourceExtent.slice(),
        sourceProj,
        true,
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_,
        );

        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
            if (tile) {
              const offset = worldsAway * worldWidth;
              this.sourceTiles_.push({tile, offset});
            }
          }
        }
        ++worldsAway;
      });

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      }
    }
  }

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }

  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((source) => {
      const tile = source.tile;
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
        extent[0] += source.offset;
        extent[2] += source.offset;
        const clipExtent = this.clipExtent_?.slice();
        if (clipExtent) {
          clipExtent[0] += source.offset;
          clipExtent[2] += source.offset;
        }
        sources.push({
          extent: extent,
          clipExtent: clipExtent,
          image: tile.getImage(),
        });
      }
    });
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === 'number' ? size : size[0];
      const height = typeof size === 'number' ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_,
      );

      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_,
      );

      this.canvas_ = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.render)(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate,
      );

      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  }

  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();

      let leftToLoad = 0;

      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(({tile}) => {
        const state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
          leftToLoad++;

          const sourceListenKey = (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.listen)(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE, (e) => {
            const state = tile.getState();
            if (
              state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED ||
              state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ||
              state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY
            ) {
              (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.unlistenByKey)(sourceListenKey);
              leftToLoad--;
              if (leftToLoad === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          });
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });

      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function ({tile}, i, arr) {
          const state = tile.getState();
          if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
            tile.load();
          }
        });
      }
    }
  }

  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_7__.unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }

  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    if (this.canvas_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_9__.releaseCanvas)(this.canvas_.getContext('2d'));
      _reproj_js__WEBPACK_IMPORTED_MODULE_3__.canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReprojTile);


/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/reproj/Triangulation
 */





/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
const MAX_SUBDIVISION = 10;

/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
const MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
class Triangulation {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
   */
  constructor(
    sourceProj,
    targetProj,
    targetExtent,
    maxSourceExtent,
    errorThreshold,
    destinationResolution,
    sourceMatrix,
  ) {
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;

    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.targetProj_ = targetProj;

    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
    let transformInvCache = {};
    const transformInv = sourceMatrix
      ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createTransformFromCoordinateTransform)((input) =>
          (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.apply)(
            sourceMatrix,
            (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform)(input, this.targetProj_, this.sourceProj_),
          ),
        )
      : (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(this.targetProj_, this.sourceProj_);

    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */
    this.transformInv_ = function (c) {
      const key = c[0] + '/' + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };

    /**
     * @type {import("../extent.js").Extent}
     * @private
     */
    this.maxSourceExtent_ = maxSourceExtent;

    /**
     * @type {number}
     * @private
     */
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;

    /**
     * @type {Array<Triangle>}
     * @private
     */
    this.triangles_ = [];

    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */
    this.wrapsXInSource_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.canWrapXInSource_ =
      this.sourceProj_.canWrapX() &&
      !!maxSourceExtent &&
      !!this.sourceProj_.getExtent() &&
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(maxSourceExtent) >= (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(this.sourceProj_.getExtent());

    /**
     * @type {?number}
     * @private
     */
    this.sourceWorldWidth_ = this.sourceProj_.getExtent()
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(this.sourceProj_.getExtent())
      : null;

    /**
     * @type {?number}
     * @private
     */
    this.targetWorldWidth_ = this.targetProj_.getExtent()
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(this.targetProj_.getExtent())
      : null;

    const destinationTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(targetExtent);
    const destinationTopRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopRight)(targetExtent);
    const destinationBottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getBottomRight)(targetExtent);
    const destinationBottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getBottomLeft)(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);

    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overall reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */
    const maxSubdivision =
      MAX_SUBDIVISION +
      (destinationResolution
        ? Math.max(
            0,
            Math.ceil(
              Math.log2(
                (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getArea)(targetExtent) /
                  (destinationResolution * destinationResolution * 256 * 256),
              ),
            ),
          )
        : 0);

    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision,
    );

    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0],
        );
      });

      // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.
      this.triangles_.forEach((triangle) => {
        if (
          Math.max(
            triangle.source[0][0],
            triangle.source[1][0],
            triangle.source[2][0],
          ) -
            leftBound >
          this.sourceWorldWidth_ / 2
        ) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]],
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }

          // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0],
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0],
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }

    transformInvCache = {};
  }

  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c],
    });
  }

  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_
      : null;
    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

    // when the quad is wrapped in the source projection
    // it covers most of the projection extent, but not fully
    const wrapsX =
      this.sourceProj_.canWrapX() &&
      sourceCoverageX > 0.5 &&
      sourceCoverageX < 1;

    let needsSubdivision = false;

    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.boundingExtent)([a, b, c, d]);
        const targetCoverageX =
          (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision =
          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision =
          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }

    if (!needsSubdivision && this.maxSourceExtent_) {
      if (
        isFinite(sourceQuadExtent[0]) &&
        isFinite(sourceQuadExtent[1]) &&
        isFinite(sourceQuadExtent[2]) &&
        isFinite(sourceQuadExtent[3])
      ) {
        if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
          // whole quad outside source projection extent -> ignore
          return;
        }
      }
    }

    let isNotFinite = 0;

    if (!needsSubdivision) {
      if (
        !isFinite(aSrc[0]) ||
        !isFinite(aSrc[1]) ||
        !isFinite(bSrc[0]) ||
        !isFinite(bSrc[1]) ||
        !isFinite(cSrc[0]) ||
        !isFinite(cSrc[1]) ||
        !isFinite(dSrc[0]) ||
        !isFinite(dSrc[1])
      ) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          // It might be the case that only 1 of the points is infinite. In this case
          // we can draw a single triangle with the other three points
          isNotFinite =
            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +
            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +
            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +
            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (
            isNotFinite != 1 &&
            isNotFinite != 2 &&
            isNotFinite != 4 &&
            isNotFinite != 8
          ) {
            return;
          }
        }
      }
    }

    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);

        let dx;
        if (wrapsX) {
          const centerSrcEstimX =
            ((0,_math_js__WEBPACK_IMPORTED_MODULE_3__.modulo)(aSrc[0], sourceWorldWidth) +
              (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.modulo)(cSrc[0], sourceWorldWidth)) /
            2;
          dx = centerSrcEstimX - (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.modulo)(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          // split horizontally (top & bottom)
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);

          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1,
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1,
          );
        } else {
          // split vertically (left & right)
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);

          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1,
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1,
          );
        }
        return;
      }
    }

    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }

    // Exactly zero or one of *Src is not finite
    // The triangles must have the diagonal line as the first side
    // This is to allow easy code in reproj.s to make it straight for broken
    // browsers that can't handle diagonal clipping
    if ((isNotFinite & 0xb) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 0xe) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      // Try the other two triangles
      if ((isNotFinite & 0xd) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 0x7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }

  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    this.triangles_.forEach(function (triangle, i, arr) {
      const src = triangle.source;
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.extendCoordinate)(extent, src[0]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.extendCoordinate)(extent, src[1]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.extendCoordinate)(extent, src[2]);
    });

    return extent;
  }

  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Triangulation);


/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ERROR_THRESHOLD: () => (/* binding */ ERROR_THRESHOLD)
/* harmony export */ });
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
const ERROR_THRESHOLD = 0.5;


/***/ }),

/***/ "./node_modules/ol/reproj/glreproj.js":
/*!********************************************!*\
  !*** ./node_modules/ol/reproj/glreproj.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canvasGLPool: () => (/* binding */ canvasGLPool),
/* harmony export */   createCanvasContextWebGL: () => (/* binding */ createCanvasContextWebGL),
/* harmony export */   releaseGLCanvas: () => (/* binding */ releaseGLCanvas),
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vec/mat4.js */ "./node_modules/ol/vec/mat4.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _webgl_Canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/Canvas.js */ "./node_modules/ol/webgl/Canvas.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/reproj/glreproj
 */





const EDGE_VERTEX_SHADER = `
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
  }
`;
const EDGE_FRAGMENT_SHADER = `
  precision mediump float;

  uniform vec4 u_val;
  void main() {
     gl_FragColor = u_val;
  }
`;

const TRIANGLE_VERTEX_SHADER = `
  attribute vec4 a_position;
  attribute vec2 a_texcoord;

  varying vec2 v_texcoord;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
     v_texcoord = a_texcoord;
  }
`;
const TRIANGLE_FRAGMENT_SHADER = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;

/**
 * Create an html canvas element and returns its webgl context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings
 * @return {WebGLRenderingContext} The context.
 */
function createCanvasContextWebGL(width, height, canvasPool, settings) {
  /** @type {HTMLCanvasElement|OffscreenCanvas} */
  let canvas;
  if (canvasPool && canvasPool.length) {
    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());
  } else if (_has_js__WEBPACK_IMPORTED_MODULE_0__.WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement('canvas');
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  //FIXME Allow OffscreenCanvasRenderingContext2D as return type
  return /** @type {WebGLRenderingContext} */ (
    canvas.getContext('webgl', settings)
  );
}

/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {WebGLRenderingContext} gl Context.
 */
function releaseGLCanvas(gl) {
  const canvas = gl.canvas;
  canvas.width = 1;
  canvas.height = 1;
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
}

/**
 * @type {Array<HTMLCanvasElement | OffscreenCanvas>}
 */
const canvasGLPool = [];

/**
 * @typedef {Object} ImageExtent
 * @property {import("../extent.js").Extent} extent Extent.
 * @property {import("../extent.js").Extent} [clipExtent] Clip extent.
 * @property {WebGLTexture} texture Texture.
 * @property {number} width Width of texture.
 * @property {number} height Height of texture.
 */

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {WebGLRenderingContext} gl the context to render in.
 * @param {number} width_ Width of the canvas.
 * @param {number} height_ Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {number} targetResolution Target resolution.
 * @param {import("../extent.js").Extent} targetExtent Target extent (tile).
 * @param {import("../reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE
 * TODO: Allow setting renderEdges value in the data as this is done in "data-space".
 * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.
 * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.
 */
function render(
  gl,
  width_,
  height_,
  pixelRatio,
  sourceResolution,
  targetResolution,
  targetExtent,
  triangulation,
  sources,
  gutter,
  dataType,
  renderEdges,
  interpolate,
  drawSingle,
) {
  const width = Math.round(pixelRatio * width_);
  const height = Math.round(pixelRatio * height_);
  gl.canvas.width = width;
  gl.canvas.height = height;

  /** @type {WebGLFramebuffer | null} */
  let resultFrameBuffer;
  /** @type {WebGLTexture | null} */
  let resultTexture;
  {
    resultTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, resultTexture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (interpolate) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    }
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      width,
      height,
      0,
      gl.RGBA,
      dataType,
      null,
    );

    resultFrameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      resultTexture,
      0,
    );
  }

  if (resultFrameBuffer === null) {
    throw new Error('Could not create framebuffer');
  }
  if (resultTexture === null) {
    throw new Error('Could not create texture');
  }

  if (sources.length === 0) {
    return {
      width,
      height,
      framebuffer: resultFrameBuffer,
      texture: resultTexture,
    };
  }

  const sourceDataExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extend)(sourceDataExtent, src.extent);
  });

  /** @type {WebGLTexture | null} */
  let stitchTexture;
  /** @type {number} */
  let stitchWidth;
  /** @type {number} */
  let stitchHeight;
  const stitchScale = 1 / sourceResolution;

  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchTexture = gl.createTexture();
    if (resultTexture === null) {
      throw new Error('Could not create texture');
    }
    stitchWidth = Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(sourceDataExtent) * stitchScale);
    stitchHeight = Math.round((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(sourceDataExtent) * stitchScale);

    // Make sure we do not exceed the max texture size by lowering the resolution for this image.
    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580
    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const largeSide = Math.max(stitchWidth, stitchHeight);
    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;
    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);
    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);

    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (interpolate) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    }
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      stitchWidthFixed,
      stitchHeightFixed,
      0,
      gl.RGBA,
      dataType,
      null,
    );

    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      stitchTexture,
      0,
    );
    const webGLCanvas = new _webgl_Canvas_js__WEBPACK_IMPORTED_MODULE_2__.Canvas(gl);

    sources.forEach(function (src, i, arr) {
      const xPos =
        (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;
      const yPos =
        -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;
      const srcWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(src.extent) * stitchScale * scaleFactor;
      const srcHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(src.extent) * stitchScale * scaleFactor;
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);

      if (src.clipExtent) {
        const xPos =
          (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;
        const yPos =
          -(src.clipExtent[3] - sourceDataExtent[3]) *
          stitchScale *
          scaleFactor;
        const width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(src.clipExtent) * stitchScale * scaleFactor;
        const height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(src.clipExtent) * stitchScale * scaleFactor;
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate ? width : Math.round(xPos + width) - Math.round(xPos),
          interpolate ? height : Math.round(yPos + height) - Math.round(yPos),
        );
      }

      webGLCanvas.drawImage(
        src.texture,
        src.width,
        src.height,
        gutter,
        gutter,
        src.width - 2 * gutter,
        src.height - 2 * gutter,
        interpolate ? xPos : Math.round(xPos),
        interpolate ? yPos : Math.round(yPos),
        interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),
        interpolate
          ? srcHeight
          : Math.round(yPos + srcHeight) - Math.round(yPos),
        stitchWidthFixed,
        stitchHeightFixed,
      );

      gl.disable(gl.SCISSOR_TEST);
    });
    gl.deleteFramebuffer(fb);
  } else {
    stitchTexture = sources[0].texture;
    stitchWidth = sources[0].width;
    stitchHeight = sources[0].width;
  }

  const targetTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopLeft)(targetExtent);
  const sourceTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopLeft)(sourceDataExtent);

  const getUVs = (
    /** @type {Array<import("../coordinate.js").Coordinate>} */ target,
  ) => {
    const u0 =
      ((target[0][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;
    const v0 =
      (-(target[0][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;
    const u1 =
      ((target[1][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;
    const v1 =
      (-(target[1][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;
    const u2 =
      ((target[2][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;
    const v2 =
      (-(target[2][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;
    return {u1, v1, u0, v0, u2, v2};
  };

  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);
  gl.viewport(0, 0, width, height);

  // Draw source to reprojtile
  {
    /** @type {Array<number>} */
    const vertices = [];
    /** @type {Array<number>} */
    const texcoords = [];

    const triProgram = (0,_webgl_Canvas_js__WEBPACK_IMPORTED_MODULE_2__.createProgram)(
      gl,
      TRIANGLE_FRAGMENT_SHADER,
      TRIANGLE_VERTEX_SHADER,
    );
    gl.useProgram(triProgram);

    // Bind image
    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');
    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);

    // Tell the shader to get the texture from texture unit 0
    gl.uniform1i(textureLocation, 0);

    // Calculate vert and tex coordinates.
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      const source = triangle.source;
      const target = triangle.target;
      // Make sure that everything is on pixel boundaries
      const {u1, v1, u0, v0, u2, v2} = getUVs(target);

      const su0 =
        (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;
      const sv0 =
        -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;
      const su1 =
        (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;
      const sv1 =
        -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;
      const su2 =
        (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;
      const sv2 =
        -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;

      vertices.push(u1, v1, u0, v0, u2, v2);
      texcoords.push(su1, sv1, su0, sv0, su2, sv2);
    });

    // Convert pixel space to clip space.
    const matrix = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__.orthographic(0, width, height, 0, -1, 1);
    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');
    gl.uniformMatrix4fv(matrixLocation, false, matrix);

    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLocation);

    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');
    const texcoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(texcoordLocation);

    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
  }

  if (renderEdges) {
    const edgeProgram = (0,_webgl_Canvas_js__WEBPACK_IMPORTED_MODULE_2__.createProgram)(
      gl,
      EDGE_FRAGMENT_SHADER,
      EDGE_VERTEX_SHADER,
    );
    gl.useProgram(edgeProgram);
    const matrix = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_3__.orthographic(0, width, height, 0, -1, 1);
    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');
    gl.uniformMatrix4fv(matrixLocation, false, matrix);

    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];
    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');
    const isFloat = true;
    if (isFloat) {
      gl.uniform4fv(burnvalLocation, burnval);
    } else {
      gl.uniform4iv(burnvalLocation, burnval);
    }

    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLocation);

    /** @type {Array<number>} */
    const lines = triangulation.getTriangles().reduce(function (
      /** @type {Array<number>} */ lines,
      triangle,
    ) {
      const target = triangle.target;
      const {u1, v1, u0, v0, u2, v2} = getUVs(target);

      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);
    }, []);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);
    gl.drawArrays(gl.LINES, 0, lines.length / 2);
  }

  return {
    width,
    height,
    framebuffer: resultFrameBuffer,
    texture: resultTexture,
  };
}


/***/ }),

/***/ "./node_modules/ol/resolutionconstraint.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/resolutionconstraint.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMinMaxResolution: () => (/* binding */ createMinMaxResolution),
/* harmony export */   createSnapToPower: () => (/* binding */ createSnapToPower),
/* harmony export */   createSnapToResolutions: () => (/* binding */ createSnapToResolutions)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/**
 * @module ol/resolutionconstraint
 */




/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */

/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */
function getViewportClampedResolution(
  resolution,
  maxExtent,
  viewportSize,
  showFullExtent,
) {
  const xResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(maxExtent) / viewportSize[0];
  const yResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(maxExtent) / viewportSize[1];

  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}

/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;

  result *=
    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +
    1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /=
      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /
        ratio +
      1;
  }
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(result, minResolution / 2, maxResolution * 2);
}

/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToResolutions(
  resolutions,
  smooth,
  maxExtent,
  showFullExtent,
) {
  smooth = smooth !== undefined ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent
          ? getViewportClampedResolution(
              maxResolution,
              maxExtent,
              size,
              showFullExtent,
            )
          : maxResolution;

        // during interacting or animating, allow intermediary values
        if (isMoving) {
          if (!smooth) {
            return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution,
          );
        }

        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.linearFindNearest)(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return undefined;
    }
  );
}

/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToPower(
  power,
  maxResolution,
  minResolution,
  smooth,
  maxExtent,
  showFullExtent,
) {
  smooth = smooth !== undefined ? smooth : true;
  minResolution = minResolution !== undefined ? minResolution : 0;

  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        const cappedMaxRes = maxExtent
          ? getViewportClampedResolution(
              maxResolution,
              maxExtent,
              size,
              showFullExtent,
            )
          : maxResolution;

        // during interacting or animating, allow intermediary values
        if (isMoving) {
          if (!smooth) {
            return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution,
          );
        }

        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance,
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset,
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(newResolution, minResolution, cappedMaxRes);
      }
      return undefined;
    }
  );
}

/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createMinMaxResolution(
  maxResolution,
  minResolution,
  smooth,
  maxExtent,
  showFullExtent,
) {
  smooth = smooth !== undefined ? smooth : true;

  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        const cappedMaxRes = maxExtent
          ? getViewportClampedResolution(
              maxResolution,
              maxExtent,
              size,
              showFullExtent,
            )
          : maxResolution;

        if (!smooth || !isMoving) {
          return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution,
        );
      }
      return undefined;
    }
  );
}


/***/ }),

/***/ "./node_modules/ol/rotationconstraint.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/rotationconstraint.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSnapToN: () => (/* binding */ createSnapToN),
/* harmony export */   createSnapToZero: () => (/* binding */ createSnapToZero),
/* harmony export */   disable: () => (/* binding */ disable),
/* harmony export */   none: () => (/* binding */ none)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/rotationconstraint
 */


/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function disable(rotation) {
  if (rotation !== undefined) {
    return 0;
  }
  return undefined;
}

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function none(rotation) {
  if (rotation !== undefined) {
    return rotation;
  }
  return undefined;
}

/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */
function createSnapToN(n) {
  const theta = (2 * Math.PI) / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return undefined;
    }
  );
}

/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */
function createSnapToZero(tolerance) {
  const t = tolerance === undefined ? (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving || rotation === undefined) {
        return rotation;
      }

      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}


/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   hasArea: () => (/* binding */ hasArea),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   toSize: () => (/* binding */ toSize)
/* harmony export */ });
/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }
  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}

/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}

/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */
function scale(size, ratio, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }
  dest[0] = (size[0] * ratio + 0.5) | 0;
  dest[1] = (size[1] * ratio + 0.5) | 0;
  return dest;
}

/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === undefined) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}


/***/ }),

/***/ "./node_modules/ol/source/OSM.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/OSM.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ATTRIBUTION: () => (/* binding */ ATTRIBUTION),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/OSM
 */



/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
const ATTRIBUTION =
  '&#169; ' +
  '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' +
  'contributors.';

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
class OSM extends _XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(options) {
    options = options || {};

    let attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    const crossOrigin =
      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';

    const url =
      options.url !== undefined
        ? options.url
        : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';

    super({
      attributions: attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX,
      zDirection: options.zDirection,
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OSM);


/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/source/Source
 */



/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */

/**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
class Source extends _Object_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} options Source options.
   */
  constructor(options) {
    super();

    /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */
    this.projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.projection);

    /**
     * @private
     * @type {?Attribution}
     */
    this.attributions_ = adaptAttributions(options.attributions);

    /**
     * @private
     * @type {boolean}
     */
    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;

    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    this.loading = false;

    /**
     * @private
     * @type {import("./Source.js").State}
     */
    this.state_ = options.state !== undefined ? options.state : 'ready';

    /**
     * @private
     * @type {boolean}
     */
    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

    /**
     * @private
     * @type {boolean}
     */
    this.interpolate_ = !!options.interpolate;

    /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */
    this.viewResolver = null;

    /**
     * @protected
     * @type {function(Error):void}
     */
    this.viewRejector = null;

    const self = this;
    /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */
    this.viewPromise_ = new Promise(function (resolve, reject) {
      self.viewResolver = resolve;
      self.viewRejector = reject;
    });
  }

  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }

  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }

  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }

  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    return null;
  }

  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }

  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }

  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }

  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }

  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }

  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }

  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(state) {
    this.state_ = state;
    this.changed();
  }
}

/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (typeof attributionLike === 'function') {
    return attributionLike;
  }
  if (!Array.isArray(attributionLike)) {
    attributionLike = [attributionLike];
  }
  return (frameState) => attributionLike;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Source);


/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TileSourceEvent: () => (/* binding */ TileSourceEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/source/Tile
 */







/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @template {import("../Tile.js").default} [TileType=import("../Tile.js").default]
 * @abstract
 * @api
 */
class TileSource extends _Source_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate,
    });

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {TileSourceOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {number}
     */
    this.tilePixelRatio_ =
      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

    /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     * @protected
     */
    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

    const tileSize = [256, 256];
    if (this.tileGrid) {
      (0,_size_js__WEBPACK_IMPORTED_MODULE_1__.toSize)(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }

    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    this.key_ = options.key || (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(this);

    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate,
    };

    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }

  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }

  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(projection) {
    const tileGrid = projection
      ? this.getTileGridForProjection(projection)
      : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }

  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {TileType|null} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_3__.getForProjection)(projection);
    }
    return this.tileGrid;
  }

  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }

  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_1__.toSize)(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return (0,_size_js__WEBPACK_IMPORTED_MODULE_1__.scale)(tileSize, tilePixelRatio, this.tmpSize);
  }

  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    const gridProjection =
      projection !== undefined ? projection : this.getProjection();
    const tileGrid =
      projection !== undefined
        ? this.getTileGridForProjection(gridProjection)
        : this.tileGrid || this.getTileGridForProjection(gridProjection);
    if (this.getWrapX() && gridProjection.isGlobal()) {
      tileCoord = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_3__.wrapX)(tileGrid, tileCoord, gridProjection);
    }
    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_4__.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
  }

  /**
   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
   * @api
   */
  clear() {}

  /**
   * @override
   */
  refresh() {
    this.clear();
    super.refresh();
  }
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
class TileSourceEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"] {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile) {
    super(type);

    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    this.tile = tile;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileSource);


/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror',
});

/**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */


/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/source/TileImage
 */









/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function
 * for the url option instead.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @deprecated Use the ol/source/ImageTile.js instead.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
class TileImage extends _UrlTile_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction
        ? options.tileLoadFunction
        : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate:
        options.interpolate !== undefined ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @protected
     * @type {?string}
     */
    this.crossOrigin =
      options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {typeof ImageTile}
     */
    this.tileClass =
      options.tileClass !== undefined ? options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    this.renderReprojectionEdges_ = false;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(projection) {
    if (
      this.getProjection() &&
      projection &&
      !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection)
    ) {
      return 0;
    }
    return this.getGutter();
  }

  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ':disable-interpolation';
    }
    return key;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] =
        (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_4__.getForProjection)(projection);
    }
    return this.tileGridForProjection[projKey];
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection,
    );
    const tileUrl = urlTileCoord
      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)
      : undefined;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_5__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_5__["default"].EMPTY,
      tileUrl !== undefined ? tileUrl : '',
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions,
    );
    tile.key = key;
    tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, this.handleTileChange.bind(this));
    return tile;
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @override
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (
      !sourceProjection ||
      !projection ||
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(sourceProjection, projection)
    ) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection,
      );
    }
    const tileCoord = [z, x, y];
    const key = this.getKey();
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection,
    );
    const tile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__["default"](
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z, x, y, pixelRatio) =>
        this.getTileInternal(z, x, y, pixelRatio, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions,
    );
    tile.key = key;
    return tile;
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    const key = this.getKey();
    return this.createTile_(z, x, y, pixelRatio, projection, key);
  }

  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render) {
    if (this.renderReprojectionEdges_ == render) {
      return;
    }
    this.renderReprojectionEdges_ = render;
    this.changed();
  }

  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
    if (proj) {
      const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
}

/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =
    src;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileImage);


/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TileEventType.js */ "./node_modules/ol/source/TileEventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../uri.js */ "./node_modules/ol/uri.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/source/UrlTile
 */







/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function
 * for the url option instead.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @deprecated Use the ol/source/ImageTile.js instead.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
class UrlTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @private
     * @type {boolean}
     */
    this.generateTileUrlFunction_ =
      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;

    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    this.tileLoadFunction = options.tileLoadFunction;

    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }

    /**
     * @protected
     * @type {!Array<string>|null}
     */
    this.urls = null;

    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    this.tileLoadingKeys_ = {};
  }

  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }

  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction
      ? this.tileUrlFunction.bind(this)
      : this.tileUrlFunction;
  }

  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }

  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = /** @type {import("../Tile.js").default} */ (event.target);
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type =
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR
          ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADERROR
          : tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED
            ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADEND
            : undefined;
    }
    if (type != undefined) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_0__.TileSourceEvent(type, tile));
    }
  }

  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }

  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  }

  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = (0,_uri_js__WEBPACK_IMPORTED_MODULE_4__.expandUrl)(url);
    this.urls = urls;
    this.setUrls(urls);
  }

  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join('\n');
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction((0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_5__.createFromTemplates)(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return undefined;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UrlTile);


/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/XYZ
 */




/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Deprecated.  Use an ImageTile source with a loader
 * instead.  Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Deprecated.  Use an ImageTile source and provide a function
 * for the url option instead.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] Deprecated.  Use an ImageTile source and provide an array of URLs for the
 * url option instead.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */
class XYZ extends _TileImage_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};

    const projection =
      options.projection !== undefined ? options.projection : 'EPSG:3857';

    const tileGrid =
      options.tileGrid !== undefined
        ? options.tileGrid
        : (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__.createXYZ)({
            extent: (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__.extentFromProjection)(projection),
            maxResolution: options.maxResolution,
            maxZoom: options.maxZoom,
            minZoom: options.minZoom,
            tileSize: options.tileSize,
          });

    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
  }

  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (XYZ);


/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_RADIUS: () => (/* binding */ DEFAULT_RADIUS),
/* harmony export */   getArea: () => (/* binding */ getArea),
/* harmony export */   getDistance: () => (/* binding */ getDistance),
/* harmony export */   getLength: () => (/* binding */ getLength),
/* harmony export */   offset: () => (/* binding */ offset)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/sphere
 */


/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
const DEFAULT_RADIUS = 6371008.8;

/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  const lat2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[0] - c1[0]) / 2;
  const a =
    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
    Math.sin(deltaLonBy2) *
      Math.sin(deltaLonBy2) *
      Math.cos(lat1) *
      Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  let length = 0;
  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}

/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || 'EPSG:3857';
  const type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  let length = 0;
  let coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint': {
      break;
    }
    case 'LineString':
    case 'LinearRing': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      length = getLengthInternal(coordinates, radius);
      break;
    }
    case 'MultiLineString':
    case 'Polygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        length += getLengthInternal(coordinates[i], radius);
      }
      break;
    }
    case 'MultiPolygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case 'GeometryCollection': {
      const geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */ (
          geometry
        ).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return length;
}

/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  let area = 0;
  const len = coordinates.length;
  let x1 = coordinates[len - 1][0];
  let y1 = coordinates[len - 1][1];
  for (let i = 0; i < len; i++) {
    const x2 = coordinates[i][0];
    const y2 = coordinates[i][1];
    area +=
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(x2 - x1) *
      (2 + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y1)) + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }
  return (area * radius * radius) / 2.0;
}

/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || 'EPSG:3857';
  const type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  let area = 0;
  let coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'LinearRing': {
      break;
    }
    case 'Polygon': {
      coordinates = /** @type {import("./geom/Polygon.js").default} */ (
        geometry
      ).getCoordinates();
      area = Math.abs(getAreaInternal(coordinates[0], radius));
      for (i = 1, ii = coordinates.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates[i], radius));
      }
      break;
    }
    case 'MultiPolygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case 'GeometryCollection': {
      const geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */ (
          geometry
        ).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return area;
}

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  const lon1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[0]);
  const dByR = distance / radius;
  const lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) +
      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing),
  );
  const lon =
    lon1 +
    Math.atan2(
      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat),
    );
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lon), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lat)];
}


/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareVersions: () => (/* binding */ compareVersions),
/* harmony export */   padNumber: () => (/* binding */ padNumber)
/* harmony export */ });
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function padNumber(number, width, precision) {
  const numberString =
    precision !== undefined ? number.toFixed(precision) : '' + number;
  let decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width
    ? numberString
    : new Array(1 + width - decimal).join('0') + numberString;
}

/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */
function compareVersions(v1, v2) {
  const s1 = ('' + v1).split('.');
  const s2 = ('' + v2).split('.');

  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {
    const n1 = parseInt(s1[i] || '0', 10);
    const n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}


/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/structs/LRUCache
 */




/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Entry|null} newer Newer.
 * @property {Entry|null} older Older.
 * @property {*} value_ Value.
 */

/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
class LRUCache {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?Entry}
     */
    this.newest_ = null;
  }

  deleteOldest() {
    const entry = this.pop();
    if (entry instanceof _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      entry.dispose();
    }
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }

  /**
   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
   * the entry will be disposed.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.deleteOldest();
    }
  }

  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    while (this.oldest_) {
      this.deleteOldest();
    }
  }

  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }

  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }

  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      entry !== undefined,
      'Tried to get a value for a key that does not exist in the cache',
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }

  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      entry !== undefined,
      'Tried to get a value for a key that does not exist in the cache',
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */ (entry.older);
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (entry.newer);
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }

  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }

  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }

  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }

  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }

  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }

  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }

  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(key) {
    return this.entries_[key]?.value_;
  }

  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */ (entry.newer);
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }

  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key); // update `newest_`
    this.entries_[key].value_ = value;
  }

  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(key in this.entries_),
      'Tried to set a value for a key that is used already',
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value,
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }

  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LRUCache);


/***/ }),

/***/ "./node_modules/ol/structs/PriorityQueue.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/structs/PriorityQueue.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DROP: () => (/* binding */ DROP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/PriorityQueue
 */



/**
 * @type {number}
 */
const DROP = Infinity;

/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
class PriorityQueue {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    /**
     * @type {function(T): number}
     * @private
     */
    this.priorityFunction_ = priorityFunction;

    /**
     * @type {function(T): string}
     * @private
     */
    this.keyFunction_ = keyFunction;

    /**
     * @type {Array<T>}
     * @private
     */
    this.elements_ = [];

    /**
     * @type {Array<number>}
     * @private
     */
    this.priorities_ = [];

    /**
     * @type {!Object<string, boolean>}
     * @private
     */
    this.queuedElements_ = {};
  }

  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.clear)(this.queuedElements_);
  }

  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = /** @type {T} */ (elements.pop());
      priorities[0] = /** @type {number} */ (priorities.pop());
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }

  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(this.keyFunction_(element) in this.queuedElements_),
      'Tried to enqueue an `element` that was already added to the queue',
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }

  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }

  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }

  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }

  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return (index - 1) >> 1;
  }

  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }

  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }

  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }

  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;

    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);

      const smallerChildIndex =
        rIndex < count && priorities[rIndex] < priorities[lIndex]
          ? rIndex
          : lIndex;

      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }

    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }

  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];

    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }

  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PriorityQueue);


/***/ }),

/***/ "./node_modules/ol/style/Circle.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Circle.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/**
 * @module ol/style/Circle
 */



/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {import('./Style.js').DeclutterMode} [declutterMode] Declutter mode
 */

/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
class CircleStyle extends _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {radius: 5};

    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== undefined ? options.scale : 1,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      rotateWithView:
        options.rotateWithView !== undefined ? options.rotateWithView : false,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode,
    });
  }

  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale = this.getScale();
    const style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
    style.setOpacity(this.getOpacity());
    return style;
  }

  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(radius) {
    this.radius = radius;
    this.render();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleStyle);


/***/ }),

/***/ "./node_modules/ol/style/Fill.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Fill.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _IconImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IconImage.js */ "./node_modules/ol/style/IconImage.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Fill
 */






/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} [color=null] A color,
 * gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats. For polygon fills (not for {@link import("./RegularShape.js").default} fills),
 * a pattern can also be provided as {@link module:ol/colorlike~PatternDescriptor}.
 * Default null; if null, the Canvas/renderer default black will be used.
 */

/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
class Fill {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {import("./IconImage.js").default|null}
     */
    this.patternImage_ = null;

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null}
     */
    this.color_ = null;
    if (options.color !== undefined) {
      this.setColor(options.color);
    }
  }

  /**
   * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || undefined,
    });
  }

  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(color) {
    if (color !== null && typeof color === 'object' && 'src' in color) {
      const patternImage = (0,_IconImage_js__WEBPACK_IMPORTED_MODULE_0__.get)(
        null,
        color.src,
        'anonymous',
        undefined,
        color.offset ? null : color.color ? color.color : null,
        !(color.offset && color.size),
      );
      patternImage.ready().then(() => {
        this.patternImage_ = null;
      });
      if (patternImage.getImageState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        patternImage.load();
      }
      if (patternImage.getImageState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
        this.patternImage_ = patternImage;
      }
    }
    this.color_ = color;
  }

  /**
   * @return {string} Key of the fill for cache lookup.
   */
  getKey() {
    const fill = this.getColor();
    if (!fill) {
      return '';
    }
    return fill instanceof CanvasPattern || fill instanceof CanvasGradient
      ? (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(fill)
      : typeof fill === 'object' && 'src' in fill
        ? fill.src + ':' + fill.offset
        : (0,_color_js__WEBPACK_IMPORTED_MODULE_3__.asArray)(fill).toString();
  }

  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }

  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Fill);


/***/ }),

/***/ "./node_modules/ol/style/Icon.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Icon.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _IconImage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IconImage.js */ "./node_modules/ol/style/IconImage.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Icon
 */








/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */

/**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */

/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement|ImageBitmap} [img] Image object for the icon.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [width] The width of the icon in pixels. This can't be used together with `scale`.
 * @property {number} [height] The height of the icon in pixels. This can't be used together with `scale`.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {import("./Style.js").DeclutterMode} [declutterMode] Declutter mode.
 */

/**
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {number|undefined} wantedWidth The wanted width.
 * @param {number|undefined} wantedHeight The wanted height.
 * @return {number|Array<number>} The scale.
 */
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== undefined && wantedHeight !== undefined) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== undefined) {
    return wantedWidth / width;
  }
  if (wantedHeight !== undefined) {
    return wantedHeight / height;
  }
  return 1;
}

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
class Icon extends _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @type {number}
     */
    const opacity = options.opacity !== undefined ? options.opacity : 1;

    /**
     * @type {number}
     */
    const rotation = options.rotation !== undefined ? options.rotation : 0;

    /**
     * @type {number|import("../size.js").Size}
     */
    const scale = options.scale !== undefined ? options.scale : 1;

    /**
     * @type {boolean}
     */
    const rotateWithView =
      options.rotateWithView !== undefined ? options.rotateWithView : false;

    super({
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView,
      declutterMode: options.declutterMode,
    });

    /**
     * @private
     * @type {Array<number>}
     */
    this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];

    /**
     * @private
     * @type {Array<number>}
     */
    this.normalizedAnchor_ = null;

    /**
     * @private
     * @type {IconOrigin}
     */
    this.anchorOrigin_ =
      options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    this.anchorXUnits_ =
      options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    this.anchorYUnits_ =
      options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ =
      options.crossOrigin !== undefined ? options.crossOrigin : null;

    const image = options.img !== undefined ? options.img : null;

    let cacheKey = options.src;

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(cacheKey !== undefined && image),
      '`image` and `src` cannot be provided at the same time',
    );

    if ((cacheKey === undefined || cacheKey.length === 0) && image) {
      cacheKey = /** @type {HTMLImageElement} */ (image).src || (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(image);
    }
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      cacheKey !== undefined && cacheKey.length > 0,
      'A defined and non-empty `src` or `image` must be provided',
    );

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(
        (options.width !== undefined || options.height !== undefined) &&
        options.scale !== undefined
      ),
      '`width` or `height` cannot be provided together with `scale`',
    );

    let imageState;
    if (options.src !== undefined) {
      imageState = _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE;
    } else if (image !== undefined) {
      if ('complete' in image) {
        if (image.complete) {
          imageState = image.src ? _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED : _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE;
        } else {
          imageState = _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADING;
        }
      } else {
        imageState = _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED;
      }
    }

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    this.color_ = options.color !== undefined ? (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(options.color) : null;

    /**
     * @private
     * @type {import("./IconImage.js").default}
     */
    this.iconImage_ = (0,_IconImage_js__WEBPACK_IMPORTED_MODULE_5__.get)(
      image,
      /** @type {string} */ (cacheKey),
      this.crossOrigin_,
      imageState,
      this.color_,
    );

    /**
     * @private
     * @type {Array<number>}
     */
    this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {IconOrigin}
     */
    this.offsetOrigin_ =
      options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = options.size !== undefined ? options.size : null;

    /**
     * @private
     */
    this.initialOptions_;

    /**
     * Calculate the scale if width or height were given.
     */
    if (options.width !== undefined || options.height !== undefined) {
      let width, height;
      if (options.size) {
        [width, height] = options.size;
      } else {
        const image = this.getImage(1);
        if (image.width && image.height) {
          width = image.width;
          height = image.height;
        } else if (image instanceof HTMLImageElement) {
          this.initialOptions_ = options;
          const onload = () => {
            this.unlistenImageChange(onload);
            if (!this.initialOptions_) {
              return;
            }
            const imageSize = this.iconImage_.getSize();
            this.setScale(
              calculateScale(
                imageSize[0],
                imageSize[1],
                options.width,
                options.height,
              ),
            );
          };
          this.listenImageChange(onload);
          return;
        }
      }
      if (width !== undefined) {
        this.setScale(
          calculateScale(width, height, options.width, options.height),
        );
      }
    }
  }

  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   * @override
   */
  clone() {
    let scale, width, height;
    if (this.initialOptions_) {
      width = this.initialOptions_.width;
      height = this.initialOptions_.height;
    } else {
      scale = this.getScale();
      scale = Array.isArray(scale) ? scale.slice() : scale;
    }
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color:
        this.color_ && this.color_.slice
          ? this.color_.slice()
          : this.color_ || undefined,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale,
      width,
      height,
      size: this.size_ !== null ? this.size_.slice() : undefined,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (
        this.anchorXUnits_ == 'fraction' ||
        this.anchorYUnits_ == 'fraction'
      ) {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == 'fraction') {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == 'fraction') {
          anchor[1] *= size[1];
        }
      }

      if (this.anchorOrigin_ != 'top-left') {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (
          this.anchorOrigin_ == 'top-right' ||
          this.anchorOrigin_ == 'bottom-right'
        ) {
          anchor[0] = -anchor[0] + size[0];
        }
        if (
          this.anchorOrigin_ == 'bottom-left' ||
          this.anchorOrigin_ == 'bottom-right'
        ) {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale = this.getScaleArray();
    // anchor is scaled by renderer but displacement should not be scaled
    // so divide by scale here
    return [
      anchor[0] - displacement[0] / scale[0],
      anchor[1] + displacement[1] / scale[1],
    ];
  }

  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }

  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }

  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   * @override
   */
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }

  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }

  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }

  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset = this.offset_;

    if (this.offsetOrigin_ != 'top-left') {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (
        this.offsetOrigin_ == 'top-right' ||
        this.offsetOrigin_ == 'bottom-right'
      ) {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (
        this.offsetOrigin_ == 'bottom-left' ||
        this.offsetOrigin_ == 'bottom-right'
      ) {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  }

  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }

  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   * @override
   */
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }

  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const scale = this.getScaleArray();
    if (this.size_) {
      return this.size_[0] * scale[0];
    }
    if (this.iconImage_.getImageState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
      return this.iconImage_.getSize()[0] * scale[0];
    }
    return undefined;
  }

  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const scale = this.getScaleArray();
    if (this.size_) {
      return this.size_[1] * scale[1];
    }
    if (this.iconImage_.getImageState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
      return this.iconImage_.getSize()[1] * scale[1];
    }
    return undefined;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   * @override
   */
  setScale(scale) {
    delete this.initialOptions_;
    super.setScale(scale);
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {
    this.iconImage_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listener);
  }

  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   * @override
   */
  load() {
    this.iconImage_.load();
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listener);
  }

  /**
   * @override
   */
  ready() {
    return this.iconImage_.ready();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Icon);


/***/ }),

/***/ "./node_modules/ol/style/IconImage.js":
/*!********************************************!*\
  !*** ./node_modules/ol/style/IconImage.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Image.js */ "./node_modules/ol/Image.js");
/* harmony import */ var _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/**
 * @module ol/style/IconImage
 */









/**
 * @type {CanvasRenderingContext2D}
 */
let taintedTestContext = null;

class IconImage extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(image, src, crossOrigin, imageState, color) {
    super();

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null}
     */
    this.image_ = image;

    /**
     * @private
     * @type {string|null}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    this.canvas_ = {};

    /**
     * @private
     * @type {import("../color.js").Color|string|null}
     */
    this.color_ = color;

    /**
     * @private
     * @type {import("../ImageState.js").default}
     */
    this.imageState_ = imageState === undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : imageState;

    /**
     * @private
     * @type {import("../size.js").Size|null}
     */
    this.size_ =
      image && image.width && image.height ? [image.width, image.height] : null;

    /**
     * @private
     * @type {string|undefined}
     */
    this.src_ = src;

    /**
     * @private
     */
    this.tainted_;

    /**
     * @private
     * @type {Promise<void>|null}
     */
    this.ready_ = null;
  }

  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }

  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === undefined && this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(1, 1, undefined, {
          willReadFrequently: true,
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }

  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  }

  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.dispatchChangeEvent_();
  }

  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.size_ = [this.image_.width, this.image_.height];
    this.dispatchChangeEvent_();
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }

  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }

  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }

  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ !== _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }

    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
    try {
      if (this.src_ !== undefined) {
        /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
      }
    } catch (e) {
      this.handleImageError_();
    }
    if (this.image_ instanceof HTMLImageElement) {
      (0,_Image_js__WEBPACK_IMPORTED_MODULE_4__.decodeFallback)(this.image_, this.src_)
        .then((image) => {
          this.image_ = image;
          this.handleImageLoad_();
        })
        .catch(this.handleImageError_.bind(this));
    }
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(pixelRatio) {
    if (
      !this.color_ ||
      this.canvas_[pixelRatio] ||
      this.imageState_ !== _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED
    ) {
      return;
    }

    const image = this.image_;
    const ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(
      Math.ceil(image.width * pixelRatio),
      Math.ceil(image.height * pixelRatio),
    );
    const canvas = ctx.canvas;

    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);

    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = (0,_color_js__WEBPACK_IMPORTED_MODULE_5__.asString)(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);

    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(image, 0, 0);

    this.canvas_[pixelRatio] = canvas;
  }

  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    if (!this.ready_) {
      this.ready_ = new Promise((resolve) => {
        if (
          this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED ||
          this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR
        ) {
          resolve();
        } else {
          const onChange = () => {
            if (
              this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED ||
              this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR
            ) {
              this.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, onChange);
              resolve();
            }
          };
          this.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, onChange);
        }
      });
    }
    return this.ready_;
  }
}

/**
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
 * @param {string|undefined} cacheKey Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default|undefined} imageState Image state.
 * @param {import("../color.js").Color|string|null} color Color.
 * @param {boolean} [pattern] Also cache a `repeat` pattern with the icon image.
 * @return {IconImage} Icon image.
 */
function get(image, cacheKey, crossOrigin, imageState, color, pattern) {
  let iconImage =
    cacheKey === undefined
      ? undefined
      : _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && 'src' in image ? image.src || undefined : cacheKey,
      crossOrigin,
      imageState,
      color,
    );
    _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  if (
    pattern &&
    iconImage &&
    !_IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.getPattern(cacheKey, crossOrigin, color)
  ) {
    _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  return iconImage;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconImage);


/***/ }),

/***/ "./node_modules/ol/style/IconImageCache.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/style/IconImageCache.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getCacheKey: () => (/* binding */ getCacheKey),
/* harmony export */   shared: () => (/* binding */ shared)
/* harmony export */ });
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/style/IconImageCache
 */




/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */
class IconImageCache {
  constructor() {
    /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */
    this.cache_ = {};

    /**
     * @type {!Object<string, CanvasPattern>}
     * @private
     */
    this.patternCache_ = {};

    /**
     * @type {number}
     * @private
     */
    this.cacheSize_ = 0;

    /**
     * @type {number}
     * @private
     */
    this.maxCacheSize_ = 1024;
  }

  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {};
    this.patternCache_ = {};
    this.cacheSize_ = 0;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }

  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let i = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          delete this.patternCache_[key];
          --this.cacheSize_;
        }
      }
    }
  }

  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(src, crossOrigin, color) {
    const key = getCacheKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  }

  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(src, crossOrigin, color) {
    const key = getCacheKey(src, crossOrigin, color);
    return key in this.patternCache_ ? this.patternCache_[key] : null;
  }

  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(src, crossOrigin, color, iconImage, pattern) {
    const key = getCacheKey(src, crossOrigin, color);
    const update = key in this.cache_;
    this.cache_[key] = iconImage;
    if (pattern) {
      if (iconImage.getImageState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
        iconImage.load();
      }
      if (iconImage.getImageState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING) {
        iconImage.ready().then(() => {
          this.patternCache_[key] = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.getSharedCanvasContext2D)().createPattern(
            iconImage.getImage(1),
            'repeat',
          );
        });
      } else {
        this.patternCache_[key] = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.getSharedCanvasContext2D)().createPattern(
          iconImage.getImage(1),
          'repeat',
        );
      }
    }
    if (!update) {
      ++this.cacheSize_;
    }
  }

  /**
   * Set the cache size of the icon cache. Default is `1024`. Change this value when
   * your map uses more than 1024 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
}

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color|string|null} color Color.
 * @return {string} Cache key.
 */
function getCacheKey(src, crossOrigin, color) {
  const colorString = color ? (0,_color_js__WEBPACK_IMPORTED_MODULE_2__.asArray)(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconImageCache);

/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
const shared = new IconImageCache();


/***/ }),

/***/ "./node_modules/ol/style/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Image.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/style/Image
 */



/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {import('../style/Style.js').DeclutterMode} declutterMode Declutter mode: `declutter`, `obstacle`, `none`.
 */

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
class ImageStyle {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;

    /**
     * @private
     * @type {boolean}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {number}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale);

    /**
     * @private
     * @type {Array<number>}
     */
    this.displacement_ = options.displacement;

    /**
     * @private
     * @type {import('../style/Style.js').DeclutterMode}
     */
    this.declutterMode_ = options.declutterMode;
  }

  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
  }

  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }

  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }

  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }

  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }

  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }

  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }

  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(pixelRatio) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return 1;
  }

  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }

  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }

  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }

  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale);
  }

  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageStyle);


/***/ }),

/***/ "./node_modules/ol/style/RegularShape.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/RegularShape.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _IconImage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IconImage.js */ "./node_modules/ol/style/IconImage.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _IconImageCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/**
 * @module ol/style/RegularShape
 */










/**
 * Specify radius for regular polygons, or both radius and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} radius Radius of a regular polygon.
 * @property {number} [radius2] Second radius to make a star instead of a regular polygon.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius` and `radius2`.
 * @property {import('./Style.js').DeclutterMode} [declutterMode] Declutter mode.
 */

/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike|undefined} strokeStyle StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when both `radius` and
 * `radius2` are provided.
 * @api
 */
class RegularShape extends _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    super({
      opacity: 1,
      rotateWithView:
        options.rotateWithView !== undefined ? options.rotateWithView : false,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: options.scale !== undefined ? options.scale : 1,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode,
    });

    /**
     * @private
     * @type {HTMLCanvasElement|null}
     */
    this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    this.radius = options.radius;

    /**
     * @private
     * @type {number|undefined}
     */
    this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_;

    /**
     * @private
     * @type {RenderOptions}
     */
    this.renderOptions_;

    /**
     * @private
     */
    this.imageState_ =
      this.fill_ && this.fill_.loading()
        ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING
        : _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    if (this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.ready().then(() => (this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED));
    }
    this.render();
  }

  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale = this.getScale();
    const style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
    style.setOpacity(this.getOpacity());
    return style;
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    const size = this.size_;
    const displacement = this.getDisplacement();
    const scale = this.getScaleArray();
    // anchor is scaled by renderer but displacement should not be scaled
    // so divide by scale here
    return [
      size[0] / 2 - displacement[0] / scale[0],
      size[1] / 2 + displacement[1] / scale[1],
    ];
  }

  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }

  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }

  /**
   * @return {HTMLCanvasElement} Image element.
   * @override
   */
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
        this.renderOptions_,
      );
    }
    return this.hitDetectionCanvas_;
  }

  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    const fillKey = this.fill_?.getKey();
    const cacheKey =
      `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` +
      Object.values(this.renderOptions_).join(',');
    let image = /** @type {HTMLCanvasElement} */ (
      _IconImageCache_js__WEBPACK_IMPORTED_MODULE_2__.shared.get(cacheKey, null, null)?.getImage(1)
    );
    if (!image) {
      const renderOptions = this.renderOptions_;
      const size = Math.ceil(renderOptions.size * pixelRatio);
      const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(size, size);
      this.draw_(renderOptions, context, pixelRatio);

      image = context.canvas;
      _IconImageCache_js__WEBPACK_IMPORTED_MODULE_2__.shared.set(
        cacheKey,
        null,
        null,
        new _IconImage_js__WEBPACK_IMPORTED_MODULE_4__["default"](image, undefined, null, _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED, null),
      );
    }
    return image;
  }

  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   * @override
   */
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }

  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.size_;
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.imageState_;
  }

  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    return this.origin_;
  }

  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }

  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius;
  }

  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }

  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   * @override
   */
  getSize() {
    return this.size_;
  }

  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {}

  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {}

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {}

  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (
      strokeWidth === 0 ||
      this.points_ === Infinity ||
      (lineJoin !== 'bevel' && lineJoin !== 'miter')
    ) {
      return strokeWidth;
    }
    // m  | ^
    // i  | |\                  .
    // t >|  #\
    // e  | |\ \              .
    // r      \s\
    //      |  \t\          .                 .
    //          \r\                      .   .
    //      |    \o\      .          .  . . .
    //          e \k\            .  .    . .
    //      |      \e\  .    .  .       . .
    //       d      \ \  .  .          . .
    //      | _ _a_ _\#  .            . .
    //   r1          / `             . .
    //      |                       . .
    //       b     /               . .
    //      |                     . .
    //           / r2            . .
    //      |                        .   .
    //         /                           .   .
    //      |α                                   .   .
    //       /                                         .   .
    //      ° center
    let r1 = this.radius;
    let r2 = this.radius2_ === undefined ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points =
      this.radius2_ === undefined ? this.points_ : this.points_ * 2;
    const alpha = (2 * Math.PI) / points;
    const a = r2 * Math.sin(alpha);
    const b = Math.sqrt(r2 * r2 - a * a);
    const d = r1 - b;
    const e = Math.sqrt(a * a + d * d);
    const miterRatio = e / a;
    if (lineJoin === 'miter' && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    // Calculate the distance from center to the stroke corner where
    // it was cut short because of the miter limit.
    //              l
    //        ----+---- <= distance from center to here is maxr
    //       /####|k ##\
    //      /#####^#####\
    //     /#### /+\# s #\
    //    /### h/+++\# t #\
    //   /### t/+++++\# r #\
    //  /### a/+++++++\# o #\
    // /### p/++ fill +\# k #\
    ///#### /+++++^+++++\# e #\
    //#####/+++++/+\+++++\#####\
    const k = strokeWidth / 2 / miterRatio;
    const l = (strokeWidth / 2) * (d / e);
    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === undefined || lineJoin === 'bevel') {
      return bevelAdd * 2;
    }
    // If outer miter is over the miter limit the inner miter may reach through the
    // center and be longer than the bevel, same calculation as above but swap r1 / r2.
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = (innerMiterRatio * strokeWidth) / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }

  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultLineCap;
    let lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(this.stroke_.getColor() ?? _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultStrokeStyle);
      strokeWidth = this.stroke_.getWidth() ?? _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultLineWidth;
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
      lineJoin = this.stroke_.getLineJoin() ?? _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultLineJoin;
      lineCap = this.stroke_.getLineCap() ?? _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultLineCap;
      miterLimit = this.stroke_.getMiterLimit() ?? _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultMiterLimit;
    }

    const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add);

    return {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit,
    };
  }

  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.hitDetectionCanvas_ = null;
    this.size_ = [size, size];
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    // set origin to canvas center
    context.translate(renderOptions.size / 2, renderOptions.size / 2);

    this.createPath_(context);

    if (this.fill_) {
      let color = this.fill_.getColor();
      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultFillStyle;
      }
      context.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(color);
      context.fill();
    }
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(renderOptions) {
    let context;
    if (this.fill_) {
      let color = this.fill_.getColor();

      // determine if fill is transparent (or pattern or gradient)
      let opacity = 0;
      if (typeof color === 'string') {
        color = (0,_color_js__WEBPACK_IMPORTED_MODULE_7__.asArray)(color);
      }
      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }
      if (opacity === 0) {
        // if a transparent fill style is set, create an extra hit-detection image
        // with a default fill style
        context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(renderOptions.size, renderOptions.size);
        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    return context ? context.canvas : this.getImage(1);
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(context) {
    let points = this.points_;
    const radius = this.radius;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === undefined ? radius : this.radius2_;
      if (this.radius2_ !== undefined) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = (2 * Math.PI) / points;
      for (let i = 0; i < points; i++) {
        const angle0 = startAngle + i * step;
        const radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(renderOptions, context) {
    // set origin to canvas center
    context.translate(renderOptions.size / 2, renderOptions.size / 2);

    this.createPath_(context);

    context.fillStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__.defaultFillStyle;
    context.fill();
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }

  /**
   * @override
   */
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegularShape);


/***/ }),

/***/ "./node_modules/ol/style/Stroke.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Stroke.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/style/Stroke
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
class Stroke {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */
    this.color_ = options.color !== undefined ? options.color : null;

    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */
    this.lineCap_ = options.lineCap;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lineDashOffset_ = options.lineDashOffset;

    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */
    this.lineJoin_ = options.lineJoin;

    /**
     * @private
     * @type {number|undefined}
     */
    this.miterLimit_ = options.miterLimit;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = options.width;
  }

  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || undefined,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth(),
    });
  }

  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }

  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }

  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }

  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }

  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }

  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }

  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }

  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }

  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }

  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }

  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }

  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }

  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(width) {
    this.width_ = width;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stroke);


/***/ }),

/***/ "./node_modules/ol/style/Style.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Style.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDefaultStyle: () => (/* binding */ createDefaultStyle),
/* harmony export */   createEditingStyle: () => (/* binding */ createEditingStyle),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   toFunction: () => (/* binding */ toFunction)
/* harmony export */ });
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stroke.js */ "./node_modules/ol/style/Stroke.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/style/Style
 */






/**
 * Defines how symbols and text are decluttered on layers ith `declutter` set to `true`
 * * **declutter**: Overlapping symbols and text are decluttered.
 * * **obstacle**: Symbols and text are rendered, but serve as obstacle for subsequent attempts
 *   to place a symbol or text at the same location.
 * * **none**: No decluttering is done.
 *
 * @typedef {"declutter"|"obstacle"|"none"} DeclutterMode
 */

/**
 * A function that takes a {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes a {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */

/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>|Array<Array<Array<import("../coordinate.js").Coordinate>>>),import("../render.js").State): void} RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */
class Style {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     */
    this.geometry_ = null;

    /**
     * @private
     * @type {!GeometryFunction}
     */
    this.geometryFunction_ = defaultGeometryFunction;

    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {import("./Image.js").default|null}
     */
    this.image_ = options.image !== undefined ? options.image : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.renderer_ = options.renderer !== undefined ? options.renderer : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.hitDetectionRenderer_ =
      options.hitDetectionRenderer !== undefined
        ? options.hitDetectionRenderer
        : null;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("./Text.js").default|null}
     */
    this.text_ = options.text !== undefined ? options.text : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.zIndex_ = options.zIndex;
  }

  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === 'object') {
      geometry = /** @type {import("../geom/Geometry.js").default} */ (
        geometry
      ).clone();
    }
    return new Style({
      geometry: geometry ?? undefined,
      fill: this.getFill() ? this.getFill().clone() : undefined,
      image: this.getImage() ? this.getImage().clone() : undefined,
      renderer: this.getRenderer() ?? undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      text: this.getText() ? this.getText().clone() : undefined,
      zIndex: this.getZIndex(),
    });
  }

  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }

  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }

  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }

  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }

  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }

  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }

  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }

  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }

  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(image) {
    this.image_ = image;
  }

  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }

  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }

  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }

  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }

  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(geometry) {
    if (typeof geometry === 'function') {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === 'string') {
      this.geometryFunction_ = function (feature) {
        return /** @type {import("../geom/Geometry.js").default} */ (
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== undefined) {
      this.geometryFunction_ = function () {
        return /** @type {import("../geom/Geometry.js").default} */ (geometry);
      };
    }
    this.geometry_ = geometry;
  }

  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
}

/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
  let styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
        typeof (/** @type {?} */ (obj).getZIndex) === 'function',
        'Expected an `Style` or an array of `Style`',
      );
      const style = /** @type {Style} */ (obj);
      styles = [style];
    }
    styleFunction = function () {
      return styles;
    };
  }
  return styleFunction;
}

/**
 * @type {Array<Style>|null}
 */
let defaultStyles = null;

/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    const fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      color: 'rgba(255,255,255,0.4)',
    });
    const stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      color: '#3399CC',
      width: 1.25,
    });
    defaultStyles = [
      new Style({
        image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          fill: fill,
          stroke: stroke,
          radius: 5,
        }),
        fill: fill,
        stroke: stroke,
      }),
    ];
  }
  return defaultStyles;
}

/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles['Polygon'] = [
    new Style({
      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        color: [255, 255, 255, 0.5],
      }),
    }),
  ];
  styles['MultiPolygon'] = styles['Polygon'];

  styles['LineString'] = [
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        color: white,
        width: width + 2,
      }),
    }),
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        color: blue,
        width: width,
      }),
    }),
  ];
  styles['MultiLineString'] = styles['LineString'];

  styles['Circle'] = styles['Polygon'].concat(styles['LineString']);

  styles['Point'] = [
    new Style({
      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        radius: width * 2,
        fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
          color: blue,
        }),
        stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          color: white,
          width: width / 2,
        }),
      }),
      zIndex: Infinity,
    }),
  ];
  styles['MultiPoint'] = styles['Point'];

  styles['GeometryCollection'] = styles['Polygon'].concat(
    styles['LineString'],
    styles['Point'],
  );

  return styles;
}

/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Style);


/***/ }),

/***/ "./node_modules/ol/style/Text.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Text.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/style/Text
 */



/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */

/**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */
const DEFAULT_FILL_COLOR = '#333';

/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number} [repeat] Repeat interval. When set, the text will be repeated at this interval, which specifies
 * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {boolean} [keepUpright=true] Whether the text can be rotated 180° to prevent being rendered upside down.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for `placement: 'line'` or the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default|null} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333). Specify `null` for no fill.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {import('../style/Style.js').DeclutterMode} [declutterMode] Declutter mode: `declutter`, `obstacle`, `none`
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */
class Text {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {string|undefined}
     */
    this.font_ = options.font;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.keepUpright_ = options.keepUpright;

    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale !== undefined ? options.scale : 1);

    /**
     * @private
     * @type {string|Array<string>|undefined}
     */
    this.text_ = options.text;

    /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */
    this.textAlign_ = options.textAlign;

    /**
     * @private
     * @type {TextJustify|undefined}
     */
    this.justify_ = options.justify;

    /**
     * @private
     * @type {number|undefined}
     */
    this.repeat_ = options.repeat;

    /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */
    this.textBaseline_ = options.textBaseline;

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    this.fill_ =
      options.fill !== undefined
        ? options.fill
        : new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({color: DEFAULT_FILL_COLOR});

    /**
     * @private
     * @type {number}
     */
    this.maxAngle_ =
      options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;

    /**
     * @private
     * @type {TextPlacement}
     */
    this.placement_ =
      options.placement !== undefined ? options.placement : 'point';

    /**
     * @private
     * @type {boolean}
     */
    this.overflow_ = !!options.overflow;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {number}
     */
    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;

    /**
     * @private
     * @type {number}
     */
    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;

    /**
     * @private
     * @type {import("./Fill.js").default|null}
     */
    this.backgroundFill_ = options.backgroundFill
      ? options.backgroundFill
      : null;

    /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */
    this.backgroundStroke_ = options.backgroundStroke
      ? options.backgroundStroke
      : null;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.padding_ = options.padding === undefined ? null : options.padding;

    /**
     * @private
     * @type {import('../style/Style.js').DeclutterMode}
     */
    this.declutterMode_ = options.declutterMode;
  }

  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      keepUpright: this.getKeepUpright(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill()
        ? this.getBackgroundFill().clone()
        : undefined,
      backgroundStroke: this.getBackgroundStroke()
        ? this.getBackgroundStroke().clone()
        : undefined,
      padding: this.getPadding() || undefined,
      declutterMode: this.getDeclutterMode(),
    });
  }

  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }

  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }

  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }

  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }

  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }

  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }

  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }

  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }

  /**
   * Determine whether the text can be rendered upside down.
   * @return {boolean|undefined} Keep text upright.
   * @api
   */
  getKeepUpright() {
    return this.keepUpright_;
  }

  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }

  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }

  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }

  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }

  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }

  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }

  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }

  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }

  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }

  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }

  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }

  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }

  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(font) {
    this.font_ = font;
  }

  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }

  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }

  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }

  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(placement) {
    this.placement_ = placement;
  }

  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }

  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }

  /**
   * Set whether the text can be rendered upside down.
   *
   * @param {boolean} keepUpright Keep text upright.
   * @api
   */
  setKeepUpright(keepUpright) {
    this.keepUpright_ = keepUpright;
  }

  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }

  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale !== undefined ? scale : 1);
  }

  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }

  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }

  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }

  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(justify) {
    this.justify_ = justify;
  }

  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }

  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }

  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }

  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(padding) {
    this.padding_ = padding;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Text);


/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   fromKey: () => (/* binding */ fromKey),
/* harmony export */   getCacheKeyForTileKey: () => (/* binding */ getCacheKeyForTileKey),
/* harmony export */   getKey: () => (/* binding */ getKey),
/* harmony export */   getKeyZXY: () => (/* binding */ getKeyZXY),
/* harmony export */   hash: () => (/* binding */ hash),
/* harmony export */   hashZXY: () => (/* binding */ hashZXY),
/* harmony export */   withinExtentAndZ: () => (/* binding */ withinExtentAndZ)
/* harmony export */ });
/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, tileCoord) {
  if (tileCoord !== undefined) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}

/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}

/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */
function getCacheKeyForTileKey(tileKey) {
  const [z, x, y] = tileKey
    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)
    .split(',')
    .map(Number);
  return getKeyZXY(z, x, y);
}

/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}

/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}

/**
 * @param {number} z The tile z coordinate.
 * @param {number} x The tile x coordinate.
 * @param {number} y The tile y coordinate.
 * @return {number} Hash.
 */
function hashZXY(z, x, y) {
  return (x << z) + y;
}

/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}


/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TileGrid: () => (/* reexport safe */ _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   WMTS: () => (/* reexport safe */ _tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   createForExtent: () => (/* binding */ createForExtent),
/* harmony export */   createForProjection: () => (/* binding */ createForProjection),
/* harmony export */   createXYZ: () => (/* binding */ createXYZ),
/* harmony export */   extentFromProjection: () => (/* binding */ extentFromProjection),
/* harmony export */   getForProjection: () => (/* binding */ getForProjection),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _tilegrid_WMTS_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilegrid/WMTS.js */ "./node_modules/ol/tilegrid/WMTS.js");
/**
 * @module ol/tilegrid
 */









/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}

/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.containsCoordinate)(projectionExtent, center)) {
    const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getWidth)(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth,
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== undefined ? corner : 'top-left';

  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
    extent: extent,
    origin: (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: tileSize,
  });
}

/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(options) {
  const xyzOptions = options || {};

  const extent = xyzOptions.extent || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:3857').getExtent();

  const gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution,
    ),
  };
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__["default"](gridOptions);
}

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== undefined ? maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_MAX_ZOOM;
  tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(tileSize !== undefined ? tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_TILE_SIZE);

  const height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(extent);
  const width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getWidth)(extent);

  maxResolution =
    maxResolution > 0
      ? maxResolution
      : Math.max(width / tileSize[0], height / tileSize[1]);

  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}

/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half =
      (180 * _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdate)(-half, -half, half, half);
  }
  return extent;
}


/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/tilegrid/TileGrid
 */










/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
const tmpTileCoord = [0, 0, 0];

/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */
const DECIMALS = 5;

/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
class TileGrid {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

    /**
     * @private
     * @type {!Array<number>}
     */
    this.resolutions_ = options.resolutions;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.isSorted)(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, b) => b - a,
        true,
      ),
      '`resolutions` must be sorted in descending order',
    );

    // check if we've got a consistent zoom factor and origin
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }

    /**
     * @private
     * @type {number|undefined}
     */
    this.zoomFactor_ = zoomFactor;

    /**
     * @protected
     * @type {number}
     */
    this.maxZoom = this.resolutions_.length - 1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    this.origin_ = options.origin !== undefined ? options.origin : null;

    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */
    this.origins_ = null;
    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
        this.origins_.length == this.resolutions_.length,
        'Number of `origins` and `resolutions` must be equal',
      );
    }

    const extent = options.extent;

    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(extent);
    }

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
      'Either `origin` or `origins` must be configured, never both',
    );

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */
    this.tileSizes_ = null;
    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
        this.tileSizes_.length == this.resolutions_.length,
        'Number of `tileSizes` and `resolutions` must be equal',
      );
    }

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.tileSize_ =
      options.tileSize !== undefined
        ? options.tileSize
        : !this.tileSizes_
          ? _common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE
          : null;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (!this.tileSize_ && this.tileSizes_) ||
        (this.tileSize_ && !this.tileSizes_),
      'Either `tileSize` or `tileSizes` must be configured, never both',
    );

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = extent !== undefined ? extent : null;

    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */
    this.fullTileRanges_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.tmpSize_ = [0, 0];

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.tmpExtent_ = [0, 0, 0, 0];

    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map((size, z) => {
        const tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_4__["default"](
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1),
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }

  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(
    tileCoord,
    callback,
    tempTileRange,
    tempExtent,
  ) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (x !== undefined && y !== undefined) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange,
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }

  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }

  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }

  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }

  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }

  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }

  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange,
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_,
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange,
      );
    }
    return null;
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }

    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];

    if (z === tileCoordZ) {
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange,
      );
    }

    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, minX, minY, minY, tempTileRange);
      }

      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
    }

    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }

  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,
    ];
  }

  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(minX, minY, maxX, maxY, tempExtent);
  }

  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord,
    );
  }

  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(
    x,
    y,
    resolution,
    reverseIntersectionPolicy,
    opt_tileCoord,
  ) {
    const z = this.getZForResolution(resolution);
    const scale = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);

    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];
    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  }

  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);

    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  }

  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord,
    );
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }

  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }

  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_
        ? this.getTileRangeForExtentAndZ(this.extent_, z)
        : null;
    }
    return this.fullTileRanges_[z];
  }

  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.linearFindNearest)(
      this.resolutions_,
      resolution,
      opt_direction || 0,
    );
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(z, this.minZoom, this.maxZoom);
  }

  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return (0,_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__.intersectsLinearRing)(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord),
    );
  }

  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileGrid);


/***/ }),

/***/ "./node_modules/ol/tilegrid/WMTS.js":
/*!******************************************!*\
  !*** ./node_modules/ol/tilegrid/WMTS.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createFromCapabilitiesMatrixSet: () => (/* binding */ createFromCapabilitiesMatrixSet),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/tilegrid/WMTS
 */




/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
 * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.
 * When no `origin` or `origins` are configured, the `origin` will be set to the
 * top-left corner of the extent.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
 * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
 * to right and downwards. If not specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
 * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
 * given, the array length should match the length of the `resolutions` array, i.e.
 * each resolution can have a different origin. Tile coordinates increase left to
 * right and downwards. If not specified, `extent` or `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each
 * resolution needs to match the zoom level. This means that even if a `minZoom`
 * is configured, the resolutions array will have a length of `maxZoom + 1`
 * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
 * to match the length of the `resolutions` array.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
 * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent for
 * which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. The length of
 * this array needs to match the length of the `resolutions` array.
 */

/**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * @api
 */
class WMTSTileGrid extends _TileGrid_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(options) {
    super({
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes,
    });

    /**
     * @private
     * @type {!Array<string>}
     */
    this.matrixIds_ = options.matrixIds;
  }

  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(z) {
    return this.matrixIds_[z];
  }

  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WMTSTileGrid);

/**
 * Create a tile grid from a WMTS capabilities matrix set and an
 * optional TileMatrixSetLimits.
 * @param {Object} matrixSet An object representing a matrixSet in the
 *     capabilities document.
 * @param {import("../extent.js").Extent} [extent] An optional extent to restrict the tile
 *     ranges the server provides.
 * @param {Array<Object>} [matrixLimits] An optional object representing
 *     the available matrices for tileGrid.
 * @return {WMTSTileGrid} WMTS tileGrid instance.
 * @api
 */
function createFromCapabilitiesMatrixSet(
  matrixSet,
  extent,
  matrixLimits,
) {
  /** @type {!Array<number>} */
  const resolutions = [];
  /** @type {!Array<string>} */
  const matrixIds = [];
  /** @type {!Array<import("../coordinate.js").Coordinate>} */
  const origins = [];
  /** @type {!Array<number|import("../size.js").Size>} */
  const tileSizes = [];
  /** @type {!Array<import("../size.js").Size>} */
  const sizes = [];

  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];

  const supportedCRSPropName = 'SupportedCRS';
  const matrixIdsPropName = 'TileMatrix';
  const identifierPropName = 'Identifier';
  const scaleDenominatorPropName = 'ScaleDenominator';
  const topLeftCornerPropName = 'TopLeftCorner';
  const tileWidthPropName = 'TileWidth';
  const tileHeightPropName = 'TileHeight';

  const code = matrixSet[supportedCRSPropName];
  const projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code);
  const metersPerUnit = projection.getMetersPerUnit();
  // swap origin x and y coordinates if axis orientation is lat/long
  const switchOriginXY = projection.getAxisOrientation().startsWith('ne');

  matrixSet[matrixIdsPropName].sort(function (a, b) {
    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
  });

  matrixSet[matrixIdsPropName].forEach(function (elt) {
    let matrixAvailable;
    // use of matrixLimits to filter TileMatrices from GetCapabilities
    // TileMatrixSet from unavailable matrix levels.
    if (matrixLimits.length > 0) {
      matrixAvailable = matrixLimits.find(function (elt_ml) {
        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
          return true;
        }
        // Fallback for tileMatrix identifiers that don't get prefixed
        // by their tileMatrixSet identifiers.
        if (!elt[identifierPropName].includes(':')) {
          return (
            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===
            elt_ml[matrixIdsPropName]
          );
        }
        return false;
      });
    } else {
      matrixAvailable = true;
    }

    if (matrixAvailable) {
      matrixIds.push(elt[identifierPropName]);
      const resolution =
        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;
      const tileWidth = elt[tileWidthPropName];
      const tileHeight = elt[tileHeightPropName];
      if (switchOriginXY) {
        origins.push([
          elt[topLeftCornerPropName][1],
          elt[topLeftCornerPropName][0],
        ]);
      } else {
        origins.push(elt[topLeftCornerPropName]);
      }
      resolutions.push(resolution);
      tileSizes.push(
        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight],
      );
      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);
    }
  });

  return new WMTSTileGrid({
    extent: extent,
    origins: origins,
    resolutions: resolutions,
    matrixIds: matrixIds,
    tileSizes: tileSizes,
    sizes: sizes,
  });
}


/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_MAX_ZOOM: () => (/* binding */ DEFAULT_MAX_ZOOM),
/* harmony export */   DEFAULT_TILE_SIZE: () => (/* binding */ DEFAULT_TILE_SIZE)
/* harmony export */ });
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
const DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
const DEFAULT_TILE_SIZE = 256;


/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createFromTemplate: () => (/* binding */ createFromTemplate),
/* harmony export */   createFromTemplates: () => (/* binding */ createFromTemplates),
/* harmony export */   createFromTileUrlFunctions: () => (/* binding */ createFromTileUrlFunctions),
/* harmony export */   expandUrl: () => (/* reexport safe */ _uri_js__WEBPACK_IMPORTED_MODULE_0__.expandUrl),
/* harmony export */   nullTileUrlFunction: () => (/* binding */ nullTileUrlFunction)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _uri_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uri.js */ "./node_modules/ol/uri.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tileurlfunction
 */




/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default|null} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      let maxY;
      const z = tileCoord[0];
      if (tileGrid) {
        // The `{-y}` placeholder only works for sources that have a tile grid at construction
        const range = tileGrid.getFullTileRange(z);
        if (range) {
          maxY = range.getHeight() - 1;
        }
      }
      return (0,_uri_js__WEBPACK_IMPORTED_MODULE_0__.renderXYZTemplate)(template, z, tileCoord[1], tileCoord[2], maxY);
    }
  );
}

/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}

/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      const h = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.hash)(tileCoord);
      const index = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}

/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}

/**
 * TODO: Update ol-mapbox-style to import this from the uri.js module.
 */



/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   compose: () => (/* binding */ compose),
/* harmony export */   composeCssTransform: () => (/* binding */ composeCssTransform),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   makeInverse: () => (/* binding */ makeInverse),
/* harmony export */   makeScale: () => (/* binding */ makeScale),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   reset: () => (/* binding */ reset),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setFromArray: () => (/* binding */ setFromArray),
/* harmony export */   toString: () => (/* binding */ toString),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/transform
 */


/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */
const tmp_ = new Array(6);

/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}

/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}

/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  const a1 = transform1[0];
  const b1 = transform1[1];
  const c1 = transform1[2];
  const d1 = transform1[3];
  const e1 = transform1[4];
  const f1 = transform1[5];
  const a2 = transform2[0];
  const b2 = transform2[1];
  const c2 = transform2[2];
  const d2 = transform2[3];
  const e2 = transform2[4];
  const f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}

/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}

/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}

/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}

/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}

/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}

/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}

/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */
function invert(source) {
  return makeInverse(source, source);
}

/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */
function makeInverse(target, source) {
  const det = determinant(source);
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(det !== 0, 'Transformation matrix cannot be inverted');

  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];

  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;

  return target;
}

/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

/**
 * @type {Array}
 */
const matrixPrecision = [1e6, 1e6, 1e6, 1e6, 2, 2];

/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */
function toString(mat) {
  const transformString =
    'matrix(' +
    mat
      .map(
        (value, i) =>
          Math.round(value * matrixPrecision[i]) / matrixPrecision[i],
      )
      .join(', ') +
    ')';
  return transformString;
}


/***/ }),

/***/ "./node_modules/ol/uri.js":
/*!********************************!*\
  !*** ./node_modules/ol/uri.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendParams: () => (/* binding */ appendParams),
/* harmony export */   expandUrl: () => (/* binding */ expandUrl),
/* harmony export */   pickUrl: () => (/* binding */ pickUrl),
/* harmony export */   renderXYZTemplate: () => (/* binding */ renderXYZTemplate)
/* harmony export */ });
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/uri
 */




/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
function appendParams(uri, params) {
  /** @type {Array<string>} */
  const keyParams = [];
  // Skip any null or undefined parameter values
  Object.keys(params).forEach(function (k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  const qs = keyParams.join('&');
  // remove any trailing ? or &
  uri = uri.replace(/[?&]$/, '');
  // append ? or & depending on whether uri has existing parameters
  uri += uri.includes('?') ? '&' : '?';
  return uri + qs;
}

const zRegEx = /\{z\}/g;
const xRegEx = /\{x\}/g;
const yRegEx = /\{y\}/g;
const dashYRegEx = /\{-y\}/g;

/**
 * @param {string} template The URL template.  Should have `{x}`, `{y}`, and `{z}` placeholders.  If
 * the template has a `{-y}` placeholder, the `maxY` parameter must be supplied.
 * @param {number} z The tile z coordinate.
 * @param {number} x The tile x coordinate.
 * @param {number} y The tile y coordinate.
 * @param {number} [maxY] The maximum y coordinate at the given z level.
 * @return {string} The URL.
 */
function renderXYZTemplate(template, z, x, y, maxY) {
  return template
    .replace(zRegEx, z.toString())
    .replace(xRegEx, x.toString())
    .replace(yRegEx, y.toString())
    .replace(dashYRegEx, function () {
      if (maxY === undefined) {
        throw new Error(
          'If the URL template has a {-y} placeholder, the grid extent must be known',
        );
      }
      return (maxY - y).toString();
    });
}

/**
 * @param {Array<string>} urls List of URLs.
 * @param {number} z The tile z coordinate.
 * @param {number} x The tile x coordinate.
 * @param {number} y The tile y coordinate.
 * @return {string} The chosen URL.
 */
function pickUrl(urls, z, x, y) {
  const hash = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_0__.hashZXY)(z, x, y);
  const index = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.modulo)(hash, urls.length);
  return urls[index];
}

/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}


/***/ }),

/***/ "./node_modules/ol/util.js":
/*!*********************************!*\
  !*** ./node_modules/ol/util.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   abstract: () => (/* binding */ abstract),
/* harmony export */   getUid: () => (/* binding */ getUid)
/* harmony export */ });
/**
 * @module ol/util
 */

/**
 * @return {never} Any return.
 */
function abstract() {
  throw new Error('Unimplemented abstract method.');
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
let uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

/**
 * OpenLayers version.
 * @type {string}
 */
const VERSION = '10.3.1';


/***/ }),

/***/ "./node_modules/ol/vec/mat4.js":
/*!*************************************!*\
  !*** ./node_modules/ol/vec/mat4.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   fromTransform: () => (/* binding */ fromTransform),
/* harmony export */   orthographic: () => (/* binding */ orthographic),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   translation: () => (/* binding */ translation)
/* harmony export */ });
/**
 * @module ol/vec/mat4
 */

/** @typedef {Array<number>} Mat4 */

/**
 * @return {Mat4} "4x4 matrix representing a 3D identity transform."
 */
function create() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

/**
 * @param {Mat4} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Mat4} "2D transformation matrix as flattened 4x4 matrix."
 */
function fromTransform(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @param {Mat4} [out] mat4 frustum matrix will be written into
 * @return {Mat4} out
 */
function orthographic(left, right, bottom, top, near, far, out) {
  out = out ?? create();
  const lr = 1 / (left - right),
    bt = 1 / (bottom - top),
    nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {Mat4} m The matrix to scale.
 * @param {number} x How much to scale in the x direction.
 * @param {number} y How much to scale in the y direction.
 * @param {number} z How much to scale in the z direction.
 * @param {Mat4} [out] The matrix to write to.
 * @return {Mat4} out
 **/
function scale(m, x, y, z, out) {
  out = out ?? create();
  out[0] = m[0] * x;
  out[1] = m[1] * x;
  out[2] = m[2] * x;
  out[3] = m[3] * x;
  out[4] = m[4] * y;
  out[5] = m[5] * y;
  out[6] = m[6] * y;
  out[7] = m[7] * y;
  out[8] = m[8] * z;
  out[9] = m[9] * z;
  out[10] = m[10] * z;
  out[11] = m[11] * z;
  out[12] = m[12];
  out[13] = m[13];
  out[14] = m[14];
  out[15] = m[15];
  return out;
}

/**
 * Translate a matrix.
 *
 * @param {Mat4} m the matrix to translate
 * @param {number} x How much to translate in the x direction.
 * @param {number} y How much to translate in the y direction.
 * @param {number} z How much to translate in the z direction.
 * @param {Mat4} [out] the receiving matrix
 * @return {Mat4} out
 */
function translate(m, x, y, z, out) {
  out = out ?? create();
  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;

  if (m === out) {
    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];
    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];
  } else {
    a00 = m[0];
    a01 = m[1];
    a02 = m[2];
    a03 = m[3];
    a10 = m[4];
    a11 = m[5];
    a12 = m[6];
    a13 = m[7];
    a20 = m[8];
    a21 = m[9];
    a22 = m[10];
    a23 = m[11];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + m[12];
    out[13] = a01 * x + a11 * y + a21 * z + m[13];
    out[14] = a02 * x + a12 * y + a22 * z + m[14];
    out[15] = a03 * x + a13 * y + a23 * z + m[15];
  }

  return out;
}

/**
 * @param {number} x x translation.
 * @param {number} y y translation.
 * @param {number} z z translation.
 * @param {Mat4} [out] optional matrix to store result
 * @return {Mat4} out
 */
function translation(x, y, z, out) {
  out = out ?? create();

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = x;
  out[13] = y;
  out[14] = z;
  out[15] = 1;

  return out;
}


/***/ }),

/***/ "./node_modules/ol/webgl/Canvas.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/webgl/Canvas.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Canvas: () => (/* binding */ Canvas),
/* harmony export */   createProgram: () => (/* binding */ createProgram)
/* harmony export */ });
/* harmony import */ var _vec_mat4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vec/mat4.js */ "./node_modules/ol/vec/mat4.js");


/**
 * @module ol/webgl/Canvas
 */

const VERTEX_SHADER = `
  attribute vec4 a_position;
  attribute vec4 a_texcoord;

  uniform mat4 u_matrix;
  uniform mat4 u_textureMatrix;

  varying vec2 v_texcoord;

  void main() {
    gl_Position = u_matrix * a_position;
    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;
    v_texcoord = texcoord;
  }
`;

const FRAGMENT_SHADER = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (
      v_texcoord.x < 0.0 ||
      v_texcoord.y < 0.0 ||
      v_texcoord.x > 1.0 ||
      v_texcoord.y > 1.0
    ) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;

/** @typedef {import("../transform.js").Transform} Matrix */

/**
 * Canvas-like operations implemented in webgl.
 */
class Canvas {
  /**
   * @param {WebGLRenderingContext} gl Context to render in.
   */
  constructor(gl) {
    /**
     * @private
     * @type {WebGLRenderingContext}
     */
    this.gl_ = gl;

    /**
     * @private
     * @type {WebGLProgram}
     */
    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);

    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');
    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');

    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');
    this.textureMatrixLocation = gl.getUniformLocation(
      this.program_,
      'u_textureMatrix',
    );
    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');

    this.positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.positions),
      gl.STATIC_DRAW,
    );

    this.texcoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);

    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.texcoords),
      gl.STATIC_DRAW,
    );
  }

  /**
   * 2dContext drawImage call implemented in webgl.
   * Unlike images, textures do not have a width and height associated
   * with them so we'll pass in the width and height of the texture.
   *
   * @param {WebGLTexture} tex Image to draw.
   * @param {number} texWidth Image width.
   * @param {number} texHeight Image height.
   * @param {number} srcX Top-left x-point to read src image.
   * @param {number} srcY Top-left y-point to read src image.
   * @param {number} [srcWidth] Width of source to read.
   * @param {number} [srcHeight] Height of source to read.
   * @param {number} [dstX] Top-left x-point of destination.
   * @param {number} [dstY] Top-left y-point of destination.
   * @param {number} [dstWidth] Width of written image in destination.
   * @param {number} [dstHeight] Height of written image in destination.
   * @param {number} [width] Width of canvas.
   * @param {number} [height] Height of canvas.
   */
  drawImage(
    tex,
    texWidth,
    texHeight,
    srcX,
    srcY,
    srcWidth,
    srcHeight,
    dstX,
    dstY,
    dstWidth,
    dstHeight,
    width,
    height,
  ) {
    const gl = this.gl_;

    if (dstX === undefined) {
      dstX = srcX;
    }
    if (dstY === undefined) {
      dstY = srcY;
    }
    if (srcWidth === undefined) {
      srcWidth = texWidth;
    }
    if (srcHeight === undefined) {
      srcHeight = texHeight;
    }
    if (dstWidth === undefined) {
      dstWidth = srcWidth;
    }
    if (dstHeight === undefined) {
      dstHeight = srcHeight;
    }
    if (width === undefined) {
      width = gl.canvas.width;
    }
    if (height === undefined) {
      height = gl.canvas.height;
    }

    gl.bindTexture(gl.TEXTURE_2D, tex);

    gl.useProgram(this.program_);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.enableVertexAttribArray(this.positionLocation);
    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    gl.enableVertexAttribArray(this.texcoordLocation);
    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);

    // matrix for converting pixels to clip space
    let matrix = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_0__.orthographic(0, width, 0, height, -1, 1);
    matrix = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_0__.translate(matrix, dstX, dstY, 0);
    matrix = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_0__.scale(matrix, dstWidth, dstHeight, 1);
    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);

    let texMatrix = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_0__.translation(srcX / texWidth, srcY / texHeight, 0);
    texMatrix = _vec_mat4_js__WEBPACK_IMPORTED_MODULE_0__.scale(
      texMatrix,
      srcWidth / texWidth,
      srcHeight / texHeight,
      1,
    );

    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);
    gl.uniform1i(this.textureLocation, 0);
    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);
  }
}

/**
 * @param {WebGLRenderingContext} gl Rendering Context.
 * @param {GLenum} type Type of shader.
 * @param {string} source source of shader.
 * @return {WebGLShader} [progam] The program.
 */
function createShader(gl, type, source) {
  const shader = gl.createShader(type);

  if (shader === null) {
    throw new Error('Shader compilation failed');
  }

  gl.shaderSource(shader, source);

  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    const log = gl.getShaderInfoLog(shader);
    if (log === null) {
      throw new Error('Shader info log creation failed');
    }
    throw new Error(log);
  }

  return shader;
}

/**
 * @param {WebGLRenderingContext} gl Rendering Context.
 * @param {string} fragmentSource Fragment shader source.
 * @param {string} vertexSource Vertex shader source.
 * @return {WebGLProgram} [progam] The program.
 */
function createProgram(gl, fragmentSource, vertexSource) {
  const program = gl.createProgram();

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
  if (program === null) {
    throw new Error('Program creation failed');
  }

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    const log = gl.getProgramInfoLog(program);
    if (log === null) {
      throw new Error('Program info log creation failed');
    }
    throw new Error();
  }
  return program;
}


/***/ }),

/***/ "./node_modules/quickselect/index.js":
/*!*******************************************!*\
  !*** ./node_modules/quickselect/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });

/**
 * Rearranges items so that all items in the [left, k] are the smallest.
 * The k-th element will have the (k - left + 1)-th smallest value in [left, right].
 *
 * @template T
 * @param {T[]} arr the array to partially sort (in place)
 * @param {number} k middle index for partial sorting (as defined above)
 * @param {number} [left=0] left index of the range to sort
 * @param {number} [right=arr.length-1] right index
 * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function
 */
function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {

    while (right > left) {
        if (right - left > 600) {
            const n = right - left + 1;
            const m = k - left + 1;
            const z = Math.log(n);
            const s = 0.5 * Math.exp(2 * z / 3);
            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselect(arr, k, newLeft, newRight, compare);
        }

        const t = arr[k];
        let i = left;
        /** @type {number} */
        let j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

/**
 * @template T
 * @param {T[]} arr
 * @param {number} i
 * @param {number} j
 */
function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * @template T
 * @param {T} a
 * @param {T} b
 * @returns {number}
 */
function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}


/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RBush)
/* harmony export */ });
/* harmony import */ var quickselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/index.js");


class RBush {
    constructor(maxEntries = 9) {
        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
    }

    all() {
        return this._all(this.data, []);
    }

    search(bbox) {
        let node = this.data;
        const result = [];

        if (!intersects(bbox, node)) return result;

        const toBBox = this.toBBox;
        const nodesToSearch = [];

        while (node) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    }

    collides(bbox) {
        let node = this.data;

        if (!intersects(bbox, node)) return false;

        const nodesToSearch = [];
        while (node) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childBBox = node.leaf ? this.toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    }

    load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (let i = 0; i < data.length; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        let node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                const tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    }

    insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    }

    clear() {
        this.data = createNode([]);
        return this;
    }

    remove(item, equalsFn) {
        if (!item) return this;

        let node = this.data;
        const bbox = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i, parent, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                const index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    }

    toBBox(item) { return item; }

    compareMinX(a, b) { return a.minX - b.minX; }
    compareMinY(a, b) { return a.minY - b.minY; }

    toJSON() { return this.data; }

    fromJSON(data) {
        this.data = data;
        return this;
    }

    _all(node, result) {
        const nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push(...node.children);
            else nodesToSearch.push(...node.children);

            node = nodesToSearch.pop();
        }
        return result;
    }

    _build(items, left, right, height) {

        const N = right - left + 1;
        let M = this._maxEntries;
        let node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        const N2 = Math.ceil(N / M);
        const N1 = N2 * Math.ceil(Math.sqrt(M));

        multiSelect(items, left, right, N1, this.compareMinX);

        for (let i = left; i <= right; i += N1) {

            const right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (let j = i; j <= right2; j += N2) {

                const right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    }

    _chooseSubtree(bbox, node, level, path) {
        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            let minArea = Infinity;
            let minEnlargement = Infinity;
            let targetNode;

            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const area = bboxArea(child);
                const enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    }

    _insert(item, level, isNode) {
        const bbox = isNode ? item : this.toBBox(item);
        const insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        const node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    }

    // split overflowed node into two
    _split(insertPath, level) {
        const node = insertPath[level];
        const M = node.children.length;
        const m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        const splitIndex = this._chooseSplitIndex(node, m, M);

        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    }

    _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    }

    _chooseSplitIndex(node, m, M) {
        let index;
        let minOverlap = Infinity;
        let minArea = Infinity;

        for (let i = m; i <= M - m; i++) {
            const bbox1 = distBBox(node, 0, i, this.toBBox);
            const bbox2 = distBBox(node, i, M, this.toBBox);

            const overlap = intersectionArea(bbox1, bbox2);
            const area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index || M - m;
    }

    // sorts node children by the best axis for split
    _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m, M, compareMinX);
        const yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    }

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);

        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m, toBBox);
        const rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

        for (let i = m; i < M - m; i++) {
            const child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (let i = M - m - 1; i >= m; i--) {
            const child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    }

    _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (let i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    }

    _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (let i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    }
}

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (let i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (let i = k; i < p; i++) {
        const child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    const minX = Math.max(a.minX, b.minX);
    const minY = Math.max(a.minY, b.minY);
    const maxX = Math.min(a.maxX, b.maxX);
    const maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    const stack = [left, right];

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        const mid = left + Math.ceil((right - left) / n / 2) * n;
        (0,quickselect__WEBPACK_IMPORTED_MODULE_0__["default"])(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_Map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/Map */ "./node_modules/ol/Map.js");
/* harmony import */ var ol_source_OSM__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/source/OSM */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_View__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/View */ "./node_modules/ol/View.js");




const map = new ol_Map__WEBPACK_IMPORTED_MODULE_0__["default"]({
    target: 'map',
    layers: [
        new ol_layer_Tile__WEBPACK_IMPORTED_MODULE_1__["default"]({
            source: new ol_source_OSM__WEBPACK_IMPORTED_MODULE_2__["default"](),
        }),
    ],
    view: new ol_View__WEBPACK_IMPORTED_MODULE_3__["default"]({
        center: [0, 0],
        zoom: 2,
    }),
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUM4Qjs7QUFFOUIsaUVBQWUsS0FBSzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBLEtBQUssa0RBQUs7QUFDVixVQUFVLGtEQUFLO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN6SkEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JKRDtBQUMrQjtBQUNLO0FBQ0E7O0FBRXJCO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyx1REFBSzs7QUFFbkI7O0FBRUEsdUNBQXVDLDBEQUFHLE9BQU8sMERBQUc7QUFDcEQsdUNBQXVDLDBEQUFHLE9BQU8sMERBQUc7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywwREFBRztBQUNkOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQzJCOztBQUUzQixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7QUFHRjtBQUNBLCtDQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQjtBQUNBOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLFNBQVMsK0NBQUc7QUFDWjtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQzs7QUFFckIsK0NBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBRztBQUNILFNBQVMsK0NBQUcsT0FBTywrQ0FBRztBQUN0Qjs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBNEI7O0FBRTVCLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQyxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLCtDQUFHO0FBQ1YsT0FBTywrQ0FBRztBQUNWLE9BQU8sK0NBQUc7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBRztBQUNIOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBLE1BQU0sK0NBQUc7QUFDVCxNQUFNLCtDQUFHO0FBQ1QsTUFBTSwrQ0FBRzs7QUFFVDtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLCtDQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUEsaUVBQWUsR0FBRyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0luQjtBQUNBO0FBQ0E7QUFDcUM7QUFDc0I7QUFDckI7O0FBRXRDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQix1Q0FBdUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ08sOEJBQThCLHdEQUFLO0FBQzFDO0FBQ0EsYUFBYSw0Q0FBNEM7QUFDekQsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrREFBbUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQyw0QkFBNEIsK0RBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDLDRCQUE0QiwrREFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQyw0QkFBNEIsK0RBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxVQUFVLEVBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ3ZVMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQkY7QUFDQTtBQUNBO0FBQzZCO0FBQ1U7QUFDUTs7QUFFL0M7QUFDQSxhQUFhLGlFQUFpRTtBQUM5RTs7QUFFQTtBQUNBLGFBQWEsb0RBQW9EO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQzs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLDhEQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxPQUFPLHlCQUF5QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLG9DQUFvQztBQUNsRCxjQUFjLDJCQUEyQjtBQUN6QztBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7O0FBRUEsdUJBQXVCLGdEQUFJO0FBQzNCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0IscURBQVM7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFTLHdCQUF3QixxREFBUztBQUNqRTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFTO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFEQUFTO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUIscURBQVM7QUFDOUI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQzs7Ozs7Ozs7Ozs7Ozs7O0FDek54QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFVBQVUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25DMUI7QUFDQTtBQUNBO0FBQzZDO0FBQ0M7QUFDTDtBQUNrQjtBQUNMO0FBQ2I7O0FBRXpDO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRSxLQUFLLE9BQU87QUFDWixxQkFBcUIsNkNBQTZDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkU7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLDhCQUE4QjtBQUM1QyxjQUFjLDBDQUEwQztBQUN4RDtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLG1DQUFtQztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOENBQThDO0FBQ3pGLElBQUksb0RBQW9EO0FBQ3hEO0FBQ0E7QUFDQSx3QkFBd0IscURBQXFEO0FBQzdFO0FBQ0E7QUFDQSxhQUFhLDJNQUEyTTtBQUN4TjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsb0RBQW9EO0FBQy9GO0FBQ0EsYUFBYSwyTUFBMk07QUFDeE47O0FBRUEsMkJBQTJCLHlEQUFXO0FBQ3RDO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSwrREFBK0Q7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDRDQUE0QyxzREFBVTs7QUFFdEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFTO0FBQ2hDOztBQUVBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5Qjs7QUFFQTtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFVO0FBQ2hDO0FBQ0EscUJBQXFCLHNEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBVTtBQUNuQyxXQUFXO0FBQ1g7QUFDQSx5QkFBeUIsc0RBQVU7QUFDbkMsa0NBQWtDO0FBQ2xDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ087QUFDUCx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksc0RBQVUsTUFBTSw0REFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxpQkFBaUIsaURBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSixzQkFBc0Isc0RBQVUsTUFBTSw0REFBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFhO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsWUFBWSwyQkFBMkI7QUFDdkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQVksSUFBSSx3REFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7Ozs7O0FDcFY1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiRjtBQUNBO0FBQ0E7QUFDNkI7QUFDVTtBQUNRO0FBQ1I7O0FBRXZDLHdCQUF3QixnREFBSTtBQUM1QjtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pELGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMscURBQXFEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSxtQkFBbUIscURBQVM7QUFDNUIsTUFBTTtBQUNOLG1CQUFtQixxREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix5Q0FBeUM7QUFDekMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVM7QUFDL0IsbUJBQW1CLHFEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVM7QUFDL0IsbUJBQW1CLHFEQUFTO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0EsY0FBYyw4REFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsU0FBUyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNwTXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsT0FBTyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdIdkI7QUFDQTtBQUNBO0FBQ3FDO0FBQ0k7QUFDa0I7QUFDQTtBQUNiO0FBQ1Q7QUFDbUI7QUFDTDtBQUNjO0FBQ047QUFDdEI7QUFDUTtBQUNGO0FBQ1E7QUFDRztBQUNGO0FBQ007QUFDN0I7QUFDUTtBQUNnQztBQUNqQztBQUlaO0FBQ1k7QUFPZjtBQUM2QztBQUNRO0FBQ3hDO0FBQzZCO0FBQzlCO0FBQ0M7QUFDZ0I7QUFDaEI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsMkJBQTJCO0FBQ3pDLGNBQWMsU0FBUztBQUN2QixjQUFjLG9DQUFvQztBQUNsRCxjQUFjLG9HQUFvRztBQUNsSDtBQUNBO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMseUNBQXlDO0FBQ3ZELGNBQWMsUUFBUTtBQUN0QixjQUFjLG9DQUFvQztBQUNsRCxjQUFjLDJCQUEyQjtBQUN6QyxjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLFdBQVc7QUFDekIsY0FBYywwQ0FBMEM7QUFDeEQsY0FBYyxlQUFlO0FBQzdCLGNBQWMsMENBQTBDO0FBQ3hELGNBQWMsUUFBUTtBQUN0QixjQUFjLHlCQUF5QjtBQUN2Qzs7QUFFQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0dBQW9HO0FBQ2xIO0FBQ0EsSUFBSSxtREFBbUQ7QUFDdkQ7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0RBQW9EO0FBQ2xFLGNBQWMsNERBQTREO0FBQzFFLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsNENBQTRDO0FBQzFELGNBQWMsbUJBQW1CO0FBQ2pDOztBQUVBO0FBQ0EsYUFBYSxtR0FBbUc7QUFDaEg7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGtHQUFrRztBQUNoSDtBQUNBLElBQUksMkNBQTJDO0FBQy9DLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsa0hBQWtIO0FBQ2hJO0FBQ0EsSUFBSSwrQ0FBK0M7QUFDbkQsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1HQUFtRztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxrRkFBa0Y7QUFDaEc7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUErQztBQUM3RDtBQUNBLElBQUksZ0NBQWdDO0FBQ3BDOztBQUVBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQTtBQUNBLHVCQUF1Qix1REFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQSx1QkFBdUIsdURBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFVO0FBQ2pDO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDRDQUE0QyxzQ0FBc0M7QUFDbEYsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0EsMkJBQTJCLHVDQUF1QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFVO0FBQzVCO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQWtCOztBQUU1QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx1Q0FBdUMscURBQWU7O0FBRXREO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx1Q0FBdUMscURBQWU7O0FBRXREO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUZBQW1GO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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NkJBQTZCO0FBQzNDO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQSxjQUFjLDJDQUEyQztBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsdUJBQXVCLGdEQUFNOztBQUU3QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdEQUFJLEVBQUUsMEJBQTBCOztBQUU5QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDRDQUE0QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFF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Q1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7O0FDTnlCO0FBQ087QUFDTTtBQUNYO0FBRTNCLE1BQU0sR0FBRyxHQUFHLElBQUksOENBQUcsQ0FBQztJQUNoQixNQUFNLEVBQUUsS0FBSztJQUNiLE1BQU0sRUFBRTtRQUNKLElBQUkscURBQVMsQ0FBQztZQUNWLE1BQU0sRUFBRSxJQUFJLHFEQUFHLEVBQUU7U0FDcEIsQ0FBQztLQUNMO0lBQ0QsSUFBSSxFQUFFLElBQUksK0NBQUksQ0FBQztRQUNYLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDZCxJQUFJLEVBQUUsQ0FBQztLQUNWLENBQUM7Q0FDTCxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9jb2xvci1wYXJzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9jb2xvci1wYXJzZS9ub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9jb2xvci1yZ2JhL2luZGV4LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL2hzbC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9sY2h1di5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9sdXYuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvY29sb3Itc3BhY2UvcmdiLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL3h5ei5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL0NvbGxlY3Rpb25FdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvRGF0YVRpbGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9JbWFnZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9JbWFnZVN0YXRlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL0ltYWdlVGlsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9LaW5ldGljLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL01hcC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50SGFuZGxlci5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRUeXBlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9NYXBQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0RXZlbnRUeXBlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL09ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvVGlsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9UaWxlUXVldWUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvVGlsZVJhbmdlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVTdGF0ZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9WaWV3LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL1ZpZXdIaW50LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL1ZpZXdQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9hc3NlcnRzLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2NlbnRlcmNvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvY29sb3IuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvY29sb3JsaWtlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9BdHRyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL0NvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9ab29tLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvY29vcmRpbmF0ZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9jc3MuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvZG9tLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0V2ZW50LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0tleS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvVGFyZ2V0LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9jb25kaXRpb24uanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvZXhwci9jcHUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvZXhwci9leHByZXNzaW9uLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9leHRlbnQvUmVsYXRpb25zaGlwLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2Z1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0dlb21ldHJ5LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vTGluZWFyUmluZy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1BvaW50LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9seWdvbi5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9hcmVhLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jbG9zZXN0LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jb250YWlucy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvb3JpZW50LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9yZXZlcnNlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9zZWdtZW50cy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9oYXMuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdCb3guanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbi5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdab29tLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFpvb20uanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vUG9pbnRlci5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9CYXNlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0Jhc2VUaWxlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0Jhc2VWZWN0b3IuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVGlsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9UaWxlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvbWF0aC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9vYmouanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9FdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcHJvai5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1Byb2plY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Vbml0cy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2czODU3LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzQzMjYuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9wcm9qZWN0aW9ucy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3RyYW5zZm9ybXMuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcHJvai91dG0uanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0JveC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0V2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvWkluZGV4Q29udGV4dC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL3N0eWxlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL0NvbXBvc2l0ZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9MYXllci5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9NYXAuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL0xheWVyLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9EYXRhVGlsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVGlsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVHJpYW5ndWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovY29tbW9uLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9nbHJlcHJvai5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yZXNvbHV0aW9uY29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9yb3RhdGlvbmNvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc2l6ZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvT1NNLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVJbWFnZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVXJsVGlsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvWFlaLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3NwaGVyZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9MUlVDYWNoZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvQ2lyY2xlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ZpbGwuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbi5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvUmVndWxhclNoYXBlLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0cm9rZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9TdHlsZS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9UZXh0LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVjb29yZC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9UaWxlR3JpZC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9XTVRTLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC90aWxldXJsZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvLi9ub2RlX21vZHVsZXMvb2wvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3VyaS5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9vbC91dGlsLmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3ZlYy9tYXQ0LmpzIiwid2VicGFjazovL2FjYXJ0aWEyLy4vbm9kZV9tb2R1bGVzL29sL3dlYmdsL0NhbnZhcy5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9xdWlja3NlbGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi8uL25vZGVfbW9kdWxlcy9yYnVzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9hY2FydGlhMi93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9hY2FydGlhMi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vYWNhcnRpYTIvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9hY2FydGlhMi93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2FjYXJ0aWEyLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBjb2xvci1wYXJzZVxuICovXG5pbXBvcnQgbmFtZXMgZnJvbSAnY29sb3ItbmFtZSdcblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VcblxuLyoqXG4gKiBCYXNlIGh1ZXNcbiAqIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jdHlwZWRlZi1uYW1lZC1odWVcbiAqL1xuLy9GSVhNRTogdXNlIGV4dGVybmFsIGh1ZSBkZXRlY3RvclxudmFyIGJhc2VIdWVzID0ge1xuXHRyZWQ6IDAsXG5cdG9yYW5nZTogNjAsXG5cdHllbGxvdzogMTIwLFxuXHRncmVlbjogMTgwLFxuXHRibHVlOiAyNDAsXG5cdHB1cnBsZTogMzAwXG59XG5cbi8qKlxuICogUGFyc2UgY29sb3IgZnJvbSB0aGUgc3RyaW5nIHBhc3NlZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gQSBzcGFjZSBpbmRpY2F0b3IgYHNwYWNlYCwgYW4gYXJyYXkgYHZhbHVlc2AgYW5kIGBhbHBoYWBcbiAqL1xuZnVuY3Rpb24gcGFyc2UoY3N0cikge1xuXHR2YXIgbSwgcGFydHMgPSBbXSwgYWxwaGEgPSAxLCBzcGFjZVxuXG5cdC8vbnVtZXJpYyBjYXNlXG5cdGlmICh0eXBlb2YgY3N0ciA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4geyBzcGFjZTogJ3JnYicsIHZhbHVlczogW2NzdHIgPj4+IDE2LCAoY3N0ciAmIDB4MDBmZjAwKSA+Pj4gOCwgY3N0ciAmIDB4MDAwMGZmXSwgYWxwaGE6IDEgfVxuXHR9XG5cdGlmICh0eXBlb2YgY3N0ciA9PT0gJ251bWJlcicpIHJldHVybiB7IHNwYWNlOiAncmdiJywgdmFsdWVzOiBbY3N0ciA+Pj4gMTYsIChjc3RyICYgMHgwMGZmMDApID4+PiA4LCBjc3RyICYgMHgwMDAwZmZdLCBhbHBoYTogMSB9XG5cblx0Y3N0ciA9IFN0cmluZyhjc3RyKS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8va2V5d29yZFxuXHRpZiAobmFtZXNbY3N0cl0pIHtcblx0XHRwYXJ0cyA9IG5hbWVzW2NzdHJdLnNsaWNlKClcblx0XHRzcGFjZSA9ICdyZ2InXG5cdH1cblxuXHQvL3Jlc2VydmVkIHdvcmRzXG5cdGVsc2UgaWYgKGNzdHIgPT09ICd0cmFuc3BhcmVudCcpIHtcblx0XHRhbHBoYSA9IDBcblx0XHRzcGFjZSA9ICdyZ2InXG5cdFx0cGFydHMgPSBbMCwgMCwgMF1cblx0fVxuXG5cdC8vaGV4XG5cdGVsc2UgaWYgKGNzdHJbMF0gPT09ICcjJykge1xuXHRcdHZhciBiYXNlID0gY3N0ci5zbGljZSgxKVxuXHRcdHZhciBzaXplID0gYmFzZS5sZW5ndGhcblx0XHR2YXIgaXNTaG9ydCA9IHNpemUgPD0gNFxuXHRcdGFscGhhID0gMVxuXG5cdFx0aWYgKGlzU2hvcnQpIHtcblx0XHRcdHBhcnRzID0gW1xuXHRcdFx0XHRwYXJzZUludChiYXNlWzBdICsgYmFzZVswXSwgMTYpLFxuXHRcdFx0XHRwYXJzZUludChiYXNlWzFdICsgYmFzZVsxXSwgMTYpLFxuXHRcdFx0XHRwYXJzZUludChiYXNlWzJdICsgYmFzZVsyXSwgMTYpXG5cdFx0XHRdXG5cdFx0XHRpZiAoc2l6ZSA9PT0gNCkge1xuXHRcdFx0XHRhbHBoYSA9IHBhcnNlSW50KGJhc2VbM10gKyBiYXNlWzNdLCAxNikgLyAyNTVcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRwYXJ0cyA9IFtcblx0XHRcdFx0cGFyc2VJbnQoYmFzZVswXSArIGJhc2VbMV0sIDE2KSxcblx0XHRcdFx0cGFyc2VJbnQoYmFzZVsyXSArIGJhc2VbM10sIDE2KSxcblx0XHRcdFx0cGFyc2VJbnQoYmFzZVs0XSArIGJhc2VbNV0sIDE2KVxuXHRcdFx0XVxuXHRcdFx0aWYgKHNpemUgPT09IDgpIHtcblx0XHRcdFx0YWxwaGEgPSBwYXJzZUludChiYXNlWzZdICsgYmFzZVs3XSwgMTYpIC8gMjU1XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJ0c1swXSkgcGFydHNbMF0gPSAwXG5cdFx0aWYgKCFwYXJ0c1sxXSkgcGFydHNbMV0gPSAwXG5cdFx0aWYgKCFwYXJ0c1syXSkgcGFydHNbMl0gPSAwXG5cblx0XHRzcGFjZSA9ICdyZ2InXG5cdH1cblxuXHQvLyBjb2xvciBzcGFjZVxuXHRlbHNlIGlmIChtID0gL14oKD86cmdiYT98aHNbbHZiXWE/fGh3YmE/fGNteWs/fHh5W3p5XXxncmF5fGxhYnxsY2h1P3Y/fFtseV11dnxsbXN8b2tsY2h8b2tsYWJ8Y29sb3IpKVxccypcXCgoW15cXCldKilcXCkvLmV4ZWMoY3N0cikpIHtcblx0XHR2YXIgbmFtZSA9IG1bMV1cblx0XHRzcGFjZSA9IG5hbWUucmVwbGFjZSgvYSQvLCAnJylcblx0XHR2YXIgZGltcyA9IHNwYWNlID09PSAnY215aycgPyA0IDogc3BhY2UgPT09ICdncmF5JyA/IDEgOiAzXG5cdFx0cGFydHMgPSBtWzJdLnRyaW0oKS5zcGxpdCgvXFxzKlssXFwvXVxccyp8XFxzKy8pXG5cblx0XHQvLyBjb2xvcihzcmdiLWxpbmVhciB4IHggeCkgLT4gc3JnYi1saW5lYXIoeCB4IHgpXG5cdFx0aWYgKHNwYWNlID09PSAnY29sb3InKSBzcGFjZSA9IHBhcnRzLnNoaWZ0KClcblxuXHRcdHBhcnRzID0gcGFydHMubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG5cdFx0XHQvLzxwZXJjZW50YWdlPlxuXHRcdFx0aWYgKHhbeC5sZW5ndGggLSAxXSA9PT0gJyUnKSB7XG5cdFx0XHRcdHggPSBwYXJzZUZsb2F0KHgpIC8gMTAwXG5cdFx0XHRcdC8vIGFscGhhIC0+IDAuLjFcblx0XHRcdFx0aWYgKGkgPT09IDMpIHJldHVybiB4XG5cdFx0XHRcdC8vIHJnYiAtPiAwLi4yNTVcblx0XHRcdFx0aWYgKHNwYWNlID09PSAncmdiJykgcmV0dXJuIHggKiAyNTVcblx0XHRcdFx0Ly8gaHNsLCBod2IgSCAtPiAwLi4xMDBcblx0XHRcdFx0aWYgKHNwYWNlWzBdID09PSAnaCcpIHJldHVybiB4ICogMTAwXG5cdFx0XHRcdC8vIGxjaCwgbGFiIEwgLT4gMC4uMTAwXG5cdFx0XHRcdGlmIChzcGFjZVswXSA9PT0gJ2wnICYmICFpKSByZXR1cm4geCAqIDEwMFxuXHRcdFx0XHQvLyBsYWIgQSBCIC0+IC0xMjUuLjEyNVxuXHRcdFx0XHRpZiAoc3BhY2UgPT09ICdsYWInKSByZXR1cm4geCAqIDEyNVxuXHRcdFx0XHQvLyBsY2ggQyAtPiAwLi4xNTAsIEggLT4gMC4uMzYwXG5cdFx0XHRcdGlmIChzcGFjZSA9PT0gJ2xjaCcpIHJldHVybiBpIDwgMiA/IHggKiAxNTAgOiB4ICogMzYwXG5cdFx0XHRcdC8vIG9rbGNoL29rbGFiIEwgLT4gMC4uMVxuXHRcdFx0XHRpZiAoc3BhY2VbMF0gPT09ICdvJyAmJiAhaSkgcmV0dXJuIHhcblx0XHRcdFx0Ly8gb2tsYWIgQSBCIC0+IC0wLjQuLjAuNFxuXHRcdFx0XHRpZiAoc3BhY2UgPT09ICdva2xhYicpIHJldHVybiB4ICogMC40XG5cdFx0XHRcdC8vIG9rbGNoIEMgLT4gMC4uMC40LCBIIC0+IDAuLjM2MFxuXHRcdFx0XHRpZiAoc3BhY2UgPT09ICdva2xjaCcpIHJldHVybiBpIDwgMiA/IHggKiAwLjQgOiB4ICogMzYwXG5cdFx0XHRcdC8vIGNvbG9yKHh4eCkgLT4gMC4uMVxuXHRcdFx0XHRyZXR1cm4geFxuXHRcdFx0fVxuXG5cdFx0XHQvL2h1ZVxuXHRcdFx0aWYgKHNwYWNlW2ldID09PSAnaCcgfHwgKGkgPT09IDIgJiYgc3BhY2Vbc3BhY2UubGVuZ3RoIC0gMV0gPT09ICdoJykpIHtcblx0XHRcdFx0Ly88YmFzZS1odWU+XG5cdFx0XHRcdGlmIChiYXNlSHVlc1t4XSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYmFzZUh1ZXNbeF1cblx0XHRcdFx0Ly88ZGVnPlxuXHRcdFx0XHRpZiAoeC5lbmRzV2l0aCgnZGVnJykpIHJldHVybiBwYXJzZUZsb2F0KHgpXG5cdFx0XHRcdC8vPHR1cm4+XG5cdFx0XHRcdGlmICh4LmVuZHNXaXRoKCd0dXJuJykpIHJldHVybiBwYXJzZUZsb2F0KHgpICogMzYwXG5cdFx0XHRcdGlmICh4LmVuZHNXaXRoKCdncmFkJykpIHJldHVybiBwYXJzZUZsb2F0KHgpICogMzYwIC8gNDAwXG5cdFx0XHRcdGlmICh4LmVuZHNXaXRoKCdyYWQnKSkgcmV0dXJuIHBhcnNlRmxvYXQoeCkgKiAxODAgLyBNYXRoLlBJXG5cdFx0XHR9XG5cdFx0XHRpZiAoeCA9PT0gJ25vbmUnKSByZXR1cm4gMFxuXHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoeClcblx0XHR9KTtcblxuXHRcdGFscGhhID0gcGFydHMubGVuZ3RoID4gZGltcyA/IHBhcnRzLnBvcCgpIDogMVxuXHR9XG5cblx0Ly9uYW1lZCBjaGFubmVscyBjYXNlXG5cdGVsc2UgaWYgKC9bMC05XSg/Olxcc3xcXC98LCkvLnRlc3QoY3N0cikpIHtcblx0XHRwYXJ0cyA9IGNzdHIubWF0Y2goLyhbMC05XSspL2cpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKVxuXHRcdH0pXG5cblx0XHRzcGFjZSA9IGNzdHIubWF0Y2goLyhbYS16XSkvaWcpPy5qb2luKCcnKT8udG9Mb3dlckNhc2UoKSB8fCAncmdiJ1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzcGFjZSxcblx0XHR2YWx1ZXM6IHBhcnRzLFxuXHRcdGFscGhhXG5cdH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IHtcblx0YWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG5cdGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuXHRhcXVhOiBbMCwgMjU1LCAyNTVdLFxuXHRhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG5cdGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG5cdGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG5cdGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuXHRibGFjazogWzAsIDAsIDBdLFxuXHRibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuXHRibHVlOiBbMCwgMCwgMjU1XSxcblx0Ymx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG5cdGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuXHRidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcblx0Y2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcblx0Y2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcblx0Y2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcblx0Y29yYWw6IFsyNTUsIDEyNywgODBdLFxuXHRjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuXHRjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuXHRjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuXHRjeWFuOiBbMCwgMjU1LCAyNTVdLFxuXHRkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG5cdGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuXHRkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcblx0ZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcblx0ZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcblx0ZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcblx0ZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG5cdGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuXHRkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcblx0ZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcblx0ZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG5cdGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuXHRkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG5cdGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuXHRkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuXHRkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG5cdGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcblx0ZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcblx0ZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcblx0ZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuXHRkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcblx0ZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuXHRkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG5cdGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuXHRmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG5cdGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG5cdGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuXHRmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuXHRnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcblx0Z2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuXHRnb2xkOiBbMjU1LCAyMTUsIDBdLFxuXHRnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuXHRncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG5cdGdyZWVuOiBbMCwgMTI4LCAwXSxcblx0Z3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuXHRncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG5cdGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG5cdGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcblx0aW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuXHRpbmRpZ286IFs3NSwgMCwgMTMwXSxcblx0aXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcblx0a2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcblx0bGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcblx0bGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuXHRsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG5cdGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuXHRsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcblx0bGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuXHRsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcblx0bGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcblx0bGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG5cdGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcblx0bGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG5cdGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuXHRsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuXHRsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcblx0bGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG5cdGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG5cdGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG5cdGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG5cdGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG5cdGxpbWU6IFswLCAyNTUsIDBdLFxuXHRsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG5cdGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG5cdG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG5cdG1hcm9vbjogWzEyOCwgMCwgMF0sXG5cdG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcblx0bWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG5cdG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG5cdG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuXHRtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG5cdG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuXHRtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcblx0bWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcblx0bWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcblx0bWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuXHRtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcblx0bWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG5cdG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG5cdG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG5cdG5hdnk6IFswLCAwLCAxMjhdLFxuXHRvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG5cdG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuXHRvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuXHRvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG5cdG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuXHRvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcblx0cGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuXHRwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcblx0cGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuXHRwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG5cdHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcblx0cGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG5cdHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuXHRwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG5cdHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcblx0cG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuXHRwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG5cdHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuXHRyZWQ6IFsyNTUsIDAsIDBdLFxuXHRyb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcblx0cm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcblx0c2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG5cdHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuXHRzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcblx0c2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG5cdHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG5cdHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcblx0c2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG5cdHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcblx0c2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcblx0c2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG5cdHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuXHRzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG5cdHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuXHRzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuXHR0YW46IFsyMTAsIDE4MCwgMTQwXSxcblx0dGVhbDogWzAsIDEyOCwgMTI4XSxcblx0dGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuXHR0b21hdG86IFsyNTUsIDk5LCA3MV0sXG5cdHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG5cdHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuXHR3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuXHR3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuXHR3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG5cdHllbGxvdzogWzI1NSwgMjU1LCAwXSxcblx0eWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG59XG4iLCIvKiogQG1vZHVsZSAgY29sb3ItcmdiYSAqL1xuaW1wb3J0IHBhcnNlIGZyb20gJ2NvbG9yLXBhcnNlJ1xuaW1wb3J0IHJnYiBmcm9tICdjb2xvci1zcGFjZS9yZ2IuanMnXG5pbXBvcnQgaHNsIGZyb20gJ2NvbG9yLXNwYWNlL2hzbC5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmdiYShjb2xvcikge1xuXHQvLyB0ZW1wbGF0ZSBsaXRlcmFsc1xuXHRpZiAoQXJyYXkuaXNBcnJheShjb2xvcikgJiYgY29sb3IucmF3KSBjb2xvciA9IFN0cmluZy5yYXcoLi4uYXJndW1lbnRzKVxuXHRpZiAoY29sb3IgaW5zdGFuY2VvZiBOdW1iZXIpIGNvbG9yID0gK2NvbG9yXG5cblx0dmFyIHZhbHVlcywgaSwgbFxuXG5cdC8vYXR0ZW1wdCB0byBwYXJzZSBub24tYXJyYXkgYXJndW1lbnRzXG5cdHZhciBwYXJzZWQgPSBwYXJzZShjb2xvcilcblxuXHRpZiAoIXBhcnNlZC5zcGFjZSkgcmV0dXJuIFtdXG5cblx0Y29uc3QgbWluID0gcGFyc2VkLnNwYWNlWzBdID09PSAnaCcgPyBoc2wubWluIDogcmdiLm1pblxuXHRjb25zdCBtYXggPSBwYXJzZWQuc3BhY2VbMF0gPT09ICdoJyA/IGhzbC5tYXggOiByZ2IubWF4XG5cblx0dmFsdWVzID0gQXJyYXkoMylcblx0dmFsdWVzWzBdID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VkLnZhbHVlc1swXSwgbWluWzBdKSwgbWF4WzBdKVxuXHR2YWx1ZXNbMV0gPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZWQudmFsdWVzWzFdLCBtaW5bMV0pLCBtYXhbMV0pXG5cdHZhbHVlc1syXSA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlZC52YWx1ZXNbMl0sIG1pblsyXSksIG1heFsyXSlcblxuXHRpZiAocGFyc2VkLnNwYWNlWzBdID09PSAnaCcpIHtcblx0XHR2YWx1ZXMgPSBoc2wucmdiKHZhbHVlcylcblx0fVxuXG5cdHZhbHVlcy5wdXNoKE1hdGgubWluKE1hdGgubWF4KHBhcnNlZC5hbHBoYSwgMCksIDEpKVxuXG5cdHJldHVybiB2YWx1ZXNcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBjb2xvci1zcGFjZS9oc2xcbiAqL1xuaW1wb3J0IHJnYiBmcm9tICcuL3JnYi5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0bmFtZTogJ2hzbCcsXG5cdG1pbjogWzAsMCwwXSxcblx0bWF4OiBbMzYwLDEwMCwxMDBdLFxuXHRjaGFubmVsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRhbGlhczogWydIU0wnXSxcblxuXHRyZ2I6IGZ1bmN0aW9uKGhzbCkge1xuXHRcdHZhciBoID0gaHNsWzBdLzM2MCwgcyA9IGhzbFsxXS8xMDAsIGwgPSBoc2xbMl0vMTAwLCB0MSwgdDIsIHQzLCByZ2IsIHZhbCwgaT0wO1xuXG5cdFx0aWYgKHMgPT09IDApIHJldHVybiB2YWwgPSBsICogMjU1LCBbdmFsLCB2YWwsIHZhbF07XG5cblx0XHR0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG5cdFx0dDEgPSAyICogbCAtIHQyO1xuXG5cdFx0cmdiID0gWzAsIDAsIDBdO1xuXHRcdGZvciAoO2k8MzspIHtcblx0XHRcdHQzID0gaCArIDEgLyAzICogLSAoaSAtIDEpO1xuXHRcdFx0dDMgPCAwID8gdDMrKyA6IHQzID4gMSAmJiB0My0tO1xuXHRcdFx0dmFsID0gNiAqIHQzIDwgMSA/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzIDpcblx0XHRcdDIgKiB0MyA8IDEgPyB0MiA6XG5cdFx0XHQzICogdDMgPCAyID8gIHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNiA6XG5cdFx0XHR0MTtcblx0XHRcdHJnYltpKytdID0gdmFsICogMjU1O1xuXHRcdH1cblxuXHRcdHJldHVybiByZ2I7XG5cdH1cbn07XG5cblxuLy9leHRlbmQgcmdiXG5yZ2IuaHNsID0gZnVuY3Rpb24ocmdiKSB7XG5cdHZhciByID0gcmdiWzBdLzI1NSxcblx0XHRcdGcgPSByZ2JbMV0vMjU1LFxuXHRcdFx0YiA9IHJnYlsyXS8yNTUsXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRoLCBzLCBsO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSAwO1xuXHR9XG5cdGVsc2UgaWYgKHIgPT09IG1heCkge1xuXHRcdGggPSAoZyAtIGIpIC8gZGVsdGE7XG5cdH1cblx0ZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG5cdFx0aCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG5cdH1cblx0ZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG5cdFx0aCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRsID0gKG1pbiArIG1heCkgLyAyO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdHMgPSAwO1xuXHR9XG5cdGVsc2UgaWYgKGwgPD0gMC41KSB7XG5cdFx0cyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHR9XG5cblx0cmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn07XG4iLCIvKipcbiAqIEN5bGluZHJpY2FsIENJRSBMVVZcbiAqXG4gKiBAbW9kdWxlIGNvbG9yLXNwYWNlL2xjaHV2XG4gKi9cbmltcG9ydCBsdXYgZnJvbSAnLi9sdXYuanMnO1xuaW1wb3J0IHh5eiBmcm9tICcuL3h5ei5qcyc7XG5cbi8vY3lsaW5kcmljYWwgbHV2XG52YXIgbGNodXYgPSB7XG5cdG5hbWU6ICdsY2h1dicsXG5cdGNoYW5uZWw6IFsnbGlnaHRuZXNzJywgJ2Nocm9tYScsICdodWUnXSxcblx0YWxpYXM6IFsnTENIdXYnLCAnY2llbGNodXYnXSxcblx0bWluOiBbMCwwLDBdLFxuXHRtYXg6IFsxMDAsMTAwLDM2MF0sXG5cblx0bHV2OiBmdW5jdGlvbihsdXYpe1xuXHRcdHZhciBsID0gbHV2WzBdLFxuXHRcdGMgPSBsdXZbMV0sXG5cdFx0aCA9IGx1dlsyXSxcblx0XHR1LCB2LCBocjtcblxuXHRcdGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuXHRcdHUgPSBjICogTWF0aC5jb3MoaHIpO1xuXHRcdHYgPSBjICogTWF0aC5zaW4oaHIpO1xuXHRcdHJldHVybiBbbCwgdSwgdl07XG5cdH0sXG5cblx0eHl6OiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gbHV2Lnh5eihsY2h1di5sdXYoYXJnKSk7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxjaHV2O1xuXG5sdXYubGNodXYgPSBmdW5jdGlvbihsdXYpe1xuXHR2YXIgbCA9IGx1dlswXSwgdSA9IGx1dlsxXSwgdiA9IGx1dlsyXTtcblxuXHR2YXIgYyA9IE1hdGguc3FydCh1KnUgKyB2KnYpO1xuXHR2YXIgaHIgPSBNYXRoLmF0YW4yKHYsdSk7XG5cdHZhciBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRyZXR1cm4gW2wsYyxoXVxufTtcblxueHl6LmxjaHV2ID0gZnVuY3Rpb24oYXJnKXtcbiAgcmV0dXJuIGx1di5sY2h1dih4eXoubHV2KGFyZykpO1xufTtcbiIsIi8qKlxuICogQ0lFIExVViAoQydlc3QgbGEgdmllKVxuICpcbiAqIEBtb2R1bGUgY29sb3Itc3BhY2UvbHV2XG4gKi9cbiBpbXBvcnQgeHl6IGZyb20gJy4veHl6LmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRuYW1lOiAnbHV2Jyxcblx0Ly9OT1RFOiBsdXYgaGFzIG5vIHJpZ2lkbHkgZGVmaW5lZCBsaW1pdHNcblx0Ly9lYXN5cmdiIGZhaWxzIHRvIGdldCBwcm9wZXIgY29vcmRzXG5cdC8vYm9yb25pbmUgc3RhdGVzIG5vIHJpZ2lkIGxpbWl0c1xuXHQvL2NvbG9yTWluZSByZWZlcnMgdGhpcyBvbmVzOlxuXHRtaW46IFswLC0xMzQsLTE0MF0sXG5cdG1heDogWzEwMCwyMjQsMTIyXSxcblx0Y2hhbm5lbDogWydsaWdodG5lc3MnLCAndScsICd2J10sXG5cdGFsaWFzOiBbJ0xVVicsICdjaWVsdXYnLCAnY2llMTk3NiddLFxuXG5cdHh5ejogZnVuY3Rpb24oYXJnLCBpLCBvKXtcblx0XHR2YXIgX3UsIF92LCBsLCB1LCB2LCB4LCB5LCB6LCB4biwgeW4sIHpuLCB1biwgdm47XG5cdFx0bCA9IGFyZ1swXSwgdSA9IGFyZ1sxXSwgdiA9IGFyZ1syXTtcblxuXHRcdGlmIChsID09PSAwKSByZXR1cm4gWzAsMCwwXTtcblxuXHRcdC8vZ2V0IGNvbnN0YW50c1xuXHRcdC8vdmFyIGUgPSAwLjAwODg1NjQ1MTY3OTAzNTYzMTsgLy8oNi8yOSleM1xuXHRcdHZhciBrID0gMC4wMDExMDcwNTY0NTk4Nzk0NTM5OyAvLygzLzI5KV4zXG5cblx0XHQvL2dldCBpbGx1bWluYW50L29ic2VydmVyXG5cdFx0aSA9IGkgfHwgJ0Q2NSc7XG5cdFx0byA9IG8gfHwgMjtcblxuXHRcdHhuID0geHl6LndoaXRlcG9pbnRbb11baV1bMF07XG5cdFx0eW4gPSB4eXoud2hpdGVwb2ludFtvXVtpXVsxXTtcblx0XHR6biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzJdO1xuXG5cdFx0dW4gPSAoNCAqIHhuKSAvICh4biArICgxNSAqIHluKSArICgzICogem4pKTtcblx0XHR2biA9ICg5ICogeW4pIC8gKHhuICsgKDE1ICogeW4pICsgKDMgKiB6bikpO1xuXHRcdC8vIHVuID0gMC4xOTc4MzAwMDY2NDI4Mztcblx0XHQvLyB2biA9IDAuNDY4MzE5OTk0OTM4Nzk7XG5cblxuXHRcdF91ID0gdSAvICgxMyAqIGwpICsgdW4gfHwgMDtcblx0XHRfdiA9IHYgLyAoMTMgKiBsKSArIHZuIHx8IDA7XG5cblx0XHR5ID0gbCA+IDggPyB5biAqIE1hdGgucG93KCAobCArIDE2KSAvIDExNiAsIDMpIDogeW4gKiBsICogaztcblxuXHRcdC8vd2lraXBlZGlhIG1ldGhvZFxuXHRcdHggPSB5ICogOSAqIF91IC8gKDQgKiBfdikgfHwgMDtcblx0XHR6ID0geSAqICgxMiAtIDMgKiBfdSAtIDIwICogX3YpIC8gKDQgKiBfdikgfHwgMDtcblxuXHRcdC8vYm9yb25pbmUgbWV0aG9kXG5cdFx0Ly9odHRwczovL2dpdGh1Yi5jb20vYm9yb25pbmUvaHVzbC9ibG9iL21hc3Rlci9odXNsLmNvZmZlZSNMMjAxXG5cdFx0Ly8geCA9IDAgLSAoOSAqIHkgKiBfdSkgLyAoKF91IC0gNCkgKiBfdiAtIF91ICogX3YpO1xuXHRcdC8vIHogPSAoOSAqIHkgLSAoMTUgKiBfdiAqIHkpIC0gKF92ICogeCkpIC8gKDMgKiBfdik7XG5cblx0XHRyZXR1cm4gW3gsIHksIHpdO1xuXHR9XG59O1xuXG4vLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0VxdWF0aW9ucy5odG1sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYm9yb25pbmUvaHVzbC9ibG9iL21hc3Rlci9odXNsLmNvZmZlZVxuLy9pIC0gaWxsdW1pbmFudFxuLy9vIC0gb2JzZXJ2ZXJcbnh5ei5sdXYgPSBmdW5jdGlvbihhcmcsIGksIG8pIHtcblx0dmFyIF91LCBfdiwgbCwgdSwgdiwgeCwgeSwgeiwgeG4sIHluLCB6biwgdW4sIHZuO1xuXG5cdC8vZ2V0IGNvbnN0YW50c1xuXHR2YXIgZSA9IDAuMDA4ODU2NDUxNjc5MDM1NjMxOyAvLyg2LzI5KV4zXG5cdHZhciBrID0gOTAzLjI5NjI5NjI5NjI5NjE7IC8vKDI5LzMpXjNcblxuXHQvL2dldCBpbGx1bWluYW50L29ic2VydmVyIGNvb3Jkc1xuXHRpID0gaSB8fCAnRDY1Jztcblx0byA9IG8gfHwgMjtcblxuXHR4biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzBdO1xuXHR5biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzFdO1xuXHR6biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzJdO1xuXG5cdHVuID0gKDQgKiB4bikgLyAoeG4gKyAoMTUgKiB5bikgKyAoMyAqIHpuKSk7XG5cdHZuID0gKDkgKiB5bikgLyAoeG4gKyAoMTUgKiB5bikgKyAoMyAqIHpuKSk7XG5cblxuXHR4ID0gYXJnWzBdLCB5ID0gYXJnWzFdLCB6ID0gYXJnWzJdO1xuXG5cblx0X3UgPSAoNCAqIHgpIC8gKHggKyAoMTUgKiB5KSArICgzICogeikpIHx8IDA7XG5cdF92ID0gKDkgKiB5KSAvICh4ICsgKDE1ICogeSkgKyAoMyAqIHopKSB8fCAwO1xuXG5cdHZhciB5ciA9IHkveW47XG5cblx0bCA9IHlyIDw9IGUgPyBrICogeXIgOiAxMTYgKiBNYXRoLnBvdyh5ciwgMS8zKSAtIDE2O1xuXG5cdHUgPSAxMyAqIGwgKiAoX3UgLSB1bik7XG5cdHYgPSAxMyAqIGwgKiAoX3YgLSB2bik7XG5cblx0cmV0dXJuIFtsLCB1LCB2XTtcbn07XG4iLCIvKipcbiAqIFJHQiBzcGFjZS5cbiAqXG4gKiBAbW9kdWxlICBjb2xvci1zcGFjZS9yZ2JcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdG5hbWU6ICdyZ2InLFxuXHRtaW46IFswLDAsMF0sXG5cdG1heDogWzI1NSwyNTUsMjU1XSxcblx0Y2hhbm5lbDogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRhbGlhczogWydSR0InXVxufTtcbiIsIi8qKlxuICogQ0lFIFhZWlxuICpcbiAqIEBtb2R1bGUgIGNvbG9yLXNwYWNlL3h5elxuICovXG5pbXBvcnQgcmdiIGZyb20gJy4vcmdiLmpzJztcblxudmFyIHh5eiA9IHtcblx0bmFtZTogJ3h5eicsXG5cdG1pbjogWzAsMCwwXSxcblx0Y2hhbm5lbDogWydYJywnWScsJ1onXSxcblx0YWxpYXM6IFsnWFlaJywgJ2NpZXh5eicsICdjaWUxOTMxJ11cbn07XG5cblxuLyoqXG4gKiBXaGl0ZXBvaW50IHJlZmVyZW5jZSB2YWx1ZXMgd2l0aCBvYnNlcnZlci9pbGx1bWluYW50XG4gKlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9pbGx1bWluYW50XG4gKi9cbnh5ei53aGl0ZXBvaW50ID0ge1xuXHQvLzE5MzEgMsKwXG5cdDI6IHtcblx0XHQvL2luY2FkZXNjZW50XG5cdFx0QTpbMTA5Ljg1LCAxMDAsIDM1LjU4NV0sXG5cdFx0Ly8gQjpbXSxcblx0XHRDOiBbOTguMDc0LCAxMDAsIDExOC4yMzJdLFxuXHRcdEQ1MDogWzk2LjQyMiwgMTAwLCA4Mi41MjFdLFxuXHRcdEQ1NTogWzk1LjY4MiwgMTAwLCA5Mi4xNDldLFxuXHRcdC8vZGF5bGlnaHRcblx0XHRENjU6IFs5NS4wNDU1OTI3MDUxNjcsIDEwMCwgMTA4LjkwNTc3NTA3NTk4NzhdLFxuXHRcdEQ3NTogWzk0Ljk3MiwgMTAwLCAxMjIuNjM4XSxcblx0XHQvL2Zsb3VyZXNjZW50XG5cdFx0Ly8gRjE6IFtdLFxuXHRcdEYyOiBbOTkuMTg3LCAxMDAsIDY3LjM5NV0sXG5cdFx0Ly8gRjM6IFtdLFxuXHRcdC8vIEY0OiBbXSxcblx0XHQvLyBGNTogW10sXG5cdFx0Ly8gRjY6W10sXG5cdFx0Rjc6IFs5NS4wNDQsIDEwMCwgMTA4Ljc1NV0sXG5cdFx0Ly8gRjg6IFtdLFxuXHRcdC8vIEY5OiBbXSxcblx0XHQvLyBGMTA6IFtdLFxuXHRcdEYxMTogWzEwMC45NjYsIDEwMCwgNjQuMzcwXSxcblx0XHQvLyBGMTI6IFtdLFxuXHRcdEU6IFsxMDAsMTAwLDEwMF1cblx0fSxcblxuXHQvLzE5NjQgIDEwwrBcblx0MTA6IHtcblx0XHQvL2luY2FkZXNjZW50XG5cdFx0QTpbMTExLjE0NCwgMTAwLCAzNS4yMDBdLFxuXHRcdEM6IFs5Ny4yODUsIDEwMCwgMTE2LjE0NV0sXG5cdFx0RDUwOiBbOTYuNzIwLCAxMDAsIDgxLjQyN10sXG5cdFx0RDU1OiBbOTUuNzk5LCAxMDAsIDkwLjkyNl0sXG5cdFx0Ly9kYXlsaWdodFxuXHRcdEQ2NTogWzk0LjgxMSwgMTAwLCAxMDcuMzA0XSxcblx0XHRENzU6IFs5NC40MTYsIDEwMCwgMTIwLjY0MV0sXG5cdFx0Ly9mbG91cmVzY2VudFxuXHRcdEYyOiBbMTAzLjI4MCwgMTAwLCA2OS4wMjZdLFxuXHRcdEY3OiBbOTUuNzkyLCAxMDAsIDEwNy42ODddLFxuXHRcdEYxMTogWzEwMy44NjYsIDEwMCwgNjUuNjI3XSxcblx0XHRFOiBbMTAwLDEwMCwxMDBdXG5cdH1cbn07XG5cblxuLyoqXG4gKiBUb3AgdmFsdWVzIGFyZSB0aGUgd2hpdGVwb2ludOKAmXMgdG9wIHZhbHVlcywgZGVmYXVsdCBhcmUgRDY1XG4gKi9cbnh5ei5tYXggPSB4eXoud2hpdGVwb2ludFsyXS5ENjU7XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0geHl6IHRvIHJnYlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiBBcnJheSBvZiB4eXogdmFsdWVzXG4gKlxuICogQHJldHVybiB7QXJyYXl9IFJHQiB2YWx1ZXNcbiAqL1xueHl6LnJnYiA9IGZ1bmN0aW9uIChfeHl6LCB3aGl0ZSkge1xuXHQvL0ZJWE1FOiBtYWtlIHN1cmUgd2UgaGF2ZSB0byBkaXZpZGUgbGlrZSB0aGlzLiBQcm9iYWJseSB3ZSBoYXZlIHRvIHJlcGxhY2UgbWF0cml4IGFzIHdlbGwgdGhlblxuXHR3aGl0ZSA9IHdoaXRlIHx8IHh5ei53aGl0ZXBvaW50WzJdLkU7XG5cblx0dmFyIHggPSBfeHl6WzBdIC8gd2hpdGVbMF0sXG5cdFx0eSA9IF94eXpbMV0gLyB3aGl0ZVsxXSxcblx0XHR6ID0gX3h5elsyXSAvIHdoaXRlWzJdLFxuXHRcdHIsIGcsIGI7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0Ly8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuXHRyID0gKHggKiAzLjI0MDk2OTk0MTkwNDUyMSkgKyAoeSAqIC0xLjUzNzM4MzE3NzU3MDA5MykgKyAoeiAqIC0wLjQ5ODYxMDc2MDI5Myk7XG5cdGcgPSAoeCAqIC0wLjk2OTI0MzYzNjI4MDg3KSArICh5ICogMS44NzU5Njc1MDE1MDc3MikgKyAoeiAqIDAuMDQxNTU1MDU3NDA3MTc1KTtcblx0YiA9ICh4ICogMC4wNTU2MzAwNzk2OTY5OTMpICsgKHkgKiAtMC4yMDM5NzY5NTg4ODg5NykgKyAoeiAqIDEuMDU2OTcxNTE0MjQyODc4KTtcblxuXHRyID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogciA9IChyICogMTIuOTIpO1xuXG5cdGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBnID0gKGcgKiAxMi45Mik7XG5cblx0YiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGIgPSAoYiAqIDEyLjkyKTtcblxuXHRyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuXHRnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuXHRiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cblxuXG4vKipcbiAqIFJHQiB0byBYWVpcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByZ2IgUkdCIGNoYW5uZWxzXG4gKlxuICogQHJldHVybiB7QXJyYXl9IFhZWiBjaGFubmVsc1xuICovXG5yZ2IueHl6ID0gZnVuY3Rpb24ocmdiLCB3aGl0ZSkge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NSxcblx0XHRcdGcgPSByZ2JbMV0gLyAyNTUsXG5cdFx0XHRiID0gcmdiWzJdIC8gMjU1O1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuXHRnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcblx0YiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cblx0dmFyIHggPSAociAqIDAuNDEyMzkwNzk5MjY1OTUpICsgKGcgKiAwLjM1NzU4NDMzOTM4Mzg3KSArIChiICogMC4xODA0ODA3ODg0MDE4Myk7XG5cdHZhciB5ID0gKHIgKiAwLjIxMjYzOTAwNTg3MTUxKSArIChnICogMC43MTUxNjg2Nzg3Njc3NSkgKyAoYiAqIDAuMDcyMTkyMzE1MzYwNzMzKTtcblx0dmFyIHogPSAociAqIDAuMDE5MzMwODE4NzE1NTkxKSArIChnICogMC4xMTkxOTQ3Nzk3OTQ2MikgKyAoYiAqIDAuOTUwNTMyMTUyMjQ5NjYpO1xuXG5cdHdoaXRlID0gd2hpdGUgfHwgeHl6LndoaXRlcG9pbnRbMl0uRTtcblxuXHRyZXR1cm4gW3ggKiB3aGl0ZVswXSwgeSAqIHdoaXRlWzFdLCB6ICogd2hpdGVbMl1dO1xufTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IHh5ejtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9Db2xsZWN0aW9uXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4vT2JqZWN0LmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBQcm9wZXJ0eSA9IHtcbiAgTEVOR1RIOiAnbGVuZ3RoJyxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbkV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb25FdmVudFR5cGUuanNcIikuZGVmYXVsdH0gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge1R9IGVsZW1lbnQgRWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgb3IgcmVtb3ZlZCBlbGVtZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgZWxlbWVudCwgaW5kZXgpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoYXQgaXMgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEB0eXBlIHtUfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBhZGRlZCBvciByZW1vdmVkIGVsZW1lbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfCdjaGFuZ2U6bGVuZ3RoJywgaW1wb3J0KFwiLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8J2FkZCd8J3JlbW92ZScsIENvbGxlY3Rpb25FdmVudDxUPiwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6bGVuZ3RoJ3wnYWRkJ3wncmVtb3ZlJyxSZXR1cm4+fSBDb2xsZWN0aW9uT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VuaXF1ZT1mYWxzZV0gRGlzYWxsb3cgdGhlIHNhbWUgaXRlbSBmcm9tIGJlaW5nIGFkZGVkIHRvXG4gKiB0aGUgY29sbGVjdGlvbiB0d2ljZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFuIGV4cGFuZGVkIHZlcnNpb24gb2Ygc3RhbmRhcmQgSlMgQXJyYXksIGFkZGluZyBjb252ZW5pZW5jZSBtZXRob2RzIGZvclxuICogbWFuaXB1bGF0aW9uLiBBZGQgYW5kIHJlbW92ZSBjaGFuZ2VzIHRvIHRoZSBDb2xsZWN0aW9uIHRyaWdnZXIgYSBDb2xsZWN0aW9uXG4gKiBldmVudC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgY292ZXIgY2hhbmdlcyB0byB0aGUgb2JqZWN0cyBfd2l0aGluXyB0aGVcbiAqIENvbGxlY3Rpb247IHRoZXkgdHJpZ2dlciBldmVudHMgb24gdGhlIGFwcHJvcHJpYXRlIG9iamVjdCwgbm90IG9uIHRoZVxuICogQ29sbGVjdGlvbiBhcyBhIHdob2xlLlxuICpcbiAqIEBmaXJlcyBDb2xsZWN0aW9uRXZlbnRcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQGFwaVxuICovXG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBbYXJyYXldIEFycmF5LlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBDb2xsZWN0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcnJheSwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb25PblNpZ25hdHVyZTxULCBpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb25PblNpZ25hdHVyZTxULCBpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbk9uU2lnbmF0dXJlPFQsIHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51bmlxdWVfID0gISFvcHRpb25zLnVuaXF1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxUPn1cbiAgICAgKi9cbiAgICB0aGlzLmFycmF5XyA9IGFycmF5ID8gYXJyYXkgOiBbXTtcblxuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKHRoaXMuYXJyYXlfW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHdoaWxlICh0aGlzLmdldExlbmd0aCgpID4gMCkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGVsZW1lbnRzIHRvIHRoZSBjb2xsZWN0aW9uLiAgVGhpcyBwdXNoZXMgZWFjaCBpdGVtIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICAgKiB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheTxUPn0gYXJyIEFycmF5LlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPFQ+fSBUaGlzIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGV4dGVuZChhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdGhpcy5wdXNoKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIGVsZW1lbnQsIGNhbGxpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsIG51bWJlciwgQXJyYXk8VD4pOiAqfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gICAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZVxuICAgKiAgICAgaW5kZXggYW5kIHRoZSBhcnJheSkuIFRoZSByZXR1cm4gdmFsdWUgaXMgaWdub3JlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaChmKSB7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLmFycmF5XztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBmKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBBcnJheSBvYmplY3QuIFdhcm5pbmc6IGlmIHRoZSBhcnJheVxuICAgKiBpcyBtdXRhdGVkLCBubyBldmVudHMgd2lsbCBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBhbmQgdGhlXG4gICAqIGNvbGxlY3Rpb24ncyBcImxlbmd0aFwiIHByb3BlcnR5IHdvbid0IGJlIGluIHN5bmMgd2l0aCB0aGUgYWN0dWFsIGxlbmd0aFxuICAgKiBvZiB0aGUgYXJyYXkuXG4gICAqIEByZXR1cm4geyFBcnJheTxUPn0gQXJyYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGl0ZW0oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV9baW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmdldChQcm9wZXJ0eS5MRU5HVEgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhbiBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW5zZXJ0QXQoaW5kZXgsIGVsZW0pIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5nZXRMZW5ndGgoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgYm91bmRzOiAnICsgaW5kZXgpO1xuICAgIH1cbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICB0aGlzLmFzc2VydFVuaXF1ZV8oZWxlbSk7XG4gICAgfVxuICAgIHRoaXMuYXJyYXlfLnNwbGljZShpbmRleCwgMCwgZWxlbSk7XG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgZWxlbSwgaW5kZXgpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gYW5kIHJldHVybiBpdC5cbiAgICogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUF0KHRoaXMuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIHByb3ZpZGVkIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgcHVzaChlbGVtKSB7XG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0pO1xuICAgIH1cbiAgICBjb25zdCBuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICB0aGlzLmluc2VydEF0KG4sIGVsZW0pO1xuICAgIHJldHVybiB0aGlzLmdldExlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgZWxlbWVudCBvciB1bmRlZmluZWQgaWYgbm9uZSBmb3VuZC5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlKGVsZW0pIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmFycmF5XztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKGFycltpXSA9PT0gZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4IGFuZCByZXR1cm4gaXQuXG4gICAqIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgY29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIHRoaXMgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFZhbHVlLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVBdChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5nZXRMZW5ndGgoKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcHJldiA9IHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgICB0aGlzLmFycmF5Xy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMudXBkYXRlTGVuZ3RoXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbkV2ZW50PFQ+fSAqLyAoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHByZXYsIGluZGV4KVxuICAgICAgKSxcbiAgICApO1xuICAgIHJldHVybiBwcmV2O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEF0KGluZGV4LCBlbGVtKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgaWYgKGluZGV4ID49IG4pIHtcbiAgICAgIHRoaXMuaW5zZXJ0QXQoaW5kZXgsIGVsZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiBib3VuZHM6ICcgKyBpbmRleCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtLCBpbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IHByZXYgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgdGhpcy5hcnJheV9baW5kZXhdID0gZWxlbTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAvKiogQHR5cGUge0NvbGxlY3Rpb25FdmVudDxUPn0gKi8gKFxuICAgICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLCBwcmV2LCBpbmRleClcbiAgICAgICksXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAvKiogQHR5cGUge0NvbGxlY3Rpb25FdmVudDxUPn0gKi8gKFxuICAgICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuQURELCBlbGVtLCBpbmRleClcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlTGVuZ3RoXygpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5MRU5HVEgsIHRoaXMuYXJyYXlfLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZXhjZXB0XSBPcHRpb25hbCBpbmRleCB0byBpZ25vcmUuXG4gICAqL1xuICBhc3NlcnRVbmlxdWVfKGVsZW0sIGV4Y2VwdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmFycmF5X1tpXSA9PT0gZWxlbSAmJiBpICE9PSBleGNlcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgaXRlbSBhZGRlZCB0byBhIHVuaXF1ZSBjb2xsZWN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxlY3Rpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvQ29sbGVjdGlvbkV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9Db2xsZWN0aW9uLkNvbGxlY3Rpb25FdmVudCNhZGRcbiAgICogQGFwaVxuICAgKi9cbiAgQUREOiAnYWRkJyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL0NvbGxlY3Rpb24uQ29sbGVjdGlvbkV2ZW50I3JlbW92ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU1PVkU6ICdyZW1vdmUnLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9EYXRhVGlsZVxuICovXG5pbXBvcnQgVGlsZSBmcm9tICcuL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SW1hZ2VCaXRtYXB9IEltYWdlTGlrZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1VpbnQ4QXJyYXl8VWludDhDbGFtcGVkQXJyYXl8RmxvYXQzMkFycmF5fERhdGFWaWV3fSBBcnJheUxpa2VcbiAqL1xuXG4vKipcbiAqIERhdGEgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGEgRGF0YVRpbGUuXG4gKiBAdHlwZWRlZiB7QXJyYXlMaWtlfEltYWdlTGlrZX0gRGF0YVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtEYXRhfSBkYXRhIFRpbGUgZGF0YS5cbiAqIEByZXR1cm4ge0ltYWdlTGlrZXxudWxsfSBUaGUgaW1hZ2UtbGlrZSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNJbWFnZUxpa2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEltYWdlIHx8XG4gICAgZGF0YSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8XG4gICAgZGF0YSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgfHxcbiAgICBkYXRhIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXBcbiAgICA/IGRhdGFcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhfSBkYXRhIFRpbGUgZGF0YS5cbiAqIEByZXR1cm4ge0FycmF5TGlrZXxudWxsfSBUaGUgYXJyYXktbGlrZSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheUxpa2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICBkYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHxcbiAgICBkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgZGF0YSBpbnN0YW5jZW9mIERhdGFWaWV3XG4gICAgPyBkYXRhXG4gICAgOiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgc2V0IGFzIHRoZSBjYW5jZWxsYXRpb24gcmVhc29uIHdoZW4gYSB0aWxlIGlzIGRpc3Bvc2VkLlxuICovXG5leHBvcnQgY29uc3QgZGlzcG9zZWRFcnJvciA9IG5ldyBFcnJvcignZGlzcG9zZWQnKTtcblxuLyoqXG4gKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9XG4gKi9cbmxldCBzaGFyZWRDb250ZXh0ID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlTGlrZX0gaW1hZ2UgVGhlIGltYWdlLlxuICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl9IFRoZSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShpbWFnZSkge1xuICBpZiAoIXNoYXJlZENvbnRleHQpIHtcbiAgICBzaGFyZWRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgaW1hZ2Uud2lkdGgsXG4gICAgICBpbWFnZS5oZWlnaHQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB7d2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlfSxcbiAgICApO1xuICB9XG4gIGNvbnN0IGNhbnZhcyA9IHNoYXJlZENvbnRleHQuY2FudmFzO1xuICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICBpZiAoY2FudmFzLndpZHRoICE9PSB3aWR0aCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgaWYgKGNhbnZhcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgc2hhcmVkQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIHNoYXJlZENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgcmV0dXJuIHNoYXJlZENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi9zaXplLmpzJykuU2l6ZX1cbiAqL1xuY29uc3QgZGVmYXVsdFNpemUgPSBbMjU2LCAyNTZdO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBQcm9taXNlPERhdGE+fSBsb2FkZXIgRGF0YSBsb2FkZXIuICBGb3IgbG9hZGVycyB0aGF0IGdlbmVyYXRlIGltYWdlcyxcbiAqIHRoZSBwcm9taXNlIHNob3VsZCBub3QgcmVzb2x2ZSB1bnRpbCB0aGUgaW1hZ2UgaXMgbG9hZGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gQSBkdXJhdGlvbiBmb3IgdGlsZSBvcGFjaXR5XG4gKiB0cmFuc2l0aW9ucyBpbiBtaWxsaXNlY29uZHMuIEEgZHVyYXRpb24gb2YgMCBkaXNhYmxlcyB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9ZmFsc2VdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiB0aGUgbmVhcmVzdCBuZWlnaGJvciBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL3NpemUuanMnKS5TaXplfSBbc2l6ZT1bMjU2LCAyNTZdXSBUaWxlIHNpemUuXG4gKiBAcHJvcGVydHkge0Fib3J0Q29udHJvbGxlcn0gW2NvbnRyb2xsZXJdIEFuIGFib3J0IGNvbnRyb2xsZXIuXG4gKiBAYXBpXG4gKi9cblxuY2xhc3MgRGF0YVRpbGUgZXh0ZW5kcyBUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBUaWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBUaWxlU3RhdGUuSURMRTtcblxuICAgIHN1cGVyKG9wdGlvbnMudGlsZUNvb3JkLCBzdGF0ZSwge1xuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oKTogUHJvbWlzZTxEYXRhPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVyXyA9IG9wdGlvbnMubG9hZGVyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0RhdGF9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRhdGFfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFcnJvcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4vc2l6ZS5qcycpLlNpemV8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV8gPSBvcHRpb25zLnNpemUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYm9ydENvbnRyb2xsZXJ8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbGxlcl8gPSBvcHRpb25zLmNvbnRyb2xsZXIgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgc2l6ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KCcuL3NpemUuanMnKS5TaXplfSBUaWxlIHNpemUuXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIGlmICh0aGlzLnNpemVfKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gYXNJbWFnZUxpa2UodGhpcy5kYXRhXyk7XG4gICAgaWYgKGltYWdlRGF0YSkge1xuICAgICAgcmV0dXJuIFtpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHRdO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFNpemU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIGZvciB0aGUgdGlsZS5cbiAgICogQHJldHVybiB7RGF0YX0gVGlsZSBkYXRhLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbnkgbG9hZGluZyBlcnJvci5cbiAgICogQHJldHVybiB7RXJyb3J9IExvYWRpbmcgZXJyb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmVycm9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSB0aWxlIGRhdGEuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBUaWxlU3RhdGUuSURMRSAmJiB0aGlzLnN0YXRlICE9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FESU5HO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5sb2FkZXJfKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YV8gPSBkYXRhO1xuICAgICAgICBzZWxmLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICAgICAgc2VsZi5jaGFuZ2VkKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBzZWxmLmVycm9yXyA9IGVycm9yO1xuICAgICAgICBzZWxmLnN0YXRlID0gVGlsZVN0YXRlLkVSUk9SO1xuICAgICAgICBzZWxmLmNoYW5nZWQoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5jb250cm9sbGVyXykge1xuICAgICAgdGhpcy5jb250cm9sbGVyXy5hYm9ydChkaXNwb3NlZEVycm9yKTtcbiAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhVGlsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9EaXNwb3NhYmxlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBPYmplY3RzIHRoYXQgbmVlZCB0byBjbGVhbiB1cCBhZnRlciB0aGVtc2VsdmVzLlxuICovXG5jbGFzcyBEaXNwb3NhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5kaXNwb3NlZCkge1xuICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbnNpb24gcG9pbnQgZm9yIGRpc3Bvc2FibGUgb2JqZWN0cy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzcG9zYWJsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9JbWFnZVxuICovXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQge0NSRUFURV9JTUFHRV9CSVRNQVAsIElNQUdFX0RFQ09ERX0gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IHtsaXN0ZW5PbmNlLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge3RvUHJvbWlzZX0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ltYWdlfkltYWdlV3JhcHBlcn0gZm9yIHRoZSBpbWFnZSBhbmQgYVxuICogYHtzdHJpbmd9YCBmb3IgdGhlIHNyYyBhcyBhcmd1bWVudHMuIEl0IGlzIHN1cHBvc2VkIHRvIG1ha2UgaXQgc28gdGhlXG4gKiB1bmRlcmx5aW5nIGltYWdlIHtAbGluayBtb2R1bGU6b2wvSW1hZ2V+SW1hZ2VXcmFwcGVyI2dldEltYWdlfSBpcyBhc3NpZ25lZCB0aGVcbiAqIGNvbnRlbnQgc3BlY2lmaWVkIGJ5IHRoZSBzcmMuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGlzXG4gKlxuICogICAgIGZ1bmN0aW9uKGltYWdlLCBzcmMpIHtcbiAqICAgICAgIGltYWdlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogICAgIH1cbiAqXG4gKiBQcm92aWRpbmcgYSBjdXN0b20gYGltYWdlTG9hZEZ1bmN0aW9uYCBjYW4gYmUgdXNlZnVsIHRvIGxvYWQgaW1hZ2VzIHdpdGhcbiAqIHBvc3QgcmVxdWVzdHMgb3IgLSBpbiBnZW5lcmFsIC0gdGhyb3VnaCBYSFIgcmVxdWVzdHMsIHdoZXJlIHRoZSBzcmMgb2YgdGhlXG4gKiBpbWFnZSBlbGVtZW50IHdvdWxkIGJlIHNldCB0byBhIGRhdGEgVVJJIHdoZW4gdGhlIGNvbnRlbnQgaXMgbG9hZGVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHQsIHN0cmluZyk6IHZvaWR9IExvYWRGdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSW1hZ2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQsIGlmIGRpZmZlcmVudCBmcm9tIHRoZSByZXF1ZXN0ZWQgb25lLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Jlc29sdXRpb24uanNcIikuUmVzb2x1dGlvbkxpa2V9IFtyZXNvbHV0aW9uXSBSZXNvbHV0aW9uLCBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgcmVxdWVzdGVkIG9uZS5cbiAqIFdoZW4geCBhbmQgeSByZXNvbHV0aW9uIGFyZSBkaWZmZXJlbnQsIHVzZSB0aGUgYXJyYXkgdHlwZSAoYFt4UmVzb2x1dGlvbiwgeVJlc29sdXRpb25dYCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsUmF0aW9dIFBpeGVsIHJhdGlvLCBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgcmVxdWVzdGVkIG9uZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBpbWFnZSBJbWFnZS5cbiAqL1xuXG4vKipcbiAqIExvYWRlciBmdW5jdGlvbiB1c2VkIGZvciBpbWFnZSBzb3VyY2VzLiBSZWNlaXZlcyBleHRlbnQsIHJlc29sdXRpb24gYW5kIHBpeGVsIHJhdGlvIGFzIGFyZ3VtZW50cy5cbiAqIEZvciBpbWFnZXMgdGhhdCBjb3ZlciBhbnkgZXh0ZW50IGFuZCByZXNvbHV0aW9uIChzdGF0aWMgaW1hZ2VzKSwgdGhlIGxvYWRlciBmdW5jdGlvbiBzaG91bGQgbm90IGFjY2VwdFxuICogYW55IGFyZ3VtZW50cy4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYW4ge0BsaW5rIGltcG9ydChcIi4vRGF0YVRpbGUuanNcIikuSW1hZ2VMaWtlIGltYWdlfSwgYW5cbiAqIHtAbGluayBpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLkltYWdlT2JqZWN0IGltYWdlIG9iamVjdH0sIG9yIGEgcHJvbWlzZSBmb3IgdGhlIHNhbWUuXG4gKiBGb3IgbG9hZGVycyB0aGF0IGdlbmVyYXRlIGltYWdlcywgdGhlIHByb21pc2Ugc2hvdWxkIG5vdCByZXNvbHZlIHVudGlsIHRoZSBpbWFnZSBpcyBsb2FkZWQuXG4gKiBJZiB0aGUgcmV0dXJuZWQgaW1hZ2UgZG9lcyBub3QgbWF0Y2ggdGhlIGV4dGVudCwgcmVzb2x1dGlvbiBvciBwaXhlbCByYXRpbyBwYXNzZWQgdG8gdGhlIGxvYWRlcixcbiAqIGl0IGhhcyB0byByZXR1cm4gYW4ge0BsaW5rIGltcG9ydChcIi4vSW1hZ2UuanNcIikuSW1hZ2VPYmplY3QgaW1hZ2Ugb2JqZWN0fSB3aXRoIHRoZSBgaW1hZ2VgIGFuZCB0aGVcbiAqIGNvcnJlY3QgYGV4dGVudGAsIGByZXNvbHV0aW9uYCBhbmQgYHBpeGVsUmF0aW9gLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlciwgbnVtYmVyLCAoZnVuY3Rpb24oSFRNTEltYWdlRWxlbWVudCwgc3RyaW5nKTogdm9pZCk9KTogaW1wb3J0KFwiLi9EYXRhVGlsZS5qc1wiKS5JbWFnZUxpa2V8SW1hZ2VPYmplY3R8UHJvbWlzZTxpbXBvcnQoXCIuL0RhdGFUaWxlLmpzXCIpLkltYWdlTGlrZXxJbWFnZU9iamVjdD59IExvYWRlclxuICogQGFwaVxuICovXG5cbi8qKlxuICogTG9hZGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGltYWdlIHNvdXJjZXMuIFJlY2VpdmVzIGV4dGVudCwgcmVzb2x1dGlvbiBhbmQgcGl4ZWwgcmF0aW8gYXMgYXJndW1lbnRzLlxuICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlIGZvciBhbiAge0BsaW5rIGltcG9ydChcIi4vSW1hZ2UuanNcIikuSW1hZ2VPYmplY3QgaW1hZ2Ugb2JqZWN0fS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LCBudW1iZXIsIG51bWJlciwgKGZ1bmN0aW9uKEhUTUxJbWFnZUVsZW1lbnQsIHN0cmluZyk6IHZvaWQpPSk6IGltcG9ydChcIi4vRGF0YVRpbGUuanNcIikuSW1hZ2VMaWtlfEltYWdlT2JqZWN0fFByb21pc2U8aW1wb3J0KFwiLi9EYXRhVGlsZS5qc1wiKS5JbWFnZUxpa2V8SW1hZ2VPYmplY3Q+fSBJbWFnZU9iamVjdFByb21pc2VMb2FkZXJcbiAqL1xuXG5jbGFzcyBJbWFnZVdyYXBwZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi4gSWYgcHJvdmlkZWQgYXMgYXJyYXksIHggYW5kIHlcbiAgICogcmVzb2x1dGlvbiB3aWxsIGJlIGFzc3VtZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vSW1hZ2UuanNcIikuTG9hZGVyfSBzdGF0ZU9yTG9hZGVyIFN0YXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdGF0ZU9yTG9hZGVyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ8QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9XG4gICAgICB0eXBlb2Ygc3RhdGVPckxvYWRlciA9PT0gJ2Z1bmN0aW9uJyA/IEltYWdlU3RhdGUuSURMRSA6IHN0YXRlT3JMb2FkZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuTG9hZGVyfVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVyID0gdHlwZW9mIHN0YXRlT3JMb2FkZXIgPT09ICdmdW5jdGlvbicgPyBzdGF0ZU9yTG9hZGVyIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjaGFuZ2VkKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICovXG4gIGdldEV4dGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBJbWFnZS5cbiAgICovXG4gIGdldEltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsUmF0aW8uXG4gICAqL1xuICBnZXRQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW9fO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcnxBcnJheTxudW1iZXI+fSBSZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnJlc29sdXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBTdGF0ZS5cbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLnN0YXRlID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgICBjb25zdCByZXF1ZXN0UmVzb2x1dGlvbiA9IEFycmF5LmlzQXJyYXkocmVzb2x1dGlvbilcbiAgICAgICAgICA/IHJlc29sdXRpb25bMF1cbiAgICAgICAgICA6IHJlc29sdXRpb247XG4gICAgICAgIHRvUHJvbWlzZSgoKSA9PlxuICAgICAgICAgIHRoaXMubG9hZGVyKFxuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnQoKSxcbiAgICAgICAgICAgIHJlcXVlc3RSZXNvbHV0aW9uLFxuICAgICAgICAgICAgdGhpcy5nZXRQaXhlbFJhdGlvKCksXG4gICAgICAgICAgKSxcbiAgICAgICAgKVxuICAgICAgICAgIC50aGVuKChpbWFnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCdpbWFnZScgaW4gaW1hZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbWFnZV8gPSBpbWFnZS5pbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnZXh0ZW50JyBpbiBpbWFnZSkge1xuICAgICAgICAgICAgICB0aGlzLmV4dGVudCA9IGltYWdlLmV4dGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncmVzb2x1dGlvbicgaW4gaW1hZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gaW1hZ2UucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncGl4ZWxSYXRpbycgaW4gaW1hZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5waXhlbFJhdGlvXyA9IGltYWdlLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICAgICAgICAgICBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwIHx8XG4gICAgICAgICAgICAgIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICAgICAgICAgICAgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBJbWFnZVN0YXRlLkVSUk9SO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5jaGFuZ2VkKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gaW1hZ2UgVGhlIGltYWdlLlxuICAgKi9cbiAgc2V0SW1hZ2UoaW1hZ2UpIHtcbiAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5PG51bWJlcj59IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICovXG4gIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gaW1hZ2UgSW1hZ2UgZWxlbWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTphbnl9IGxvYWRIYW5kbGVyIExvYWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6YW55fSBlcnJvckhhbmRsZXIgRXJyb3IgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpOnZvaWR9IENhbGxiYWNrIHRvIHN0b3AgbGlzdGVuaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuSW1hZ2UoaW1hZ2UsIGxvYWRIYW5kbGVyLCBlcnJvckhhbmRsZXIpIHtcbiAgY29uc3QgaW1nID0gLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAoaW1hZ2UpO1xuICBsZXQgbGlzdGVuaW5nID0gdHJ1ZTtcbiAgbGV0IGRlY29kaW5nID0gZmFsc2U7XG4gIGxldCBsb2FkZWQgPSBmYWxzZTtcblxuICBjb25zdCBsaXN0ZW5lcktleXMgPSBbXG4gICAgbGlzdGVuT25jZShpbWcsIEV2ZW50VHlwZS5MT0FELCBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgaWYgKCFkZWNvZGluZykge1xuICAgICAgICBsb2FkSGFuZGxlcigpO1xuICAgICAgfVxuICAgIH0pLFxuICBdO1xuXG4gIGlmIChpbWcuc3JjICYmIElNQUdFX0RFQ09ERSkge1xuICAgIGRlY29kaW5nID0gdHJ1ZTtcbiAgICBpbWdcbiAgICAgIC5kZWNvZGUoKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICAgICAgbG9hZEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgICAgIGxvYWRIYW5kbGVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXJLZXlzLnB1c2gobGlzdGVuT25jZShpbWcsIEV2ZW50VHlwZS5FUlJPUiwgZXJyb3JIYW5kbGVyKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gdW5saXN0ZW4oKSB7XG4gICAgbGlzdGVuaW5nID0gZmFsc2U7XG4gICAgbGlzdGVuZXJLZXlzLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gIH07XG59XG5cbi8qKlxuICogTG9hZHMgYW4gaW1hZ2UuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltYWdlIEltYWdlLCBub3QgeWV0IGxvYWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSBgc3JjYCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlLiBPcHRpb25hbCwgbm90IHJlcXVpcmVkIGlmIGFscmVhZHkgcHJlc2VudC5cbiAqIEByZXR1cm4ge1Byb21pc2U8SFRNTEltYWdlRWxlbWVudD59IFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGBIVE1MSW1hZ2VFbGVtZW50YC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWQoaW1hZ2UsIHNyYykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ltYWdlIGxvYWQgZXJyb3InKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVubGlzdGVuKCkge1xuICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZUxvYWQpO1xuICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgfVxuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVMb2FkKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICBpZiAoc3JjKSB7XG4gICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltYWdlIEltYWdlLCBub3QgeWV0IGxvYWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSBgc3JjYCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlLiBPcHRpb25hbCwgbm90IHJlcXVpcmVkIGlmIGFscmVhZHkgcHJlc2VudC5cbiAqIEByZXR1cm4ge1Byb21pc2U8SFRNTEltYWdlRWxlbWVudD59IFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGBIVE1MSW1hZ2VFbGVtZW50YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUZhbGxiYWNrKGltYWdlLCBzcmMpIHtcbiAgaWYgKHNyYykge1xuICAgIGltYWdlLnNyYyA9IHNyYztcbiAgfVxuICByZXR1cm4gaW1hZ2Uuc3JjICYmIElNQUdFX0RFQ09ERVxuICAgID8gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgaW1hZ2VcbiAgICAgICAgICAuZGVjb2RlKClcbiAgICAgICAgICAudGhlbigoKSA9PiByZXNvbHZlKGltYWdlKSlcbiAgICAgICAgICAuY2F0Y2goKGUpID0+XG4gICAgICAgICAgICBpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS53aWR0aCA/IHJlc29sdmUoaW1hZ2UpIDogcmVqZWN0KGUpLFxuICAgICAgICAgICksXG4gICAgICApXG4gICAgOiBsb2FkKGltYWdlKTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZSBhbmQgZGVjb2RlcyBpdCB0byBhbiBgSW1hZ2VCaXRtYXBgIGlmIGBjcmVhdGVJbWFnZUJpdG1hcCgpYCBpcyBzdXBwb3J0ZWQuIFJldHVybnNcbiAqIHRoZSBsb2FkZWQgaW1hZ2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSBJbWFnZSwgbm90IHlldCBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gYHNyY2AgYXR0cmlidXRlIG9mIHRoZSBpbWFnZS4gT3B0aW9uYWwsIG5vdCByZXF1aXJlZCBpZiBhbHJlYWR5IHByZXNlbnQuXG4gKiBAcmV0dXJuIHtQcm9taXNlPEltYWdlQml0bWFwfEhUTUxJbWFnZUVsZW1lbnQ+fSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBgSW1hZ2VCaXRtYXBgIG9yIGFuXG4gKiBgSFRNTEltYWdlRWxlbWVudGAgaWYgYGNyZWF0ZUltYWdlQml0bWFwKClgIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoaW1hZ2UsIHNyYykge1xuICBpZiAoc3JjKSB7XG4gICAgaW1hZ2Uuc3JjID0gc3JjO1xuICB9XG4gIHJldHVybiBpbWFnZS5zcmMgJiYgSU1BR0VfREVDT0RFICYmIENSRUFURV9JTUFHRV9CSVRNQVBcbiAgICA/IGltYWdlXG4gICAgICAgIC5kZWNvZGUoKVxuICAgICAgICAudGhlbigoKSA9PiBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSkpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KVxuICAgIDogZGVjb2RlRmFsbGJhY2soaW1hZ2UpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVdyYXBwZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIEVSUk9SOiAzLFxuICBFTVBUWTogNCxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VUaWxlXG4gKi9cbmltcG9ydCBUaWxlIGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2xpc3RlbkltYWdlfSBmcm9tICcuL0ltYWdlLmpzJztcblxuY2xhc3MgSW1hZ2VUaWxlIGV4dGVuZHMgVGlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBJbWFnZSBzb3VyY2UgVVJJLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGUgbG9hZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuT3B0aW9uc30gW29wdGlvbnNdIFRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbGVDb29yZCwgc3RhdGUsIHNyYywgY3Jvc3NPcmlnaW4sIHRpbGVMb2FkRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBzdXBlcih0aWxlQ29vcmQsIHN0YXRlLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbl8gPSBjcm9zc09yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIEltYWdlIFVSSVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3JjXyA9IHNyYztcblxuICAgIHRoaXMua2V5ID0gc3JjO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICAgIGlmIChjcm9zc09yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24oKTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMudW5saXN0ZW5fID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyA9IHRpbGVMb2FkRnVuY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBIVE1MIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgdGlsZSAobWF5IGJlIGEgQ2FudmFzLCBJbWFnZSwgb3IgVmlkZW8pLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IEltYWdlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBIVE1MIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgdGlsZSAobWF5IGJlIGEgQ2FudmFzIG9yIHByZWxvYWRlZCBJbWFnZSkuXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gZWxlbWVudCBFbGVtZW50LlxuICAgKi9cbiAgc2V0SW1hZ2UoZWxlbWVudCkge1xuICAgIHRoaXMuaW1hZ2VfID0gZWxlbWVudDtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIGxvYWRpbmcgb3IgcmVhZCBlcnJvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVJbWFnZUVycm9yXygpIHtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmltYWdlXyA9IGdldEJsYW5rSW1hZ2UoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja3Mgc3VjY2Vzc2Z1bCBpbWFnZSBsb2FkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VMb2FkXygpIHtcbiAgICBjb25zdCBpbWFnZSA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKHRoaXMuaW1hZ2VfKTtcbiAgICBpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmIGltYWdlLm5hdHVyYWxIZWlnaHQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH1cbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgaW1hZ2Ugb3IgcmV0cnkgaWYgbG9hZGluZyBwcmV2aW91c2x5IGZhaWxlZC5cbiAgICogTG9hZGluZyBpcyB0YWtlbiBjYXJlIG9mIGJ5IHRoZSB0aWxlIHF1ZXVlLCBhbmQgY2FsbGluZyB0aGlzIG1ldGhvZCBpc1xuICAgKiBvbmx5IG5lZWRlZCBmb3IgcHJlbG9hZGluZyBvciBmb3IgcmVsb2FkaW5nIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gICAqXG4gICAqIFRvIHJldHJ5IGxvYWRpbmcgdGlsZXMgb24gZmFpbGVkIHJlcXVlc3RzLCB1c2UgYSBjdXN0b20gYHRpbGVMb2FkRnVuY3Rpb25gXG4gICAqIHRoYXQgY2hlY2tzIGZvciBlcnJvciBzdGF0dXMgY29kZXMgYW5kIHJlbG9hZHMgb25seSB3aGVuIHRoZSBzdGF0dXMgY29kZSBpc1xuICAgKiA0MDgsIDQyOSwgNTAwLCA1MDIsIDUwMyBhbmQgNTA0LCBhbmQgb25seSB3aGVuIG5vdCB0b28gbWFueSByZXRyaWVzIGhhdmUgYmVlblxuICAgKiBtYWRlIGFscmVhZHk6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJldHJ5Q29kZXMgPSBbNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF07XG4gICAqIGNvbnN0IHJldHJpZXMgPSB7fTtcbiAgICogc291cmNlLnNldFRpbGVMb2FkRnVuY3Rpb24oKHRpbGUsIHNyYykgPT4ge1xuICAgKiAgIGNvbnN0IGltYWdlID0gdGlsZS5nZXRJbWFnZSgpO1xuICAgKiAgIGZldGNoKHNyYylcbiAgICogICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgKiAgICAgICBpZiAocmV0cnlDb2Rlcy5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAqICAgICAgICAgcmV0cmllc1tzcmNdID0gKHJldHJpZXNbc3JjXSB8fCAwKSArIDE7XG4gICAqICAgICAgICAgaWYgKHJldHJpZXNbc3JjXSA8PSAzKSB7XG4gICAqICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRpbGUubG9hZCgpLCByZXRyaWVzW3NyY10gKiAxMDAwKTtcbiAgICogICAgICAgICB9XG4gICAqICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAqICAgICAgIH1cbiAgICogICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICogICAgIH0pXG4gICAqICAgICAudGhlbigoYmxvYikgPT4ge1xuICAgKiAgICAgICBjb25zdCBpbWFnZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAqICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xuICAgKiAgICAgICBzZXRUaW1lb3V0KCgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwoaW1hZ2VVcmwpLCA1MDAwKTtcbiAgICogICAgIH0pXG4gICAqICAgICAuY2F0Y2goKCkgPT4gdGlsZS5zZXRTdGF0ZSgzKSk7IC8vIGVycm9yXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLklETEU7XG4gICAgICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW5fICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbl8odGhpcywgdGhpcy5zcmNfKTtcbiAgICAgIHRoaXMudW5saXN0ZW5fID0gbGlzdGVuSW1hZ2UoXG4gICAgICAgIHRoaXMuaW1hZ2VfLFxuICAgICAgICB0aGlzLmhhbmRsZUltYWdlTG9hZF8uYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUVycm9yXy5iaW5kKHRoaXMpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzY2FyZHMgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbGlzdGVuIGZvciBsb2FkIGNvbXBsZXRpb24gb3IgZXJyb3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5saXN0ZW5JbWFnZV8oKSB7XG4gICAgaWYgKHRoaXMudW5saXN0ZW5fKSB7XG4gICAgICB0aGlzLnVubGlzdGVuXygpO1xuICAgICAgdGhpcy51bmxpc3Rlbl8gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGEgMS1waXhlbCBibGFuayBpbWFnZS5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBCbGFuayBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxhbmtJbWFnZSgpIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gIHJldHVybiBjdHguY2FudmFzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvS2luZXRpY1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50YXRpb24gb2YgaW5lcnRpYWwgZGVjZWxlcmF0aW9uIGZvciBtYXAgbW92ZW1lbnQuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBLaW5ldGljIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWNheSBSYXRlIG9mIGRlY2F5IChtdXN0IGJlIG5lZ2F0aXZlKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblZlbG9jaXR5IE1pbmltdW0gdmVsb2NpdHkgKHBpeGVscy9taWxsaXNlY29uZCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBEZWxheSB0byBjb25zaWRlciB0byBjYWxjdWxhdGUgdGhlIGtpbmV0aWNcbiAgICogICAgIGluaXRpYWwgdmFsdWVzIChtaWxsaXNlY29uZHMpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVjYXksIG1pblZlbG9jaXR5LCBkZWxheSkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2F5XyA9IGRlY2F5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluVmVsb2NpdHlfID0gbWluVmVsb2NpdHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWxheV8gPSBkZWxheTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5wb2ludHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBiZWdpbigpIHtcbiAgICB0aGlzLnBvaW50c18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLmFuZ2xlXyA9IDA7XG4gICAgdGhpcy5pbml0aWFsVmVsb2NpdHlfID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKi9cbiAgdXBkYXRlKHgsIHkpIHtcbiAgICB0aGlzLnBvaW50c18ucHVzaCh4LCB5LCBEYXRlLm5vdygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHdlIHNob3VsZCBkbyBraW5ldGljIGFuaW1hdGlvbi5cbiAgICovXG4gIGVuZCgpIHtcbiAgICBpZiAodGhpcy5wb2ludHNfLmxlbmd0aCA8IDYpIHtcbiAgICAgIC8vIGF0IGxlYXN0IDIgcG9pbnRzIGFyZSByZXF1aXJlZCAoaS5lLiB0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IDYgZWxlbWVudHNcbiAgICAgIC8vIGluIHRoZSBhcnJheSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBEYXRlLm5vdygpIC0gdGhpcy5kZWxheV87XG4gICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5wb2ludHNfLmxlbmd0aCAtIDM7XG4gICAgaWYgKHRoaXMucG9pbnRzX1tsYXN0SW5kZXggKyAyXSA8IGRlbGF5KSB7XG4gICAgICAvLyB0aGUgbGFzdCB0cmFja2VkIHBvaW50IGlzIHRvbyBvbGQsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHVzZXIgc3RvcHBlZFxuICAgICAgLy8gcGFubmluZyBiZWZvcmUgcmVsZWFzaW5nIHRoZSBtYXBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGZpcnN0IHBvaW50IHdoaWNoIHN0aWxsIGZhbGxzIGludG8gdGhlIGRlbGF5IHRpbWVcbiAgICBsZXQgZmlyc3RJbmRleCA9IGxhc3RJbmRleCAtIDM7XG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPiAwICYmIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4ICsgMl0gPiBkZWxheSkge1xuICAgICAgZmlyc3RJbmRleCAtPSAzO1xuICAgIH1cblxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDJdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAyXTtcbiAgICAvLyB3ZSBkb24ndCB3YW50IGEgZHVyYXRpb24gb2YgMCAoZGl2aWRlIGJ5IHplcm8pXG4gICAgLy8gd2UgYWxzbyBtYWtlIHN1cmUgdGhlIHVzZXIgcGFubmVkIGZvciBhIGR1cmF0aW9uIG9mIGF0IGxlYXN0IG9uZSBmcmFtZVxuICAgIC8vICgxLzYwcykgdG8gY29tcHV0ZSBzYW5lIGRpc3BsYWNlbWVudCB2YWx1ZXNcbiAgICBpZiAoZHVyYXRpb24gPCAxMDAwIC8gNjApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkeCA9IHRoaXMucG9pbnRzX1tsYXN0SW5kZXhdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXhdO1xuICAgIGNvbnN0IGR5ID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDFdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAxXTtcbiAgICB0aGlzLmFuZ2xlXyA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gZHVyYXRpb247XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA+IHRoaXMubWluVmVsb2NpdHlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVG90YWwgZGlzdGFuY2UgdHJhdmVsbGVkIChwaXhlbHMpLlxuICAgKi9cbiAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuICh0aGlzLm1pblZlbG9jaXR5XyAtIHRoaXMuaW5pdGlhbFZlbG9jaXR5XykgLyB0aGlzLmRlY2F5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIG9mIHRoZSBraW5ldGljIHBhbm5pbmcgYW5pbWF0aW9uIChyYWRpYW5zKS5cbiAgICovXG4gIGdldEFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLmFuZ2xlXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLaW5ldGljO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcFxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBDb21wb3NpdGVNYXBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL0NvbXBvc2l0ZS5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9sYXllci9MYXllci5qcyc7XG5pbXBvcnQgTGF5ZXJHcm91cCwge0dyb3VwRXZlbnR9IGZyb20gJy4vbGF5ZXIvR3JvdXAuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJFdmVudC5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50SGFuZGxlciBmcm9tICcuL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBFdmVudCBmcm9tICcuL01hcEV2ZW50LmpzJztcbmltcG9ydCBNYXBFdmVudFR5cGUgZnJvbSAnLi9NYXBFdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcFByb3BlcnR5IGZyb20gJy4vTWFwUHJvcGVydHkuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUaWxlUXVldWUsIHtnZXRUaWxlUHJpb3JpdHl9IGZyb20gJy4vVGlsZVF1ZXVlLmpzJztcbmltcG9ydCBWaWV3IGZyb20gJy4vVmlldy5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge0RFVklDRV9QSVhFTF9SQVRJTywgUEFTU0lWRV9FVkVOVF9MSVNURU5FUlN9IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sXG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG59IGZyb20gJy4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNyZWF0ZU9yVXBkYXRlRW1wdHksXG4gIGVxdWFscyBhcyBlcXVhbHNFeHRlbnQsXG4gIGdldEZvclZpZXdBbmRTaXplLFxuICBpc0VtcHR5LFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmF1bHRzIGFzIGRlZmF1bHRDb250cm9sc30gZnJvbSAnLi9jb250cm9sL2RlZmF1bHRzLmpzJztcbmltcG9ydCB7ZGVmYXVsdHMgYXMgZGVmYXVsdEludGVyYWN0aW9uc30gZnJvbSAnLi9pbnRlcmFjdGlvbi9kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi9hcnJheS5qcyc7XG5pbXBvcnQge2Zyb21Vc2VyQ29vcmRpbmF0ZSwgdG9Vc2VyQ29vcmRpbmF0ZX0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IHtoYXNBcmVhfSBmcm9tICcuL3NpemUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7d2Fybn0gZnJvbSAnLi9jb25zb2xlLmpzJztcblxuLyoqXG4gKiBTdGF0ZSBvZiB0aGUgY3VycmVudCBmcmFtZS4gT25seSBgcGl4ZWxSYXRpb2AsIGB0aW1lYCBhbmQgYHZpZXdTdGF0ZWAgc2hvdWxkXG4gKiBiZSB1c2VkIGluIGFwcGxpY2F0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZyYW1lU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvIFRoZSBwaXhlbCByYXRpbyBvZiB0aGUgZnJhbWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZSBUaGUgdGltZSB3aGVuIHJlbmRlcmluZyBvZiB0aGUgZnJhbWUgd2FzIHJlcXVlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9WaWV3LmpzXCIpLlN0YXRlfSB2aWV3U3RhdGUgVGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFuaW1hdGUgQW5pbWF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSBDb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwicmJ1c2hcIikuZGVmYXVsdDxpbXBvcnQoJy4vcmVuZGVyL2NhbnZhcy9FeGVjdXRvci5qcycpLkRlY2x1dHRlckVudHJ5Pj58bnVsbH0gZGVjbHV0dGVyXG4gKiBEZWNsdXR0ZXIgdHJlZXMgYnkgZGVjbHV0dGVyIGdyb3VwLlxuICogV2hlbiBudWxsLCBubyBkZWNsdXR0ZXJpbmcgaXMgbmVlZGVkIGJlY2F1c2Ugbm8gbGF5ZXJzIGhhdmUgZGVjbHV0dGVyaW5nIGVuYWJsZWQuXG4gKiBAcHJvcGVydHkge251bGx8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50IChpbiB2aWV3IHByb2plY3Rpb24gY29vcmRpbmF0ZXMpLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtuZXh0RXh0ZW50XSBOZXh0IGV4dGVudCBkdXJpbmcgYW4gYW5pbWF0aW9uIHNlcmllcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZT59IGxheWVyU3RhdGVzQXJyYXkgTGF5ZXJTdGF0ZXNBcnJheS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXllckluZGV4IExheWVySW5kZXguXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0gUGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0uXG4gKiBAcHJvcGVydHkge0FycmF5PFBvc3RSZW5kZXJGdW5jdGlvbj59IHBvc3RSZW5kZXJGdW5jdGlvbnMgUG9zdFJlbmRlckZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEBwcm9wZXJ0eSB7VGlsZVF1ZXVlfSB0aWxlUXVldWUgVGlsZVF1ZXVlLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgYm9vbGVhbj4+fSB1c2VkVGlsZXMgVXNlZFRpbGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB2aWV3SGludHMgVmlld0hpbnRzLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgYm9vbGVhbj4+fSB3YW50ZWRUaWxlcyBXYW50ZWRUaWxlcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXBJZCBUaGUgaWQgb2YgdGhlIG1hcC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHJlbmRlclRhcmdldHMgSWRlbnRpZmllcnMgb2YgcHJldmlvdXNseSByZW5kZXJlZCBlbGVtZW50cy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihNYXAsIEZyYW1lU3RhdGUpOiBhbnl9IFBvc3RSZW5kZXJGdW5jdGlvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXRQaXhlbE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7dW5kZWZpbmVkfGZ1bmN0aW9uKGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuL3NvdXJjZS9Tb3VyY2VcIikuZGVmYXVsdD4pOiBib29sZWFufSBbbGF5ZXJGaWx0ZXJdIExheWVyIGZpbHRlclxuICogZnVuY3Rpb24uIFRoZSBmaWx0ZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIG9uZSBhcmd1bWVudCwgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyIGxheWVyLWNhbmRpZGF0ZX0gYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLlxuICogT25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgXG4gKiB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGl0VG9sZXJhbmNlPTBdIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlIGluIGNzcyBwaXhlbHMuIFBpeGVsc1xuICogaW5zaWRlIHRoZSByYWRpdXMgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aWxsIGJlIGNoZWNrZWQgZm9yIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2hlY2tXcmFwcGVkPXRydWVdIENoZWNrLVdyYXBwZWQgV2lsbCBjaGVjayBmb3Igd3JhcHBlZCBnZW9tZXRyaWVzIGluc2lkZSB0aGUgcmFuZ2Ugb2ZcbiAqICAgKy8tIDEgd29ybGQgd2lkdGguIFdvcmtzIG9ubHkgaWYgYSBwcm9qZWN0aW9uIGlzIHVzZWQgdGhhdCBjYW4gYmUgd3JhcHBlZC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNJbnRlcm5hbFxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBbY29udHJvbHNdIENvbnRyb2xzLlxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IFtpbnRlcmFjdGlvbnNdIEludGVyYWN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9IGtleWJvYXJkRXZlbnRUYXJnZXQgS2V5Ym9hcmRFdmVudFRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IG92ZXJsYXlzIE92ZXJsYXlzLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCAqPn0gdmFsdWVzIFZhbHVlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmxheWVyZ3JvdXAnfCdjaGFuZ2U6c2l6ZSd8J2NoYW5nZTp0YXJnZXQnfCdjaGFuZ2U6dmlldyd9IE1hcE9iamVjdEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxNYXBPYmplY3RFdmVudFR5cGVzLCBpbXBvcnQoXCIuL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9NYXBCcm93c2VyRXZlbnRUeXBlXCIpLlR5cGVzLCBpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudFwiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL01hcEV2ZW50VHlwZVwiKS5UeXBlcywgaW1wb3J0KFwiLi9NYXBFdmVudFwiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL3JlbmRlci9FdmVudFR5cGVcIikuTWFwUmVuZGVyRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9yZW5kZXIvRXZlbnRcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xNYXBPYmplY3RFdmVudFR5cGVzfFxuICogICAgICBpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudFR5cGVcIikuVHlwZXN8aW1wb3J0KFwiLi9NYXBFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgIGltcG9ydChcIi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5NYXBSZW5kZXJFdmVudFR5cGVzLCBSZXR1cm4+fSBNYXBFdmVudEhhbmRsZXJcbiAqL1xuXG4vKipcbiAqIE9iamVjdCBsaXRlcmFsIHdpdGggY29uZmlnIG9wdGlvbnMgZm9yIHRoZSBtYXAuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXBPcHRpb25zXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IFtjb250cm9sc11cbiAqIENvbnRyb2xzIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBJZiBub3Qgc3BlY2lmaWVkLFxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL2RlZmF1bHRzLmRlZmF1bHRzfSBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbFJhdGlvPXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXSBUaGUgcmF0aW8gYmV0d2VlblxuICogcGh5c2ljYWwgcGl4ZWxzIGFuZCBkZXZpY2UtaW5kZXBlbmRlbnQgcGl4ZWxzIChkaXBzKSBvbiB0aGUgZGV2aWNlLlxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gW2ludGVyYWN0aW9uc11cbiAqIEludGVyYWN0aW9ucyB0aGF0IGFyZSBpbml0aWFsbHkgYWRkZWQgdG8gdGhlIG1hcC4gSWYgbm90IHNwZWNpZmllZCxcbiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vZGVmYXVsdHMuZGVmYXVsdHN9IGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fERvY3VtZW50fHN0cmluZ30gW2tleWJvYXJkRXZlbnRUYXJnZXRdIFRoZSBlbGVtZW50IHRvXG4gKiBsaXN0ZW4gdG8ga2V5Ym9hcmQgZXZlbnRzIG9uLiBUaGlzIGRldGVybWluZXMgd2hlbiB0aGUgYEtleWJvYXJkUGFuYCBhbmRcbiAqIGBLZXlib2FyZFpvb21gIGludGVyYWN0aW9ucyB0cmlnZ2VyLiBGb3IgZXhhbXBsZSwgaWYgdGhpcyBvcHRpb24gaXMgc2V0IHRvXG4gKiBgZG9jdW1lbnRgIHRoZSBrZXlib2FyZCBpbnRlcmFjdGlvbnMgd2lsbCBhbHdheXMgdHJpZ2dlci4gSWYgdGhpcyBvcHRpb24gaXNcbiAqIG5vdCBzcGVjaWZpZWQsIHRoZSBlbGVtZW50IHRoZSBsaWJyYXJ5IGxpc3RlbnMgdG8ga2V5Ym9hcmQgZXZlbnRzIG9uIGlzIHRoZVxuICogbWFwIHRhcmdldCAoaS5lLiB0aGUgdXNlci1wcm92aWRlZCBkaXYgZm9yIHRoZSBtYXApLiBJZiB0aGlzIGlzIG5vdFxuICogYGRvY3VtZW50YCwgdGhlIHRhcmdldCBlbGVtZW50IG5lZWRzIHRvIGJlIGZvY3VzZWQgZm9yIGtleSBldmVudHMgdG8gYmVcbiAqIGVtaXR0ZWQsIHJlcXVpcmluZyB0aGF0IHRoZSB0YXJnZXQgZWxlbWVudCBoYXMgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fENvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fExheWVyR3JvdXB9IFtsYXllcnNdXG4gKiBMYXllcnMuIElmIHRoaXMgaXMgbm90IGRlZmluZWQsIGEgbWFwIHdpdGggbm8gbGF5ZXJzIHdpbGwgYmUgcmVuZGVyZWQuIE5vdGVcbiAqIHRoYXQgbGF5ZXJzIGFyZSByZW5kZXJlZCBpbiB0aGUgb3JkZXIgc3VwcGxpZWQsIHNvIGlmIHlvdSB3YW50LCBmb3IgZXhhbXBsZSxcbiAqIGEgdmVjdG9yIGxheWVyIHRvIGFwcGVhciBvbiB0b3Agb2YgYSB0aWxlIGxheWVyLCBpdCBtdXN0IGNvbWUgYWZ0ZXIgdGhlIHRpbGVcbiAqIGxheWVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhUaWxlc0xvYWRpbmc9MTZdIE1heGltdW0gbnVtYmVyIHRpbGVzIHRvIGxvYWRcbiAqIHNpbXVsdGFuZW91c2x5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttb3ZlVG9sZXJhbmNlPTFdIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGluIHBpeGVscyB0aGVcbiAqIGN1cnNvciBtdXN0IG1vdmUgdG8gYmUgZGV0ZWN0ZWQgYXMgYSBtYXAgbW92ZSBldmVudCBpbnN0ZWFkIG9mIGEgY2xpY2suXG4gKiBJbmNyZWFzaW5nIHRoaXMgdmFsdWUgY2FuIG1ha2UgaXQgZWFzaWVyIHRvIGNsaWNrIG9uIHRoZSBtYXAuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gW292ZXJsYXlzXVxuICogT3ZlcmxheXMgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIEJ5IGRlZmF1bHQsIG5vIG92ZXJsYXlzIGFyZSBhZGRlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBUaGUgY29udGFpbmVyIGZvciB0aGUgbWFwLCBlaXRoZXIgdGhlXG4gKiBlbGVtZW50IGl0c2VsZiBvciB0aGUgYGlkYCBvZiB0aGUgZWxlbWVudC4gSWYgbm90IHNwZWNpZmllZCBhdCBjb25zdHJ1Y3Rpb25cbiAqIHRpbWUsIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcCNzZXRUYXJnZXR9IG11c3QgYmUgY2FsbGVkIGZvciB0aGUgbWFwIHRvIGJlXG4gKiByZW5kZXJlZC4gSWYgcGFzc2VkIGJ5IGVsZW1lbnQsIHRoZSBjb250YWluZXIgY2FuIGJlIGluIGEgc2Vjb25kYXJ5IGRvY3VtZW50LlxuICogRm9yIGFjY2Vzc2liaWxpdHkgKGZvY3VzIGFuZCBrZXlib2FyZCBldmVudHMgZm9yIG1hcCBuYXZpZ2F0aW9uKSwgdGhlIGB0YXJnZXRgIGVsZW1lbnQgbXVzdCBoYXZlIGFcbiAqICBwcm9wZXJseSBjb25maWd1cmVkIGB0YWJpbmRleGAgYXR0cmlidXRlLiBJZiB0aGUgYHRhcmdldGAgZWxlbWVudCBpcyBpbnNpZGUgYSBTaGFkb3cgRE9NLCB0aGVcbiAqICBgdGFiaW5kZXhgIGF0cmlidXRlIG11c3QgYmUgc2V0IG9uIHRoZSBjdXN0b20gZWxlbWVudCdzIGhvc3QgZWxlbWVudC5cbiAqICoqTm90ZToqKiBDU1MgYHRyYW5zZm9ybWAgc3VwcG9ydCBmb3IgdGhlIHRhcmdldCBlbGVtZW50IGlzIGxpbWl0ZWQgdG8gYHNjYWxlYC5cbiAqIEBwcm9wZXJ0eSB7Vmlld3xQcm9taXNlPGltcG9ydChcIi4vVmlldy5qc1wiKS5WaWV3T3B0aW9ucz59IFt2aWV3XSBUaGUgbWFwJ3Mgdmlldy4gIE5vIGxheWVyIHNvdXJjZXMgd2lsbCBiZVxuICogZmV0Y2hlZCB1bmxlc3MgdGhpcyBpcyBzcGVjaWZpZWQgYXQgY29uc3RydWN0aW9uIHRpbWUgb3IgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwI3NldFZpZXd9LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxheWVyTWFwUHJvcGVydHkobGF5ZXIpIHtcbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICBsYXllci5zZXRNYXBJbnRlcm5hbChudWxsKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgIGxheWVyLmdldExheWVycygpLmZvckVhY2gocmVtb3ZlTGF5ZXJNYXBQcm9wZXJ0eSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAqIEBwYXJhbSB7TWFwfSBtYXAgTWFwLlxuICovXG5mdW5jdGlvbiBzZXRMYXllck1hcFByb3BlcnR5KGxheWVyLCBtYXApIHtcbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICBsYXllci5zZXRNYXBJbnRlcm5hbChtYXApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gbGF5ZXIuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgc2V0TGF5ZXJNYXBQcm9wZXJ0eShsYXllcnNbaV0sIG1hcCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGhlIG1hcCBpcyB0aGUgY29yZSBjb21wb25lbnQgb2YgT3BlbkxheWVycy4gRm9yIGEgbWFwIHRvIHJlbmRlciwgYSB2aWV3LFxuICogb25lIG9yIG1vcmUgbGF5ZXJzLCBhbmQgYSB0YXJnZXQgY29udGFpbmVyIGFyZSBuZWVkZWQ6XG4gKlxuICogICAgIGltcG9ydCBNYXAgZnJvbSAnb2wvTWFwLmpzJztcbiAqICAgICBpbXBvcnQgVmlldyBmcm9tICdvbC9WaWV3LmpzJztcbiAqICAgICBpbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUuanMnO1xuICogICAgIGltcG9ydCBPU00gZnJvbSAnb2wvc291cmNlL09TTS5qcyc7XG4gKlxuICogICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoe1xuICogICAgICAgdmlldzogbmV3IFZpZXcoe1xuICogICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAqICAgICAgICAgem9vbTogMSxcbiAqICAgICAgIH0pLFxuICogICAgICAgbGF5ZXJzOiBbXG4gKiAgICAgICAgIG5ldyBUaWxlTGF5ZXIoe1xuICogICAgICAgICAgIHNvdXJjZTogbmV3IE9TTSgpLFxuICogICAgICAgICB9KSxcbiAqICAgICAgIF0sXG4gKiAgICAgICB0YXJnZXQ6ICdtYXAnLFxuICogICAgIH0pO1xuICpcbiAqIFRoZSBhYm92ZSBzbmlwcGV0IGNyZWF0ZXMgYSBtYXAgdXNpbmcgYSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1RpbGV+VGlsZUxheWVyfSB0b1xuICogZGlzcGxheSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9PU01+T1NNfSBPU00gZGF0YSBhbmQgcmVuZGVyIGl0IHRvIGEgRE9NXG4gKiBlbGVtZW50IHdpdGggdGhlIGlkIGBtYXBgLlxuICpcbiAqIFRoZSBjb25zdHJ1Y3RvciBwbGFjZXMgYSB2aWV3cG9ydCBjb250YWluZXIgKHdpdGggQ1NTIGNsYXNzIG5hbWVcbiAqIGBvbC12aWV3cG9ydGApIGluIHRoZSB0YXJnZXQgZWxlbWVudCAoc2VlIGBnZXRWaWV3cG9ydCgpYCksIGFuZCB0aGVuIHR3b1xuICogZnVydGhlciBlbGVtZW50cyB3aXRoaW4gdGhlIHZpZXdwb3J0OiBvbmUgd2l0aCBDU1MgY2xhc3MgbmFtZVxuICogYG9sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50YCBmb3IgY29udHJvbHMgYW5kIHNvbWUgb3ZlcmxheXMsIGFuZCBvbmUgd2l0aFxuICogQ1NTIGNsYXNzIG5hbWUgYG9sLW92ZXJsYXljb250YWluZXJgIGZvciBvdGhlciBvdmVybGF5cyAoc2VlIHRoZSBgc3RvcEV2ZW50YFxuICogb3B0aW9uIG9mIHtAbGluayBtb2R1bGU6b2wvT3ZlcmxheX5PdmVybGF5fSBmb3IgdGhlIGRpZmZlcmVuY2UpLiBUaGUgbWFwXG4gKiBpdHNlbGYgaXMgcGxhY2VkIGluIGEgZnVydGhlciBlbGVtZW50IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gKlxuICogTGF5ZXJzIGFyZSBzdG9yZWQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaW5cbiAqIGxheWVyR3JvdXBzLiBBIHRvcC1sZXZlbCBncm91cCBpcyBwcm92aWRlZCBieSB0aGUgbGlicmFyeS4gVGhpcyBpcyB3aGF0IGlzXG4gKiBhY2Nlc3NlZCBieSBgZ2V0TGF5ZXJHcm91cGAgYW5kIGBzZXRMYXllckdyb3VwYC4gTGF5ZXJzIGVudGVyZWQgaW4gdGhlXG4gKiBvcHRpb25zIGFyZSBhZGRlZCB0byB0aGlzIGdyb3VwLCBhbmQgYGFkZExheWVyYCBhbmQgYHJlbW92ZUxheWVyYCBjaGFuZ2UgdGhlXG4gKiBsYXllciBjb2xsZWN0aW9uIGluIHRoZSBncm91cC4gYGdldExheWVyc2AgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3JcbiAqIGBnZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKClgLiBOb3RlIHRoYXQge0BsaW5rIG1vZHVsZTpvbC9sYXllci9Hcm91cH5MYXllckdyb3VwfVxuICogaXMgYSBzdWJjbGFzcyBvZiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyfSwgc28gbGF5ZXJzIGVudGVyZWQgaW4gdGhlXG4gKiBvcHRpb25zIG9yIGFkZGVkIHdpdGggYGFkZExheWVyYCBjYW4gYmUgZ3JvdXBzLCB3aGljaCBjYW4gY29udGFpbiBmdXJ0aGVyXG4gKiBncm91cHMsIGFuZCBzbyBvbi5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9NYXBCcm93c2VyRXZlbnQuanNcIikuTWFwQnJvd3NlckV2ZW50XG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9NYXBFdmVudC5qc1wiKS5NYXBFdmVudFxuICogQGZpcmVzIGltcG9ydChcIi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHQjcHJlY29tcG9zZVxuICogQGZpcmVzIGltcG9ydChcIi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHQjcG9zdGNvbXBvc2VcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL3JlbmRlci9FdmVudC5qc1wiKS5kZWZhdWx0I3JlbmRlcmNvbXBsZXRlXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE1hcCBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtNYXBPcHRpb25zfSBbb3B0aW9uc10gTWFwIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNYXBFdmVudEhhbmRsZXI8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNYXBFdmVudEhhbmRsZXI8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge01hcEV2ZW50SGFuZGxlcjx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgY29uc3Qgb3B0aW9uc0ludGVybmFsID0gY3JlYXRlT3B0aW9uc0ludGVybmFsKG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckNvbXBsZXRlXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZF8gPSB0cnVlO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF8gPSB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudC5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4VGlsZXNMb2FkaW5nXyA9XG4gICAgICBvcHRpb25zLm1heFRpbGVzTG9hZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhUaWxlc0xvYWRpbmcgOiAxNjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID1cbiAgICAgIG9wdGlvbnMucGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5waXhlbFJhdGlvXG4gICAgICAgIDogREVWSUNFX1BJWEVMX1JBVElPO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD59XG4gICAgICovXG4gICAgdGhpcy5wb3N0UmVuZGVyVGltZW91dEhhbmRsZV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvbkRlbGF5XyA9IHRoaXMuYW5pbWF0aW9uRGVsYXlfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVJbmRleF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0ZyYW1lU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXh0ZW50IGF0IHRoZSBwcmV2aW91cyAnbW92ZWVuZCcgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNFeHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdwb3J0XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMudmlld3BvcnRfLmNsYXNzTmFtZSA9XG4gICAgICAnb2wtdmlld3BvcnQnICsgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyA/ICcgb2wtdG91Y2gnIDogJycpO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5zdHlsZS56SW5kZXggPSAnMCc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5jbGFzc05hbWUgPSAnb2wtb3ZlcmxheWNvbnRhaW5lcic7XG4gICAgdGhpcy52aWV3cG9ydF8uYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5Q29udGFpbmVyXyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshSFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uc3R5bGUuekluZGV4ID0gJzAnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uY2xhc3NOYW1lID0gJ29sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50JztcbiAgICB0aGlzLnZpZXdwb3J0Xy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge01hcEJyb3dzZXJFdmVudEhhbmRsZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tb3ZlVG9sZXJhbmNlXyA9IG9wdGlvbnMubW92ZVRvbGVyYW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fERvY3VtZW50fVxuICAgICAqL1xuICAgIHRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF8gPSBvcHRpb25zSW50ZXJuYWwua2V5Ym9hcmRFdmVudFRhcmdldDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0Q2hhbmdlSGFuZGxlcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRFbGVtZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXyA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLnVwZGF0ZVNpemUoKSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5jb250cm9scyA9IG9wdGlvbnNJbnRlcm5hbC5jb250cm9scyB8fCBkZWZhdWx0Q29udHJvbHMoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25zID1cbiAgICAgIG9wdGlvbnNJbnRlcm5hbC5pbnRlcmFjdGlvbnMgfHxcbiAgICAgIGRlZmF1bHRJbnRlcmFjdGlvbnMoe1xuICAgICAgICBvbkZvY3VzT25seTogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5c18gPSBvcHRpb25zSW50ZXJuYWwub3ZlcmxheXM7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBvdmVybGF5cyBieSBpZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5SWRJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3JlbmRlcmVyL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8UG9zdFJlbmRlckZ1bmN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtUaWxlUXVldWV9XG4gICAgICovXG4gICAgdGhpcy50aWxlUXVldWVfID0gbmV3IFRpbGVRdWV1ZShcbiAgICAgIHRoaXMuZ2V0VGlsZVByaW9yaXR5LmJpbmQodGhpcyksXG4gICAgICB0aGlzLmhhbmRsZVRpbGVDaGFuZ2VfLmJpbmQodGhpcyksXG4gICAgKTtcblxuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoXG4gICAgICBNYXBQcm9wZXJ0eS5MQVlFUkdST1VQLFxuICAgICAgdGhpcy5oYW5kbGVMYXllckdyb3VwQ2hhbmdlZF8sXG4gICAgKTtcbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKE1hcFByb3BlcnR5LlZJRVcsIHRoaXMuaGFuZGxlVmlld0NoYW5nZWRfKTtcbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKE1hcFByb3BlcnR5LlNJWkUsIHRoaXMuaGFuZGxlU2l6ZUNoYW5nZWRfKTtcbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKE1hcFByb3BlcnR5LlRBUkdFVCwgdGhpcy5oYW5kbGVUYXJnZXRDaGFuZ2VkXyk7XG5cbiAgICAvLyBzZXRQcm9wZXJ0aWVzIHdpbGwgdHJpZ2dlciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBtYXAgaWYgdGhlIG1hcFxuICAgIC8vIGlzIFwiZGVmaW5lZFwiIGFscmVhZHkuXG4gICAgdGhpcy5zZXRQcm9wZXJ0aWVzKG9wdGlvbnNJbnRlcm5hbC52YWx1ZXMpO1xuXG4gICAgY29uc3QgbWFwID0gdGhpcztcbiAgICBpZiAob3B0aW9ucy52aWV3ICYmICEob3B0aW9ucy52aWV3IGluc3RhbmNlb2YgVmlldykpIHtcbiAgICAgIG9wdGlvbnMudmlldy50aGVuKGZ1bmN0aW9uICh2aWV3T3B0aW9ucykge1xuICAgICAgICBtYXAuc2V0VmlldyhuZXcgVmlldyh2aWV3T3B0aW9ucykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9scy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50XG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcCh0aGlzKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMuY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKG51bGwpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAodGhpcyk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9ucy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMub3ZlcmxheXNfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfKGV2ZW50LmVsZW1lbnQpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5vdmVybGF5c18uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGV2ZW50LmVsZW1lbnQuZ2V0SWQoKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLmNvbnRyb2xzLmZvckVhY2goXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdH0gY29udHJvbCBDb250cm9sLlxuICAgICAgICovXG4gICAgICAoY29udHJvbCkgPT4ge1xuICAgICAgICBjb250cm9sLnNldE1hcCh0aGlzKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmZvckVhY2goXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fSBpbnRlcmFjdGlvbiBJbnRlcmFjdGlvbi5cbiAgICAgICAqL1xuICAgICAgKGludGVyYWN0aW9uKSA9PiB7XG4gICAgICAgIGludGVyYWN0aW9uLnNldE1hcCh0aGlzKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMub3ZlcmxheXNfLmZvckVhY2godGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR9IGNvbnRyb2wgQ29udHJvbC5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRkQ29udHJvbChjb250cm9sKSB7XG4gICAgdGhpcy5nZXRDb250cm9scygpLnB1c2goY29udHJvbCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBpbnRlcmFjdGlvbiB0byB0aGUgbWFwLiBJZiB5b3Ugd2FudCB0byBhZGQgYW4gaW50ZXJhY3Rpb25cbiAgICogYXQgYW5vdGhlciBwb2ludCBvZiB0aGUgY29sbGVjdGlvbiB1c2UgYGdldEludGVyYWN0aW9ucygpYCBhbmQgdGhlIG1ldGhvZHNcbiAgICogYXZhaWxhYmxlIG9uIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufS4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuICAgKiBzdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbiBmcm9tIHRoZSBoYW5kbGVFdmVudCBmdW5jdGlvbi4gVGhlIGludGVyYWN0aW9uc1xuICAgKiBnZXQgdG8gaGFuZGxlIHRoZSBldmVudHMgaW4gdGhlIHJldmVyc2Ugb3JkZXIgb2YgdGhpcyBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24gdG8gYWRkLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRJbnRlcmFjdGlvbihpbnRlcmFjdGlvbikge1xuICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkucHVzaChpbnRlcmFjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIHRvcCBvZiB0aGlzIG1hcC4gSWYgeW91IHdhbnQgdG8gYWRkIGEgbGF5ZXJcbiAgICogZWxzZXdoZXJlIGluIHRoZSBzdGFjaywgdXNlIGBnZXRMYXllcnMoKWAgYW5kIHRoZSBtZXRob2RzIGF2YWlsYWJsZSBvblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRMYXllcihsYXllcikge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpO1xuICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvR3JvdXAuanNcIikuR3JvdXBFdmVudH0gZXZlbnQgVGhlIGxheWVyIGFkZCBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyQWRkXyhldmVudCkge1xuICAgIHNldExheWVyTWFwUHJvcGVydHkoZXZlbnQubGF5ZXIsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gb3ZlcmxheSB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZE92ZXJsYXkob3ZlcmxheSkge1xuICAgIHRoaXMuZ2V0T3ZlcmxheXMoKS5wdXNoKG92ZXJsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGVhbHMgd2l0aCBtYXAncyBvdmVybGF5IGNvbGxlY3Rpb24gY2hhbmdlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gb3ZlcmxheSBPdmVybGF5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkT3ZlcmxheUludGVybmFsXyhvdmVybGF5KSB7XG4gICAgY29uc3QgaWQgPSBvdmVybGF5LmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldID0gb3ZlcmxheTtcbiAgICB9XG4gICAgb3ZlcmxheS5zZXRNYXAodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQ2xlYW4gdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMuY29udHJvbHMuY2xlYXIoKTtcbiAgICB0aGlzLmludGVyYWN0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMub3ZlcmxheXNfLmNsZWFyKCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuc2V0VGFyZ2V0KG51bGwpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydCwgYW5kIGV4ZWN1dGUgYVxuICAgKiBjYWxsYmFjayB3aXRoIGVhY2ggaW50ZXJzZWN0aW5nIGZlYXR1cmUuIExheWVycyBpbmNsdWRlZCBpbiB0aGUgZGV0ZWN0aW9uIGNhblxuICAgKiBiZSBjb25maWd1cmVkIHRocm91Z2ggdGhlIGBsYXllckZpbHRlcmAgb3B0aW9uIGluIGBvcHRpb25zYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuL3NvdXJjZS9Tb3VyY2VcIikuZGVmYXVsdD4sIGltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0KTogVH0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICogICAgIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBvbmVcbiAgICogICAgIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlIGZlYXR1cmV9IG9yXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlflJlbmRlckZlYXR1cmUgcmVuZGVyIGZlYXR1cmV9IGF0IHRoZSBwaXhlbCwgdGhlIHNlY29uZCBpc1xuICAgKiAgICAgdGhlIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJ9IG9mIHRoZSBmZWF0dXJlIGFuZCB3aWxsIGJlIG51bGwgZm9yXG4gICAqICAgICB1bm1hbmFnZWQgbGF5ZXJzLiBUbyBzdG9wIGRldGVjdGlvbiwgY2FsbGJhY2sgZnVuY3Rpb25zIGNhbiByZXR1cm4gYVxuICAgKiAgICAgdHJ1dGh5IHZhbHVlLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdCwgaS5lLiB0aGUgcmV0dXJuIHZhbHVlIG9mIGxhc3RcbiAgICogY2FsbGJhY2sgZXhlY3V0aW9uLCBvciB0aGUgZmlyc3QgdHJ1dGh5IGNhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmVBdFBpeGVsKHBpeGVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mcmFtZVN0YXRlXyB8fCAhdGhpcy5yZW5kZXJlcl8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29vcmRpbmF0ZSA9IHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKHBpeGVsKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9O1xuICAgIGNvbnN0IGhpdFRvbGVyYW5jZSA9XG4gICAgICBvcHRpb25zLmhpdFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5oaXRUb2xlcmFuY2UgOiAwO1xuICAgIGNvbnN0IGxheWVyRmlsdGVyID1cbiAgICAgIG9wdGlvbnMubGF5ZXJGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGF5ZXJGaWx0ZXIgOiBUUlVFO1xuICAgIGNvbnN0IGNoZWNrV3JhcHBlZCA9IG9wdGlvbnMuY2hlY2tXcmFwcGVkICE9PSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl8uZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLFxuICAgICAgdGhpcy5mcmFtZVN0YXRlXyxcbiAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgIGNoZWNrV3JhcHBlZCxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbnVsbCxcbiAgICAgIGxheWVyRmlsdGVyLFxuICAgICAgbnVsbCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7QXRQaXhlbE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2U+fSBUaGUgZGV0ZWN0ZWQgZmVhdHVyZXMgb3JcbiAgICogYW4gZW1wdHkgYXJyYXkgaWYgbm9uZSB3ZXJlIGZvdW5kLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlc0F0UGl4ZWwocGl4ZWwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKFxuICAgICAgcGl4ZWwsXG4gICAgICBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgfSxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBsYXllcnMgZnJvbSBhbGwgbGF5ZXIgZ3JvdXBzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBMYXllcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFsbExheWVycygpIHtcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBhZGRMYXllcnNGcm9tKGxheWVyR3JvdXApIHtcbiAgICAgIGxheWVyR3JvdXAuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgICAgICAgIGFkZExheWVyc0Zyb20obGF5ZXIuZ2V0TGF5ZXJzKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExheWVyc0Zyb20odGhpcy5nZXRMYXllcnMoKSk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgZmVhdHVyZXMgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlXG4gICAqIGRldGVjdGlvbiBjYW4gYmUgY29uZmlndXJlZCB0aHJvdWdoIHRoZSBgbGF5ZXJGaWx0ZXJgIG9wdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRoZXJlIGEgZmVhdHVyZSBhdCB0aGUgZ2l2ZW4gcGl4ZWw/XG4gICAqIEBhcGlcbiAgICovXG4gIGhhc0ZlYXR1cmVBdFBpeGVsKHBpeGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfIHx8ICF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG4gICAgY29uc3QgbGF5ZXJGaWx0ZXIgPVxuICAgICAgb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYXllckZpbHRlciA6IFRSVUU7XG4gICAgY29uc3QgaGl0VG9sZXJhbmNlID1cbiAgICAgIG9wdGlvbnMuaGl0VG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG4gICAgY29uc3QgY2hlY2tXcmFwcGVkID0gb3B0aW9ucy5jaGVja1dyYXBwZWQgIT09IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5oYXNGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHRoaXMuZnJhbWVTdGF0ZV8sXG4gICAgICBoaXRUb2xlcmFuY2UsXG4gICAgICBjaGVja1dyYXBwZWQsXG4gICAgICBsYXllckZpbHRlcixcbiAgICAgIG51bGwsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGluIHVzZXIgcHJvamVjdGlvbiBmb3IgYSBicm93c2VyIGV2ZW50LlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXZlbnRDb29yZGluYXRlKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLmdldEV2ZW50UGl4ZWwoZXZlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGluIHZpZXcgcHJvamVjdGlvbiBmb3IgYSBicm93c2VyIGV2ZW50LlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAgICovXG4gIGdldEV2ZW50Q29vcmRpbmF0ZUludGVybmFsKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKHRoaXMuZ2V0RXZlbnRQaXhlbChldmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1hcCBwaXhlbCBwb3NpdGlvbiBmb3IgYSBicm93c2VyIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtVSUV2ZW50fHtjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn19IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBQaXhlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXZlbnRQaXhlbChldmVudCkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydF87XG4gICAgY29uc3Qgdmlld3BvcnRQb3NpdGlvbiA9IHZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHZpZXdwb3J0U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIGNvbnN0IHNjYWxlWCA9IHZpZXdwb3J0UG9zaXRpb24ud2lkdGggLyB2aWV3cG9ydFNpemVbMF07XG4gICAgY29uc3Qgc2NhbGVZID0gdmlld3BvcnRQb3NpdGlvbi5oZWlnaHQgLyB2aWV3cG9ydFNpemVbMV07XG4gICAgY29uc3QgZXZlbnRQb3NpdGlvbiA9XG4gICAgICAvL0ZJWE1FIEFyZSB3ZSByZWFsbHkgY2FsbGluZyB0aGlzIHdpdGggYSBUb3VjaEV2ZW50IGFueXdoZXJlP1xuICAgICAgJ2NoYW5nZWRUb3VjaGVzJyBpbiBldmVudFxuICAgICAgICA/IC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8gKGV2ZW50KS5jaGFuZ2VkVG91Y2hlc1swXVxuICAgICAgICA6IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8gKGV2ZW50KTtcblxuICAgIHJldHVybiBbXG4gICAgICAoZXZlbnRQb3NpdGlvbi5jbGllbnRYIC0gdmlld3BvcnRQb3NpdGlvbi5sZWZ0KSAvIHNjYWxlWCxcbiAgICAgIChldmVudFBvc2l0aW9uLmNsaWVudFkgLSB2aWV3cG9ydFBvc2l0aW9uLnRvcCkgLyBzY2FsZVksXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhcmdldCBpbiB3aGljaCB0aGlzIG1hcCBpcyByZW5kZXJlZC5cbiAgICogTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB3aGF0IGlzIGVudGVyZWQgYXMgYW4gb3B0aW9uIG9yIGluIHNldFRhcmdldDpcbiAgICogaWYgdGhhdCB3YXMgYW4gZWxlbWVudCwgaXQgcmV0dXJucyBhbiBlbGVtZW50OyBpZiBhIHN0cmluZywgaXQgcmV0dXJucyB0aGF0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSBUaGUgRWxlbWVudCBvciBpZCBvZiB0aGUgRWxlbWVudCB0aGF0IHRoZVxuICAgKiAgICAgbWFwIGlzIHJlbmRlcmVkIGluLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoTWFwUHJvcGVydHkuVEFSR0VUKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBET00gZWxlbWVudCBpbnRvIHdoaWNoIHRoaXMgbWFwIGlzIHJlbmRlcmVkLiBJbiBjb250cmFzdCB0b1xuICAgKiBgZ2V0VGFyZ2V0YCB0aGlzIG1ldGhvZCBhbHdheXMgcmV0dXJuIGFuIGBFbGVtZW50YCwgb3IgYG51bGxgIGlmIHRoZVxuICAgKiBtYXAgaGFzIG5vIHRhcmdldC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBlbGVtZW50IHRoYXQgdGhlIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGFyZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRFbGVtZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gcGl4ZWwuICBUaGlzIHJldHVybnMgYSBjb29yZGluYXRlIGluIHRoZVxuICAgKiB1c2VyIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSBjb29yZGluYXRlIGZvciB0aGUgcGl4ZWwgcG9zaXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVGcm9tUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdG9Vc2VyQ29vcmRpbmF0ZShcbiAgICAgIHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKHBpeGVsKSxcbiAgICAgIHRoaXMuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBwaXhlbC4gIFRoaXMgcmV0dXJucyBhIGNvb3JkaW5hdGUgaW4gdGhlXG4gICAqIG1hcCB2aWV3IHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSBjb29yZGluYXRlIGZvciB0aGUgcGl4ZWwgcG9zaXRpb24uXG4gICAqL1xuICBnZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgcGl4ZWwuc2xpY2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY29udHJvbHMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgY29udHJvbHNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IENvbnRyb2xzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb250cm9scygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9scztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBvdmVybGF5cy4gTW9kaWZ5aW5nIHRoaXMgY29sbGVjdGlvbiBjaGFuZ2VzIHRoZSBvdmVybGF5c1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IE92ZXJsYXlzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPdmVybGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5c187XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG92ZXJsYXkgYnkgaXRzIGlkZW50aWZpZXIgKHRoZSB2YWx1ZSByZXR1cm5lZCBieSBvdmVybGF5LmdldElkKCkpLlxuICAgKiBOb3RlIHRoYXQgdGhlIGluZGV4IHRyZWF0cyBzdHJpbmcgYW5kIG51bWVyaWMgaWRlbnRpZmllcnMgYXMgdGhlIHNhbWUuIFNvXG4gICAqIGBtYXAuZ2V0T3ZlcmxheUJ5SWQoMilgIHdpbGwgcmV0dXJuIGFuIG92ZXJsYXkgd2l0aCBpZCBgJzInYCBvciBgMmAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgT3ZlcmxheSBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdHxudWxsfSBPdmVybGF5LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPdmVybGF5QnlJZChpZCkge1xuICAgIGNvbnN0IG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlJZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICByZXR1cm4gb3ZlcmxheSAhPT0gdW5kZWZpbmVkID8gb3ZlcmxheSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgaW50ZXJhY3Rpb25zLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIGludGVyYWN0aW9uc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICpcbiAgICogSW50ZXJhY3Rpb25zIGFyZSB1c2VkIGZvciBlLmcuIHBhbiwgem9vbSBhbmQgcm90YXRlLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IEludGVyYWN0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJhY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmludGVyYWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyZ3JvdXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHtMYXllckdyb3VwfSBBIGxheWVyIGdyb3VwIGNvbnRhaW5pbmcgdGhlIGxheWVycyBpbiB0aGlzIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5ZXJHcm91cCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtMYXllckdyb3VwfSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuTEFZRVJHUk9VUCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFueSBleGlzdGluZyBsYXllcnMgYW5kIGFkZCBsYXllcnMgdG8gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD59IGxheWVycyBUaGUgbGF5ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExheWVycyhsYXllcnMpIHtcbiAgICBjb25zdCBncm91cCA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpO1xuICAgIGlmIChsYXllcnMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICBncm91cC5zZXRMYXllcnMobGF5ZXJzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xsZWN0aW9uID0gZ3JvdXAuZ2V0TGF5ZXJzKCk7XG4gICAgY29sbGVjdGlvbi5jbGVhcigpO1xuICAgIGNvbGxlY3Rpb24uZXh0ZW5kKGxheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb2xsZWN0aW9uIG9mIGxheWVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXAuXG4gICAqIEByZXR1cm4geyFDb2xsZWN0aW9uPGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0Pn0gTGF5ZXJzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXllcnMoKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBMYXllcnMgaGF2ZSBzb3VyY2VzIHRoYXQgYXJlIHN0aWxsIGxvYWRpbmcuXG4gICAqL1xuICBnZXRMb2FkaW5nT3JOb3RSZWFkeSgpIHtcbiAgICBjb25zdCBsYXllclN0YXRlc0FycmF5ID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJTdGF0ZXNBcnJheSgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVyU3RhdGVzQXJyYXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBsYXllclN0YXRlc0FycmF5W2ldO1xuICAgICAgaWYgKCFzdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyZXIgPSBzdGF0ZS5sYXllci5nZXRSZW5kZXJlcigpO1xuICAgICAgaWYgKHJlbmRlcmVyICYmICFyZW5kZXJlci5yZWFkeSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNvdXJjZSA9IHN0YXRlLmxheWVyLmdldFNvdXJjZSgpO1xuICAgICAgaWYgKHNvdXJjZSAmJiBzb3VyY2UubG9hZGluZykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGl4ZWwgZm9yIGEgY29vcmRpbmF0ZS4gIFRoaXMgdGFrZXMgYSBjb29yZGluYXRlIGluIHRoZSB1c2VyXG4gICAqIHByb2plY3Rpb24gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQSBtYXAgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gQSBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQaXhlbEZyb21Db29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICBjb25zdCB2aWV3Q29vcmRpbmF0ZSA9IGZyb21Vc2VyQ29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsXG4gICAgICB0aGlzLmdldFZpZXcoKS5nZXRQcm9qZWN0aW9uKCksXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZyb21Db29yZGluYXRlSW50ZXJuYWwodmlld0Nvb3JkaW5hdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGl4ZWwgZm9yIGEgY29vcmRpbmF0ZS4gIFRoaXMgdGFrZXMgYSBjb29yZGluYXRlIGluIHRoZSBtYXAgdmlld1xuICAgKiBwcm9qZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIEEgbWFwIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IEEgcGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICovXG4gIGdldFBpeGVsRnJvbUNvb3JkaW5hdGVJbnRlcm5hbChjb29yZGluYXRlKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKFxuICAgICAgZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSxcbiAgICAgIGNvb3JkaW5hdGUuc2xpY2UoMCwgMiksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCByZW5kZXJlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9yZW5kZXJlci9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBSZW5kZXJlclxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIG1hcCBpbiB0aGUgRE9NLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoTWFwUHJvcGVydHkuU0laRSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXAuIEEgdmlldyBtYW5hZ2VzIHByb3BlcnRpZXMgc3VjaCBhc1xuICAgKiBjZW50ZXIgYW5kIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge1ZpZXd9IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFZpZXcoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Vmlld30gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LlZJRVcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFZpZXdwb3J0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRWaWV3cG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHRoYXQgc2VydmVzIGFzIHRoZSBjb250YWluZXIgZm9yIG92ZXJsYXlzLiAgRWxlbWVudHMgYWRkZWQgdG9cbiAgICogdGhpcyBjb250YWluZXIgd2lsbCBsZXQgbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGV2ZW50cyB0aHJvdWdoIHRvIHRoZSBtYXAsXG4gICAqIHNvIGNsaWNrcyBhbmQgZ2VzdHVyZXMgb24gYW4gb3ZlcmxheSB3aWxsIHRyaWdnZXIge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fVxuICAgKiBldmVudHMuXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gVGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyLlxuICAgKi9cbiAgZ2V0T3ZlcmxheUNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgYSBjb250YWluZXIgZm9yIG92ZXJsYXlzIHRoYXQgZG9uJ3QgYWxsb3dcbiAgICogZXZlbnQgcHJvcGFnYXRpb24uIEVsZW1lbnRzIGFkZGVkIHRvIHRoaXMgY29udGFpbmVyIHdvbid0IGxldCBtb3VzZWRvd24gYW5kXG4gICAqIHRvdWNoc3RhcnQgZXZlbnRzIHRocm91Z2ggdG8gdGhlIG1hcCwgc28gY2xpY2tzIGFuZCBnZXN0dXJlcyBvbiBhbiBvdmVybGF5XG4gICAqIGRvbid0IHRyaWdnZXIgYW55IHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0uXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gVGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyIHRoYXQgc3RvcHMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0T3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRG9jdW1lbnR9IFRoZSBkb2N1bWVudCB3aGVyZSB0aGUgbWFwIGlzIGRpc3BsYXllZC5cbiAgICovXG4gIGdldE93bmVyRG9jdW1lbnQoKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuICAgIHJldHVybiB0YXJnZXRFbGVtZW50ID8gdGFyZ2V0RWxlbWVudC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGlsZVNvdXJjZUtleSBUaWxlIHNvdXJjZSBrZXkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRpbGVDZW50ZXIgVGlsZSBjZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlUmVzb2x1dGlvbiBUaWxlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwcmlvcml0eS5cbiAgICovXG4gIGdldFRpbGVQcmlvcml0eSh0aWxlLCB0aWxlU291cmNlS2V5LCB0aWxlQ2VudGVyLCB0aWxlUmVzb2x1dGlvbikge1xuICAgIHJldHVybiBnZXRUaWxlUHJpb3JpdHkoXG4gICAgICB0aGlzLmZyYW1lU3RhdGVfLFxuICAgICAgdGlsZSxcbiAgICAgIHRpbGVTb3VyY2VLZXksXG4gICAgICB0aWxlQ2VudGVyLFxuICAgICAgdGlsZVJlc29sdXRpb24sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VJRXZlbnR9IGJyb3dzZXJFdmVudCBCcm93c2VyIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFR5cGUuXG4gICAqL1xuICBoYW5kbGVCcm93c2VyRXZlbnQoYnJvd3NlckV2ZW50LCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgfHwgYnJvd3NlckV2ZW50LnR5cGU7XG4gICAgY29uc3QgbWFwQnJvd3NlckV2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudCh0eXBlLCB0aGlzLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuaGFuZGxlTWFwQnJvd3NlckV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlLlxuICAgKi9cbiAgaGFuZGxlTWFwQnJvd3NlckV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghdGhpcy5mcmFtZVN0YXRlXykge1xuICAgICAgLy8gV2l0aCBubyB2aWV3IGRlZmluZWQsIHdlIGNhbm5vdCB0cmFuc2xhdGUgcGl4ZWxzIGludG8gZ2VvZ3JhcGhpY2FsXG4gICAgICAvLyBjb29yZGluYXRlcyBzbyBpbnRlcmFjdGlvbnMgY2Fubm90IGJlIHVzZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge1BvaW50ZXJFdmVudH0gKi8gKFxuICAgICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICApO1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IG9yaWdpbmFsRXZlbnQudHlwZTtcbiAgICBpZiAoXG4gICAgICBldmVudFR5cGUgPT09IFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkRPV04gfHxcbiAgICAgIGV2ZW50VHlwZSA9PT0gRXZlbnRUeXBlLldIRUVMIHx8XG4gICAgICBldmVudFR5cGUgPT09IEV2ZW50VHlwZS5LRVlET1dOXG4gICAgKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLmdldE93bmVyRG9jdW1lbnQoKTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gdGhpcy52aWV3cG9ydF8uZ2V0Um9vdE5vZGVcbiAgICAgICAgPyB0aGlzLnZpZXdwb3J0Xy5nZXRSb290Tm9kZSgpXG4gICAgICAgIDogZG9jO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAob3JpZ2luYWxFdmVudC50YXJnZXQpO1xuXG4gICAgICBjb25zdCBjdXJyZW50RG9jID1cbiAgICAgICAgcm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290XG4gICAgICAgICAgPyByb290Tm9kZS5ob3N0ID09PSB0YXJnZXRcbiAgICAgICAgICAgID8gcm9vdE5vZGUuaG9zdC5vd25lckRvY3VtZW50XG4gICAgICAgICAgICA6IHJvb3ROb2RlXG4gICAgICAgICAgOiByb290Tm9kZSA9PT0gZG9jXG4gICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgIDogcm9vdE5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIEFib3J0IGlmIHRoZSB0YXJnZXQgaXMgYSBjaGlsZCBvZiB0aGUgY29udGFpbmVyIGZvciBlbGVtZW50cyB3aG9zZSBldmVudHMgYXJlIG5vdCBtZWFudFxuICAgICAgICAvLyB0byBiZSBoYW5kbGVkIGJ5IG1hcCBpbnRlcmFjdGlvbnMuXG4gICAgICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uY29udGFpbnModGFyZ2V0KSB8fFxuICAgICAgICAvLyBBYm9ydCBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIGEgY2hpbGQgb2YgdGhlIGNvbnRhaW5lciB0aGF0IGlzIG5vIGxvbmdlciBpbiB0aGUgcGFnZS5cbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgdGhlIHRhcmdldCB0byBubyBsb25nZXIgYmUgaW4gdGhlIHBhZ2UgaWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBhblxuICAgICAgICAvLyBldmVudCBsaXN0ZW5lciwgdGhpcyBtaWdodCBoYXBwZW4gaW4gYSBDb250cm9sIHRoYXQgcmVjcmVhdGVzIGl0J3MgY29udGVudCBiYXNlZCBvblxuICAgICAgICAvLyB1c2VyIGludGVyYWN0aW9uIGVpdGhlciBtYW51YWxseSBvciB2aWEgYSByZW5kZXIgaW4gc29tZXRoaW5nIGxpa2UgaHR0cHM6Ly9yZWFjdGpzLm9yZy9cbiAgICAgICAgIWN1cnJlbnREb2MuY29udGFpbnModGFyZ2V0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFwQnJvd3NlckV2ZW50LmZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQobWFwQnJvd3NlckV2ZW50KSAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGludGVyYWN0aW9uc0FycmF5ID0gdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5nZXRBcnJheSgpLnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gaW50ZXJhY3Rpb25zQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbnNBcnJheVtpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGludGVyYWN0aW9uLmdldE1hcCgpICE9PSB0aGlzIHx8XG4gICAgICAgICAgIWludGVyYWN0aW9uLmdldEFjdGl2ZSgpIHx8XG4gICAgICAgICAgIXRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnQgPSBpbnRlcmFjdGlvbi5oYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICBpZiAoIWNvbnQgfHwgbWFwQnJvd3NlckV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVBvc3RSZW5kZXIoKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG5cbiAgICAvLyBNYW5hZ2UgdGhlIHRpbGUgcXVldWVcbiAgICAvLyBJbWFnZSBsb2FkcyBhcmUgZXhwZW5zaXZlIGFuZCBhIGxpbWl0ZWQgcmVzb3VyY2UsIHNvIHRyeSB0byB1c2UgdGhlbVxuICAgIC8vIGVmZmljaWVudGx5OlxuICAgIC8vICogV2hlbiB0aGUgdmlldyBpcyBzdGF0aWMgd2UgYWxsb3cgYSBsYXJnZSBudW1iZXIgb2YgcGFyYWxsZWwgdGlsZSBsb2Fkc1xuICAgIC8vICAgdG8gY29tcGxldGUgdGhlIGZyYW1lIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gICAgLy8gKiBXaGVuIGFuaW1hdGluZyBvciBpbnRlcmFjdGluZywgaW1hZ2UgbG9hZHMgY2FuIGNhdXNlIGphbmtzLCBzbyB3ZSByZWR1Y2VcbiAgICAvLyAgIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsb2FkcyBwZXIgZnJhbWUgYW5kIGxpbWl0IHRoZSBudW1iZXIgb2YgcGFyYWxsZWxcbiAgICAvLyAgIHRpbGUgbG9hZHMgdG8gcmVtYWluIHJlYWN0aXZlIHRvIHZpZXcgY2hhbmdlcyBhbmQgdG8gcmVkdWNlIHRoZSBjaGFuY2Ugb2ZcbiAgICAvLyAgIGxvYWRpbmcgdGlsZXMgdGhhdCB3aWxsIHF1aWNrbHkgZGlzYXBwZWFyIGZyb20gdmlldy5cbiAgICBjb25zdCB0aWxlUXVldWUgPSB0aGlzLnRpbGVRdWV1ZV87XG4gICAgaWYgKCF0aWxlUXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICBsZXQgbWF4VG90YWxMb2FkaW5nID0gdGhpcy5tYXhUaWxlc0xvYWRpbmdfO1xuICAgICAgbGV0IG1heE5ld0xvYWRzID0gbWF4VG90YWxMb2FkaW5nO1xuICAgICAgaWYgKGZyYW1lU3RhdGUpIHtcbiAgICAgICAgY29uc3QgaGludHMgPSBmcmFtZVN0YXRlLnZpZXdIaW50cztcbiAgICAgICAgaWYgKGhpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gfHwgaGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddKSB7XG4gICAgICAgICAgY29uc3QgbG93T25GcmFtZUJ1ZGdldCA9IERhdGUubm93KCkgLSBmcmFtZVN0YXRlLnRpbWUgPiA4O1xuICAgICAgICAgIG1heFRvdGFsTG9hZGluZyA9IGxvd09uRnJhbWVCdWRnZXQgPyAwIDogODtcbiAgICAgICAgICBtYXhOZXdMb2FkcyA9IGxvd09uRnJhbWVCdWRnZXQgPyAwIDogMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRpbGVRdWV1ZS5nZXRUaWxlc0xvYWRpbmcoKSA8IG1heFRvdGFsTG9hZGluZykge1xuICAgICAgICB0aWxlUXVldWUucmVwcmlvcml0aXplKCk7IC8vIEZJWE1FIG9ubHkgY2FsbCBpZiB2aWV3IGhhcyBjaGFuZ2VkXG4gICAgICAgIHRpbGVRdWV1ZS5sb2FkTW9yZVRpbGVzKG1heFRvdGFsTG9hZGluZywgbWF4TmV3TG9hZHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFtZVN0YXRlICYmIHRoaXMucmVuZGVyZXJfICYmICFmcmFtZVN0YXRlLmFuaW1hdGUpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbXBsZXRlXykge1xuICAgICAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcihSZW5kZXJFdmVudFR5cGUuUkVOREVSQ09NUExFVEUpKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlcl8uZGlzcGF0Y2hSZW5kZXJFdmVudChcbiAgICAgICAgICAgIFJlbmRlckV2ZW50VHlwZS5SRU5ERVJDT01QTEVURSxcbiAgICAgICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2FkZWRfID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMubG9hZGVkXyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5MT0FERU5ELCB0aGlzLCBmcmFtZVN0YXRlKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubG9hZGVkXyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvYWRlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTE9BRFNUQVJULCB0aGlzLCBmcmFtZVN0YXRlKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwb3N0UmVuZGVyRnVuY3Rpb25zID0gdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXztcbiAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zdFJlbmRlckZ1bmN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHBvc3RSZW5kZXJGdW5jdGlvbnNbaV0odGhpcywgZnJhbWVTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3RSZW5kZXJGdW5jdGlvbnMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU2l6ZUNoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLmdldFZpZXcoKSAmJiAhdGhpcy5nZXRWaWV3KCkuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHRoaXMuZ2V0VmlldygpLnJlc29sdmVDb25zdHJhaW50cygwKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUYXJnZXRDaGFuZ2VkXygpIHtcbiAgICBpZiAodGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c18ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMudGFyZ2V0Q2hhbmdlSGFuZGxlcktleXNfW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFyZ2V0Q2hhbmdlSGFuZGxlcktleXNfID0gbnVsbDtcbiAgICAgIHRoaXMudmlld3BvcnRfLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEV2ZW50VHlwZS5DT05URVhUTUVOVSxcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF8sXG4gICAgICApO1xuICAgICAgdGhpcy52aWV3cG9ydF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLldIRUVMLFxuICAgICAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50XyxcbiAgICAgICk7XG4gICAgICB0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8gPSBudWxsO1xuICAgICAgdGhpcy52aWV3cG9ydF8ucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0RWxlbWVudF8pIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLnVub2JzZXJ2ZSh0aGlzLnRhcmdldEVsZW1lbnRfKTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gdGhpcy50YXJnZXRFbGVtZW50Xy5nZXRSb290Tm9kZSgpO1xuICAgICAgaWYgKHJvb3ROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy51bm9ic2VydmUocm9vdE5vZGUuaG9zdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNpemUodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXQgbWF5IGJlIHVuZGVmaW5lZCwgbnVsbCwgYSBzdHJpbmcgb3IgYW4gRWxlbWVudC5cbiAgICAvLyBJZiBpdCdzIGEgc3RyaW5nIHdlIGNvbnZlcnQgaXQgdG8gYW4gRWxlbWVudCBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBJZiBpdCdzIG5vdCBub3cgYW4gRWxlbWVudCB3ZSByZW1vdmUgdGhlIHZpZXdwb3J0IGZyb20gdGhlIERPTS5cbiAgICAvLyBJZiBpdCdzIGFuIEVsZW1lbnQgd2UgYXBwZW5kIHRoZSB2aWV3cG9ydCBlbGVtZW50IHRvIGl0LlxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID1cbiAgICAgIHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KSA6IHRhcmdldDtcbiAgICB0aGlzLnRhcmdldEVsZW1lbnRfID0gdGFyZ2V0RWxlbWVudDtcbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3N0UmVuZGVyVGltZW91dEhhbmRsZV8pO1xuICAgICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnJlbmRlcmVyXy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXJfID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xykge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRfKTtcbiAgICAgIGlmICghdGhpcy5yZW5kZXJlcl8pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlcl8gPSBuZXcgQ29tcG9zaXRlTWFwUmVuZGVyZXIodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8gPSBuZXcgTWFwQnJvd3NlckV2ZW50SGFuZGxlcihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5tb3ZlVG9sZXJhbmNlXyxcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBNYXBCcm93c2VyRXZlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlW2tleV0sXG4gICAgICAgICAgdGhpcy5oYW5kbGVNYXBCcm93c2VyRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmlld3BvcnRfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEV2ZW50VHlwZS5DT05URVhUTUVOVSxcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF8sXG4gICAgICAgIGZhbHNlLFxuICAgICAgKTtcbiAgICAgIHRoaXMudmlld3BvcnRfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEV2ZW50VHlwZS5XSEVFTCxcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF8sXG4gICAgICAgIFBBU1NJVkVfRVZFTlRfTElTVEVORVJTID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlLFxuICAgICAgKTtcblxuICAgICAgbGV0IGtleWJvYXJkRXZlbnRUYXJnZXQ7XG4gICAgICBpZiAoIXRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF8pIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgbWFwIHRhcmdldCBpcyBpbiBzaGFkb3dET00sIGlmIHllcyB1c2UgaG9zdCBlbGVtZW50IGFzIHRhcmdldFxuICAgICAgICBjb25zdCB0YXJnZXRSb290ID0gdGFyZ2V0RWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXRDYW5kaWRhdGUgPVxuICAgICAgICAgIHRhcmdldFJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gdGFyZ2V0Um9vdC5ob3N0IDogdGFyZ2V0RWxlbWVudDtcbiAgICAgICAga2V5Ym9hcmRFdmVudFRhcmdldCA9IHRhcmdldENhbmRpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleWJvYXJkRXZlbnRUYXJnZXQgPSB0aGlzLmtleWJvYXJkRXZlbnRUYXJnZXRfO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRhcmdldENoYW5nZUhhbmRsZXJLZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuKFxuICAgICAgICAgIGtleWJvYXJkRXZlbnRUYXJnZXQsXG4gICAgICAgICAgRXZlbnRUeXBlLktFWURPV04sXG4gICAgICAgICAgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgKSxcbiAgICAgICAgbGlzdGVuKFxuICAgICAgICAgIGtleWJvYXJkRXZlbnRUYXJnZXQsXG4gICAgICAgICAgRXZlbnRUeXBlLktFWVBSRVNTLFxuICAgICAgICAgIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICksXG4gICAgICBdO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0YXJnZXRFbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICBpZiAocm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLm9ic2VydmUocm9vdE5vZGUuaG9zdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy5vYnNlcnZlKHRhcmdldEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIC8vIHVwZGF0ZVNpemUgY2FsbHMgc2V0U2l6ZSwgc28gbm8gbmVlZCB0byBjYWxsIHRoaXMucmVuZGVyXG4gICAgLy8gb3Vyc2VsdmVzIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRpbGVDaGFuZ2VfKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVZpZXdDaGFuZ2VkXygpIHtcbiAgICBpZiAodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gdGhpcy5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRTaXplXyh0aGlzLmdldFNpemUoKSk7XG5cbiAgICAgIHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgICB2aWV3LFxuICAgICAgICBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8sXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuICAgICAgdGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgICB2aWV3LFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfLFxuICAgICAgICB0aGlzLFxuICAgICAgKTtcblxuICAgICAgdmlldy5yZXNvbHZlQ29uc3RyYWludHMoMCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXygpIHtcbiAgICBpZiAodGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfKSB7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxheWVyR3JvdXAgPSB0aGlzLmdldExheWVyR3JvdXAoKTtcbiAgICBpZiAobGF5ZXJHcm91cCkge1xuICAgICAgdGhpcy5oYW5kbGVMYXllckFkZF8obmV3IEdyb3VwRXZlbnQoJ2FkZGxheWVyJywgbGF5ZXJHcm91cCkpO1xuICAgICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gW1xuICAgICAgICBsaXN0ZW4obGF5ZXJHcm91cCwgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLCB0aGlzLnJlbmRlciwgdGhpcyksXG4gICAgICAgIGxpc3RlbihsYXllckdyb3VwLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLnJlbmRlciwgdGhpcyksXG4gICAgICAgIGxpc3RlbihsYXllckdyb3VwLCAnYWRkbGF5ZXInLCB0aGlzLmhhbmRsZUxheWVyQWRkXywgdGhpcyksXG4gICAgICAgIGxpc3RlbihsYXllckdyb3VwLCAncmVtb3ZlbGF5ZXInLCB0aGlzLmhhbmRsZUxheWVyUmVtb3ZlXywgdGhpcyksXG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHJlbmRlcmVkLlxuICAgKi9cbiAgaXNSZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmZyYW1lU3RhdGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRpb25EZWxheV8oKSB7XG4gICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZW5kZXJGcmFtZV8oRGF0ZS5ub3coKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgYW4gaW1tZWRpYXRlIHJlbmRlciBpbiBhIHN5bmNocm9ub3VzIG1hbm5lci5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVuZGVyU3luYygpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25EZWxheUtleV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25EZWxheV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRyYXdzIGFsbCB0ZXh0IGFmdGVyIG5ldyBmb250cyBoYXZlIGxvYWRlZFxuICAgKi9cbiAgcmVkcmF3VGV4dCgpIHtcbiAgICBjb25zdCBsYXllclN0YXRlcyA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVyU3RhdGVzQXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllclN0YXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsYXllciA9IGxheWVyU3RhdGVzW2ldLmxheWVyO1xuICAgICAgaWYgKGxheWVyLmhhc1JlbmRlcmVyKCkpIHtcbiAgICAgICAgbGF5ZXIuZ2V0UmVuZGVyZXIoKS5oYW5kbGVGb250c0NoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCBhIG1hcCByZW5kZXJpbmcgKGF0IHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcl8gJiYgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EZWxheV8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR9IGNvbnRyb2wgQ29udHJvbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGNvbnRyb2wgKG9yIHVuZGVmaW5lZFxuICAgKiAgICAgaWYgdGhlIGNvbnRyb2wgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUNvbnRyb2woY29udHJvbCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRyb2xzKCkucmVtb3ZlKGNvbnRyb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW50ZXJhY3Rpb24gZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24gdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBpbnRlcmFjdGlvbiAob3JcbiAgICogICAgIHVuZGVmaW5lZCBpZiB0aGUgaW50ZXJhY3Rpb24gd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkucmVtb3ZlKGludGVyYWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGxheWVyIChvciB1bmRlZmluZWQgaWYgdGhlXG4gICAqICAgICBsYXllciB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzLnJlbW92ZShsYXllcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2xheWVyL0dyb3VwLmpzXCIpLkdyb3VwRXZlbnR9IGV2ZW50IFRoZSBsYXllciByZW1vdmUgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllclJlbW92ZV8oZXZlbnQpIHtcbiAgICByZW1vdmVMYXllck1hcFByb3BlcnR5KGV2ZW50LmxheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIG92ZXJsYXkgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgb3ZlcmxheSAob3IgdW5kZWZpbmVkXG4gICAqICAgICBpZiB0aGUgb3ZlcmxheSB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlT3ZlcmxheShvdmVybGF5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3ZlcmxheXMoKS5yZW1vdmUob3ZlcmxheSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGltZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbmRlckZyYW1lXyh0aW1lKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLmdldFZpZXcoKTtcbiAgICBjb25zdCBwcmV2aW91c0ZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIC8qKiBAdHlwZSB7P0ZyYW1lU3RhdGV9ICovXG4gICAgbGV0IGZyYW1lU3RhdGUgPSBudWxsO1xuICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQgJiYgaGFzQXJlYShzaXplKSAmJiB2aWV3ICYmIHZpZXcuaXNEZWYoKSkge1xuICAgICAgY29uc3Qgdmlld0hpbnRzID0gdmlldy5nZXRIaW50cyhcbiAgICAgICAgdGhpcy5mcmFtZVN0YXRlXyA/IHRoaXMuZnJhbWVTdGF0ZV8udmlld0hpbnRzIDogdW5kZWZpbmVkLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZpZXdTdGF0ZSA9IHZpZXcuZ2V0U3RhdGUoKTtcbiAgICAgIGZyYW1lU3RhdGUgPSB7XG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTogdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8sXG4gICAgICAgIGRlY2x1dHRlcjogbnVsbCxcbiAgICAgICAgZXh0ZW50OiBnZXRGb3JWaWV3QW5kU2l6ZShcbiAgICAgICAgICB2aWV3U3RhdGUuY2VudGVyLFxuICAgICAgICAgIHZpZXdTdGF0ZS5yZXNvbHV0aW9uLFxuICAgICAgICAgIHZpZXdTdGF0ZS5yb3RhdGlvbixcbiAgICAgICAgICBzaXplLFxuICAgICAgICApLFxuICAgICAgICBpbmRleDogdGhpcy5mcmFtZUluZGV4XysrLFxuICAgICAgICBsYXllckluZGV4OiAwLFxuICAgICAgICBsYXllclN0YXRlc0FycmF5OiB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCksXG4gICAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtOiB0aGlzLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtXyxcbiAgICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uczogW10sXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHRpbGVRdWV1ZTogdGhpcy50aWxlUXVldWVfLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB1c2VkVGlsZXM6IHt9LFxuICAgICAgICB2aWV3U3RhdGU6IHZpZXdTdGF0ZSxcbiAgICAgICAgdmlld0hpbnRzOiB2aWV3SGludHMsXG4gICAgICAgIHdhbnRlZFRpbGVzOiB7fSxcbiAgICAgICAgbWFwSWQ6IGdldFVpZCh0aGlzKSxcbiAgICAgICAgcmVuZGVyVGFyZ2V0czoge30sXG4gICAgICB9O1xuICAgICAgaWYgKHZpZXdTdGF0ZS5uZXh0Q2VudGVyICYmIHZpZXdTdGF0ZS5uZXh0UmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGlzTmFOKHZpZXdTdGF0ZS5uZXh0Um90YXRpb24pXG4gICAgICAgICAgPyB2aWV3U3RhdGUucm90YXRpb25cbiAgICAgICAgICA6IHZpZXdTdGF0ZS5uZXh0Um90YXRpb247XG5cbiAgICAgICAgZnJhbWVTdGF0ZS5uZXh0RXh0ZW50ID0gZ2V0Rm9yVmlld0FuZFNpemUoXG4gICAgICAgICAgdmlld1N0YXRlLm5leHRDZW50ZXIsXG4gICAgICAgICAgdmlld1N0YXRlLm5leHRSZXNvbHV0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZVN0YXRlXyA9IGZyYW1lU3RhdGU7XG4gICAgdGhpcy5yZW5kZXJlcl8ucmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSk7XG5cbiAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKGZyYW1lU3RhdGUuYW5pbWF0ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoXG4gICAgICAgIHRoaXMucG9zdFJlbmRlckZ1bmN0aW9uc18sXG4gICAgICAgIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucyxcbiAgICAgICk7XG5cbiAgICAgIGlmIChwcmV2aW91c0ZyYW1lU3RhdGUpIHtcbiAgICAgICAgY29uc3QgbW92ZVN0YXJ0ID1cbiAgICAgICAgICAhdGhpcy5wcmV2aW91c0V4dGVudF8gfHxcbiAgICAgICAgICAoIWlzRW1wdHkodGhpcy5wcmV2aW91c0V4dGVudF8pICYmXG4gICAgICAgICAgICAhZXF1YWxzRXh0ZW50KGZyYW1lU3RhdGUuZXh0ZW50LCB0aGlzLnByZXZpb3VzRXh0ZW50XykpO1xuICAgICAgICBpZiAobW92ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5NT1ZFU1RBUlQsIHRoaXMsIHByZXZpb3VzRnJhbWVTdGF0ZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkodGhpcy5wcmV2aW91c0V4dGVudF8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGUgPVxuICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyAmJlxuICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSAmJlxuICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddICYmXG4gICAgICAgICFlcXVhbHNFeHRlbnQoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcblxuICAgICAgaWYgKGlkbGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRUVORCwgdGhpcywgZnJhbWVTdGF0ZSksXG4gICAgICAgICk7XG4gICAgICAgIGNsb25lKGZyYW1lU3RhdGUuZXh0ZW50LCB0aGlzLnByZXZpb3VzRXh0ZW50Xyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuUE9TVFJFTkRFUiwgdGhpcywgZnJhbWVTdGF0ZSkpO1xuXG4gICAgdGhpcy5yZW5kZXJDb21wbGV0ZV8gPVxuICAgICAgKHRoaXMuaGFzTGlzdGVuZXIoTWFwRXZlbnRUeXBlLkxPQURTVEFSVCkgfHxcbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lcihNYXBFdmVudFR5cGUuTE9BREVORCkgfHxcbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lcihSZW5kZXJFdmVudFR5cGUuUkVOREVSQ09NUExFVEUpKSAmJlxuICAgICAgIXRoaXMudGlsZVF1ZXVlXy5nZXRUaWxlc0xvYWRpbmcoKSAmJlxuICAgICAgIXRoaXMudGlsZVF1ZXVlXy5nZXRDb3VudCgpICYmXG4gICAgICAhdGhpcy5nZXRMb2FkaW5nT3JOb3RSZWFkeSgpO1xuXG4gICAgaWYgKCF0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXykge1xuICAgICAgdGhpcy5wb3N0UmVuZGVyVGltZW91dEhhbmRsZV8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyVGltZW91dEhhbmRsZV8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9zdFJlbmRlcigpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxheWVyZ3JvdXAgb2YgdGhpcyBtYXAuXG4gICAqIEBwYXJhbSB7TGF5ZXJHcm91cH0gbGF5ZXJHcm91cCBBIGxheWVyIGdyb3VwIGNvbnRhaW5pbmcgdGhlIGxheWVycyBpbiB0aGlzIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGF5ZXJHcm91cChsYXllckdyb3VwKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJHcm91cCA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpO1xuICAgIGlmIChvbGRMYXllckdyb3VwKSB7XG4gICAgICB0aGlzLmhhbmRsZUxheWVyUmVtb3ZlXyhuZXcgR3JvdXBFdmVudCgncmVtb3ZlbGF5ZXInLCBvbGRMYXllckdyb3VwKSk7XG4gICAgfVxuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LkxBWUVSR1JPVVAsIGxheWVyR3JvdXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2l6ZSBvZiB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IHNpemUgVGhlIHNpemUgaW4gcGl4ZWxzIG9mIHRoZSBtYXAgaW4gdGhlIERPTS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2l6ZShzaXplKSB7XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuU0laRSwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0YXJnZXQgZWxlbWVudCB0byByZW5kZXIgdGhpcyBtYXAgaW50by5cbiAgICogRm9yIGFjY2Vzc2liaWxpdHkgKGZvY3VzIGFuZCBrZXlib2FyZCBldmVudHMgZm9yIG1hcCBuYXZpZ2F0aW9uKSwgdGhlIGB0YXJnZXRgIGVsZW1lbnQgbXVzdCBoYXZlIGFcbiAgICogIHByb3Blcmx5IGNvbmZpZ3VyZWQgYHRhYmluZGV4YCBhdHRyaWJ1dGUuIElmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGluc2lkZSBhIFNoYWRvdyBET00sIHRoZVxuICAgKiAgYHRhYmluZGV4YCBhdHJpYnV0ZSBtdXN0IGJlIHNldCBvbiB0aGUgY3VzdG9tIGVsZW1lbnQncyBob3N0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBUaGUgRWxlbWVudCBvciBpZCBvZiB0aGUgRWxlbWVudFxuICAgKiAgICAgdGhhdCB0aGUgbWFwIGlzIHJlbmRlcmVkIGluLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuVEFSR0VULCB0YXJnZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmlldyBmb3IgdGhpcyBtYXAuXG4gICAqIEBwYXJhbSB7Vmlld3xQcm9taXNlPGltcG9ydChcIi4vVmlldy5qc1wiKS5WaWV3T3B0aW9ucz59IHZpZXcgVGhlIHZpZXcgdGhhdCBjb250cm9scyB0aGlzIG1hcC5cbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwYXNzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGluZyBhIHZpZXcuICBUaGlzXG4gICAqIGFsdGVybmF0aXZlIGFsbG93cyB2aWV3IHByb3BlcnRpZXMgdG8gYmUgcmVzb2x2ZWQgYnkgc291cmNlcyBvciBvdGhlciBjb21wb25lbnRzIHRoYXQgbG9hZFxuICAgKiB2aWV3LXJlbGF0ZWQgbWV0YWRhdGEuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFZpZXcodmlldykge1xuICAgIGlmICghdmlldyB8fCB2aWV3IGluc3RhbmNlb2YgVmlldykge1xuICAgICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuVklFVywgdmlldyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlZJRVcsIG5ldyBWaWV3KCkpO1xuXG4gICAgY29uc3QgbWFwID0gdGhpcztcbiAgICB2aWV3LnRoZW4oZnVuY3Rpb24gKHZpZXdPcHRpb25zKSB7XG4gICAgICBtYXAuc2V0VmlldyhuZXcgVmlldyh2aWV3T3B0aW9ucykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIGEgcmVjYWxjdWxhdGlvbiBvZiB0aGUgbWFwIHZpZXdwb3J0IHNpemUuICBUaGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlblxuICAgKiB0aGlyZC1wYXJ0eSBjb2RlIGNoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQGFwaVxuICAgKi9cbiAgdXBkYXRlU2l6ZSgpIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG5cbiAgICBsZXQgc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWxlbWVudCk7XG4gICAgICBjb25zdCB3aWR0aCA9XG4gICAgICAgIHRhcmdldEVsZW1lbnQub2Zmc2V0V2lkdGggLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlckxlZnRXaWR0aCddKSAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ0xlZnQnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdSaWdodCddKSAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyUmlnaHRXaWR0aCddKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9XG4gICAgICAgIHRhcmdldEVsZW1lbnQub2Zmc2V0SGVpZ2h0IC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJUb3BXaWR0aCddKSAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ1RvcCddKSAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ0JvdHRvbSddKSAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyQm90dG9tV2lkdGgnXSk7XG4gICAgICBpZiAoIWlzTmFOKHdpZHRoKSAmJiAhaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICBzaXplID0gW01hdGgubWF4KDAsIHdpZHRoKSwgTWF0aC5tYXgoMCwgaGVpZ2h0KV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaGFzQXJlYShzaXplKSAmJlxuICAgICAgICAgICEhKFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5vZmZzZXRXaWR0aCB8fFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5vZmZzZXRIZWlnaHQgfHxcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIk5vIG1hcCB2aXNpYmxlIGJlY2F1c2UgdGhlIG1hcCBjb250YWluZXIncyB3aWR0aCBvciBoZWlnaHQgYXJlIDAuXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICBpZiAoc2l6ZSAmJiAoIW9sZFNpemUgfHwgIWVxdWFscyhzaXplLCBvbGRTaXplKSkpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZShzaXplKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRTaXplXyhzaXplKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjb21wdXRlcyB0aGUgdmlld3BvcnQgc2l6ZSBhbmQgc2F2ZSBpdCBvbiB0aGUgdmlldyBvYmplY3QgKGlmIGFueSlcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IHNpemUgVGhlIHNpemUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVWaWV3cG9ydFNpemVfKHNpemUpIHtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHZpZXcuc2V0Vmlld3BvcnRTaXplKHNpemUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwT3B0aW9uc30gb3B0aW9ucyBNYXAgb3B0aW9ucy5cbiAqIEByZXR1cm4ge01hcE9wdGlvbnNJbnRlcm5hbH0gSW50ZXJuYWwgbWFwIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnNJbnRlcm5hbChvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9XG4gICAqL1xuICBsZXQga2V5Ym9hcmRFdmVudFRhcmdldCA9IG51bGw7XG4gIGlmIChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGtleWJvYXJkRXZlbnRUYXJnZXQgPVxuICAgICAgdHlwZW9mIG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQpXG4gICAgICAgIDogb3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICovXG4gIGNvbnN0IHZhbHVlcyA9IHt9O1xuXG4gIGNvbnN0IGxheWVyR3JvdXAgPVxuICAgIG9wdGlvbnMubGF5ZXJzICYmXG4gICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvcHRpb25zLmxheWVycykuZ2V0TGF5ZXJzKSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyAvKiogQHR5cGUge0xheWVyR3JvdXB9ICovIChvcHRpb25zLmxheWVycylcbiAgICAgIDogbmV3IExheWVyR3JvdXAoe1xuICAgICAgICAgIGxheWVyczpcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fSAqLyAoXG4gICAgICAgICAgICAgIG9wdGlvbnMubGF5ZXJzXG4gICAgICAgICAgICApLFxuICAgICAgICB9KTtcbiAgdmFsdWVzW01hcFByb3BlcnR5LkxBWUVSR1JPVVBdID0gbGF5ZXJHcm91cDtcblxuICB2YWx1ZXNbTWFwUHJvcGVydHkuVEFSR0VUXSA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5WSUVXXSA9XG4gICAgb3B0aW9ucy52aWV3IGluc3RhbmNlb2YgVmlldyA/IG9wdGlvbnMudmlldyA6IG5ldyBWaWV3KCk7XG5cbiAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICBsZXQgY29udHJvbHM7XG4gIGlmIChvcHRpb25zLmNvbnRyb2xzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmNvbnRyb2xzKSkge1xuICAgICAgY29udHJvbHMgPSBuZXcgQ29sbGVjdGlvbihvcHRpb25zLmNvbnRyb2xzLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5jb250cm9scykuZ2V0QXJyYXkpID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAnRXhwZWN0ZWQgYGNvbnRyb2xzYCB0byBiZSBhbiBhcnJheSBvciBhbiBgb2wvQ29sbGVjdGlvbi5qc2AnLFxuICAgICAgKTtcbiAgICAgIGNvbnRyb2xzID0gb3B0aW9ucy5jb250cm9scztcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvblwiKS5kZWZhdWx0Pn0gKi9cbiAgbGV0IGludGVyYWN0aW9ucztcbiAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyYWN0aW9ucykpIHtcbiAgICAgIGludGVyYWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMuaW50ZXJhY3Rpb25zLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5pbnRlcmFjdGlvbnMpLmdldEFycmF5KSA9PT1cbiAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgICAnRXhwZWN0ZWQgYGludGVyYWN0aW9uc2AgdG8gYmUgYW4gYXJyYXkgb3IgYW4gYG9sL0NvbGxlY3Rpb24uanNgJyxcbiAgICAgICk7XG4gICAgICBpbnRlcmFjdGlvbnMgPSBvcHRpb25zLmludGVyYWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSAqL1xuICBsZXQgb3ZlcmxheXM7XG4gIGlmIChvcHRpb25zLm92ZXJsYXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm92ZXJsYXlzKSkge1xuICAgICAgb3ZlcmxheXMgPSBuZXcgQ29sbGVjdGlvbihvcHRpb25zLm92ZXJsYXlzLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5vdmVybGF5cykuZ2V0QXJyYXkpID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAnRXhwZWN0ZWQgYG92ZXJsYXlzYCB0byBiZSBhbiBhcnJheSBvciBhbiBgb2wvQ29sbGVjdGlvbi5qc2AnLFxuICAgICAgKTtcbiAgICAgIG92ZXJsYXlzID0gb3B0aW9ucy5vdmVybGF5cztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3ZlcmxheXMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250cm9sczogY29udHJvbHMsXG4gICAgaW50ZXJhY3Rpb25zOiBpbnRlcmFjdGlvbnMsXG4gICAga2V5Ym9hcmRFdmVudFRhcmdldDoga2V5Ym9hcmRFdmVudFRhcmdldCxcbiAgICBvdmVybGF5czogb3ZlcmxheXMsXG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCBNYXA7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlckV2ZW50XG4gKi9cbmltcG9ydCBNYXBFdmVudCBmcm9tICcuL01hcEV2ZW50LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBhcyBtYXAgYnJvd3NlciBldmVudHMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfSBmb3Igd2hpY2ggZXZlbnRzIHRyaWdnZXIgYSBtYXAgYnJvd3NlciBldmVudC5cbiAqIEB0ZW1wbGF0ZSB7VUlFdmVudH0gRVZFTlRcbiAqL1xuY2xhc3MgTWFwQnJvd3NlckV2ZW50IGV4dGVuZHMgTWFwRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAcGFyYW0ge0VWRU5UfSBvcmlnaW5hbEV2ZW50IE9yaWdpbmFsIGV2ZW50LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkcmFnZ2luZ10gSXMgdGhlIG1hcCBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZD9cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBbZnJhbWVTdGF0ZV0gRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8UG9pbnRlckV2ZW50Pn0gW2FjdGl2ZVBvaW50ZXJzXSBBY3RpdmUgcG9pbnRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBtYXAsIG9yaWdpbmFsRXZlbnQsIGRyYWdnaW5nLCBmcmFtZVN0YXRlLCBhY3RpdmVQb2ludGVycykge1xuICAgIHN1cGVyKHR5cGUsIG1hcCwgZnJhbWVTdGF0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7RVZFTlR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIHBpeGVsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIGluIHRoZSB1c2VyIHByb2plY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIG1hcCBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZC4gT25seSBzZXQgZm9yXG4gICAgICogYFBPSU5URVJEUkFHYCBhbmQgYFBPSU5URVJNT1ZFYCBldmVudHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmcgIT09IHVuZGVmaW5lZCA/IGRyYWdnaW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9pbnRlckV2ZW50Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVQb2ludGVycyA9IGFjdGl2ZVBvaW50ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYXAgcGl4ZWwgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0IHBpeGVsKCkge1xuICAgIGlmICghdGhpcy5waXhlbF8pIHtcbiAgICAgIHRoaXMucGl4ZWxfID0gdGhpcy5tYXAuZ2V0RXZlbnRQaXhlbCh0aGlzLm9yaWdpbmFsRXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5waXhlbF87XG4gIH1cbiAgc2V0IHBpeGVsKHBpeGVsKSB7XG4gICAgdGhpcy5waXhlbF8gPSBwaXhlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29vcmRpbmF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LiAgVGhpcyB3aWxsIGJlIGluIHRoZSB1c2VyXG4gICAqIHByb2plY3Rpb24gaWYgb25lIGlzIHNldC4gIE90aGVyd2lzZSBpdCB3aWxsIGJlIGluIHRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0IGNvb3JkaW5hdGUoKSB7XG4gICAgaWYgKCF0aGlzLmNvb3JkaW5hdGVfKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVfID0gdGhpcy5tYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLnBpeGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZV87XG4gIH1cbiAgc2V0IGNvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgIHRoaXMuY29vcmRpbmF0ZV8gPSBjb29yZGluYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LnByZXZlbnREZWZhdWx0LlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgc3VwZXIucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoJ3ByZXZlbnREZWZhdWx0JyBpbiB0aGlzLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgIC8qKiBAdHlwZSB7VUlFdmVudH0gKi8gKHRoaXMub3JpZ2luYWxFdmVudCkucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5zdG9wUHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgc3VwZXIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKCdzdG9wUHJvcGFnYXRpb24nIGluIHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgLyoqIEB0eXBlIHtVSUV2ZW50fSAqLyAodGhpcy5vcmlnaW5hbEV2ZW50KS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFwQnJvd3NlckV2ZW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudEhhbmRsZXJcbiAqL1xuXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlckV2ZW50LmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCB7UEFTU0lWRV9FVkVOVF9MSVNURU5FUlN9IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5cbmNsYXNzIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIgZXh0ZW5kcyBUYXJnZXQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgVGhlIG1hcCB3aXRoIHRoZSB2aWV3cG9ydCB0byBsaXN0ZW4gdG8gZXZlbnRzIG9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vdmVUb2xlcmFuY2VdIFRoZSBtaW5pbWFsIGRpc3RhbmNlIHRoZSBwb2ludGVyIG11c3QgdHJhdmVsIHRvIHRyaWdnZXIgYSBtb3ZlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFwLCBtb3ZlVG9sZXJhbmNlKSB7XG4gICAgc3VwZXIobWFwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGxpc3RlbiB0byB0aGUgcmVhbCBldmVudHMgb24uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNsaWNrVGltZW91dElkXztcblxuICAgIC8qKlxuICAgICAqIEVtdWxhdGUgZGJsY2xpY2sgYW5kIHNpbmdsZWNsaWNrLiBXaWxsIGJlIHRydWUgd2hlbiBvbmx5IG9uZSBwb2ludGVyIGlzIGFjdGl2ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVtdWxhdGVDbGlja3NfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tb3ZlVG9sZXJhbmNlXyA9IG1vdmVUb2xlcmFuY2UgPT09IHVuZGVmaW5lZCA/IDEgOiBtb3ZlVG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IFwiZG93blwiIHR5cGUgZXZlbnQgKG9yIG51bGwgaWYgbm9uZSBoYXZlIG9jY3VycmVkKS5cbiAgICAgKiBTZXQgb24gcG9pbnRlcmRvd24uXG4gICAgICogQHR5cGUge1BvaW50ZXJFdmVudHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kb3duXyA9IG51bGw7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5tYXBfLmdldFZpZXdwb3J0KCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9pbnRlckV2ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxudW1iZXIsIEV2ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSBlbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgZWxlbWVudCxcbiAgICAgIFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sXG4gICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duXyxcbiAgICAgIHRoaXMsXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQb2ludGVyRXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVsYXllZExpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgIGVsZW1lbnQsXG4gICAgICBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgdGhpcy5yZWxheU1vdmVFdmVudF8sXG4gICAgICB0aGlzLFxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRIYW5kbGVUb3VjaE1vdmVfID0gdGhpcy5oYW5kbGVUb3VjaE1vdmVfLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmVsZW1lbnRfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuVE9VQ0hNT1ZFLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVRvdWNoTW92ZV8sXG4gICAgICBQQVNTSVZFX0VWRU5UX0xJU1RFTkVSUyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtdWxhdGVDbGlja18ocG9pbnRlckV2ZW50KSB7XG4gICAgbGV0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICB0aGlzLm1hcF8sXG4gICAgICBwb2ludGVyRXZlbnQsXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIGlmICh0aGlzLmNsaWNrVGltZW91dElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkb3VibGUtY2xpY2tcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZW91dElkXyk7XG4gICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgICAgIG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSyxcbiAgICAgICAgdGhpcy5tYXBfLFxuICAgICAgICBwb2ludGVyRXZlbnQsXG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2xpY2tcbiAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQoXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSyxcbiAgICAgICAgICB0aGlzLm1hcF8sXG4gICAgICAgICAgcG9pbnRlckV2ZW50LFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgfSwgMjUwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb24gaG93IG1hbnkgcG9pbnRlcnMgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IHBvaW50ZXJFdmVudDtcbiAgICBjb25zdCBpZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuICAgIGlmIChcbiAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVAgfHxcbiAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSQ0FOQ0VMXG4gICAgKSB7XG4gICAgICBkZWxldGUgdGhpcy50cmFja2VkVG91Y2hlc19baWRdO1xuICAgICAgZm9yIChjb25zdCBwb2ludGVySWQgaW4gdGhpcy50cmFja2VkVG91Y2hlc18pIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZFRvdWNoZXNfW3BvaW50ZXJJZF0udGFyZ2V0ICE9PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAvLyBTb21lIHBsYXRmb3JtcyBhc3NpZ24gYSBuZXcgcG9pbnRlcklkIHdoZW4gdGhlIHRhcmdldCBjaGFuZ2VzLlxuICAgICAgICAgIC8vIElmIHRoaXMgaGFwcGVucywgZGVsZXRlIG9uZSB0cmFja2VkIHBvaW50ZXIuIElmIHRoZXJlIGlzIG1vcmVcbiAgICAgICAgICAvLyB0aGFuIG9uZSB0cmFja2VkIHBvaW50ZXIgZm9yIHRoZSBvbGQgdGFyZ2V0LCBpdCB3aWxsIGJlIGNsZWFyZWRcbiAgICAgICAgICAvLyBieSBzdWJzZXF1ZW50IFBPSU5URVJVUCBldmVudHMgZnJvbSBvdGhlciBwb2ludGVycy5cbiAgICAgICAgICBkZWxldGUgdGhpcy50cmFja2VkVG91Y2hlc19bcG9pbnRlcklkXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04gfHxcbiAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRVxuICAgICkge1xuICAgICAgdGhpcy50cmFja2VkVG91Y2hlc19baWRdID0gZXZlbnQ7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gT2JqZWN0LnZhbHVlcyh0aGlzLnRyYWNrZWRUb3VjaGVzXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUG9pbnRlclVwXyhwb2ludGVyRXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQLFxuICAgICAgdGhpcy5tYXBfLFxuICAgICAgcG9pbnRlckV2ZW50LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5hY3RpdmVQb2ludGVyc18sXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgLy8gV2UgZW11bGF0ZSBjbGljayBldmVudHMgb24gbGVmdCBtb3VzZSBidXR0b24gY2xpY2ssIHRvdWNoIGNvbnRhY3QsIGFuZCBwZW5cbiAgICAvLyBjb250YWN0LiBpc01vdXNlQWN0aW9uQnV0dG9uIHJldHVybnMgdHJ1ZSBpbiB0aGVzZSBjYXNlcyAoZXZ0LmJ1dHRvbiBpcyBzZXRcbiAgICAvLyB0byAwKS5cbiAgICAvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jYnV0dG9uLXN0YXRlc1xuICAgIC8vIFdlIG9ubHkgZmlyZSBjbGljaywgc2luZ2xlY2xpY2ssIGFuZCBkb3VibGVjbGljayBpZiBub2JvZHkgaGFzIGNhbGxlZFxuICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbXVsYXRlQ2xpY2tzXyAmJlxuICAgICAgIW5ld0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICF0aGlzLmRyYWdnaW5nXyAmJlxuICAgICAgdGhpcy5pc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpXG4gICAgKSB7XG4gICAgICB0aGlzLmVtdWxhdGVDbGlja18odGhpcy5kb3duXyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlUG9pbnRlcnNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5kcmFnZ2luZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMuZG93bl8gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiB3YXMgcHJlc3NlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW91c2VBY3Rpb25CdXR0b25fKHBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVBvaW50ZXJEb3duXyhwb2ludGVyRXZlbnQpIHtcbiAgICB0aGlzLmVtdWxhdGVDbGlja3NfID0gdGhpcy5hY3RpdmVQb2ludGVyc18ubGVuZ3RoID09PSAwO1xuICAgIHRoaXMudXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCk7XG4gICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTixcbiAgICAgIHRoaXMubWFwXyxcbiAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfLFxuICAgICk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblxuICAgIHRoaXMuZG93bl8gPSBuZXcgUG9pbnRlckV2ZW50KHBvaW50ZXJFdmVudC50eXBlLCBwb2ludGVyRXZlbnQpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmRvd25fLCAndGFyZ2V0Jywge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHBvaW50ZXJFdmVudC50YXJnZXQsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMubWFwXy5nZXRPd25lckRvY3VtZW50KCk7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBkb2MsXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICApLFxuICAgICAgICBsaXN0ZW4oZG9jLCBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCwgdGhpcy5oYW5kbGVQb2ludGVyVXBfLCB0aGlzKSxcbiAgICAgICAgLyogTm90ZSB0aGF0IHRoZSBsaXN0ZW5lciBmb3IgYHBvaW50ZXJjYW5jZWwgaXMgc2V0IHVwIG9uXG4gICAgICAgICAqIGBwb2ludGVyRXZlbnRIYW5kbGVyX2AgYW5kIG5vdCBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgbGlrZVxuICAgICAgICAgKiB0aGUgYHBvaW50ZXJ1cGAgYW5kIGBwb2ludGVybW92ZWAgbGlzdGVuZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoZSBmb2xsb3dpbmc6IGBUb3VjaFNvdXJjZS52YWN1dW1Ub3VjaGVzXygpYFxuICAgICAgICAgKiBpc3N1ZXMgYHBvaW50ZXJjYW5jZWxgIGV2ZW50cywgd2hlbiB0aGVyZSB3YXMgbm8gYHRvdWNoZW5kYCBmb3IgYVxuICAgICAgICAgKiBgdG91Y2hzdGFydGAuIE5vdywgbGV0J3Mgc2F5IGEgZmlyc3QgYHRvdWNoc3RhcnRgIGlzIHJlZ2lzdGVyZWQgb25cbiAgICAgICAgICogYHBvaW50ZXJFdmVudEhhbmRsZXJfYC4gVGhlIGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBpcyBzZXQgdXAuXG4gICAgICAgICAqIEJ1dCBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgZG9lc24ndCBrbm93IGFib3V0IHRoZSBmaXJzdFxuICAgICAgICAgKiBgdG91Y2hzdGFydGAuIElmIHRoZXJlIGlzIG5vIGB0b3VjaGVuZGAgZm9yIHRoZSBgdG91Y2hzdGFydGAsIHdlIGNhblxuICAgICAgICAgKiBvbmx5IHJlY2VpdmUgYSBgdG91Y2hjYW5jZWxgIGZyb20gYHBvaW50ZXJFdmVudEhhbmRsZXJfYCwgYmVjYXVzZSBpdCBpc1xuICAgICAgICAgKiBvbmx5IHJlZ2lzdGVyZWQgdGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAgdGhpcy5lbGVtZW50XyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJDQU5DRUwsXG4gICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXBfLFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudF8uZ2V0Um9vdE5vZGUgJiYgdGhpcy5lbGVtZW50Xy5nZXRSb290Tm9kZSgpICE9PSBkb2MpIHtcbiAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5wdXNoKFxuICAgICAgICAgIGxpc3RlbihcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudF8uZ2V0Um9vdE5vZGUoKSxcbiAgICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXBfLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyTW92ZV8ocG9pbnRlckV2ZW50KSB7XG4gICAgLy8gQmV0d2VlbiBwb2ludGVyZG93biBhbmQgcG9pbnRlcnVwLCBwb2ludGVybW92ZSBldmVudHMgYXJlIHRyaWdnZXJlZC5cbiAgICAvLyBUbyBhdm9pZCBhICdmYWxzZScgdG91Y2htb3ZlIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQsIHdlIHRlc3QgaWYgdGhlIHBvaW50ZXJcbiAgICAvLyBtb3ZlZCBhIHNpZ25pZmljYW50IGRpc3RhbmNlLlxuICAgIGlmICh0aGlzLmlzTW92aW5nXyhwb2ludGVyRXZlbnQpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgICAgdGhpcy5kcmFnZ2luZ18gPSB0cnVlO1xuICAgICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHLFxuICAgICAgICB0aGlzLm1hcF8sXG4gICAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgICAgdGhpcy5kcmFnZ2luZ18sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5hY3RpdmVQb2ludGVyc18sXG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbmQgcmVsYXkgYSBwb2ludGVybW92ZSBldmVudC5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVsYXlNb3ZlRXZlbnRfKHBvaW50ZXJFdmVudCkge1xuICAgIHRoaXMub3JpZ2luYWxQb2ludGVyTW92ZUV2ZW50XyA9IHBvaW50ZXJFdmVudDtcbiAgICBjb25zdCBkcmFnZ2luZyA9ICEhKHRoaXMuZG93bl8gJiYgdGhpcy5pc01vdmluZ18ocG9pbnRlckV2ZW50KSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgICAgdGhpcy5tYXBfLFxuICAgICAgICBwb2ludGVyRXZlbnQsXG4gICAgICAgIGRyYWdnaW5nLFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsZXhpYmxlIGhhbmRsaW5nIG9mIGEgYHRvdWNoLWFjdGlvbjogbm9uZWAgY3NzIGVxdWl2YWxlbnQ6IGJlY2F1c2UgY2FsbGluZ1xuICAgKiBgcHJldmVudERlZmF1bHQoKWAgb24gYSBgcG9pbnRlcm1vdmVgIGV2ZW50IGRvZXMgbm90IHN0b3AgbmF0aXZlIHBhZ2Ugc2Nyb2xsaW5nXG4gICAqIGFuZCB6b29taW5nLCB3ZSBhbHNvIGxpc3RlbiBmb3IgYHRvdWNobW92ZWAgYW5kIGNhbGwgYHByZXZlbnREZWZhdWx0KClgIG9uIGl0XG4gICAqIHdoZW4gYW4gaW50ZXJhY3Rpb24gKGN1cnJlbnRseSBgRHJhZ1BhbmAgaGFuZGxlcyB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUb3VjaE1vdmVfKGV2ZW50KSB7XG4gICAgLy8gRHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tcGl6ZW5iZXJnL2VsbS1wZXAvaXNzdWVzLzIsIGB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF9gXG4gICAgLy8gbWF5IG5vdCBiZSBpbml0aWFsaXplZCB5ZXQgd2hlbiB3ZSBnZXQgaGVyZSBvbiBhIHBsYXRmb3JtIHdpdGhvdXQgbmF0aXZlIHBvaW50ZXIgZXZlbnRzLFxuICAgIC8vIHdoZW4gZWxtLXBlcCBpcyB1c2VkIGFzIHBvaW50ZXIgZXZlbnRzIHBvbHlmaWxsLlxuICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF87XG4gICAgaWYgKFxuICAgICAgKCFvcmlnaW5hbEV2ZW50IHx8IG9yaWdpbmFsRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiZcbiAgICAgICh0eXBlb2YgZXZlbnQuY2FuY2VsYWJsZSAhPT0gJ2Jvb2xlYW4nIHx8IGV2ZW50LmNhbmNlbGFibGUgPT09IHRydWUpXG4gICAgKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIG1vdmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW92aW5nXyhwb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5kcmFnZ2luZ18gfHxcbiAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRYIC0gdGhpcy5kb3duXy5jbGllbnRYKSA+XG4gICAgICAgIHRoaXMubW92ZVRvbGVyYW5jZV8gfHxcbiAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRZIC0gdGhpcy5kb3duXy5jbGllbnRZKSA+IHRoaXMubW92ZVRvbGVyYW5jZV9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucmVsYXllZExpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRfLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuVE9VQ0hNT1ZFLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVRvdWNoTW92ZV8sXG4gICAgKTtcblxuICAgIGlmICh0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuZWxlbWVudF8gPSBudWxsO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlckV2ZW50VHlwZVxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBldmVudCBuYW1lcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEEgdHJ1ZSBzaW5nbGUgY2xpY2sgd2l0aCBubyBkcmFnZ2luZyBhbmQgbm8gZG91YmxlIGNsaWNrLiBOb3RlIHRoYXQgdGhpc1xuICAgKiBldmVudCBpcyBkZWxheWVkIGJ5IDI1MCBtcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBub3QgYSBkb3VibGUgY2xpY2suXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNzaW5nbGVjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBTSU5HTEVDTElDSzogJ3NpbmdsZWNsaWNrJyxcblxuICAvKipcbiAgICogQSBjbGljayB3aXRoIG5vIGRyYWdnaW5nLiBBIGRvdWJsZSBjbGljayB3aWxsIGZpcmUgdHdvIG9mIHRoaXMuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBDTElDSzogRXZlbnRUeXBlLkNMSUNLLFxuXG4gIC8qKlxuICAgKiBBIHRydWUgZG91YmxlIGNsaWNrLCB3aXRoIG5vIGRyYWdnaW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjZGJsY2xpY2tcbiAgICogQGFwaVxuICAgKi9cbiAgREJMQ0xJQ0s6IEV2ZW50VHlwZS5EQkxDTElDSyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwb2ludGVyIGlzIGRyYWdnZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNwb2ludGVyZHJhZ1xuICAgKiBAYXBpXG4gICAqL1xuICBQT0lOVEVSRFJBRzogJ3BvaW50ZXJkcmFnJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwb2ludGVyIGlzIG1vdmVkLiBOb3RlIHRoYXQgb24gdG91Y2ggZGV2aWNlcyB0aGlzIGlzXG4gICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgcGFubmVkLCBzbyBpcyBub3QgdGhlIHNhbWUgYXMgbW91c2Vtb3ZlLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjcG9pbnRlcm1vdmVcbiAgICogQGFwaVxuICAgKi9cbiAgUE9JTlRFUk1PVkU6ICdwb2ludGVybW92ZScsXG5cbiAgUE9JTlRFUkRPV046ICdwb2ludGVyZG93bicsXG4gIFBPSU5URVJVUDogJ3BvaW50ZXJ1cCcsXG4gIFBPSU5URVJPVkVSOiAncG9pbnRlcm92ZXInLFxuICBQT0lOVEVST1VUOiAncG9pbnRlcm91dCcsXG4gIFBPSU5URVJFTlRFUjogJ3BvaW50ZXJlbnRlcicsXG4gIFBPSU5URVJMRUFWRTogJ3BvaW50ZXJsZWF2ZScsXG4gIFBPSU5URVJDQU5DRUw6ICdwb2ludGVyY2FuY2VsJyxcbn07XG5cbi8qKipcbiAqIEB0eXBlZGVmIHsnc2luZ2xlY2xpY2snfCdjbGljayd8J2RibGNsaWNrJ3wncG9pbnRlcmRyYWcnfCdwb2ludGVybW92ZSd9IFR5cGVzXG4gKi9cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBFdmVudFxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGFzIG1hcCBldmVudHMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfSBmb3Igd2hpY2ggZXZlbnRzIHRyaWdnZXIgYSBtYXAgZXZlbnQuXG4gKi9cbmNsYXNzIE1hcEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBbZnJhbWVTdGF0ZV0gRnJhbWUgc3RhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBtYXAsIGZyYW1lU3RhdGUpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IG1hcDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBzdGF0ZSBhdCB0aGUgdGltZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL01hcC5qc1wiKS5GcmFtZVN0YXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlICE9PSB1bmRlZmluZWQgPyBmcmFtZVN0YXRlIDogbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXBFdmVudDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBFdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciBhIG1hcCBmcmFtZSBpcyByZW5kZXJlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNwb3N0cmVuZGVyXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RSRU5ERVI6ICdwb3N0cmVuZGVyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgbW92aW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I21vdmVzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBNT1ZFU1RBUlQ6ICdtb3Zlc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1hcCBpcyBtb3ZlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNtb3ZlZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIE1PVkVFTkQ6ICdtb3ZlZW5kJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gbG9hZGluZyBvZiBhZGRpdGlvbmFsIG1hcCBkYXRhICh0aWxlcywgaW1hZ2VzLCBmZWF0dXJlcykgc3RhcnRzLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I2xvYWRzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBMT0FEU1RBUlQ6ICdsb2Fkc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBsb2FkaW5nIG9mIGFkZGl0aW9uYWwgbWFwIGRhdGEgaGFzIGNvbXBsZXRlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNsb2FkZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIExPQURFTkQ6ICdsb2FkZW5kJyxcbn07XG5cbi8qKipcbiAqIEB0eXBlZGVmIHsncG9zdHJlbmRlcid8J21vdmVzdGFydCd8J21vdmVlbmQnfCdsb2Fkc3RhcnQnfCdsb2FkZW5kJ30gVHlwZXNcbiAqL1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcFByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIExBWUVSR1JPVVA6ICdsYXllcmdyb3VwJyxcbiAgU0laRTogJ3NpemUnLFxuICBUQVJHRVQ6ICd0YXJnZXQnLFxuICBWSUVXOiAndmlldycsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09iamVjdFxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuL09ic2VydmFibGUuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4vb2JqLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgZm9yIGBrZXlgLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwga2V5LCBvbGRWYWx1ZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIGNoYW5naW5nLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0ga2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9sZCB2YWx1ZS4gVG8gZ2V0IHRoZSBuZXcgdmFsdWUgdXNlIGBlLnRhcmdldC5nZXQoZS5rZXkpYCB3aGVyZVxuICAgICAqIGBlYCBpcyB0aGUgZXZlbnQgb2JqZWN0LlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gIH1cbn1cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXMsIE9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzLCBSZXR1cm4+fSBPYmplY3RPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTW9zdCBub24tdHJpdmlhbCBjbGFzc2VzIGluaGVyaXQgZnJvbSB0aGlzLlxuICpcbiAqIFRoaXMgZXh0ZW5kcyB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZX0gd2l0aCBvYnNlcnZhYmxlXG4gKiBwcm9wZXJ0aWVzLCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIG9ic2VydmFibGUgYXMgd2VsbCBhcyB0aGUgb2JqZWN0IGFzIGFcbiAqIHdob2xlLlxuICpcbiAqIENsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyBoYXZlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMsIHRvIHdoaWNoIHlvdSBjYW5cbiAqIGFkZCB5b3VyIG93bnMuIFRoZSBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzIGFyZSBsaXN0ZWQgaW4gdGhpcyBkb2N1bWVudGF0aW9uIGFzXG4gKiAnT2JzZXJ2YWJsZSBQcm9wZXJ0aWVzJywgYW5kIGhhdmUgdGhlaXIgb3duIGFjY2Vzc29yczsgZm9yIGV4YW1wbGUsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGhhcyBhIGB0YXJnZXRgIHByb3BlcnR5LCBhY2Nlc3NlZCB3aXRoXG4gKiBgZ2V0VGFyZ2V0KClgIGFuZCBjaGFuZ2VkIHdpdGggYHNldFRhcmdldCgpYC4gTm90IGFsbCBwcm9wZXJ0aWVzIGFyZSBob3dldmVyXG4gKiBzZXR0YWJsZS4gVGhlcmUgYXJlIGFsc28gZ2VuZXJhbC1wdXJwb3NlIGFjY2Vzc29ycyBgZ2V0KClgIGFuZCBgc2V0KClgLiBGb3JcbiAqIGV4YW1wbGUsIGBnZXQoJ3RhcmdldCcpYCBpcyBlcXVpdmFsZW50IHRvIGBnZXRUYXJnZXQoKWAuXG4gKlxuICogVGhlIGBzZXRgIGFjY2Vzc29ycyB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCBhbmQgeW91IGNhbiBtb25pdG9yIHRoaXMgYnlcbiAqIHJlZ2lzdGVyaW5nIGEgbGlzdGVuZXIuIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL1ZpZXd+Vmlld30gaGFzIGFcbiAqIGBjZW50ZXJgIHByb3BlcnR5LCBzbyBgdmlldy5vbignY2hhbmdlOmNlbnRlcicsIGZ1bmN0aW9uKGV2dCkgey4uLn0pO2Agd291bGRcbiAqIGNhbGwgdGhlIGZ1bmN0aW9uIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgY2VudGVyIHByb3BlcnR5IGNoYW5nZXMuIFdpdGhpblxuICogdGhlIGZ1bmN0aW9uLCBgZXZ0LnRhcmdldGAgd291bGQgYmUgdGhlIHZpZXcsIHNvIGBldnQudGFyZ2V0LmdldENlbnRlcigpYFxuICogd291bGQgcmV0dXJuIHRoZSBuZXcgY2VudGVyLlxuICpcbiAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG9ic2VydmFibGUgcHJvcGVydGllcyB3aXRoXG4gKiBgb2JqZWN0LnNldCgncHJvcCcsICd2YWx1ZScpYCwgYW5kIHJldHJpZXZlIHRoYXQgd2l0aCBgb2JqZWN0LmdldCgncHJvcCcpYC5cbiAqIFlvdSBjYW4gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoYXQgcHJvcGVydHkgdmFsdWUgd2l0aFxuICogYG9iamVjdC5vbignY2hhbmdlOnByb3AnLCBsaXN0ZW5lcilgLiBZb3UgY2FuIGdldCBhIGxpc3Qgb2YgYWxsXG4gKiBwcm9wZXJ0aWVzIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdCNnZXRQcm9wZXJ0aWVzfS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG9ic2VydmFibGUgcHJvcGVydGllcyBhcmUgc2VwYXJhdGUgZnJvbSBzdGFuZGFyZCBKUyBwcm9wZXJ0aWVzLlxuICogWW91IGNhbiwgZm9yIGV4YW1wbGUsIGdpdmUgeW91ciBtYXAgb2JqZWN0IGEgdGl0bGUgd2l0aFxuICogYG1hcC50aXRsZT0nTmV3IHRpdGxlJ2AgYW5kIHdpdGggYG1hcC5zZXQoJ3RpdGxlJywgJ0Fub3RoZXIgdGl0bGUnKWAuIFRoZVxuICogZmlyc3Qgd2lsbCBiZSBhIGBoYXNPd25Qcm9wZXJ0eWA7IHRoZSBzZWNvbmQgd2lsbCBhcHBlYXIgaW5cbiAqIGBnZXRQcm9wZXJ0aWVzKClgLiBPbmx5IHRoZSBzZWNvbmQgaXMgb2JzZXJ2YWJsZS5cbiAqXG4gKiBQcm9wZXJ0aWVzIGNhbiBiZSBkZWxldGVkIGJ5IHVzaW5nIHRoZSB1bnNldCBtZXRob2QuIEUuZy5cbiAqIG9iamVjdC51bnNldCgnZm9vJykuXG4gKlxuICogQGZpcmVzIE9iamVjdEV2ZW50XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEJhc2VPYmplY3QgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj59IFt2YWx1ZXNdIEFuIG9iamVjdCB3aXRoIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge09iamVjdE9uU2lnbmF0dXJlPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0T25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge09iamVjdE9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvLyBDYWxsIHtAbGluayBtb2R1bGU6b2wvdXRpbC5nZXRVaWR9IHRvIGVuc3VyZSB0aGF0IHRoZSBvcmRlciBvZiBvYmplY3RzJyBpZHMgaXNcbiAgICAvLyB0aGUgc2FtZSBhcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGNyZWF0ZWQuICBUaGlzIGFsc28gaGVscHMgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBvYmplY3QgcHJvcGVydGllcyBhcmUgYWx3YXlzIGFkZGVkIGluIHRoZSBzYW1lIG9yZGVyLCB3aGljaFxuICAgIC8vIGhlbHBzIG1hbnkgSmF2YVNjcmlwdCBlbmdpbmVzIGdlbmVyYXRlIGZhc3RlciBjb2RlLlxuICAgIGdldFVpZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNfID0gbnVsbDtcblxuICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHJldHVybiB7Kn0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiB0aGlzLnZhbHVlc18uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2Ygb2JqZWN0IHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBMaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiAodGhpcy52YWx1ZXNfICYmIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzXykpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3Qgb2YgYWxsIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsICo+fSBPYmplY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnZhbHVlc18gJiYgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZXNfKSkgfHwge307XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy5cbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgKj4/fSBPYmplY3QuXG4gICAqL1xuICBnZXRQcm9wZXJ0aWVzSW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGhhcyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgaGFzUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gISF0aGlzLnZhbHVlc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBPbGQgdmFsdWUuXG4gICAqL1xuICBub3RpZnkoa2V5LCBvbGRWYWx1ZSkge1xuICAgIGxldCBldmVudFR5cGU7XG4gICAgZXZlbnRUeXBlID0gYGNoYW5nZToke2tleX1gO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gICAgfVxuICAgIGV2ZW50VHlwZSA9IE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcihldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE9iamVjdEV2ZW50KGV2ZW50VHlwZSwga2V5LCBvbGRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIGFkZENoYW5nZUxpc3RlbmVyKGtleSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYGNoYW5nZToke2tleX1gLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5MaXN0ZW5lcn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcihrZXksIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGBjaGFuZ2U6JHtrZXl9YCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSk7XG4gICAgaWYgKHNpbGVudCkge1xuICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY29sbGVjdGlvbiBvZiBrZXktdmFsdWUgcGFpcnMuICBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIGFueSBleGlzdGluZ1xuICAgKiBwcm9wZXJ0aWVzIGFuZCBhZGRzIG5ldyBvbmVzIChpdCBkb2VzIG5vdCByZW1vdmUgYW55IGV4aXN0aW5nIHByb3BlcnRpZXMpLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnRdIFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFByb3BlcnRpZXModmFsdWVzLCBzaWxlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWVzW2tleV0sIHNpbGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGFueSBwcm9wZXJ0aWVzIGZyb20gYW5vdGhlciBvYmplY3Qgd2l0aG91dCB0cmlnZ2VyaW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIHtCYXNlT2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGFwcGx5UHJvcGVydGllcyhzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZS52YWx1ZXNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSksIHNvdXJjZS52YWx1ZXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNldHMgYSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVbnNldCB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHVuc2V0KGtleSwgc2lsZW50KSB7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiBrZXkgaW4gdGhpcy52YWx1ZXNfKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgZGVsZXRlIHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgaWYgKGlzRW1wdHkodGhpcy52YWx1ZXNfKSkge1xuICAgICAgICB0aGlzLnZhbHVlc18gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0RXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvT2JqZWN0Lk9iamVjdEV2ZW50I3Byb3BlcnR5Y2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIFBST1BFUlRZQ0hBTkdFOiAncHJvcGVydHljaGFuZ2UnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3Byb3BlcnR5Y2hhbmdlJ30gVHlwZXNcbiAqL1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09ic2VydmFibGVcbiAqL1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgbGlzdGVuT25jZSwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gVHlwZVxuICogQHRlbXBsYXRlIHtFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBFdmVudENsYXNzXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7KHR5cGU6IFR5cGUsIGxpc3RlbmVyOiAoZXZlbnQ6IEV2ZW50Q2xhc3MpID0+ID8pID0+IFJldHVybn0gT25TaWduYXR1cmVcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gVHlwZVxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYgeyh0eXBlOiBUeXBlW10sIGxpc3RlbmVyOiAoZXZlbnQ6IEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpID0+ID8pID0+IFJldHVybiBleHRlbmRzIHZvaWQgPyB2b2lkIDogUmV0dXJuW119IENvbWJpbmVkT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnY2hhbmdlJ3wnZXJyb3InfSBFdmVudFR5cGVzXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge09uU2lnbmF0dXJlPEV2ZW50VHlwZXMsIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJiBDb21iaW5lZE9uU2lnbmF0dXJlPEV2ZW50VHlwZXMsIFJldHVybj59IE9ic2VydmFibGVPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQW4gZXZlbnQgdGFyZ2V0IHByb3ZpZGluZyBjb252ZW5pZW50IG1ldGhvZHMgZm9yIGxpc3RlbmVyIHJlZ2lzdHJhdGlvblxuICogYW5kIHVucmVnaXN0cmF0aW9uLiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgYWx3YXlzIGF2YWlsYWJsZSB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSNjaGFuZ2VkfS5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdFxuICogQGFwaVxuICovXG5jbGFzcyBPYnNlcnZhYmxlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vbiA9XG4gICAgICAvKiogQHR5cGUge09ic2VydmFibGVPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fSAqLyAoXG4gICAgICAgIHRoaXMub25JbnRlcm5hbFxuICAgICAgKTtcblxuICAgIHRoaXMub25jZSA9XG4gICAgICAvKiogQHR5cGUge09ic2VydmFibGVPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fSAqLyAoXG4gICAgICAgIHRoaXMub25jZUludGVybmFsXG4gICAgICApO1xuXG4gICAgdGhpcy51biA9IC8qKiBAdHlwZSB7T2JzZXJ2YWJsZU9uU2lnbmF0dXJlPHZvaWQ+fSAqLyAodGhpcy51bkludGVybmFsKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJldmlzaW9uXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSByZXZpc2lvbiBjb3VudGVyIGFuZCBkaXNwYXRjaGVzIGEgJ2NoYW5nZScgZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGNoYW5nZWQoKSB7XG4gICAgKyt0aGlzLnJldmlzaW9uXztcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG51bWJlciBmb3IgdGhpcyBvYmplY3QuICBFYWNoIHRpbWUgdGhlIG9iamVjdCBpcyBtb2RpZmllZCxcbiAgICogaXRzIHZlcnNpb24gbnVtYmVyIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV2aXNpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJldmlzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJldmlzaW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpKTogP30gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBFdmVudCBrZXkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG9uSW50ZXJuYWwodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgY29uc3QgbGVuID0gdHlwZS5sZW5ndGg7XG4gICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleXNbaV0gPSBsaXN0ZW4odGhpcywgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIHJldHVybiBsaXN0ZW4odGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IEV2ZW50IGtleS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgb25jZUludGVybmFsKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgbGV0IGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgY29uc3QgbGVuID0gdHlwZS5sZW5ndGg7XG4gICAgICBrZXkgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAga2V5W2ldID0gbGlzdGVuT25jZSh0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGxpc3Rlbk9uY2UodGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKiogQHR5cGUge09iamVjdH0gKi8gKGxpc3RlbmVyKS5vbF9rZXkgPSBrZXk7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdW5JbnRlcm5hbCh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAobGlzdGVuZXIpLm9sX2tleTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICB1bkJ5S2V5KGtleSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0eXBlLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICogICAgIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIHJldHVyblxuICogICAgIHdpbGwgYmUgYW4gYXJyYXkgb2Yga2V5cy5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUub247XG5cbi8qKlxuICogTGlzdGVuIG9uY2UgZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICogICAgIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIHJldHVyblxuICogICAgIHdpbGwgYmUgYW4gYXJyYXkgb2Yga2V5cy5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUub25jZTtcblxuLyoqXG4gKiBVbmxpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUudW47XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciB1c2luZyB0aGUga2V5IHJldHVybmVkIGJ5IGBvbigpYCBvciBgb25jZSgpYC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IGtleSBUaGUga2V5IHJldHVybmVkIGJ5IGBvbigpYFxuICogICAgIG9yIGBvbmNlKClgIChvciBhbiBhcnJheSBvZiBrZXlzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuQnlLZXkoa2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBrZXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdW5saXN0ZW5CeUtleShrZXlbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1bmxpc3RlbkJ5S2V5KC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fSAqLyAoa2V5KSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JzZXJ2YWJsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlXG4gKi9cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IHtlYXNlSW59IGZyb20gJy4vZWFzaW5nLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL1RpbGV+VGlsZX0gZm9yIHRoZSB0aWxlIGFuZCBhXG4gKiBge3N0cmluZ31gIGZvciB0aGUgdXJsIGFzIGFyZ3VtZW50cy4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcbiAqICAgdGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH0pO1xuICogYGBgXG4gKiBGb3IgbW9yZSBmaW5lIGdyYWluZWQgY29udHJvbCwgdGhlIGxvYWQgZnVuY3Rpb24gY2FuIHVzZSBmZXRjaCBvciBYTUxIdHRwUmVxdWVzdCBhbmQgaW52b2x2ZVxuICogZXJyb3IgaGFuZGxpbmc6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBUaWxlU3RhdGUgZnJvbSAnb2wvVGlsZVN0YXRlLmpzJztcbiAqXG4gKiBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcbiAqICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gKiAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gKiAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKGV2dCkge1xuICogICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3BvbnNlO1xuICogICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAqICAgICAgIHRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICB0aWxlLnNldFN0YXRlKFRpbGVTdGF0ZS5FUlJPUik7XG4gKiAgICAgfVxuICogICB9KTtcbiAqICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICogICAgIHRpbGUuc2V0U3RhdGUoVGlsZVN0YXRlLkVSUk9SKTtcbiAqICAgfSk7XG4gKiAgIHhoci5vcGVuKCdHRVQnLCBzcmMpO1xuICogICB4aHIuc2VuZCgpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oVGlsZSwgc3RyaW5nKTogdm9pZH0gTG9hZEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IHNvdXJjZXMgdXNlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIHRvIGdldFxuICogdGhlIHVybCB0aGF0IHByb3ZpZGVzIGEgdGlsZSBmb3IgYSBnaXZlbiB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gZm9yIHRoZSB0aWxlXG4gKiBjb29yZGluYXRlLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSBwaXhlbCByYXRpbyBhbmQgYVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhcyBhcmd1bWVudHNcbiAqIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIHRpbGUgVVJMLCBvciB1bmRlZmluZWQgaWYgbm8gdGlsZVxuICogc2hvdWxkIGJlIHJlcXVlc3RlZCBmb3IgdGhlIHBhc3NlZCB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCwgbnVtYmVyLFxuICogICAgICAgICAgIGltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQpOiAoc3RyaW5nfHVuZGVmaW5lZCl9IFVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBBIGR1cmF0aW9uIGZvciB0aWxlIG9wYWNpdHlcbiAqIHRyYW5zaXRpb25zIGluIG1pbGxpc2Vjb25kcy4gQSBkdXJhdGlvbiBvZiAwIGRpc2FibGVzIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICogQGFwaVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3IgdGlsZXMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFRpbGUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gVGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZUNvb3JkLCBzdGF0ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ29vcmQgPSB0aWxlQ29vcmQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQSBrZXkgYXNzaWduZWQgdG8gdGhlIHRpbGUuIFRoaXMgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgc291cmNlIGtleVxuICAgICAqIHRvIGRldGVybWluZSBpZiBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgdGlsZSBtYXkgYmUgdXNlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIGZvciB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25fID1cbiAgICAgIG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkID8gMjUwIDogb3B0aW9ucy50cmFuc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIG9mIHN0YXJ0IHRpbWVzIGZvciByZW5kZXJpbmcgdHJhbnNpdGlvbnMuICBJZiB0aGUgc3RhcnQgdGltZSBpc1xuICAgICAqIGVxdWFsIHRvIC0xLCB0aGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSAhIW9wdGlvbnMuaW50ZXJwb2xhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY2hhbmdlZCgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGJ5IHRoZSB0aWxlIGNhY2hlIHdoZW4gdGhlIHRpbGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSBkdWUgdG8gZXhwaXJ5XG4gICAqL1xuICByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIC8vIHRvIHJlbW92ZSB0aGUgYGNoYW5nZWAgbGlzdGVuZXIgb24gdGhpcyB0aWxlIGluIGBvbC9UaWxlUXVldWUjaGFuZGxlVGlsZUNoYW5nZWBcbiAgICAgIHRoaXMuc2V0U3RhdGUoVGlsZVN0YXRlLkVNUFRZKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ICsgJy8nICsgdGhpcy50aWxlQ29vcmQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoaXMgdGlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlQ29vcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNvb3JkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9IFN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhpcyB0aWxlLiBJZiB5b3Ugd3JpdGUgeW91ciBvd24ge0BsaW5rIG1vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbiB0aWxlTG9hZEZ1bmN0aW9ufSAsXG4gICAqIGl0IGlzIGltcG9ydGFudCB0byBzZXQgdGhlIHN0YXRlIGNvcnJlY3RseSB0byB7QGxpbmsgbW9kdWxlOm9sL1RpbGVTdGF0ZX5FUlJPUn1cbiAgICogd2hlbiB0aGUgdGlsZSBjYW5ub3QgYmUgbG9hZGVkLiBPdGhlcndpc2UgdGhlIHRpbGUgY2Fubm90IGJlIHJlbW92ZWQgZnJvbVxuICAgKiB0aGUgdGlsZSBxdWV1ZSBhbmQgd2lsbCBibG9jayBvdGhlciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gVGlsZVN0YXRlLkVSUk9SICYmIHRoaXMuc3RhdGUgPiBzdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGxvYWQgc2VxdWVuY2UgdmlvbGF0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBvciByZXRyeSBpZiBsb2FkaW5nIHByZXZpb3VzbHkgZmFpbGVkLlxuICAgKiBMb2FkaW5nIGlzIHRha2VuIGNhcmUgb2YgYnkgdGhlIHRpbGUgcXVldWUsIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzXG4gICAqIG9ubHkgbmVlZGVkIGZvciBwcmVsb2FkaW5nIG9yIGZvciByZWxvYWRpbmcgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBhcGlcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFscGhhIHZhbHVlIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgcmVuZGVyIGZyYW1lIHRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgKi9cbiAgZ2V0QWxwaGEoaWQsIHRpbWUpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGxldCBzdGFydCA9IHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdO1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gdGltZTtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gc3RhcnQ7XG4gICAgfSBlbHNlIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gdGltZSAtIHN0YXJ0ICsgMTAwMCAvIDYwOyAvLyBhdm9pZCByZW5kZXJpbmcgYXQgMFxuICAgIGlmIChkZWx0YSA+PSB0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VJbihkZWx0YSAvIHRoaXMudHJhbnNpdGlvbl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHRpbGUgaXMgaW4gYW4gYWxwaGEgdHJhbnNpdGlvbi4gIEEgdGlsZSBpcyBjb25zaWRlcmVkIGluXG4gICAqIHRyYW5zaXRpb24gaWYgdGlsZS5nZXRBbHBoYSgpIGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkIG9yIGhhcyBiZWVuIGNhbGxlZFxuICAgKiBhbmQgcmV0dXJuZWQgMS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIGlzIGluIHRyYW5zaXRpb24uXG4gICAqL1xuICBpblRyYW5zaXRpb24oaWQpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdICE9PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIGEgdHJhbnNpdGlvbiBhcyBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqL1xuICBlbmRUcmFuc2l0aW9uKGlkKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMucmVsZWFzZSgpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVF1ZXVlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBQcmlvcml0eVF1ZXVlLCB7RFJPUH0gZnJvbSAnLi9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0LCBzdHJpbmcsIGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlLCBudW1iZXIpOiBudW1iZXJ9IFByaW9yaXR5RnVuY3Rpb25cbiAqL1xuXG5jbGFzcyBUaWxlUXVldWUgZXh0ZW5kcyBQcmlvcml0eVF1ZXVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UHJpb3JpdHlGdW5jdGlvbn0gdGlsZVByaW9yaXR5RnVuY3Rpb24gVGlsZSBwcmlvcml0eSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiA/fSB0aWxlQ2hhbmdlQ2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIG9uIGVhY2ggdGlsZSBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlUHJpb3JpdHlGdW5jdGlvbiwgdGlsZUNoYW5nZUNhbGxiYWNrKSB7XG4gICAgc3VwZXIoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gUHJpb3JpdHkuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aWxlUHJpb3JpdHlGdW5jdGlvbi5hcHBseShudWxsLCBlbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGVsZW1lbnRbMF0pLmdldEtleSgpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZVRpbGVDaGFuZ2VfID0gdGhpcy5oYW5kbGVUaWxlQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbigpOiA/fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNoYW5nZUNhbGxiYWNrXyA9IHRpbGVDaGFuZ2VDYWxsYmFjaztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVzTG9hZGluZ18gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsYm9vbGVhbj59XG4gICAgICovXG4gICAgdGhpcy50aWxlc0xvYWRpbmdLZXlzXyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBlbnF1ZXVlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBhZGRlZCA9IHN1cGVyLmVucXVldWUoZWxlbWVudCk7XG4gICAgaWYgKGFkZGVkKSB7XG4gICAgICBjb25zdCB0aWxlID0gZWxlbWVudFswXTtcbiAgICAgIHRpbGUuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmJvdW5kSGFuZGxlVGlsZUNoYW5nZV8pO1xuICAgIH1cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgdGlsZXMgbG9hZGluZy5cbiAgICovXG4gIGdldFRpbGVzTG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlc0xvYWRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVRpbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgaWYgKFxuICAgICAgc3RhdGUgPT09IFRpbGVTdGF0ZS5MT0FERUQgfHxcbiAgICAgIHN0YXRlID09PSBUaWxlU3RhdGUuRVJST1IgfHxcbiAgICAgIHN0YXRlID09PSBUaWxlU3RhdGUuRU1QVFlcbiAgICApIHtcbiAgICAgIGlmIChzdGF0ZSAhPT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHRpbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmJvdW5kSGFuZGxlVGlsZUNoYW5nZV8pO1xuICAgICAgfVxuICAgICAgY29uc3QgdGlsZUtleSA9IHRpbGUuZ2V0S2V5KCk7XG4gICAgICBpZiAodGlsZUtleSBpbiB0aGlzLnRpbGVzTG9hZGluZ0tleXNfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzTG9hZGluZ0tleXNfW3RpbGVLZXldO1xuICAgICAgICAtLXRoaXMudGlsZXNMb2FkaW5nXztcbiAgICAgIH1cbiAgICAgIHRoaXMudGlsZUNoYW5nZUNhbGxiYWNrXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VG90YWxMb2FkaW5nIE1heGltdW0gbnVtYmVyIHRpbGVzIHRvIGxvYWQgc2ltdWx0YW5lb3VzbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhOZXdMb2FkcyBNYXhpbXVtIG51bWJlciBvZiBuZXcgdGlsZXMgdG8gbG9hZC5cbiAgICovXG4gIGxvYWRNb3JlVGlsZXMobWF4VG90YWxMb2FkaW5nLCBtYXhOZXdMb2Fkcykge1xuICAgIGxldCBuZXdMb2FkcyA9IDA7XG4gICAgd2hpbGUgKFxuICAgICAgdGhpcy50aWxlc0xvYWRpbmdfIDwgbWF4VG90YWxMb2FkaW5nICYmXG4gICAgICBuZXdMb2FkcyA8IG1heE5ld0xvYWRzICYmXG4gICAgICB0aGlzLmdldENvdW50KCkgPiAwXG4gICAgKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH1cbiAgICAgICAqL1xuICAgICAgY29uc3QgdGlsZSA9IHRoaXMuZGVxdWV1ZSgpWzBdO1xuICAgICAgY29uc3QgdGlsZUtleSA9IHRpbGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gVGlsZVN0YXRlLklETEUgJiYgISh0aWxlS2V5IGluIHRoaXMudGlsZXNMb2FkaW5nS2V5c18pKSB7XG4gICAgICAgIHRoaXMudGlsZXNMb2FkaW5nS2V5c19bdGlsZUtleV0gPSB0cnVlO1xuICAgICAgICArK3RoaXMudGlsZXNMb2FkaW5nXztcbiAgICAgICAgKytuZXdMb2FkcztcbiAgICAgICAgdGlsZS5sb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVRdWV1ZTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9NYXAuanMnKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbGVTb3VyY2VLZXkgVGlsZSBzb3VyY2Uga2V5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdGlsZUNlbnRlciBUaWxlIGNlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlUmVzb2x1dGlvbiBUaWxlIHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcHJpb3JpdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWxlUHJpb3JpdHkoXG4gIGZyYW1lU3RhdGUsXG4gIHRpbGUsXG4gIHRpbGVTb3VyY2VLZXksXG4gIHRpbGVDZW50ZXIsXG4gIHRpbGVSZXNvbHV0aW9uLFxuKSB7XG4gIC8vIEZpbHRlciBvdXQgdGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIHRoYW4gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCwgb3IgdGhhdFxuICAvLyBhcmUgb3V0c2lkZSB0aGUgdmlzaWJsZSBleHRlbnQuXG4gIGlmICghZnJhbWVTdGF0ZSB8fCAhKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS53YW50ZWRUaWxlcykpIHtcbiAgICByZXR1cm4gRFJPUDtcbiAgfVxuICBpZiAoIWZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV1bdGlsZS5nZXRLZXkoKV0pIHtcbiAgICByZXR1cm4gRFJPUDtcbiAgfVxuICAvLyBQcmlvcml0aXplIHRoZSBoaWdoZXN0IHpvb20gbGV2ZWwgdGlsZXMgY2xvc2VzdCB0byB0aGUgZm9jdXMuXG4gIC8vIFRpbGVzIGF0IGhpZ2hlciB6b29tIGxldmVscyBhcmUgcHJpb3JpdGl6ZWQgdXNpbmcgTWF0aC5sb2codGlsZVJlc29sdXRpb24pLlxuICAvLyBXaXRoaW4gYSB6b29tIGxldmVsLCB0aWxlcyBhcmUgcHJpb3JpdGl6ZWQgYnkgdGhlIGRpc3RhbmNlIGluIHBpeGVscyBiZXR3ZWVuXG4gIC8vIHRoZSBjZW50ZXIgb2YgdGhlIHRpbGUgYW5kIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LiAgVGhlIGZhY3RvciBvZiA2NTUzNlxuICAvLyBtZWFucyB0aGF0IHRoZSBwcmlvcml0aXphdGlvbiBzaG91bGQgYmVoYXZlIGFzIGRlc2lyZWQgZm9yIHRpbGVzIHVwIHRvXG4gIC8vIDY1NTM2ICogTWF0aC5sb2coMikgPSA0NTQyNiBwaXhlbHMgZnJvbSB0aGUgZm9jdXMuXG4gIGNvbnN0IGNlbnRlciA9IGZyYW1lU3RhdGUudmlld1N0YXRlLmNlbnRlcjtcbiAgY29uc3QgZGVsdGFYID0gdGlsZUNlbnRlclswXSAtIGNlbnRlclswXTtcbiAgY29uc3QgZGVsdGFZID0gdGlsZUNlbnRlclsxXSAtIGNlbnRlclsxXTtcbiAgcmV0dXJuIChcbiAgICA2NTUzNiAqIE1hdGgubG9nKHRpbGVSZXNvbHV0aW9uKSArXG4gICAgTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSkgLyB0aWxlUmVzb2x1dGlvblxuICApO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVSYW5nZVxuICovXG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbnRpZ3VvdXMgYmxvY2sgb2YgdGlsZXMuICBBIHRpbGUgcmFuZ2UgaXMgc3BlY2lmaWVkXG4gKiBieSBpdHMgbWluL21heCB0aWxlIGNvb3JkaW5hdGVzIGFuZCBpcyBpbmNsdXNpdmUgb2YgY29vcmRpbmF0ZXMuXG4gKi9cbmNsYXNzIFRpbGVSYW5nZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblggPSBtaW5YO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFggPSBtYXhYO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyB0aWxlIGNvb3JkaW5hdGUuXG4gICAqL1xuICBjb250YWlucyh0aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1hZKHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zLlxuICAgKi9cbiAgY29udGFpbnNUaWxlUmFuZ2UodGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWluWCA8PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICAgdGlsZVJhbmdlLm1heFggPD0gdGhpcy5tYXhYICYmXG4gICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1pblkgJiZcbiAgICAgIHRpbGVSYW5nZS5tYXhZIDw9IHRoaXMubWF4WVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBjb29yZGluYXRlLlxuICAgKi9cbiAgY29udGFpbnNYWSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA8PSB4ICYmIHggPD0gdGhpcy5tYXhYICYmIHRoaXMubWluWSA8PSB5ICYmIHkgPD0gdGhpcy5tYXhZO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRXF1YWxzLlxuICAgKi9cbiAgZXF1YWxzKHRpbGVSYW5nZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1pblggPT0gdGlsZVJhbmdlLm1pblggJiZcbiAgICAgIHRoaXMubWluWSA9PSB0aWxlUmFuZ2UubWluWSAmJlxuICAgICAgdGhpcy5tYXhYID09IHRpbGVSYW5nZS5tYXhYICYmXG4gICAgICB0aGlzLm1heFkgPT0gdGlsZVJhbmdlLm1heFlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICovXG4gIGV4dGVuZCh0aWxlUmFuZ2UpIHtcbiAgICBpZiAodGlsZVJhbmdlLm1pblggPCB0aGlzLm1pblgpIHtcbiAgICAgIHRoaXMubWluWCA9IHRpbGVSYW5nZS5taW5YO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1heFggPiB0aGlzLm1heFgpIHtcbiAgICAgIHRoaXMubWF4WCA9IHRpbGVSYW5nZS5tYXhYO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1pblkgPCB0aGlzLm1pblkpIHtcbiAgICAgIHRoaXMubWluWSA9IHRpbGVSYW5nZS5taW5ZO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1heFkgPiB0aGlzLm1heFkpIHtcbiAgICAgIHRoaXMubWF4WSA9IHRpbGVSYW5nZS5tYXhZO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodC5cbiAgICovXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gU2l6ZS5cbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhYIC0gdGhpcy5taW5YICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEludGVyc2VjdHMuXG4gICAqL1xuICBpbnRlcnNlY3RzKHRpbGVSYW5nZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1pblggPD0gdGlsZVJhbmdlLm1heFggJiZcbiAgICAgIHRoaXMubWF4WCA+PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICAgdGhpcy5taW5ZIDw9IHRpbGVSYW5nZS5tYXhZICYmXG4gICAgICB0aGlzLm1heFkgPj0gdGlsZVJhbmdlLm1pbllcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHtUaWxlUmFuZ2V9IFt0aWxlUmFuZ2VdIFRpbGVSYW5nZS5cbiAqIEByZXR1cm4ge1RpbGVSYW5nZX0gVGlsZSByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1heFgsIG1pblksIG1heFksIHRpbGVSYW5nZSkge1xuICBpZiAodGlsZVJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aWxlUmFuZ2UubWluWCA9IG1pblg7XG4gICAgdGlsZVJhbmdlLm1heFggPSBtYXhYO1xuICAgIHRpbGVSYW5nZS5taW5ZID0gbWluWTtcbiAgICB0aWxlUmFuZ2UubWF4WSA9IG1heFk7XG4gICAgcmV0dXJuIHRpbGVSYW5nZTtcbiAgfVxuICByZXR1cm4gbmV3IFRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVJhbmdlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aWxlIGxvYWRpbmcgZmFpbGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IFZpZXdQcm9wZXJ0eSBmcm9tICcuL1ZpZXdQcm9wZXJ0eS5qcyc7XG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL3RpbGVncmlkL2NvbW1vbi5qcyc7XG5pbXBvcnQge1xuICBNRVRFUlNfUEVSX1VOSVQsXG4gIGNyZWF0ZVByb2plY3Rpb24sXG4gIGRpc2FibGVDb29yZGluYXRlV2FybmluZyxcbiAgZnJvbVVzZXJDb29yZGluYXRlLFxuICBmcm9tVXNlckV4dGVudCxcbiAgZ2V0VXNlclByb2plY3Rpb24sXG4gIHRvVXNlckNvb3JkaW5hdGUsXG4gIHRvVXNlckV4dGVudCxcbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYWRkIGFzIGFkZENvb3JkaW5hdGUsXG4gIGVxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsLFxuICBlcXVhbHMsXG4gIHJvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlLFxufSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge25vbmUgYXMgY2VudGVyTm9uZSwgY3JlYXRlRXh0ZW50fSBmcm9tICcuL2NlbnRlcmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IHtjbGFtcCwgbW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTWluTWF4UmVzb2x1dGlvbixcbiAgY3JlYXRlU25hcFRvUG93ZXIsXG4gIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zLFxufSBmcm9tICcuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVNuYXBUb04sXG4gIGNyZWF0ZVNuYXBUb1plcm8sXG4gIGRpc2FibGUsXG4gIG5vbmUgYXMgcm90YXRpb25Ob25lLFxufSBmcm9tICcuL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQge2Vhc2VPdXQsIGluQW5kT3V0fSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQge1xuICBnZXRDZW50ZXIsXG4gIGdldEZvclZpZXdBbmRTaXplLFxuICBnZXRIZWlnaHQsXG4gIGdldFdpZHRoLFxuICBpc0VtcHR5LFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7ZnJvbUV4dGVudCBhcyBwb2x5Z29uRnJvbUV4dGVudH0gZnJvbSAnLi9nZW9tL1BvbHlnb24uanMnO1xuXG4vKipcbiAqIEFuIGFuaW1hdGlvbiBjb25maWd1cmF0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbc291cmNlQ2VudGVyXSBTb3VyY2UgY2VudGVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW3RhcmdldENlbnRlcl0gVGFyZ2V0IGNlbnRlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUmVzb2x1dGlvbl0gU291cmNlIHJlc29sdXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldFJlc29sdXRpb25dIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSb3RhdGlvbl0gU291cmNlIHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRSb3RhdGlvbl0gVGFyZ2V0IHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gQW5jaG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IFN0YXJ0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb21wbGV0ZSBDb21wbGV0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IGVhc2luZyBFYXNpbmcuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IGNhbGxiYWNrIENhbGxiYWNrLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RyYWludHNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jZW50ZXJjb25zdHJhaW50LmpzXCIpLlR5cGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3JvdGF0aW9uY29uc3RyYWludC5qc1wiKS5UeXBlfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpdE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGJveCB0b1xuICogZml0IHRoZSBleHRlbnQgaW50by4gRGVmYXVsdHMgdG8gdGhlIHNpemUgb2YgdGhlIG1hcCB0aGUgdmlldyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiBJZiBubyBtYXAgb3IgbXVsdGlwbGUgbWFwcyBhcmUgY29ubmVjdGVkIHRvIHRoZSB2aWV3LCBwcm92aWRlIHRoZSBkZXNpcmVkIGJveCBzaXplXG4gKiAoZS5nLiBgbWFwLmdldFNpemUoKWApLlxuICogQHByb3BlcnR5IHshQXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIChpbiBwaXhlbHMpIHRvIGJlXG4gKiBjbGVhcmVkIGluc2lkZSB0aGUgdmlldy4gVmFsdWVzIGluIHRoZSBhcnJheSBhcmUgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0XG4gKiBwYWRkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbmVhcmVzdD1mYWxzZV0gSWYgdGhlIHZpZXcgYGNvbnN0cmFpblJlc29sdXRpb25gIG9wdGlvbiBpcyBgdHJ1ZWAsXG4gKiBnZXQgdGhlIG5lYXJlc3QgZXh0ZW50IGluc3RlYWQgb2YgdGhlIGNsb3Nlc3QgdGhhdCBhY3R1YWxseSBmaXRzIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uPTBdIE1pbmltdW0gcmVzb2x1dGlvbiB0aGF0IHdlIHpvb20gdG8uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCB0aGF0IHdlIHpvb20gdG8uIElmXG4gKiBgbWluUmVzb2x1dGlvbmAgaXMgZ2l2ZW4sIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiB0byB0aGUgdGFyZ2V0IGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZCBkdXJpbmdcbiAqIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IFtjYWxsYmFja10gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgaW5cbiAqIGl0cyBmaW5hbCBwb3NpdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYHRydWVgIGlmIHRoZSBhbmltYXRpb25cbiAqIHNlcmllcyBjb21wbGV0ZWQgb24gaXRzIG93biBvciBgZmFsc2VgIGlmIGl0IHdhcyBjYW5jZWxsZWQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGluaXRpYWwgY2VudGVyIGZvclxuICogdGhlIHZpZXcuIElmIGEgdXNlciBwcm9qZWN0aW9uIGlzIG5vdCBzZXQsIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdGhlIGNlbnRlciBpc1xuICogc3BlY2lmaWVkIHdpdGggdGhlIGBwcm9qZWN0aW9uYCBvcHRpb24uIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmUgZmV0Y2hlZCBpZiB0aGlzXG4gKiBpcyBub3Qgc2V0LCBidXQgdGhlIGNlbnRlciBjYW4gYmUgc2V0IGxhdGVyIHdpdGgge0BsaW5rICNzZXRDZW50ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufG51bWJlcn0gW2NvbnN0cmFpblJvdGF0aW9uPXRydWVdIFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKiBgZmFsc2VgIG1lYW5zIG5vIGNvbnN0cmFpbnQuIGB0cnVlYCBtZWFucyBubyBjb25zdHJhaW50LCBidXQgc25hcCB0byB6ZXJvXG4gKiBuZWFyIHplcm8uIEEgbnVtYmVyIGNvbnN0cmFpbnMgdGhlIHJvdGF0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHZhbHVlcy4gRm9yXG4gKiBleGFtcGxlLCBgNGAgd2lsbCBjb25zdHJhaW4gdGhlIHJvdGF0aW9uIHRvIDAsIDkwLCAxODAsIGFuZCAyNzAgZGVncmVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZVJvdGF0aW9uPXRydWVdIEVuYWJsZSByb3RhdGlvbi5cbiAqIElmIGBmYWxzZWAsIGEgcm90YXRpb24gY29uc3RyYWludCB0aGF0IGFsd2F5cyBzZXRzIHRoZSByb3RhdGlvbiB0byB6ZXJvIGlzXG4gKiB1c2VkLiBUaGUgYGNvbnN0cmFpblJvdGF0aW9uYCBvcHRpb24gaGFzIG5vIGVmZmVjdCBpZiBgZW5hYmxlUm90YXRpb25gIGlzXG4gKiBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBleHRlbnQgdGhhdCBjb25zdHJhaW5zIHRoZVxuICogdmlldywgaW4gb3RoZXIgd29yZHMsIG5vdGhpbmcgb3V0c2lkZSBvZiB0aGlzIGV4dGVudCBjYW4gYmUgdmlzaWJsZSBvbiB0aGUgbWFwLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluT25seUNlbnRlcj1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIG9ubHkgYXBwbHkgdG8gdGhlIHZpZXcgY2VudGVyIGFuZCBub3QgdGhlIHdob2xlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Ntb290aEV4dGVudENvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIGJlIGFwcGxpZWQgc21vb3RobHksIGkuZS4gYWxsb3cgdGhlIHZpZXcgdG8gZ28gc2xpZ2h0bHkgb3V0c2lkZVxuICogb2YgdGhlIGdpdmVuIGBleHRlbnRgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1pblJlc29sdXRpb25gIChvclxuICogYG1heFpvb21gKSBhbmQgYHpvb21GYWN0b3JgLiBJZiB1bnNwZWNpZmllZCBpdCBpcyBjYWxjdWxhdGVkIGluIHN1Y2ggYSB3YXlcbiAqIHRoYXQgdGhlIHByb2plY3Rpb24ncyB2YWxpZGl0eSBleHRlbnQgZml0cyBpbiBhIDI1NngyNTYgcHggdGlsZS4gSWYgdGhlXG4gKiBwcm9qZWN0aW9uIGlzIFNwaGVyaWNhbCBNZXJjYXRvciAodGhlIGRlZmF1bHQpIHRoZW4gYG1heFJlc29sdXRpb25gIGRlZmF1bHRzXG4gKiB0byBgNDAwNzUwMTYuNjg1NTc4NDkgLyAyNTYgPSAxNTY1NDMuMDMzOTI4MDQwOTdgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiAgSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtYXhSZXNvbHV0aW9uYCAob3JcbiAqIGBtaW5ab29tYCkgYW5kIGB6b29tRmFjdG9yYC4gIElmIHVuc3BlY2lmaWVkIGl0IGlzIGNhbGN1bGF0ZWQgYXNzdW1pbmcgMjlcbiAqIHpvb20gbGV2ZWxzICh3aXRoIGEgZmFjdG9yIG9mIDIpLiBJZiB0aGUgcHJvamVjdGlvbiBpcyBTcGhlcmljYWwgTWVyY2F0b3JcbiAqICh0aGUgZGVmYXVsdCkgdGhlbiBgbWluUmVzb2x1dGlvbmAgZGVmYXVsdHMgdG9cbiAqIGA0MDA3NTAxNi42ODU1Nzg0OSAvIDI1NiAvIE1hdGgucG93KDIsIDI4KSA9IDAuMDAwNTgzMTY4MjQ1NTgzOTI1M2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MjhdIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWluWm9vbWAgKG9yXG4gKiBgbWF4UmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1pblJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1heFpvb21gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWF4Wm9vbWAgKG9yXG4gKiBgbWluUmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1heFJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1pblpvb21gLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlXb3JsZD1mYWxzZV0gSWYgYGZhbHNlYCB0aGUgdmlldyBpcyBjb25zdHJhaW5lZCBzb1xuICogb25seSBvbmUgd29ybGQgaXMgdmlzaWJsZSwgYW5kIHlvdSBjYW5ub3QgcGFuIG9mZiB0aGUgZWRnZS4gIElmIGB0cnVlYCB0aGUgbWFwXG4gKiBtYXkgc2hvdyBtdWx0aXBsZSB3b3JsZHMgYXQgbG93IHpvb20gbGV2ZWxzLiAgT25seSB1c2VkIGlmIHRoZSBgcHJvamVjdGlvbmAgaXNcbiAqIGdsb2JhbC4gIE5vdGUgdGhhdCBpZiBgZXh0ZW50YCBpcyBhbHNvIHByb3ZpZGVkIGl0IGlzIGdpdmVuIHByZWNlZGVuY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGFsd2F5c1xuICogYW5pbWF0ZSB0byB0aGUgY2xvc2VzdCB6b29tIGxldmVsIGFmdGVyIGFuIGludGVyYWN0aW9uOyBmYWxzZSBtZWFuc1xuICogaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbGxvd2VkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIHJlc29sdXRpb25cbiAqIG1pbi9tYXggdmFsdWVzIHdpbGwgYmUgYXBwbGllZCBzbW9vdGhseSwgaS4gZS4gYWxsb3cgdGhlIHZpZXcgdG8gZXhjZWVkIHNsaWdodGx5XG4gKiB0aGUgZ2l2ZW4gcmVzb2x1dGlvbiBvciB6b29tIGJvdW5kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dGdWxsRXh0ZW50PWZhbHNlXSBBbGxvdyB0aGUgdmlldyB0byBiZSB6b29tZWQgb3V0IHRvXG4gKiBzaG93IHRoZSBmdWxsIGNvbmZpZ3VyZWQgZXh0ZW50LiBCeSBkZWZhdWx0LCB3aGVuIGEgdmlldyBpcyBjb25maWd1cmVkIHdpdGggYW5cbiAqIGV4dGVudCwgdXNlcnMgd2lsbCBub3QgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGUgdmlld3BvcnQgZXhjZWVkcyB0aGUgZXh0ZW50IGluXG4gKiBlaXRoZXIgZGltZW5zaW9uLiBUaGlzIG1lYW5zIHRoZSBmdWxsIGV4dGVudCBtYXkgbm90IGJlIHZpc2libGUgaWYgdGhlIHZpZXdwb3J0XG4gKiBpcyB0YWxsZXIgb3Igd2lkZXIgdGhhbiB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudC4gSWZcbiAqIHNob3dGdWxsRXh0ZW50IGlzIHRydWUsIHRoZSB1c2VyIHdpbGwgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGF0IHRoZSB2aWV3cG9ydFxuICogZXhjZWVkcyB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudCwgYnV0IG5vdCBib3RoLCBhbGxvd2luZyB0aGVcbiAqIGZ1bGwgZXh0ZW50IHRvIGJlIHNob3duLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXSBUaGVcbiAqIHByb2plY3Rpb24uIFRoZSBkZWZhdWx0IGlzIFNwaGVyaWNhbCBNZXJjYXRvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzb2x1dGlvbl0gVGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuIFRoZVxuICogdW5pdHMgYXJlIGBwcm9qZWN0aW9uYCB1bml0cyBwZXIgcGl4ZWwgKGUuZy4gbWV0ZXJzIHBlciBwaXhlbCkuIEFuXG4gKiBhbHRlcm5hdGl2ZSB0byBzZXR0aW5nIHRoaXMgaXMgdG8gc2V0IGB6b29tYC4gTGF5ZXIgc291cmNlcyB3aWxsIG5vdCBiZVxuICogZmV0Y2hlZCBpZiBuZWl0aGVyIHRoaXMgbm9yIGB6b29tYCBhcmUgZGVmaW5lZCwgYnV0IHRoZXkgY2FuIGJlIHNldCBsYXRlclxuICogd2l0aCB7QGxpbmsgI3NldFpvb219IG9yIHtAbGluayAjc2V0UmVzb2x1dGlvbn0uXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9uc10gUmVzb2x1dGlvbnMgdGhhdCBkZXRlcm1pbmUgdGhlXG4gKiB6b29tIGxldmVscyBpZiBzcGVjaWZpZWQuIFRoZSBpbmRleCBpbiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gdGhlIHpvb20gbGV2ZWwsXG4gKiB0aGVyZWZvcmUgdGhlIHJlc29sdXRpb24gdmFsdWVzIGhhdmUgdG8gYmUgaW4gZGVzY2VuZGluZyBvcmRlci4gSXQgYWxzbyBjb25zdHJhaW5zXG4gKiB0aGUgcmVzb2x1dGlvbiBieSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgc2V0IHRoZSBgbWF4UmVzb2x1dGlvbmAsXG4gKiBgbWluUmVzb2x1dGlvbmAsIGBtaW5ab29tYCwgYG1heFpvb21gLCBhbmQgYHpvb21GYWN0b3JgIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSBpbml0aWFsIHJvdGF0aW9uIGZvciB0aGUgdmlldyBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCAwIG1lYW5zIE5vcnRoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gT25seSB1c2VkIGlmIGByZXNvbHV0aW9uYCBpcyBub3QgZGVmaW5lZC4gWm9vbVxuICogbGV2ZWwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21GYWN0b3I9Ml0gVGhlIHpvb20gZmFjdG9yIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5PG51bWJlcj59IFtwYWRkaW5nPVswLCAwLCAwLCAwXV0gUGFkZGluZyAoaW4gY3NzIHBpeGVscykuXG4gKiBJZiB0aGUgbWFwIHZpZXdwb3J0IGlzIHBhcnRpYWxseSBjb3ZlcmVkIHdpdGggb3RoZXIgY29udGVudCAob3ZlcmxheXMpIGFsb25nXG4gKiBpdHMgZWRnZXMsIHRoaXMgc2V0dGluZyBhbGxvd3MgdG8gc2hpZnQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgYXdheSBmcm9tXG4gKiB0aGF0IGNvbnRlbnQuIFRoZSBvcmRlciBvZiB0aGUgdmFsdWVzIGlzIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjZW50ZXJdIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZlxuICogdGhlIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGFuaW1hdGlvbi4gVGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHJlc29sdXRpb25gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kXG4gKiBvZiB0aGUgYW5pbWF0aW9uLiAgSWYgYHpvb21gIGlzIGFsc28gcHJvdmlkZWQsIHRoaXMgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb25dIFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mXG4gKiB0aGUgYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gT3B0aW9uYWwgYW5jaG9yIHRvIHJlbWFpbiBmaXhlZFxuICogZHVyaW5nIGEgcm90YXRpb24gb3IgcmVzb2x1dGlvbiBhbmltYXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMDBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZFxuICogZHVyaW5nIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoaW4gdmlldyBwcm9qZWN0aW9uIGNvb3JkaW5hdGVzKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtuZXh0Q2VudGVyXSBUaGUgbmV4dCBjZW50ZXIgZHVyaW5nIGFuIGFuaW1hdGlvbiBzZXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW25leHRSZXNvbHV0aW9uXSBUaGUgbmV4dCByZXNvbHV0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtuZXh0Um90YXRpb25dIFRoZSBuZXh0IHJvdGF0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb20gWm9vbS5cbiAqL1xuXG4vKipcbiAqIExpa2Uge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LCBidXQganVzdCBgdmlld1N0YXRlYCBhbmQgYGV4dGVudGAuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50XG4gKiBAcHJvcGVydHkge1N0YXRlfSB2aWV3U3RhdGUgVmlldyBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50IChpbiB1c2VyIHByb2plY3Rpb24gY29vcmRpbmF0ZXMpLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlPn0gW2xheWVyU3RhdGVzQXJyYXldIExheWVyIHN0YXRlcy5cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWluIHpvb20gbGV2ZWwgZm9yIHRoZSBtYXAgdmlldy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IERFRkFVTFRfTUlOX1pPT00gPSAwO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmNlbnRlcid8J2NoYW5nZTpyZXNvbHV0aW9uJ3wnY2hhbmdlOnJvdGF0aW9uJ30gVmlld09iamVjdEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPFZpZXdPYmplY3RFdmVudFR5cGVzLCBpbXBvcnQoXCIuL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfFZpZXdPYmplY3RFdmVudFR5cGVzLCBSZXR1cm4+fSBWaWV3T25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgVmlldyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbXBsZSAyRCB2aWV3IG9mIHRoZSBtYXAuXG4gKlxuICogVGhpcyBpcyB0aGUgb2JqZWN0IHRvIGFjdCB1cG9uIHRvIGNoYW5nZSB0aGUgY2VudGVyLCByZXNvbHV0aW9uLFxuICogYW5kIHJvdGF0aW9uIG9mIHRoZSBtYXAuXG4gKlxuICogQSBWaWV3IGhhcyBhIGBwcm9qZWN0aW9uYC4gVGhlIHByb2plY3Rpb24gZGV0ZXJtaW5lcyB0aGVcbiAqIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjZW50ZXIsIGFuZCBpdHMgdW5pdHMgZGV0ZXJtaW5lIHRoZSB1bml0cyBvZiB0aGVcbiAqIHJlc29sdXRpb24gKHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsKS4gVGhlIGRlZmF1bHQgcHJvamVjdGlvbiBpc1xuICogV2ViIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICpcbiAqICMjIyBUaGUgdmlldyBzdGF0ZXNcbiAqXG4gKiBBIFZpZXcgaXMgZGV0ZXJtaW5lZCBieSB0aHJlZSBzdGF0ZXM6IGBjZW50ZXJgLCBgcmVzb2x1dGlvbmAsXG4gKiBhbmQgYHJvdGF0aW9uYC4gRWFjaCBzdGF0ZSBoYXMgYSBjb3JyZXNwb25kaW5nIGdldHRlciBhbmQgc2V0dGVyLCBlLmcuXG4gKiBgZ2V0Q2VudGVyYCBhbmQgYHNldENlbnRlcmAgZm9yIHRoZSBgY2VudGVyYCBzdGF0ZS5cbiAqXG4gKiBUaGUgYHpvb21gIHN0YXRlIGlzIGFjdHVhbGx5IG5vdCBzYXZlZCBvbiB0aGUgdmlldzogYWxsIGNvbXB1dGF0aW9uc1xuICogaW50ZXJuYWxseSB1c2UgdGhlIGByZXNvbHV0aW9uYCBzdGF0ZS4gU3RpbGwsIHRoZSBgc2V0Wm9vbWAgYW5kIGBnZXRab29tYFxuICogbWV0aG9kcyBhcmUgYXZhaWxhYmxlLCBhcyB3ZWxsIGFzIGBnZXRSZXNvbHV0aW9uRm9yWm9vbWAgYW5kXG4gKiBgZ2V0Wm9vbUZvclJlc29sdXRpb25gIHRvIHN3aXRjaCBmcm9tIG9uZSBzeXN0ZW0gdG8gdGhlIG90aGVyLlxuICpcbiAqICMjIyBUaGUgY29uc3RyYWludHNcbiAqXG4gKiBgc2V0Q2VudGVyYCwgYHNldFJlc29sdXRpb25gIGFuZCBgc2V0Um90YXRpb25gIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGVcbiAqIHN0YXRlcyBvZiB0aGUgdmlldywgYnV0IGFueSBjb25zdHJhaW50IGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdpbGxcbiAqIGJlIGFwcGxpZWQgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBBIFZpZXcgb2JqZWN0IGNhbiBoYXZlIGEgKnJlc29sdXRpb24gY29uc3RyYWludCosIGEgKnJvdGF0aW9uIGNvbnN0cmFpbnQqXG4gKiBhbmQgYSAqY2VudGVyIGNvbnN0cmFpbnQqLlxuICpcbiAqIFRoZSAqcmVzb2x1dGlvbiBjb25zdHJhaW50KiB0eXBpY2FsbHkgcmVzdHJpY3RzIG1pbi9tYXggdmFsdWVzIGFuZFxuICogc25hcHMgdG8gc3BlY2lmaWMgcmVzb2x1dGlvbnMuIEl0IGlzIGRldGVybWluZWQgYnkgdGhlIGZvbGxvd2luZ1xuICogb3B0aW9uczogYHJlc29sdXRpb25zYCwgYG1heFJlc29sdXRpb25gLCBgbWF4Wm9vbWAgYW5kIGB6b29tRmFjdG9yYC5cbiAqIElmIGByZXNvbHV0aW9uc2AgaXMgc2V0LCB0aGUgb3RoZXIgdGhyZWUgb3B0aW9ucyBhcmUgaWdub3JlZC4gU2VlXG4gKiBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG9wdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIHZpZXdcbiAqIG9ubHkgaGFzIGEgbWluL21heCByZXN0cmljdGlvbiBhbmQgYWxsb3cgaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIHdoZW5cbiAqIHBpbmNoLXpvb21pbmcgZm9yIGV4YW1wbGUuXG4gKlxuICogVGhlICpyb3RhdGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyBhbmdsZXMuIEl0IGlzIGRldGVybWluZWRcbiAqIGJ5IHRoZSBmb2xsb3dpbmcgb3B0aW9uczogYGVuYWJsZVJvdGF0aW9uYCBhbmQgYGNvbnN0cmFpblJvdGF0aW9uYC5cbiAqIEJ5IGRlZmF1bHQgcm90YXRpb24gaXMgYWxsb3dlZCBhbmQgaXRzIHZhbHVlIGlzIHNuYXBwZWQgdG8gemVybyB3aGVuIGFwcHJvYWNoaW5nIHRoZVxuICogaG9yaXpvbnRhbC5cbiAqXG4gKiBUaGUgKmNlbnRlciBjb25zdHJhaW50KiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgZXh0ZW50YCBvcHRpb24uIEJ5XG4gKiBkZWZhdWx0IHRoZSB2aWV3IGNlbnRlciBpcyBub3QgY29uc3RyYWluZWQgYXQgYWxsLlxuICpcbiAqICMjIyBDaGFuZ2luZyB0aGUgdmlldyBzdGF0ZVxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgYHNldFpvb21gLCBgc2V0UmVzb2x1dGlvbmAsIGBzZXRDZW50ZXJgIGFuZFxuICogYHNldFJvdGF0aW9uYCBhcmUgc3ViamVjdCB0byB0aGUgYWJvdmUgbWVudGlvbmVkIGNvbnN0cmFpbnRzLiBBcyBzdWNoLCBpdFxuICogbWF5IHNvbWV0aW1lcyBub3QgYmUgcG9zc2libGUgdG8ga25vdyBpbiBhZHZhbmNlIHRoZSByZXN1bHRpbmcgc3RhdGUgb2YgdGhlXG4gKiBWaWV3LiBGb3IgZXhhbXBsZSwgY2FsbGluZyBgc2V0UmVzb2x1dGlvbigxMClgIGRvZXMgbm90IGd1YXJhbnRlZSB0aGF0XG4gKiBgZ2V0UmVzb2x1dGlvbigpYCB3aWxsIHJldHVybiBgMTBgLlxuICpcbiAqIEEgY29uc2VxdWVuY2Ugb2YgdGhpcyBpcyB0aGF0LCB3aGVuIGFwcGx5aW5nIGEgZGVsdGEgb24gdGhlIHZpZXcgc3RhdGUsIG9uZVxuICogc2hvdWxkIHVzZSBgYWRqdXN0Q2VudGVyYCwgYGFkanVzdFJvdGF0aW9uYCwgYGFkanVzdFpvb21gIGFuZCBgYWRqdXN0UmVzb2x1dGlvbmBcbiAqIHJhdGhlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIHNldHRlcnMuIFRoaXMgd2lsbCBsZXQgdmlldyBkbyBpdHMgaW50ZXJuYWxcbiAqIGNvbXB1dGF0aW9ucy4gQmVzaWRlcywgdGhlIGBhZGp1c3QqYCBtZXRob2RzIGFsc28gdGFrZSBhbiBgYW5jaG9yYFxuICogYXJndW1lbnQgd2hpY2ggYWxsb3dzIHNwZWNpZnlpbmcgYW4gb3JpZ2luIGZvciB0aGUgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogIyMjIEludGVyYWN0aW5nIHdpdGggdGhlIHZpZXdcbiAqXG4gKiBWaWV3IGNvbnN0cmFpbnRzIGFyZSB1c3VhbGx5IG9ubHkgYXBwbGllZCB3aGVuIHRoZSB2aWV3IGlzICphdCByZXN0KiwgbWVhbmluZyB0aGF0XG4gKiBubyBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgb25nb2luZy4gQXMgc3VjaCwgaWYgdGhlIHVzZXIgcHV0cyB0aGUgdmlldyBpbiBhXG4gKiBzdGF0ZSB0aGF0IGlzIG5vdCBlcXVpdmFsZW50IHRvIGEgY29uc3RyYWluZWQgb25lIChlLmcuIHJvdGF0aW5nIHRoZSB2aWV3IHdoZW5cbiAqIHRoZSBzbmFwIGFuZ2xlIGlzIDApLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgYXQgdGhlIGludGVyYWN0aW9uIGVuZCB0b1xuICogcHV0IGJhY2sgdGhlIHZpZXcgdG8gYSBzdGFibGUgc3RhdGU7XG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBWaWV3IGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBbb3B0aW9uc10gVmlldyBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Vmlld09uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuaGludHNfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8QW5pbWF0aW9uPj59XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy52aWV3cG9ydFNpemVfID0gWzEwMCwgMTAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMubmV4dENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0aW9ucy5wcm9qZWN0aW9uKSB7XG4gICAgICBkaXNhYmxlQ29vcmRpbmF0ZVdhcm5pbmcoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICBvcHRpb25zLmNlbnRlciA9IGZyb21Vc2VyQ29vcmRpbmF0ZShvcHRpb25zLmNlbnRlciwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4dGVudCkge1xuICAgICAgb3B0aW9ucy5leHRlbnQgPSBmcm9tVXNlckV4dGVudChvcHRpb25zLmV4dGVudCwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAgICovXG4gIGFwcGx5T3B0aW9uc18ob3B0aW9ucykge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBWaWV3UHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2tleV07XG4gICAgfVxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0cnVlKTtcblxuICAgIGNvbnN0IHJlc29sdXRpb25Db25zdHJhaW50SW5mbyA9IGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWF4UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblJlc29sdXRpb25fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby56b29tRmFjdG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wYWRkaW5nXyA9IG9wdGlvbnMucGFkZGluZztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblpvb21fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblpvb207XG5cbiAgICBjb25zdCBjZW50ZXJDb25zdHJhaW50ID0gY3JlYXRlQ2VudGVyQ29uc3RyYWludChvcHRpb25zKTtcbiAgICBjb25zdCByZXNvbHV0aW9uQ29uc3RyYWludCA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5jb25zdHJhaW50O1xuICAgIGNvbnN0IHJvdGF0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVJvdGF0aW9uQ29uc3RyYWludChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NvbnN0cmFpbnRzfVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHNfID0ge1xuICAgICAgY2VudGVyOiBjZW50ZXJDb25zdHJhaW50LFxuICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbkNvbnN0cmFpbnQsXG4gICAgICByb3RhdGlvbjogcm90YXRpb25Db25zdHJhaW50LFxuICAgIH07XG5cbiAgICB0aGlzLnNldFJvdGF0aW9uKG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwKTtcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFxuICAgICAgb3B0aW9ucy5jZW50ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2VudGVyIDogbnVsbCxcbiAgICApO1xuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKG9wdGlvbnMucmVzb2x1dGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRab29tKG9wdGlvbnMuem9vbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhZGRpbmcgKGluIGNzcyBwaXhlbHMpLlxuICAgKiBJZiB0aGUgbWFwIHZpZXdwb3J0IGlzIHBhcnRpYWxseSBjb3ZlcmVkIHdpdGggb3RoZXIgY29udGVudCAob3ZlcmxheXMpIGFsb25nXG4gICAqIGl0cyBlZGdlcywgdGhpcyBzZXR0aW5nIGFsbG93cyB0byBzaGlmdCB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhd2F5IGZyb20gdGhhdFxuICAgKiBjb250ZW50LiBUaGUgb3JkZXIgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgaXMgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LlxuICAgKiBUaGUgZGVmYXVsdCBpcyBubyBwYWRkaW5nLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIGBbMCwgMCwgMCwgMF1gLlxuICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAqIEBhcGlcbiAgICovXG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBhZGRpbmdfO1xuICB9XG4gIHNldCBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBsZXQgb2xkUGFkZGluZyA9IHRoaXMucGFkZGluZ187XG4gICAgdGhpcy5wYWRkaW5nXyA9IHBhZGRpbmc7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgIGNvbnN0IG5ld1BhZGRpbmcgPSBwYWRkaW5nIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIG9sZFBhZGRpbmcgPSBvbGRQYWRkaW5nIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICAgIGNvbnN0IG9mZnNldFggPVxuICAgICAgICAocmVzb2x1dGlvbiAvIDIpICpcbiAgICAgICAgKG5ld1BhZGRpbmdbM10gLSBvbGRQYWRkaW5nWzNdICsgb2xkUGFkZGluZ1sxXSAtIG5ld1BhZGRpbmdbMV0pO1xuICAgICAgY29uc3Qgb2Zmc2V0WSA9XG4gICAgICAgIChyZXNvbHV0aW9uIC8gMikgKlxuICAgICAgICAobmV3UGFkZGluZ1swXSAtIG9sZFBhZGRpbmdbMF0gKyBvbGRQYWRkaW5nWzJdIC0gbmV3UGFkZGluZ1syXSk7XG4gICAgICB0aGlzLnNldENlbnRlckludGVybmFsKFtjZW50ZXJbMF0gKyBvZmZzZXRYLCBjZW50ZXJbMV0gLSBvZmZzZXRZXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIHZpZXcgb3B0aW9ucyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdmlldy4gIFRoZVxuICAgKiBjdXJyZW50IHJlc29sdXRpb24gKG9yIHpvb20pLCBjZW50ZXIsIGFuZCByb3RhdGlvbiBhcmUgYXBwbGllZCB0byBhbnkgc3RvcmVkXG4gICAqIG9wdGlvbnMuICBUaGUgcHJvdmlkZWQgb3B0aW9ucyBjYW4gYmUgdXNlZCB0byBhcHBseSBuZXcgbWluL21heCB6b29tIG9yXG4gICAqIHJlc29sdXRpb24gbGltaXRzLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBuZXdPcHRpb25zIE5ldyBvcHRpb25zIHRvIGJlIGFwcGxpZWQuXG4gICAqIEByZXR1cm4ge1ZpZXdPcHRpb25zfSBOZXcgb3B0aW9ucyB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgdmlldyBzdGF0ZS5cbiAgICovXG4gIGdldFVwZGF0ZWRPcHRpb25zXyhuZXdPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuXG4gICAgLy8gcHJlc2VydmUgcmVzb2x1dGlvbiAob3Igem9vbSlcbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnpvb20gPSB0aGlzLmdldFpvb20oKTtcbiAgICB9XG5cbiAgICAvLyBwcmVzZXJ2ZSBjZW50ZXJcbiAgICBvcHRpb25zLmNlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcblxuICAgIC8vIHByZXNlcnZlIHJvdGF0aW9uXG4gICAgb3B0aW9ucy5yb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRlIHRoZSB2aWV3LiAgVGhlIHZpZXcncyBjZW50ZXIsIHpvb20gKG9yIHJlc29sdXRpb24pLCBhbmQgcm90YXRpb25cbiAgICogY2FuIGJlIGFuaW1hdGVkIGZvciBzbW9vdGggdHJhbnNpdGlvbnMgYmV0d2VlbiB2aWV3IHN0YXRlcy4gIEZvciBleGFtcGxlLFxuICAgKiB0byBhbmltYXRlIHRoZSB2aWV3IHRvIGEgbmV3IHpvb20gbGV2ZWw6XG4gICAqXG4gICAqICAgICB2aWV3LmFuaW1hdGUoe3pvb206IHZpZXcuZ2V0Wm9vbSgpICsgMX0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgYW5pbWF0aW9uIGxhc3RzIG9uZSBzZWNvbmQgYW5kIHVzZXMgaW4tYW5kLW91dCBlYXNpbmcuICBZb3VcbiAgICogY2FuIGN1c3RvbWl6ZSB0aGlzIGJlaGF2aW9yIGJ5IGluY2x1ZGluZyBgZHVyYXRpb25gIChpbiBtaWxsaXNlY29uZHMpIGFuZFxuICAgKiBgZWFzaW5nYCBvcHRpb25zIChzZWUge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmd9KS5cbiAgICpcbiAgICogVG8gY2hhaW4gdG9nZXRoZXIgbXVsdGlwbGUgYW5pbWF0aW9ucywgY2FsbCB0aGUgbWV0aG9kIHdpdGggbXVsdGlwbGVcbiAgICogYW5pbWF0aW9uIG9iamVjdHMuICBGb3IgZXhhbXBsZSwgdG8gZmlyc3Qgem9vbSBhbmQgdGhlbiBwYW46XG4gICAqXG4gICAqICAgICB2aWV3LmFuaW1hdGUoe3pvb206IDEwfSwge2NlbnRlcjogWzAsIDBdfSk7XG4gICAqXG4gICAqIElmIHlvdSBwcm92aWRlIGEgZnVuY3Rpb24gYXMgdGhlIGxhc3QgYXJndW1lbnQgdG8gdGhlIGFuaW1hdGUgbWV0aG9kLCBpdFxuICAgKiB3aWxsIGdldCBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24gc2VyaWVzLiAgVGhlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICogY2FsbGVkIHdpdGggYHRydWVgIGlmIHRoZSBhbmltYXRpb24gc2VyaWVzIGNvbXBsZXRlZCBvbiBpdHMgb3duIG9yIGBmYWxzZWBcbiAgICogaWYgaXQgd2FzIGNhbmNlbGxlZC5cbiAgICpcbiAgICogQW5pbWF0aW9ucyBhcmUgY2FuY2VsbGVkIGJ5IHVzZXIgaW50ZXJhY3Rpb25zIChlLmcuIGRyYWdnaW5nIHRoZSBtYXApIG9yIGJ5XG4gICAqIGNhbGxpbmcgYHZpZXcuc2V0Q2VudGVyKClgLCBgdmlldy5zZXRSZXNvbHV0aW9uKClgLCBvciBgdmlldy5zZXRSb3RhdGlvbigpYFxuICAgKiAob3IgYW5vdGhlciBtZXRob2QgdGhhdCBjYWxscyBvbmUgb2YgdGhlc2UpLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihBbmltYXRpb25PcHRpb25zfGZ1bmN0aW9uKGJvb2xlYW4pOiB2b2lkKX0gdmFyX2FyZ3MgQW5pbWF0aW9uXG4gICAqICAgICBvcHRpb25zLiAgTXVsdGlwbGUgYW5pbWF0aW9ucyBjYW4gYmUgcnVuIGluIHNlcmllcyBieSBwYXNzaW5nIG11bHRpcGxlXG4gICAqICAgICBvcHRpb25zIG9iamVjdHMuICBUbyBydW4gbXVsdGlwbGUgYW5pbWF0aW9ucyBpbiBwYXJhbGxlbCwgY2FsbCB0aGUgbWV0aG9kXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcy4gIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCBhcyBhIGZpbmFsXG4gICAqICAgICBhcmd1bWVudC4gIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICogICAgIHRoZSBhbmltYXRpb24gY29tcGxldGVkIHdpdGhvdXQgYmVpbmcgY2FuY2VsbGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBhbmltYXRlKHZhcl9hcmdzKSB7XG4gICAgaWYgKHRoaXMuaXNEZWYoKSAmJiAhdGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoMCk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChvcHRpb25zLmNlbnRlcikge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuY2VudGVyID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgICAgIG9wdGlvbnMuY2VudGVyLFxuICAgICAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYW5jaG9yKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5hbmNob3IgPSBmcm9tVXNlckNvb3JkaW5hdGUoXG4gICAgICAgICAgb3B0aW9ucy5hbmNob3IsXG4gICAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gb3B0aW9ucztcbiAgICB9XG4gICAgdGhpcy5hbmltYXRlSW50ZXJuYWwuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oQW5pbWF0aW9uT3B0aW9uc3xmdW5jdGlvbihib29sZWFuKTogdm9pZCl9IHZhcl9hcmdzIEFuaW1hdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYW5pbWF0ZUludGVybmFsKHZhcl9hcmdzKSB7XG4gICAgbGV0IGFuaW1hdGlvbkNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgaWYgKFxuICAgICAgYW5pbWF0aW9uQ291bnQgPiAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV0gPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV07XG4gICAgICAtLWFuaW1hdGlvbkNvdW50O1xuICAgIH1cblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGFuaW1hdGlvbkNvdW50ICYmICF0aGlzLmlzRGVmKCk7ICsraSkge1xuICAgICAgLy8gaWYgdmlldyBwcm9wZXJ0aWVzIGFyZSBub3QgeWV0IHNldCwgc2hvcnRjdXQgdG8gdGhlIGZpbmFsIHN0YXRlXG4gICAgICBjb25zdCBzdGF0ZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChzdGF0ZS5jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChzdGF0ZS5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFpvb20oc3RhdGUuem9vbSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnJlc29sdXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKHN0YXRlLnJlc29sdXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihzdGF0ZS5yb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBhbmltYXRpb25Db3VudCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLnRhcmdldENlbnRlcl8uc2xpY2UoKTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0UmVzb2x1dGlvbl87XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy50YXJnZXRSb3RhdGlvbl87XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgZm9yICg7IGkgPCBhbmltYXRpb25Db3VudDsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtBbmltYXRpb25PcHRpb25zfSAqLyAoYXJndW1lbnRzW2ldKTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgYW5jaG9yOiBvcHRpb25zLmFuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nIHx8IGluQW5kT3V0LFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZUNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldENlbnRlciA9IG9wdGlvbnMuY2VudGVyLnNsaWNlKCk7XG4gICAgICAgIGNlbnRlciA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbShvcHRpb25zLnpvb20pO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIGNvbnN0IGRlbHRhID1cbiAgICAgICAgICBtb2R1bG8ob3B0aW9ucy5yb3RhdGlvbiAtIHJvdGF0aW9uICsgTWF0aC5QSSwgMiAqIE1hdGguUEkpIC0gTWF0aC5QSTtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uID0gcm90YXRpb24gKyBkZWx0YTtcbiAgICAgICAgcm90YXRpb24gPSBhbmltYXRpb24udGFyZ2V0Um90YXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBhIG5vLW9wXG4gICAgICBpZiAoaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgYW5pbWF0aW9uLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gd2Ugc3RpbGwgcHVzaCBpdCBvbnRvIHRoZSBzZXJpZXMgZm9yIGNhbGxiYWNrIGhhbmRsaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCArPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICB9XG4gICAgICBzZXJpZXMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnNfLnB1c2goc2VyaWVzKTtcbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAxKTtcbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB2aWV3IGlzIGJlaW5nIGFuaW1hdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlldyBpcyBiZWluZyBhbmltYXRlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1tWaWV3SGludC5BTklNQVRJTkddID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlldywgc3VjaCBhcyBwYW5uaW5nIG9yIHpvb21pbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aWV3IGlzIGJlaW5nIGludGVyYWN0ZWQgd2l0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJhY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW1ZpZXdIaW50LklOVEVSQUNUSU5HXSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBvbmdvaW5nIGFuaW1hdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNhbmNlbEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LkFOSU1BVElORywgLXRoaXMuaGludHNfW1ZpZXdIaW50LkFOSU1BVElOR10pO1xuICAgIGxldCBhbmNob3I7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLmFuaW1hdGlvbnNfW2ldO1xuICAgICAgaWYgKHNlcmllc1swXS5jYWxsYmFjaykge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFjayhzZXJpZXNbMF0uY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHNlcmllcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gc2VyaWVzW2pdO1xuICAgICAgICAgIGlmICghYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBhbmltYXRpb24uYW5jaG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSBhbmNob3I7XG4gICAgdGhpcy5uZXh0Q2VudGVyXyA9IG51bGw7XG4gICAgdGhpcy5uZXh0UmVzb2x1dGlvbl8gPSBOYU47XG4gICAgdGhpcy5uZXh0Um90YXRpb25fID0gTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbGwgYW5pbWF0aW9ucy5cbiAgICovXG4gIHVwZGF0ZUFuaW1hdGlvbnNfKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVBbmltYXRpb25LZXlfKTtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IG1vcmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5hbmltYXRpb25zX1tpXTtcbiAgICAgIGxldCBzZXJpZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBzZXJpZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBzZXJpZXNbal07XG4gICAgICAgIGlmIChhbmltYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGFwc2VkID0gbm93IC0gYW5pbWF0aW9uLnN0YXJ0O1xuICAgICAgICBsZXQgZnJhY3Rpb24gPVxuICAgICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA+IDAgPyBlbGFwc2VkIC8gYW5pbWF0aW9uLmR1cmF0aW9uIDogMTtcbiAgICAgICAgaWYgKGZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICBhbmltYXRpb24uY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGZyYWN0aW9uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gYW5pbWF0aW9uLmVhc2luZyhmcmFjdGlvbik7XG4gICAgICAgIGlmIChhbmltYXRpb24uc291cmNlQ2VudGVyKSB7XG4gICAgICAgICAgY29uc3QgeDAgPSBhbmltYXRpb24uc291cmNlQ2VudGVyWzBdO1xuICAgICAgICAgIGNvbnN0IHkwID0gYW5pbWF0aW9uLnNvdXJjZUNlbnRlclsxXTtcbiAgICAgICAgICBjb25zdCB4MSA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXJbMF07XG4gICAgICAgICAgY29uc3QgeTEgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyWzFdO1xuICAgICAgICAgIHRoaXMubmV4dENlbnRlcl8gPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyO1xuICAgICAgICAgIGNvbnN0IHggPSB4MCArIHByb2dyZXNzICogKHgxIC0geDApO1xuICAgICAgICAgIGNvbnN0IHkgPSB5MCArIHByb2dyZXNzICogKHkxIC0geTApO1xuICAgICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IFt4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gJiYgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICAgICAgICBjb25zdCByZXNvbHV0aW9uID1cbiAgICAgICAgICAgIHByb2dyZXNzID09PSAxXG4gICAgICAgICAgICAgID8gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb25cbiAgICAgICAgICAgICAgOiBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiArXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgKlxuICAgICAgICAgICAgICAgICAgKGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uIC0gYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKFxuICAgICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IHRoaXMuY2FsY3VsYXRlQ2VudGVyWm9vbShcbiAgICAgICAgICAgICAgY29uc3RyYWluZWRSZXNvbHV0aW9uLFxuICAgICAgICAgICAgICBhbmltYXRpb24uYW5jaG9yLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvbl8gPSBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID1cbiAgICAgICAgICAgIHByb2dyZXNzID09PSAxXG4gICAgICAgICAgICAgID8gbW9kdWxvKGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiArIE1hdGguUEksIDIgKiBNYXRoLlBJKSAtXG4gICAgICAgICAgICAgICAgTWF0aC5QSVxuICAgICAgICAgICAgICA6IGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiArXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgKlxuICAgICAgICAgICAgICAgICAgKGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiAtIGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbik7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbi5hbmNob3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbmVkUm90YXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yb3RhdGlvbihcbiAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJSb3RhdGUoXG4gICAgICAgICAgICAgIGNvbnN0cmFpbmVkUm90YXRpb24sXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmNob3IsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHRSb3RhdGlvbl8gPSBhbmltYXRpb24udGFyZ2V0Um90YXRpb247XG4gICAgICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKHRydWUpO1xuICAgICAgICBtb3JlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcmllc0NvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc19baV0gPSBudWxsO1xuICAgICAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAtMSk7XG4gICAgICAgIHRoaXMubmV4dENlbnRlcl8gPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRSZXNvbHV0aW9uXyA9IE5hTjtcbiAgICAgICAgdGhpcy5uZXh0Um90YXRpb25fID0gTmFOO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHNlcmllc1swXS5jYWxsYmFjaztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBydW5lIGNvbXBsZXRlZCBzZXJpZXNcbiAgICB0aGlzLmFuaW1hdGlvbnNfID0gdGhpcy5hbmltYXRpb25zXy5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKG1vcmUgJiYgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25zXy5iaW5kKHRoaXMpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFRhcmdldCByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFJvdGF0aW9uIGFuY2hvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIgZm9yIHJvdGF0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBjYWxjdWxhdGVDZW50ZXJSb3RhdGUocm90YXRpb24sIGFuY2hvcikge1xuICAgIGxldCBjZW50ZXI7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICBpZiAoY3VycmVudENlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjZW50ZXIgPSBbY3VycmVudENlbnRlclswXSAtIGFuY2hvclswXSwgY3VycmVudENlbnRlclsxXSAtIGFuY2hvclsxXV07XG4gICAgICByb3RhdGVDb29yZGluYXRlKGNlbnRlciwgcm90YXRpb24gLSB0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgICAgYWRkQ29vcmRpbmF0ZShjZW50ZXIsIGFuY2hvcik7XG4gICAgfVxuICAgIHJldHVybiBjZW50ZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBab29tIGFuY2hvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIgZm9yIHJlc29sdXRpb24gYW5kIGFuY2hvci5cbiAgICovXG4gIGNhbGN1bGF0ZUNlbnRlclpvb20ocmVzb2x1dGlvbiwgYW5jaG9yKSB7XG4gICAgbGV0IGNlbnRlcjtcbiAgICBjb25zdCBjdXJyZW50Q2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICAgIGNvbnN0IGN1cnJlbnRSZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB4ID1cbiAgICAgICAgYW5jaG9yWzBdIC1cbiAgICAgICAgKHJlc29sdXRpb24gKiAoYW5jaG9yWzBdIC0gY3VycmVudENlbnRlclswXSkpIC8gY3VycmVudFJlc29sdXRpb247XG4gICAgICBjb25zdCB5ID1cbiAgICAgICAgYW5jaG9yWzFdIC1cbiAgICAgICAgKHJlc29sdXRpb24gKiAoYW5jaG9yWzFdIC0gY3VycmVudENlbnRlclsxXSkpIC8gY3VycmVudFJlc29sdXRpb247XG4gICAgICBjZW50ZXIgPSBbeCwgeV07XG4gICAgfVxuICAgIHJldHVybiBjZW50ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2aWV3cG9ydCBzaXplLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uXSBUYWtlIGludG8gYWNjb3VudCB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0IHdoZW4gZ2l2aW5nIHRoZSBzaXplXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBWaWV3cG9ydCBzaXplIG9yIGBbMTAwLCAxMDBdYCB3aGVuIG5vIHZpZXdwb3J0IGlzIGZvdW5kLlxuICAgKi9cbiAgZ2V0Vmlld3BvcnRTaXplXyhyb3RhdGlvbikge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnZpZXdwb3J0U2l6ZV87XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICBjb25zdCB3ID0gc2l6ZVswXTtcbiAgICAgIGNvbnN0IGggPSBzaXplWzFdO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5hYnModyAqIE1hdGguY29zKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoICogTWF0aC5zaW4ocm90YXRpb24pKSxcbiAgICAgICAgTWF0aC5hYnModyAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoICogTWF0aC5jb3Mocm90YXRpb24pKSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgdmlld3BvcnQgc2l6ZSBvbiB0aGUgdmlldy4gVGhlIHZpZXdwb3J0IHNpemUgaXMgbm90IHJlYWQgZXZlcnkgdGltZSBmcm9tIHRoZSBET01cbiAgICogdG8gYXZvaWQgcGVyZm9ybWFuY2UgaGl0IGFuZCBsYXlvdXQgcmVmbG93LlxuICAgKiBUaGlzIHNob3VsZCBiZSBkb25lIG9uIG1hcCBzaXplIGNoYW5nZS5cbiAgICogTm90ZTogdGhlIGNvbnN0cmFpbnRzIGFyZSBub3QgcmVzb2x2ZWQgZHVyaW5nIGFuIGFuaW1hdGlvbiB0byBhdm9pZCBzdG9wcGluZyBpdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gVmlld3BvcnQgc2l6ZTsgaWYgdW5kZWZpbmVkLCBbMTAwLCAxMDBdIGlzIGFzc3VtZWRcbiAgICovXG4gIHNldFZpZXdwb3J0U2l6ZShzaXplKSB7XG4gICAgdGhpcy52aWV3cG9ydFNpemVfID0gQXJyYXkuaXNBcnJheShzaXplKSA/IHNpemUuc2xpY2UoKSA6IFsxMDAsIDEwMF07XG4gICAgaWYgKCF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGNlbnRlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDZW50ZXIoKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICAgIGlmICghY2VudGVyKSB7XG4gICAgICByZXR1cm4gY2VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gdG9Vc2VyQ29vcmRpbmF0ZShjZW50ZXIsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgY2VudGVyIHdpdGhvdXQgdHJhbnNmb3JtaW5nIHRvIHVzZXIgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKi9cbiAgZ2V0Q2VudGVySW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29uc3RyYWludHN9IENvbnN0cmFpbnRzLlxuICAgKi9cbiAgZ2V0Q29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJlc29sdXRpb24gY29uc3RyYWludCBpcyBzZXRcbiAgICovXG4gIGdldENvbnN0cmFpblJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdjb25zdHJhaW5SZXNvbHV0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbaGludHNdIERlc3RpbmF0aW9uIGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBIaW50LlxuICAgKi9cbiAgZ2V0SGludHMoaGludHMpIHtcbiAgICBpZiAoaGludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGludHNbMF0gPSB0aGlzLmhpbnRzX1swXTtcbiAgICAgIGhpbnRzWzFdID0gdGhpcy5oaW50c19bMV07XG4gICAgICByZXR1cm4gaGludHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhpbnRzXy5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXh0ZW50IGZvciB0aGUgY3VycmVudCB2aWV3IHN0YXRlIGFuZCB0aGUgcGFzc2VkIGJveCBzaXplLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gVGhlIHBpeGVsIGRpbWVuc2lvbnMgb2YgdGhlIGJveFxuICAgKiBpbnRvIHdoaWNoIHRoZSBjYWxjdWxhdGVkIGV4dGVudCBzaG91bGQgZml0LiBEZWZhdWx0cyB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICogbWFwIHRoZSB2aWV3IGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICogSWYgbm8gbWFwIG9yIG11bHRpcGxlIG1hcHMgYXJlIGNvbm5lY3RlZCB0byB0aGUgdmlldywgcHJvdmlkZSB0aGUgZGVzaXJlZFxuICAgKiBib3ggc2l6ZSAoZS5nLiBgbWFwLmdldFNpemUoKWApLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgY2FsY3VsYXRlRXh0ZW50KHNpemUpIHtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLmNhbGN1bGF0ZUV4dGVudEludGVybmFsKHNpemUpO1xuICAgIHJldHVybiB0b1VzZXJFeHRlbnQoZXh0ZW50LCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIEJveCBwaXhlbCBzaXplLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqIHRoZSBtYXAncyBsYXN0IGtub3duIHZpZXdwb3J0IHNpemUgd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICovXG4gIGNhbGN1bGF0ZUV4dGVudEludGVybmFsKHNpemUpIHtcbiAgICBzaXplID0gc2l6ZSB8fCB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICBjb25zdCBjZW50ZXIgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpXG4gICAgKTtcbiAgICBhc3NlcnQoY2VudGVyLCAnVGhlIHZpZXcgY2VudGVyIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IC8qKiBAdHlwZSB7IW51bWJlcn0gKi8gKHRoaXMuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICBhc3NlcnQocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkLCAnVGhlIHZpZXcgcmVzb2x1dGlvbiBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLyoqIEB0eXBlIHshbnVtYmVyfSAqLyAodGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICBhc3NlcnQocm90YXRpb24gIT09IHVuZGVmaW5lZCwgJ1RoZSB2aWV3IHJvdGF0aW9uIGlzIG5vdCBkZWZpbmVkJyk7XG5cbiAgICByZXR1cm4gZ2V0Rm9yVmlld0FuZFNpemUoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWF4UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNaW5SZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1pblJlc29sdXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhab29tKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKFxuICAgICAgdGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbih0aGlzLm1pblJlc29sdXRpb25fKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbmV3IG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1heFpvb20oem9vbSkge1xuICAgIHRoaXMuYXBwbHlPcHRpb25zXyh0aGlzLmdldFVwZGF0ZWRPcHRpb25zXyh7bWF4Wm9vbTogem9vbX0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluWm9vbSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChcbiAgICAgIHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24odGhpcy5tYXhSZXNvbHV0aW9uXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBUaGUgbWluaW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaW5ab29tKHpvb20pIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe21pblpvb206IHpvb219KSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIHZpZXcgc2hvdWxkIGFsbG93IGludGVybWVkaWFyeSB6b29tIGxldmVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFdoZXRoZXIgdGhlIHJlc29sdXRpb24gaXMgY29uc3RyYWluZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvbnN0cmFpblJlc29sdXRpb24oZW5hYmxlZCkge1xuICAgIHRoaXMuYXBwbHlPcHRpb25zXyh0aGlzLmdldFVwZGF0ZWRPcHRpb25zXyh7Y29uc3RyYWluUmVzb2x1dGlvbjogZW5hYmxlZH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gVGhlIHByb2plY3Rpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByb2plY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovICh0aGlzLmdldChWaWV3UHJvcGVydHkuUkVTT0xVVElPTikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbnMgZm9yIHRoZSB2aWV3LiBUaGlzIHJldHVybnMgdGhlIGFycmF5IG9mIHJlc29sdXRpb25zXG4gICAqIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIFZpZXcsIG9yIHVuZGVmaW5lZCBpZiBub25lIHdlcmUgZ2l2ZW4uXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBUaGUgcmVzb2x1dGlvbnMgb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIGEgcHJvdmlkZWQgZXh0ZW50IChpbiBtYXAgdW5pdHMpIGFuZCBzaXplIChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIEJveCBwaXhlbCBzaXplLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBwcm92aWRlZCBleHRlbnQgd2lsbCByZW5kZXIgYXRcbiAgICogICAgIHRoZSBnaXZlbiBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50KGV4dGVudCwgc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFJlc29sdXRpb25Gb3JFeHRlbnRJbnRlcm5hbChcbiAgICAgIGZyb21Vc2VyRXh0ZW50KGV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpLFxuICAgICAgc2l6ZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgYSBwcm92aWRlZCBleHRlbnQgKGluIG1hcCB1bml0cykgYW5kIHNpemUgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gQm94IHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIHByb3ZpZGVkIGV4dGVudCB3aWxsIHJlbmRlciBhdFxuICAgKiAgICAgdGhlIGdpdmVuIHNpemUuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwoZXh0ZW50LCBzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKCk7XG4gICAgY29uc3QgeFJlc29sdXRpb24gPSBnZXRXaWR0aChleHRlbnQpIC8gc2l6ZVswXTtcbiAgICBjb25zdCB5UmVzb2x1dGlvbiA9IGdldEhlaWdodChleHRlbnQpIC8gc2l6ZVsxXTtcbiAgICByZXR1cm4gTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGFcbiAgICogcmVzb2x1dGlvbi4gRXhwb25lbnRpYWwgc2NhbGluZyBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvd2VyXSBQb3dlci5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSBSZXNvbHV0aW9uIGZvciB2YWx1ZSBmdW5jdGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uKHBvd2VyKSB7XG4gICAgcG93ZXIgPSBwb3dlciB8fCAyO1xuICAgIGNvbnN0IG1heFJlc29sdXRpb24gPSB0aGlzLmdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0aGlzLm1heFJlc29sdXRpb25fKTtcbiAgICBjb25zdCBtaW5SZXNvbHV0aW9uID0gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgICBjb25zdCBtYXggPSBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcik7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlLlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhwb3dlciwgdmFsdWUgKiBtYXgpO1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVzb2x1dGlvbiBmb3IgYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIDAgYW5kIDEuIEV4cG9uZW50aWFsIHNjYWxpbmcgaXMgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3dlcl0gUG93ZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlcik6IG51bWJlcn0gVmFsdWUgZm9yIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAqL1xuICBnZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbihwb3dlcikge1xuICAgIGNvbnN0IGxvZ1Bvd2VyID0gTWF0aC5sb2cocG93ZXIgfHwgMik7XG4gICAgY29uc3QgbWF4UmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pO1xuICAgIGNvbnN0IG1pblJlc29sdXRpb24gPSB0aGlzLm1pblJlc29sdXRpb25fO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZhbHVlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAocmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyIC8gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBtaW51cyBwYWRkaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uXSBUYWtlIGludG8gYWNjb3VudCB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0IHdoZW4gZ2l2aW5nIHRoZSBzaXplXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBWaWV3cG9ydCBzaXplIHJlZHVjZWQgYnkgdGhlIHBhZGRpbmcuXG4gICAqL1xuICBnZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKHJvdGF0aW9uKSB7XG4gICAgbGV0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8ocm90YXRpb24pO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmdfO1xuICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICBzaXplID0gW1xuICAgICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICAgIHNpemVbMV0gLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0YXRlfSBWaWV3IHN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgY2VudGVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpXG4gICAgKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICBpZiAocGFkZGluZykge1xuICAgICAgY29uc3QgcmVkdWNlZFNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICAgIGNlbnRlciA9IGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjZW50ZXIsXG4gICAgICAgIHRoaXMuZ2V0Vmlld3BvcnRTaXplXygpLFxuICAgICAgICBbcmVkdWNlZFNpemVbMF0gLyAyICsgcGFkZGluZ1szXSwgcmVkdWNlZFNpemVbMV0gLyAyICsgcGFkZGluZ1swXV0sXG4gICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlcjogY2VudGVyLnNsaWNlKDApLFxuICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gcHJvamVjdGlvbiA6IG51bGwsXG4gICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgbmV4dENlbnRlcjogdGhpcy5uZXh0Q2VudGVyXyxcbiAgICAgIG5leHRSZXNvbHV0aW9uOiB0aGlzLm5leHRSZXNvbHV0aW9uXyxcbiAgICAgIG5leHRSb3RhdGlvbjogdGhpcy5uZXh0Um90YXRpb25fLFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgem9vbTogdGhpcy5nZXRab29tKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtWaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBMaWtlIGBGcmFtZVN0YXRlYCwgYnV0IGp1c3QgYHZpZXdTdGF0ZWAgYW5kIGBleHRlbnRgLlxuICAgKi9cbiAgZ2V0Vmlld1N0YXRlQW5kRXh0ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2aWV3U3RhdGU6IHRoaXMuZ2V0U3RhdGUoKSxcbiAgICAgIGV4dGVudDogdGhpcy5jYWxjdWxhdGVFeHRlbnQoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB6b29tIGxldmVsLiBUaGlzIG1ldGhvZCBtYXkgcmV0dXJuIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzXG4gICAqIGlmIHRoZSB2aWV3IGRvZXMgbm90IGNvbnN0cmFpbiB0aGUgcmVzb2x1dGlvbiwgb3IgaWYgYW4gaW50ZXJhY3Rpb24gb3JcbiAgICogYW5pbWF0aW9uIGlzIHVuZGVyd2F5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBab29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRab29tKCkge1xuICAgIGxldCB6b29tO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB6b29tID0gdGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB6b29tIGxldmVsIGZvciBhIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgem9vbSBsZXZlbCBmb3IgdGhlIHByb3ZpZGVkIHJlc29sdXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5taW5ab29tXyB8fCAwO1xuICAgIGxldCBtYXgsIHpvb21GYWN0b3I7XG4gICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfKSB7XG4gICAgICBjb25zdCBuZWFyZXN0ID0gbGluZWFyRmluZE5lYXJlc3QodGhpcy5yZXNvbHV0aW9uc18sIHJlc29sdXRpb24sIDEpO1xuICAgICAgb2Zmc2V0ID0gbmVhcmVzdDtcbiAgICAgIG1heCA9IHRoaXMucmVzb2x1dGlvbnNfW25lYXJlc3RdO1xuICAgICAgaWYgKG5lYXJlc3QgPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMSkge1xuICAgICAgICB6b29tRmFjdG9yID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSBtYXggLyB0aGlzLnJlc29sdXRpb25zX1tuZWFyZXN0ICsgMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heCA9IHRoaXMubWF4UmVzb2x1dGlvbl87XG4gICAgICB6b29tRmFjdG9yID0gdGhpcy56b29tRmFjdG9yXztcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIE1hdGgubG9nKG1heCAvIHJlc29sdXRpb24pIC8gTWF0aC5sb2coem9vbUZhY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciBhIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZpZXcgcmVzb2x1dGlvbiBmb3IgdGhlIHByb3ZpZGVkIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3Jab29tKHpvb20pIHtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uc18/Lmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bMF07XG4gICAgICB9XG4gICAgICBjb25zdCBiYXNlTGV2ZWwgPSBjbGFtcChcbiAgICAgICAgTWF0aC5mbG9vcih6b29tKSxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMixcbiAgICAgICk7XG4gICAgICBjb25zdCB6b29tRmFjdG9yID1cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvIHRoaXMucmVzb2x1dGlvbnNfW2Jhc2VMZXZlbCArIDFdO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvXG4gICAgICAgIE1hdGgucG93KHpvb21GYWN0b3IsIGNsYW1wKHpvb20gLSBiYXNlTGV2ZWwsIDAsIDEpKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gLyBNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCB6b29tIC0gdGhpcy5taW5ab29tXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpdCB0aGUgZ2l2ZW4gZ2VvbWV0cnkgb3IgZXh0ZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBtYXAgc2l6ZSBhbmQgYm9yZGVyLlxuICAgKiBUaGUgc2l6ZSBpcyBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3ggdG8gZml0IHRoZSBleHRlbnQgaW50by5cbiAgICogSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCB3YW50IHRvIHVzZSB0aGUgbWFwIHNpemUsIHRoYXQgaXMgYG1hcC5nZXRTaXplKClgLlxuICAgKiBUYWtlcyBjYXJlIG9mIHRoZSBtYXAgYW5nbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBnZW9tZXRyeU9yRXh0ZW50IFRoZSBnZW9tZXRyeSBvclxuICAgKiAgICAgZXh0ZW50IHRvIGZpdCB0aGUgdmlldyB0by5cbiAgICogQHBhcmFtIHtGaXRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZml0KGdlb21ldHJ5T3JFeHRlbnQsIG9wdGlvbnMpIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIGxldCBnZW9tZXRyeTtcbiAgICBhc3NlcnQoXG4gICAgICBBcnJheS5pc0FycmF5KGdlb21ldHJ5T3JFeHRlbnQpIHx8XG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAoZ2VvbWV0cnlPckV4dGVudCkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KSA9PT1cbiAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgJ0ludmFsaWQgZXh0ZW50IG9yIGdlb21ldHJ5IHByb3ZpZGVkIGFzIGBnZW9tZXRyeWAnLFxuICAgICk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvbWV0cnlPckV4dGVudCkpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgIWlzRW1wdHkoZ2VvbWV0cnlPckV4dGVudCksXG4gICAgICAgICdDYW5ub3QgZml0IGVtcHR5IGV4dGVudCBwcm92aWRlZCBhcyBgZ2VvbWV0cnlgJyxcbiAgICAgICk7XG4gICAgICBjb25zdCBleHRlbnQgPSBmcm9tVXNlckV4dGVudChnZW9tZXRyeU9yRXh0ZW50LCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeU9yRXh0ZW50LmdldFR5cGUoKSA9PT0gJ0NpcmNsZScpIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IGZyb21Vc2VyRXh0ZW50KFxuICAgICAgICBnZW9tZXRyeU9yRXh0ZW50LmdldEV4dGVudCgpLFxuICAgICAgICB0aGlzLmdldFByb2plY3Rpb24oKSxcbiAgICAgICk7XG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCk7XG4gICAgICBnZW9tZXRyeS5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbigpLCBnZXRDZW50ZXIoZXh0ZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeU9yRXh0ZW50XG4gICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSh1c2VyUHJvamVjdGlvbiwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5T3JFeHRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maXRJbnRlcm5hbChnZW9tZXRyeSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJvdGF0ZWQgZXh0ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnRcIikuRXh0ZW50fSBUaGUgcm90YXRlZCBleHRlbnQgZm9yIHRoZSBnZW9tZXRyeS5cbiAgICovXG4gIHJvdGF0ZWRFeHRlbnRGb3JHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IGNvc0FuZ2xlID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICBjb25zdCBjb29yZHMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgbWluUm90WCA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWluUm90WSA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCByb3RYID0gY29vcmRzW2ldICogY29zQW5nbGUgLSBjb29yZHNbaSArIDFdICogc2luQW5nbGU7XG4gICAgICBjb25zdCByb3RZID0gY29vcmRzW2ldICogc2luQW5nbGUgKyBjb29yZHNbaSArIDFdICogY29zQW5nbGU7XG4gICAgICBtaW5Sb3RYID0gTWF0aC5taW4obWluUm90WCwgcm90WCk7XG4gICAgICBtaW5Sb3RZID0gTWF0aC5taW4obWluUm90WSwgcm90WSk7XG4gICAgICBtYXhSb3RYID0gTWF0aC5tYXgobWF4Um90WCwgcm90WCk7XG4gICAgICBtYXhSb3RZID0gTWF0aC5tYXgobWF4Um90WSwgcm90WSk7XG4gICAgfVxuICAgIHJldHVybiBbbWluUm90WCwgbWluUm90WSwgbWF4Um90WCwgbWF4Um90WV07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0ZpdE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgZml0SW50ZXJuYWwoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgIHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9XG4gICAgICBvcHRpb25zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGFkZGluZyA6IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBuZWFyZXN0ID0gb3B0aW9ucy5uZWFyZXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5lYXJlc3QgOiBmYWxzZTtcbiAgICBsZXQgbWluUmVzb2x1dGlvbjtcbiAgICBpZiAob3B0aW9ucy5taW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSBvcHRpb25zLm1pblJlc29sdXRpb247XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvclpvb20ob3B0aW9ucy5tYXhab29tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IDA7XG4gICAgfVxuXG4gICAgY29uc3Qgcm90YXRlZEV4dGVudCA9IHRoaXMucm90YXRlZEV4dGVudEZvckdlb21ldHJ5KGdlb21ldHJ5KTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXNvbHV0aW9uXG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb25Gb3JFeHRlbnRJbnRlcm5hbChyb3RhdGVkRXh0ZW50LCBbXG4gICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICBzaXplWzFdIC0gcGFkZGluZ1swXSAtIHBhZGRpbmdbMl0sXG4gICAgXSk7XG4gICAgcmVzb2x1dGlvbiA9IGlzTmFOKHJlc29sdXRpb24pXG4gICAgICA/IG1pblJlc29sdXRpb25cbiAgICAgIDogTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbik7XG4gICAgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHJlc29sdXRpb24sIG5lYXJlc3QgPyAwIDogMSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgY2VudGVyXG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgY29uc3QgY2VudGVyUm90ID0gZ2V0Q2VudGVyKHJvdGF0ZWRFeHRlbnQpO1xuICAgIGNlbnRlclJvdFswXSArPSAoKHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdKSAvIDIpICogcmVzb2x1dGlvbjtcbiAgICBjZW50ZXJSb3RbMV0gKz0gKChwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSkgLyAyKSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IGNlbnRlclJvdFswXSAqIGNvc0FuZ2xlIC0gY2VudGVyUm90WzFdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyWSA9IGNlbnRlclJvdFsxXSAqIGNvc0FuZ2xlICsgY2VudGVyUm90WzBdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDb25zdHJhaW5lZENlbnRlcihbY2VudGVyWCwgY2VudGVyWV0sIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayA/IG9wdGlvbnMuY2FsbGJhY2sgOiBWT0lEO1xuXG4gICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRlSW50ZXJuYWwoXG4gICAgICAgIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSBjZW50ZXI7XG4gICAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKGZhbHNlLCB0cnVlKTtcbiAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2VudGVyIG9uIGNvb3JkaW5hdGUgYW5kIHZpZXcgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB0aGUgdmlldyB0byBjZW50ZXIgb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGNlbnRlck9uKGNvb3JkaW5hdGUsIHNpemUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5jZW50ZXJPbkludGVybmFsKFxuICAgICAgZnJvbVVzZXJDb29yZGluYXRlKGNvb3JkaW5hdGUsIHRoaXMuZ2V0UHJvamVjdGlvbigpKSxcbiAgICAgIHNpemUsXG4gICAgICBwb3NpdGlvbixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB0aGUgdmlldyB0byBjZW50ZXIgb24uXG4gICAqL1xuICBjZW50ZXJPbkludGVybmFsKGNvb3JkaW5hdGUsIHNpemUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChcbiAgICAgIGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjb29yZGluYXRlLFxuICAgICAgICBzaXplLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgdGhpcy5nZXRSZXNvbHV0aW9uKCksXG4gICAgICAgIHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzaGlmdCBiZXR3ZWVuIG1hcCBhbmQgdmlld3BvcnQgY2VudGVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IENlbnRlciBzaGlmdC5cbiAgICovXG4gIGNhbGN1bGF0ZUNlbnRlclNoaWZ0KGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUpIHtcbiAgICBsZXQgY2VudGVyU2hpZnQ7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMucGFkZGluZ187XG4gICAgaWYgKHBhZGRpbmcgJiYgY2VudGVyKSB7XG4gICAgICBjb25zdCByZWR1Y2VkU2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplTWludXNQYWRkaW5nXygtcm90YXRpb24pO1xuICAgICAgY29uc3Qgc2hpZnRlZENlbnRlciA9IGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjZW50ZXIsXG4gICAgICAgIHNpemUsXG4gICAgICAgIFtyZWR1Y2VkU2l6ZVswXSAvIDIgKyBwYWRkaW5nWzNdLCByZWR1Y2VkU2l6ZVsxXSAvIDIgKyBwYWRkaW5nWzBdXSxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICApO1xuICAgICAgY2VudGVyU2hpZnQgPSBbXG4gICAgICAgIGNlbnRlclswXSAtIHNoaWZ0ZWRDZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlclsxXSAtIHNoaWZ0ZWRDZW50ZXJbMV0sXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyU2hpZnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZGVmaW5lZC5cbiAgICovXG4gIGlzRGVmKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKSAmJiB0aGlzLmdldFJlc29sdXRpb24oKSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldy4gQW55IGV4dGVudCBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRlbHRhQ29vcmRpbmF0ZXMgUmVsYXRpdmUgdmFsdWUgdG8gYWRkLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGp1c3RDZW50ZXIoZGVsdGFDb29yZGluYXRlcykge1xuICAgIGNvbnN0IGNlbnRlciA9IHRvVXNlckNvb3JkaW5hdGUodGhpcy50YXJnZXRDZW50ZXJfLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgdGhpcy5zZXRDZW50ZXIoW1xuICAgICAgY2VudGVyWzBdICsgZGVsdGFDb29yZGluYXRlc1swXSxcbiAgICAgIGNlbnRlclsxXSArIGRlbHRhQ29vcmRpbmF0ZXNbMV0sXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyByZWxhdGl2ZSBjb29yZGluYXRlcyB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3LiBBbnkgZXh0ZW50IGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZGVsdGFDb29yZGluYXRlcyBSZWxhdGl2ZSB2YWx1ZSB0byBhZGQuXG4gICAqL1xuICBhZGp1c3RDZW50ZXJJbnRlcm5hbChkZWx0YUNvb3JkaW5hdGVzKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy50YXJnZXRDZW50ZXJfO1xuICAgIHRoaXMuc2V0Q2VudGVySW50ZXJuYWwoW1xuICAgICAgY2VudGVyWzBdICsgZGVsdGFDb29yZGluYXRlc1swXSxcbiAgICAgIGNlbnRlclsxXSArIGRlbHRhQ29vcmRpbmF0ZXNbMV0sXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdGhlIHZpZXcgcmVzb2x1dGlvbiBieSBhIHJhdGlvLCBvcHRpb25hbGx5IHVzaW5nIGFuIGFuY2hvci4gQW55IHJlc29sdXRpb25cbiAgICogY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gVGhlIHJhdGlvIHRvIGFwcGx5IG9uIHRoZSB2aWV3IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGp1c3RSZXNvbHV0aW9uKHJhdGlvLCBhbmNob3IpIHtcbiAgICBhbmNob3IgPSBhbmNob3IgJiYgZnJvbVVzZXJDb29yZGluYXRlKGFuY2hvciwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgIHRoaXMuYWRqdXN0UmVzb2x1dGlvbkludGVybmFsKHJhdGlvLCBhbmNob3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoZSB2aWV3IHJlc29sdXRpb24gYnkgYSByYXRpbywgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFRoZSByYXRpbyB0byBhcHBseSBvbiB0aGUgdmlldyByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICovXG4gIGFkanVzdFJlc29sdXRpb25JbnRlcm5hbChyYXRpbywgYW5jaG9yKSB7XG4gICAgY29uc3QgaXNNb3ZpbmcgPSB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fICogcmF0aW8sXG4gICAgICAwLFxuICAgICAgc2l6ZSxcbiAgICAgIGlzTW92aW5nLFxuICAgICk7XG5cbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclpvb20obmV3UmVzb2x1dGlvbiwgYW5jaG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fICo9IHJhdGlvO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIHZpZXcgem9vbSBsZXZlbCwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFJlbGF0aXZlIHZhbHVlIHRvIGFkZCB0byB0aGUgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFpvb20oZGVsdGEsIGFuY2hvcikge1xuICAgIHRoaXMuYWRqdXN0UmVzb2x1dGlvbihNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCAtZGVsdGEpLCBhbmNob3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgdmlldyByb3RhdGlvbiwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByb3RhdGlvblxuICAgKiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBSZWxhdGl2ZSB2YWx1ZSB0byBhZGQgdG8gdGhlIHpvb20gcm90YXRpb24sIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFJvdGF0aW9uKGRlbHRhLCBhbmNob3IpIHtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBmcm9tVXNlckNvb3JkaW5hdGUoYW5jaG9yLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgUmVsYXRpdmUgdmFsdWUgdG8gYWRkIHRvIHRoZSB6b29tIHJvdGF0aW9uLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKi9cbiAgYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKSB7XG4gICAgY29uc3QgaXNNb3ZpbmcgPSB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKTtcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gKyBkZWx0YSxcbiAgICAgIGlzTW92aW5nLFxuICAgICk7XG4gICAgaWYgKGFuY2hvcikge1xuICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJSb3RhdGUobmV3Um90YXRpb24sIGFuY2hvcik7XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0Um90YXRpb25fICs9IGRlbHRhO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciBvZiB0aGUgY3VycmVudCB2aWV3LiBBbnkgZXh0ZW50IGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDZW50ZXIoY2VudGVyKSB7XG4gICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChcbiAgICAgIGNlbnRlciA/IGZyb21Vc2VyQ29vcmRpbmF0ZShjZW50ZXIsIHRoaXMuZ2V0UHJvamVjdGlvbigpKSA6IGNlbnRlcixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIHVzaW5nIHRoZSB2aWV3IHByb2plY3Rpb24gKG5vdCB0aGUgdXNlciBwcm9qZWN0aW9uKS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKi9cbiAgc2V0Q2VudGVySW50ZXJuYWwoY2VudGVyKSB7XG4gICAgdGhpcy50YXJnZXRDZW50ZXJfID0gY2VudGVyO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVmlld0hpbnQuanNcIikuZGVmYXVsdH0gaGludCBIaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IHZhbHVlLlxuICAgKi9cbiAgc2V0SGludChoaW50LCBkZWx0YSkge1xuICAgIHRoaXMuaGludHNfW2hpbnRdICs9IGRlbHRhO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1toaW50XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoaXMgdmlldy4gQW55IHJlc29sdXRpb24gY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uIGZvciB0aGlzIHZpZXcuIEFueSByb3RhdGlvbiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLnRhcmdldFJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tIHRvIGEgc3BlY2lmaWMgem9vbSBsZXZlbC4gQW55IHJlc29sdXRpb24gY29uc3RyYWluIHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFpvb20oem9vbSkge1xuICAgIHRoaXMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb25Gb3Jab29tKHpvb20pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbXB1dGUgcm90YXRpb24vcmVzb2x1dGlvbi9jZW50ZXIgYmFzZWQgb24gdGFyZ2V0IHZhbHVlcy5cbiAgICogTm90ZTogd2UgaGF2ZSB0byBjb21wdXRlIHJvdGF0aW9uIGZpcnN0LCB0aGVuIHJlc29sdXRpb24gYW5kIGNlbnRlciBjb25zaWRlcmluZyB0aGF0XG4gICAqIHBhcmFtZXRlcnMgY2FuIGluZmx1ZW5jZSBvbmUgYW5vdGhlciBpbiBjYXNlIGEgdmlldyBleHRlbnQgY29uc3RyYWludCBpcyBwcmVzZW50LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdENhbmNlbEFuaW1zXSBEbyBub3QgY2FuY2VsIGFuaW1hdGlvbnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlTW92aW5nXSBBcHBseSBjb25zdHJhaW50cyBhcyBpZiB0aGUgdmlldyBpcyBtb3ZpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhcHBseVRhcmdldFN0YXRlXyhkb05vdENhbmNlbEFuaW1zLCBmb3JjZU1vdmluZykge1xuICAgIGNvbnN0IGlzTW92aW5nID1cbiAgICAgIHRoaXMuZ2V0QW5pbWF0aW5nKCkgfHwgdGhpcy5nZXRJbnRlcmFjdGluZygpIHx8IGZvcmNlTW92aW5nO1xuXG4gICAgLy8gY29tcHV0ZSByb3RhdGlvblxuICAgIGNvbnN0IG5ld1JvdGF0aW9uID0gdGhpcy5jb25zdHJhaW50c18ucm90YXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJvdGF0aW9uXyxcbiAgICAgIGlzTW92aW5nLFxuICAgICk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgMCxcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZyxcbiAgICApO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHRoaXMuY29uc3RyYWludHNfLmNlbnRlcihcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICBzaXplLFxuICAgICAgaXNNb3ZpbmcsXG4gICAgICB0aGlzLmNhbGN1bGF0ZUNlbnRlclNoaWZ0KFxuICAgICAgICB0aGlzLnRhcmdldENlbnRlcl8sXG4gICAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICAgIG5ld1JvdGF0aW9uLFxuICAgICAgICBzaXplLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5ST1RBVElPTikgIT09IG5ld1JvdGF0aW9uKSB7XG4gICAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUk9UQVRJT04sIG5ld1JvdGF0aW9uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OKSAhPT0gbmV3UmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIG5ld1Jlc29sdXRpb24pO1xuICAgICAgdGhpcy5zZXQoJ3pvb20nLCB0aGlzLmdldFpvb20oKSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFuZXdDZW50ZXIgfHxcbiAgICAgICF0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSwgbmV3Q2VudGVyKVxuICAgICkge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUiwgbmV3Q2VudGVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSAmJiAhZG9Ob3RDYW5jZWxBbmltcykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIHRoaXMuY2FuY2VsQW5jaG9yXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhbnkgY29uc3RyYWludHMgbmVlZCB0byBiZSBhcHBsaWVkLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgb24gaW50ZXJhY3Rpb24gZW5kLlxuICAgKiBOb3RlOiBjYWxsaW5nIHRoaXMgd2l0aCBhIGR1cmF0aW9uIG9mIDAgd2lsbCBhcHBseSB0aGUgY29uc3RyYWluZWQgdmFsdWVzIHN0cmFpZ2h0IGF3YXksXG4gICAqIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25EaXJlY3Rpb25dIFdoaWNoIGRpcmVjdGlvbiB0byB6b29tLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICovXG4gIHJlc29sdmVDb25zdHJhaW50cyhkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiAyMDA7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gcmVzb2x1dGlvbkRpcmVjdGlvbiB8fCAwO1xuXG4gICAgY29uc3QgbmV3Um90YXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yb3RhdGlvbih0aGlzLnRhcmdldFJvdGF0aW9uXyk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgc2l6ZSxcbiAgICApO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHRoaXMuY29uc3RyYWludHNfLmNlbnRlcihcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICBzaXplLFxuICAgICAgZmFsc2UsXG4gICAgICB0aGlzLmNhbGN1bGF0ZUNlbnRlclNoaWZ0KFxuICAgICAgICB0aGlzLnRhcmdldENlbnRlcl8sXG4gICAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICAgIG5ld1JvdGF0aW9uLFxuICAgICAgICBzaXplLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwICYmICF0aGlzLmNhbmNlbEFuY2hvcl8pIHtcbiAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbl8gPSBuZXdSZXNvbHV0aW9uO1xuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSBuZXdSb3RhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IG5ld0NlbnRlcjtcbiAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmNob3IgPSBhbmNob3IgfHwgKGR1cmF0aW9uID09PSAwID8gdGhpcy5jYW5jZWxBbmNob3JfIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmdldFJlc29sdXRpb24oKSAhPT0gbmV3UmVzb2x1dGlvbiB8fFxuICAgICAgdGhpcy5nZXRSb3RhdGlvbigpICE9PSBuZXdSb3RhdGlvbiB8fFxuICAgICAgIXRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldENlbnRlckludGVybmFsKCksIG5ld0NlbnRlcilcbiAgICApIHtcbiAgICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICAgIHJvdGF0aW9uOiBuZXdSb3RhdGlvbixcbiAgICAgICAgY2VudGVyOiBuZXdDZW50ZXIsXG4gICAgICAgIHJlc29sdXRpb246IG5ld1Jlc29sdXRpb24sXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIFZpZXcgdGhhdCBhbiBpbnRlcmFjdGlvbiBoYXMgc3RhcnRlZC5cbiAgICogVGhlIHZpZXcgc3RhdGUgd2lsbCBiZSByZXNvbHZlZCB0byBhIHN0YWJsZSBvbmUgaWYgbmVlZGVkXG4gICAqIChkZXBlbmRpbmcgb24gaXRzIGNvbnN0cmFpbnRzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgYmVnaW5JbnRlcmFjdGlvbigpIHtcbiAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcblxuICAgIHRoaXMuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBlbmRJbnRlcmFjdGlvbihkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgYW5jaG9yID0gYW5jaG9yICYmIGZyb21Vc2VyQ29vcmRpbmF0ZShhbmNob3IsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICB0aGlzLmVuZEludGVyYWN0aW9uSW50ZXJuYWwoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKi9cbiAgZW5kSW50ZXJhY3Rpb25JbnRlcm5hbChkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgaWYgKCF0aGlzLmdldEludGVyYWN0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdmFsaWQgcG9zaXRpb24gZm9yIHRoZSB2aWV3IGNlbnRlciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29uc3RyYWludHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlciBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0YXJnZXRSZXNvbHV0aW9uXSBUYXJnZXQgcmVzb2x1dGlvbi4gSWYgbm90IHN1cHBsaWVkLCB0aGUgY3VycmVudCBvbmUgd2lsbCBiZSB1c2VkLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBndWVzcyBhIHZhbGlkIGNlbnRlciBwb3NpdGlvbiBhdCBhIGRpZmZlcmVudCB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IFZhbGlkIGNlbnRlciBwb3NpdGlvbi5cbiAgICovXG4gIGdldENvbnN0cmFpbmVkQ2VudGVyKHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbikge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8odGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGFyZ2V0Q2VudGVyLFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvbiB8fCB0aGlzLmdldFJlc29sdXRpb24oKSxcbiAgICAgIHNpemUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCB6b29tIGxldmVsIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2aWV3IGNvbnN0cmFpbnRzLlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHRhcmdldFpvb20gVGFyZ2V0IHpvb20uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGlyZWN0aW9uPTBdIEluZGljYXRlIHdoaWNoIHJlc29sdXRpb24gc2hvdWxkIGJlIHVzZWRcbiAgICogYnkgYSByZW5kZXJlciBpZiB0aGUgdmlldyByZXNvbHV0aW9uIGRvZXMgbm90IG1hdGNoIGFueSByZXNvbHV0aW9uIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb25cbiAgICogd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3QgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBWYWxpZCB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0Q29uc3RyYWluZWRab29tKHRhcmdldFpvb20sIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldFJlcyA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvclpvb20odGFyZ2V0Wm9vbSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24oXG4gICAgICB0aGlzLmdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0YXJnZXRSZXMsIGRpcmVjdGlvbiksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCByZXNvbHV0aW9uIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2aWV3IGNvbnN0cmFpbnRzLlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGlyZWN0aW9uPTBdIEluZGljYXRlIHdoaWNoIHJlc29sdXRpb24gc2hvdWxkIGJlIHVzZWRcbiAgICogYnkgYSByZW5kZXJlciBpZiB0aGUgdmlldyByZXNvbHV0aW9uIGRvZXMgbm90IG1hdGNoIGFueSByZXNvbHV0aW9uIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb25cbiAgICogd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3QgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBWYWxpZCByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRhcmdldFJlc29sdXRpb24sIGRpcmVjdGlvbikge1xuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAwO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8odGhpcy5nZXRSb3RhdGlvbigpKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKHRhcmdldFJlc29sdXRpb24sIGRpcmVjdGlvbiwgc2l6ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gcmV0dXJuVmFsdWUgUmV0dXJuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhbmltYXRpb25DYWxsYmFjayhjYWxsYmFjaywgcmV0dXJuVmFsdWUpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2socmV0dXJuVmFsdWUpO1xuICB9LCAwKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY2VudGVyY29uc3RyYWludC5qc1wiKS5UeXBlfSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNlbnRlckNvbnN0cmFpbnQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHNtb290aCA9XG4gICAgICBvcHRpb25zLnNtb290aEV4dGVudENvbnN0cmFpbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuc21vb3RoRXh0ZW50Q29uc3RyYWludFxuICAgICAgICA6IHRydWU7XG4gICAgcmV0dXJuIGNyZWF0ZUV4dGVudChvcHRpb25zLmV4dGVudCwgb3B0aW9ucy5jb25zdHJhaW5Pbmx5Q2VudGVyLCBzbW9vdGgpO1xuICB9XG5cbiAgY29uc3QgcHJvamVjdGlvbiA9IGNyZWF0ZVByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uLCAnRVBTRzozODU3Jyk7XG4gIGlmIChvcHRpb25zLm11bHRpV29ybGQgIT09IHRydWUgJiYgcHJvamVjdGlvbi5pc0dsb2JhbCgpKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKS5zbGljZSgpO1xuICAgIGV4dGVudFswXSA9IC1JbmZpbml0eTtcbiAgICBleHRlbnRbMl0gPSBJbmZpbml0eTtcbiAgICByZXR1cm4gY3JlYXRlRXh0ZW50KGV4dGVudCwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBjZW50ZXJOb25lO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG9wdGlvbnMgVmlldyBvcHRpb25zLlxuICogQHJldHVybiB7e2NvbnN0cmFpbnQ6IGltcG9ydChcIi4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZSwgbWF4UmVzb2x1dGlvbjogbnVtYmVyLFxuICogICAgIG1pblJlc29sdXRpb246IG51bWJlciwgbWluWm9vbTogbnVtYmVyLCB6b29tRmFjdG9yOiBudW1iZXJ9fSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpIHtcbiAgbGV0IHJlc29sdXRpb25Db25zdHJhaW50O1xuICBsZXQgbWF4UmVzb2x1dGlvbjtcbiAgbGV0IG1pblJlc29sdXRpb247XG5cbiAgLy8gVE9ETzogbW92ZSB0aGVzZSB0byBiZSBvbCBjb25zdGFudHNcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVubGF5ZXJzL29wZW5sYXllcnMvaXNzdWVzLzIwNzZcbiAgY29uc3QgZGVmYXVsdE1heFpvb20gPSAyODtcbiAgY29uc3QgZGVmYXVsdFpvb21GYWN0b3IgPSAyO1xuXG4gIGxldCBtaW5ab29tID1cbiAgICBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IERFRkFVTFRfTUlOX1pPT007XG5cbiAgbGV0IG1heFpvb20gPVxuICAgIG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhab29tIDogZGVmYXVsdE1heFpvb207XG5cbiAgY29uc3Qgem9vbUZhY3RvciA9XG4gICAgb3B0aW9ucy56b29tRmFjdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21GYWN0b3IgOiBkZWZhdWx0Wm9vbUZhY3RvcjtcblxuICBjb25zdCBtdWx0aVdvcmxkID1cbiAgICBvcHRpb25zLm11bHRpV29ybGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXVsdGlXb3JsZCA6IGZhbHNlO1xuXG4gIGNvbnN0IHNtb290aCA9XG4gICAgb3B0aW9ucy5zbW9vdGhSZXNvbHV0aW9uQ29uc3RyYWludCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IG9wdGlvbnMuc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnRcbiAgICAgIDogdHJ1ZTtcblxuICBjb25zdCBzaG93RnVsbEV4dGVudCA9XG4gICAgb3B0aW9ucy5zaG93RnVsbEV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaG93RnVsbEV4dGVudCA6IGZhbHNlO1xuXG4gIGNvbnN0IHByb2plY3Rpb24gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuICBjb25zdCBwcm9qRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgbGV0IGNvbnN0cmFpbk9ubHlDZW50ZXIgPSBvcHRpb25zLmNvbnN0cmFpbk9ubHlDZW50ZXI7XG4gIGxldCBleHRlbnQgPSBvcHRpb25zLmV4dGVudDtcbiAgaWYgKCFtdWx0aVdvcmxkICYmICFleHRlbnQgJiYgcHJvamVjdGlvbi5pc0dsb2JhbCgpKSB7XG4gICAgY29uc3RyYWluT25seUNlbnRlciA9IGZhbHNlO1xuICAgIGV4dGVudCA9IHByb2pFeHRlbnQ7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbnMgPSBvcHRpb25zLnJlc29sdXRpb25zO1xuICAgIG1heFJlc29sdXRpb24gPSByZXNvbHV0aW9uc1ttaW5ab29tXTtcbiAgICBtaW5SZXNvbHV0aW9uID1cbiAgICAgIHJlc29sdXRpb25zW21heFpvb21dICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXNvbHV0aW9uc1ttYXhab29tXVxuICAgICAgICA6IHJlc29sdXRpb25zW3Jlc29sdXRpb25zLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbikge1xuICAgICAgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVTbmFwVG9SZXNvbHV0aW9ucyhcbiAgICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgIWNvbnN0cmFpbk9ubHlDZW50ZXIgJiYgZXh0ZW50LFxuICAgICAgICBzaG93RnVsbEV4dGVudCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdXRpb25Db25zdHJhaW50ID0gY3JlYXRlTWluTWF4UmVzb2x1dGlvbihcbiAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgbWluUmVzb2x1dGlvbixcbiAgICAgICAgc21vb3RoLFxuICAgICAgICAhY29uc3RyYWluT25seUNlbnRlciAmJiBleHRlbnQsXG4gICAgICAgIHNob3dGdWxsRXh0ZW50LFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWZhdWx0IG1pbiBhbmQgbWF4IHJlc29sdXRpb25cbiAgICBjb25zdCBzaXplID0gIXByb2pFeHRlbnRcbiAgICAgID8gLy8gdXNlIGFuIGV4dGVudCB0aGF0IGNhbiBmaXQgdGhlIHdob2xlIHdvcmxkIGlmIG5lZWQgYmVcbiAgICAgICAgKDM2MCAqIE1FVEVSU19QRVJfVU5JVC5kZWdyZWVzKSAvIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpXG4gICAgICA6IE1hdGgubWF4KGdldFdpZHRoKHByb2pFeHRlbnQpLCBnZXRIZWlnaHQocHJvakV4dGVudCkpO1xuXG4gICAgY29uc3QgZGVmYXVsdE1heFJlc29sdXRpb24gPVxuICAgICAgc2l6ZSAvIERFRkFVTFRfVElMRV9TSVpFIC8gTWF0aC5wb3coZGVmYXVsdFpvb21GYWN0b3IsIERFRkFVTFRfTUlOX1pPT00pO1xuXG4gICAgY29uc3QgZGVmYXVsdE1pblJlc29sdXRpb24gPVxuICAgICAgZGVmYXVsdE1heFJlc29sdXRpb24gL1xuICAgICAgTWF0aC5wb3coZGVmYXVsdFpvb21GYWN0b3IsIGRlZmF1bHRNYXhab29tIC0gREVGQVVMVF9NSU5fWk9PTSk7XG5cbiAgICAvLyB1c2VyIHByb3ZpZGVkIG1heFJlc29sdXRpb24gdGFrZXMgcHJlY2VkZW5jZVxuICAgIG1heFJlc29sdXRpb24gPSBvcHRpb25zLm1heFJlc29sdXRpb247XG4gICAgaWYgKG1heFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluWm9vbSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFJlc29sdXRpb24gPSBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1pblpvb20pO1xuICAgIH1cblxuICAgIC8vIHVzZXIgcHJvdmlkZWQgbWluUmVzb2x1dGlvbiB0YWtlcyBwcmVjZWRlbmNlXG4gICAgbWluUmVzb2x1dGlvbiA9IG9wdGlvbnMubWluUmVzb2x1dGlvbjtcbiAgICBpZiAobWluUmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWluUmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluUmVzb2x1dGlvbiA9IGRlZmF1bHRNaW5SZXNvbHV0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdpdmVuIGRpc2NyZXRlIHpvb20gbGV2ZWxzLCBtaW5SZXNvbHV0aW9uIG1heSBiZSBkaWZmZXJlbnQgdGhhbiBwcm92aWRlZFxuICAgIG1heFpvb20gPVxuICAgICAgbWluWm9vbSArXG4gICAgICBNYXRoLmZsb29yKFxuICAgICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKSxcbiAgICAgICk7XG4gICAgbWluUmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tIC0gbWluWm9vbSk7XG5cbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uKSB7XG4gICAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVNuYXBUb1Bvd2VyKFxuICAgICAgICB6b29tRmFjdG9yLFxuICAgICAgICBtYXhSZXNvbHV0aW9uLFxuICAgICAgICBtaW5SZXNvbHV0aW9uLFxuICAgICAgICBzbW9vdGgsXG4gICAgICAgICFjb25zdHJhaW5Pbmx5Q2VudGVyICYmIGV4dGVudCxcbiAgICAgICAgc2hvd0Z1bGxFeHRlbnQsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZU1pbk1heFJlc29sdXRpb24oXG4gICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgIG1pblJlc29sdXRpb24sXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgIWNvbnN0cmFpbk9ubHlDZW50ZXIgJiYgZXh0ZW50LFxuICAgICAgICBzaG93RnVsbEV4dGVudCxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY29uc3RyYWludDogcmVzb2x1dGlvbkNvbnN0cmFpbnQsXG4gICAgbWF4UmVzb2x1dGlvbjogbWF4UmVzb2x1dGlvbixcbiAgICBtaW5SZXNvbHV0aW9uOiBtaW5SZXNvbHV0aW9uLFxuICAgIG1pblpvb206IG1pblpvb20sXG4gICAgem9vbUZhY3Rvcjogem9vbUZhY3RvcixcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vcm90YXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGV9IFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3RhdGlvbkNvbnN0cmFpbnQob3B0aW9ucykge1xuICBjb25zdCBlbmFibGVSb3RhdGlvbiA9XG4gICAgb3B0aW9ucy5lbmFibGVSb3RhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5lbmFibGVSb3RhdGlvbiA6IHRydWU7XG4gIGlmIChlbmFibGVSb3RhdGlvbikge1xuICAgIGNvbnN0IGNvbnN0cmFpblJvdGF0aW9uID0gb3B0aW9ucy5jb25zdHJhaW5Sb3RhdGlvbjtcbiAgICBpZiAoY29uc3RyYWluUm90YXRpb24gPT09IHVuZGVmaW5lZCB8fCBjb25zdHJhaW5Sb3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNuYXBUb1plcm8oKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpblJvdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJvdGF0aW9uTm9uZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW5Sb3RhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTbmFwVG9OKGNvbnN0cmFpblJvdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdGF0aW9uTm9uZTtcbiAgfVxuICByZXR1cm4gZGlzYWJsZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYW5pbWF0aW9uIGludm9sdmVzIG5vIHZpZXcgY2hhbmdlLlxuICogQHBhcmFtIHtBbmltYXRpb259IGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGFuaW1hdGlvbiBpbnZvbHZlcyBubyB2aWV3IGNoYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9vcEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIgJiYgYW5pbWF0aW9uLnRhcmdldENlbnRlcikge1xuICAgIGlmICghY29vcmRpbmF0ZXNFcXVhbChhbmltYXRpb24uc291cmNlQ2VudGVyLCBhbmltYXRpb24udGFyZ2V0Q2VudGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIEJveCBwaXhlbCBzaXplLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB0aGUgdmlldyB0byBjZW50ZXIgb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFNoaWZ0ZWQgY2VudGVyLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDZW50ZXJPbihjb29yZGluYXRlLCBzaXplLCBwb3NpdGlvbiwgcmVzb2x1dGlvbiwgcm90YXRpb24pIHtcbiAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgcG9zaXRpb25cbiAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcygtcm90YXRpb24pO1xuICBsZXQgc2luQW5nbGUgPSBNYXRoLnNpbigtcm90YXRpb24pO1xuICBsZXQgcm90WCA9IGNvb3JkaW5hdGVbMF0gKiBjb3NBbmdsZSAtIGNvb3JkaW5hdGVbMV0gKiBzaW5BbmdsZTtcbiAgbGV0IHJvdFkgPSBjb29yZGluYXRlWzFdICogY29zQW5nbGUgKyBjb29yZGluYXRlWzBdICogc2luQW5nbGU7XG4gIHJvdFggKz0gKHNpemVbMF0gLyAyIC0gcG9zaXRpb25bMF0pICogcmVzb2x1dGlvbjtcbiAgcm90WSArPSAocG9zaXRpb25bMV0gLSBzaXplWzFdIC8gMikgKiByZXNvbHV0aW9uO1xuXG4gIC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgYW5nbGVcbiAgc2luQW5nbGUgPSAtc2luQW5nbGU7IC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgcm90YXRpb25cbiAgY29uc3QgY2VudGVyWCA9IHJvdFggKiBjb3NBbmdsZSAtIHJvdFkgKiBzaW5BbmdsZTtcbiAgY29uc3QgY2VudGVyWSA9IHJvdFkgKiBjb3NBbmdsZSArIHJvdFggKiBzaW5BbmdsZTtcblxuICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdIaW50XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFOSU1BVElORzogMCxcbiAgSU5URVJBQ1RJTkc6IDEsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBDRU5URVI6ICdjZW50ZXInLFxuICBSRVNPTFVUSU9OOiAncmVzb2x1dGlvbicsXG4gIFJPVEFUSU9OOiAncm90YXRpb24nLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9hcnJheVxuICovXG5cbi8qKlxuICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBwcm92aWRlZCBzb3J0ZWQgbGlzdCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gaWYgZm91bmQuIElmIGl0IGNhbid0IGJlIGZvdW5kIGl0J2xsIHJldHVybiAtMS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL2JpbmFyeS1zZWFyY2hcbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBoYXlzdGFjayBJdGVtcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSB7Kn0gbmVlZGxlIFRoZSBpdGVtIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIENvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZCwgLTEgaWYgbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIGNvbXBhcmF0b3IpIHtcbiAgbGV0IG1pZCwgY21wO1xuICBjb21wYXJhdG9yID0gY29tcGFyYXRvciB8fCBhc2NlbmRpbmc7XG4gIGxldCBsb3cgPSAwO1xuICBsZXQgaGlnaCA9IGhheXN0YWNrLmxlbmd0aDtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAvKiBOb3RlIHRoYXQgXCIobG93ICsgaGlnaCkgPj4+IDFcIiBtYXkgb3ZlcmZsb3csIGFuZCByZXN1bHRzIGluIGEgdHlwZWNhc3RcbiAgICAgKiB0byBkb3VibGUgKHdoaWNoIGdpdmVzIHRoZSB3cm9uZyByZXN1bHRzKS4gKi9cbiAgICBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuICAgIGNtcCA9ICtjb21wYXJhdG9yKGhheXN0YWNrW21pZF0sIG5lZWRsZSk7XG5cbiAgICBpZiAoY21wIDwgMC4wKSB7XG4gICAgICAvKiBUb28gbG93LiAqL1xuICAgICAgbG93ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogS2V5IGZvdW5kIG9yIHRvbyBoaWdoICovXG4gICAgICBoaWdoID0gbWlkO1xuICAgICAgZm91bmQgPSAhY21wO1xuICAgIH1cbiAgfVxuXG4gIC8qIEtleSBub3QgZm91bmQuICovXG4gIHJldHVybiBmb3VuZCA/IGxvdyA6IH5sb3c7XG59XG5cbi8qKlxuICogQ29tcGFyZSBmdW5jdGlvbiBzb3J0aW5nIGFycmF5cyBpbiBhc2NlbmRpbmcgb3JkZXIuICBTYWZlIHRvIHVzZSBmb3IgbnVtZXJpYyB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGFzIHRoZSBmaXJzdFxuICogICAgIGFyZ3VtZW50IGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufVxuXG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gc29ydGluZyBhcnJheXMgaW4gZGVzY2VuZGluZyBvcmRlci4gIFNhZmUgdG8gdXNlIGZvciBudW1lcmljIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHsqfSBiIFRoZSBzZWNvbmQgb2JqZWN0IHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybiB7bnVtYmVyfSBBIG5lZ2F0aXZlIG51bWJlciwgemVybywgb3IgYSBwb3NpdGl2ZSBudW1iZXIgYXMgdGhlIGZpcnN0XG4gKiAgICAgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuLCBlcXVhbCB0bywgb3IgbGVzcyB0aGFuIHRoZSBzZWNvbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xufVxuXG4vKipcbiAqIHtAbGluayBtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR+VGlsZUdyaWQjZ2V0WkZvclJlc29sdXRpb259IGNhbiB1c2UgYSBmdW5jdGlvblxuICogb2YgdGhpcyB0eXBlIHRvIGRldGVybWluZSB3aGljaCBuZWFyZXN0IHJlc29sdXRpb24gdG8gdXNlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBge251bWJlcn1gIHJlcHJlc2VudGluZyBhIHZhbHVlIGJldHdlZW4gdHdvIGFycmF5IGVudHJpZXMsXG4gKiBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGUgbmVhcmVzdCBoaWdoZXIgZW50cnkgYW5kXG4gKiBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGUgbmVhcmVzdCBsb3dlciBlbnRyeVxuICogYXMgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgYHtudW1iZXJ9YC4gSWYgYSBuZWdhdGl2ZSBudW1iZXIgb3IgemVybyBpcyByZXR1cm5lZFxuICogdGhlIGxvd2VyIHZhbHVlIHdpbGwgYmUgdXNlZCwgaWYgYSBwb3NpdGl2ZSBudW1iZXIgaXMgcmV0dXJuZWQgdGhlIGhpZ2hlciB2YWx1ZVxuICogd2lsbCBiZSB1c2VkLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIpOiBudW1iZXJ9IE5lYXJlc3REaXJlY3Rpb25GdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhcnIgQXJyYXkgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ8TmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufSBkaXJlY3Rpb25cbiAqICAgIDAgbWVhbnMgcmV0dXJuIHRoZSBuZWFyZXN0LFxuICogICAgPiAwIG1lYW5zIHJldHVybiB0aGUgbGFyZ2VzdCBuZWFyZXN0LFxuICogICAgPCAwIG1lYW5zIHJldHVybiB0aGUgc21hbGxlc3QgbmVhcmVzdC5cbiAqIEByZXR1cm4ge251bWJlcn0gSW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJGaW5kTmVhcmVzdChhcnIsIHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGlmIChhcnJbMF0gPD0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgaWYgKHRhcmdldCA8PSBhcnJbbiAtIDFdKSB7XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gYXJyW2ldO1xuICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZSA8IHRhcmdldCkge1xuICAgICAgICBpZiAoZGlyZWN0aW9uKHRhcmdldCwgYXJyW2kgLSAxXSwgY2FuZGlkYXRlKSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuIC0gMTtcbiAgfVxuXG4gIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbiAtIDE7XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoYXJyW2ldIDw9IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgIGlmIChhcnJbaSAtIDFdIC0gdGFyZ2V0IDwgdGFyZ2V0IC0gYXJyW2ldKSB7XG4gICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbiAtIDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIEFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luIEJlZ2luIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlU3ViQXJyYXkoYXJyLCBiZWdpbiwgZW5kKSB7XG4gIHdoaWxlIChiZWdpbiA8IGVuZCkge1xuICAgIGNvbnN0IHRtcCA9IGFycltiZWdpbl07XG4gICAgYXJyW2JlZ2luXSA9IGFycltlbmRdO1xuICAgIGFycltlbmRdID0gdG1wO1xuICAgICsrYmVnaW47XG4gICAgLS1lbmQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFZBTFVFPn0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyFBcnJheTxWQUxVRT58VkFMVUV9IGRhdGEgVGhlIGVsZW1lbnRzIG9yIGFycmF5cyBvZiBlbGVtZW50cyB0byBhZGQgdG8gYXJyLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoYXJyLCBkYXRhKSB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xuICBjb25zdCBsZW5ndGggPSBleHRlbnNpb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2Fyci5sZW5ndGhdID0gZXh0ZW5zaW9uW2ldO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtWQUxVRX0gb2JqIFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKG9iaik7XG4gIGNvbnN0IGZvdW5kID0gaSA+IC0xO1xuICBpZiAoZm91bmQpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGFueT58VWludDhDbGFtcGVkQXJyYXl9IGFycjEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5PGFueT58VWludDhDbGFtcGVkQXJyYXl9IGFycjIgVGhlIHNlY29uZCBhcnJheSB0byBjb21wYXJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdHdvIGFycmF5cyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYXJyMSwgYXJyMikge1xuICBjb25zdCBsZW4xID0gYXJyMS5sZW5ndGg7XG4gIGlmIChsZW4xICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFNvcnQgdGhlIHBhc3NlZCBhcnJheSBzdWNoIHRoYXQgdGhlIHJlbGF0aXZlIG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzIGlzIHByZXNlcnZlZC5cbiAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb3J0aW5nX2FsZ29yaXRobSNTdGFiaWxpdHkgZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHNvcnQgKG1vZGlmaWVzIG9yaWdpbmFsKS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCosICopOiBudW1iZXJ9IGNvbXBhcmVGbmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWJsZVNvcnQoYXJyLCBjb21wYXJlRm5jKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IHRtcCA9IEFycmF5KGFyci5sZW5ndGgpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG1wW2ldID0ge2luZGV4OiBpLCB2YWx1ZTogYXJyW2ldfTtcbiAgfVxuICB0bXAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlRm5jKGEudmFsdWUsIGIudmFsdWUpIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KTtcbiAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRtcFtpXS52YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyciBUaGUgYXJyYXkgdG8gdGVzdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmdW5jXSBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0XSBTdHJpY3RseSBzb3J0ZWQgKGRlZmF1bHQgZmFsc2UpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTb3J0ZWQoYXJyLCBmdW5jLCBzdHJpY3QpIHtcbiAgY29uc3QgY29tcGFyZSA9IGZ1bmMgfHwgYXNjZW5kaW5nO1xuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uIChjdXJyZW50VmFsLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmUoYXJyW2luZGV4IC0gMV0sIGN1cnJlbnRWYWwpO1xuICAgIHJldHVybiAhKHJlcyA+IDAgfHwgKHN0cmljdCAmJiByZXMgPT09IDApKTtcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvYXNzZXJ0c1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBhc3NlcnRpb24gQXNzZXJ0aW9uIHdlIGV4cGVjdGVkIHRvIGJlIHRydXRoeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvck1lc3NhZ2UgRXJyb3IgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb24sIGVycm9yTWVzc2FnZSkge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvY2VudGVyY29uc3RyYWludFxuICovXG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkKSwgbnVtYmVyLCBpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZSwgYm9vbGVhbj0sIEFycmF5PG51bWJlcj49KTogKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZCl9IFR5cGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBvbmx5Q2VudGVyIElmIHRydWUsIHRoZSBjb25zdHJhaW50IHdpbGwgb25seSBhcHBseSB0byB0aGUgdmlldyBjZW50ZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNtb290aCBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGJlIGFibGUgdG8gZ28gc2xpZ2h0bHkgb3V0IG9mIHRoZSBnaXZlbiBleHRlbnRcbiAqIChvbmx5IGR1cmluZyBpbnRlcmFjdGlvbiBhbmQgYW5pbWF0aW9uKS5cbiAqIEByZXR1cm4ge1R5cGV9IFRoZSBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZW50KGV4dGVudCwgb25seUNlbnRlciwgc21vb3RoKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IGNlbnRlciBDZW50ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplOyB1bnVzZWQgaWYgYG9ubHlDZW50ZXJgIHdhcyBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb3ZpbmddIFRydWUgaWYgYW4gaW50ZXJhY3Rpb24gb3IgYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2NlbnRlclNoaWZ0XSBTaGlmdCBiZXR3ZWVuIG1hcCBjZW50ZXIgYW5kIHZpZXdwb3J0IGNlbnRlci5cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IENlbnRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2VudGVyLCByZXNvbHV0aW9uLCBzaXplLCBpc01vdmluZywgY2VudGVyU2hpZnQpIHtcbiAgICAgIGlmICghY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc29sdXRpb24gJiYgIW9ubHlDZW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNlbnRlcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZpZXdXaWR0aCA9IG9ubHlDZW50ZXIgPyAwIDogc2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgICBjb25zdCB2aWV3SGVpZ2h0ID0gb25seUNlbnRlciA/IDAgOiBzaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHNoaWZ0WCA9IGNlbnRlclNoaWZ0ID8gY2VudGVyU2hpZnRbMF0gOiAwO1xuICAgICAgY29uc3Qgc2hpZnRZID0gY2VudGVyU2hpZnQgPyBjZW50ZXJTaGlmdFsxXSA6IDA7XG4gICAgICBsZXQgbWluWCA9IGV4dGVudFswXSArIHZpZXdXaWR0aCAvIDIgKyBzaGlmdFg7XG4gICAgICBsZXQgbWF4WCA9IGV4dGVudFsyXSAtIHZpZXdXaWR0aCAvIDIgKyBzaGlmdFg7XG4gICAgICBsZXQgbWluWSA9IGV4dGVudFsxXSArIHZpZXdIZWlnaHQgLyAyICsgc2hpZnRZO1xuICAgICAgbGV0IG1heFkgPSBleHRlbnRbM10gLSB2aWV3SGVpZ2h0IC8gMiArIHNoaWZ0WTtcblxuICAgICAgLy8gbm90ZTogd2hlbiB6b29taW5nIG91dCBvZiBib3VuZHMsIG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgeCBhbmQgeSBtYXlcbiAgICAgIC8vIGVuZCB1cCBpbnZlcnRlZCAobWluID4gbWF4KTsgdGhpcyBoYXMgdG8gYmUgYWNjb3VudGVkIGZvclxuICAgICAgaWYgKG1pblggPiBtYXhYKSB7XG4gICAgICAgIG1pblggPSAobWF4WCArIG1pblgpIC8gMjtcbiAgICAgICAgbWF4WCA9IG1pblg7XG4gICAgICB9XG4gICAgICBpZiAobWluWSA+IG1heFkpIHtcbiAgICAgICAgbWluWSA9IChtYXhZICsgbWluWSkgLyAyO1xuICAgICAgICBtYXhZID0gbWluWTtcbiAgICAgIH1cblxuICAgICAgbGV0IHggPSBjbGFtcChjZW50ZXJbMF0sIG1pblgsIG1heFgpO1xuICAgICAgbGV0IHkgPSBjbGFtcChjZW50ZXJbMV0sIG1pblksIG1heFkpO1xuXG4gICAgICAvLyBkdXJpbmcgYW4gaW50ZXJhY3Rpb24sIGFsbG93IHNvbWUgb3ZlcnNjcm9sbFxuICAgICAgaWYgKGlzTW92aW5nICYmIHNtb290aCAmJiByZXNvbHV0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gMzAgKiByZXNvbHV0aW9uO1xuICAgICAgICB4ICs9XG4gICAgICAgICAgLXJhdGlvICogTWF0aC5sb2coMSArIE1hdGgubWF4KDAsIG1pblggLSBjZW50ZXJbMF0pIC8gcmF0aW8pICtcbiAgICAgICAgICByYXRpbyAqIE1hdGgubG9nKDEgKyBNYXRoLm1heCgwLCBjZW50ZXJbMF0gLSBtYXhYKSAvIHJhdGlvKTtcbiAgICAgICAgeSArPVxuICAgICAgICAgIC1yYXRpbyAqIE1hdGgubG9nKDEgKyBNYXRoLm1heCgwLCBtaW5ZIC0gY2VudGVyWzFdKSAvIHJhdGlvKSArXG4gICAgICAgICAgcmF0aW8gKiBNYXRoLmxvZygxICsgTWF0aC5tYXgoMCwgY2VudGVyWzFdIC0gbWF4WSkgLyByYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjZW50ZXJdIENlbnRlci5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uZShjZW50ZXIpIHtcbiAgcmV0dXJuIGNlbnRlcjtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9jb2xvclxuICovXG5pbXBvcnQgbGNodXYgZnJvbSAnY29sb3Itc3BhY2UvbGNodXYuanMnO1xuaW1wb3J0IHBhcnNlUmdiYSBmcm9tICdjb2xvci1yZ2JhJztcbmltcG9ydCByZ2IgZnJvbSAnY29sb3Itc3BhY2UvcmdiLmpzJztcbmltcG9ydCB4eXogZnJvbSAnY29sb3Itc3BhY2UveHl6LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogQSBjb2xvciByZXByZXNlbnRlZCBhcyBhIHNob3J0IGFycmF5IFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV0uXG4gKiByZWQsIGdyZWVuLCBhbmQgYmx1ZSBzaG91bGQgYmUgaW50ZWdlcnMgaW4gdGhlIHJhbmdlIDAuLjI1NSBpbmNsdXNpdmUuXG4gKiBhbHBoYSBzaG91bGQgYmUgYSBmbG9hdCBpbiB0aGUgcmFuZ2UgMC4uMSBpbmNsdXNpdmUuIElmIG5vIGFscGhhIHZhbHVlIGlzXG4gKiBnaXZlbiB0aGVuIGAxYCB3aWxsIGJlIHVzZWQuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gQ29sb3JcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIENvbG9yIHRvIGluZGljYXRlIHRoYXQgbm8gY29sb3Igc2hvdWxkIGJlIHJlbmRlcmVkLiBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgZm9yIHBlci1yZWZlcmVuY2VcbiAqIGNvbXBhcmlzb25zIG9ubHkuXG4gKiBAdHlwZSB7Q29sb3J9XG4gKi9cbmV4cG9ydCBjb25zdCBOT19DT0xPUiA9IFtOYU4sIE5hTiwgTmFOLCAwXTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbG9yIGFzIGFuIHJnYmEgc3RyaW5nLlxuICogQHBhcmFtIHtDb2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBSZ2JhIHN0cmluZy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIHJldHVybiB0b1N0cmluZyhjb2xvcik7XG59XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX0NBQ0hFX1NJWkUgPSAxMDI0O1xuXG4vKipcbiAqIFdlIG1haW50YWluIGEgc21hbGwgY2FjaGUgb2YgcGFyc2VkIHN0cmluZ3MuICBXaGVuZXZlciB0aGUgY2FjaGUgZ3Jvd3MgdG9vIGxhcmdlLFxuICogd2UgZGVsZXRlIGFuIGFyYml0cmFyeSBzZXQgb2YgdGhlIGVudHJpZXMuXG4gKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIENvbG9yPn1cbiAqL1xuY29uc3QgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5sZXQgY2FjaGVTaXplID0gMDtcblxuLyoqXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBBIGNvbG9yIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBhbHBoYSBjaGFubmVsLlxuICogQHJldHVybiB7Q29sb3J9IFRoZSBpbnB1dCBjb2xvciB3aXRoIGFuIGFscGhhIGNoYW5uZWwuICBJZiB0aGUgaW5wdXQgY29sb3IgaGFzXG4gKiBhbiBhbHBoYSBjaGFubmVsLCB0aGUgaW5wdXQgY29sb3Igd2lsbCBiZSByZXR1cm5lZCB1bmNoYW5nZWQuICBPdGhlcndpc2UsIGEgbmV3XG4gKiBhcnJheSB3aWxsIGJlIHJldHVybmVkIHdpdGggdGhlIGlucHV0IGNvbG9yIGFuZCBhbiBhbHBoYSBjaGFubmVsIG9mIDEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQWxwaGEoY29sb3IpIHtcbiAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICBjb25zdCBvdXRwdXQgPSBjb2xvci5zbGljZSgpO1xuICBvdXRwdXRbM10gPSAxO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIFJHQkEgY29sb3IuXG4gKiBAcmV0dXJuIHtDb2xvcn0gTENIdXYgY29sb3Igd2l0aCBhbHBoYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJnYmFUb0xjaGEoY29sb3IpIHtcbiAgY29uc3Qgb3V0cHV0ID0geHl6LmxjaHV2KHJnYi54eXooY29sb3IpKTtcbiAgb3V0cHV0WzNdID0gY29sb3JbM107XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgTENIdXYgY29sb3Igd2l0aCBhbHBoYS5cbiAqIEByZXR1cm4ge0NvbG9yfSBSR0JBIGNvbG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGNoYVRvUmdiYShjb2xvcikge1xuICBjb25zdCBvdXRwdXQgPSB4eXoucmdiKGxjaHV2Lnh5eihjb2xvcikpO1xuICBvdXRwdXRbM10gPSBjb2xvclszXTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcuXG4gKiBAcmV0dXJuIHtDb2xvcn0gQ29sb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHMpIHtcbiAgaWYgKHMgPT09ICdub25lJykge1xuICAgIHJldHVybiBOT19DT0xPUjtcbiAgfVxuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICByZXR1cm4gY2FjaGVbc107XG4gIH1cbiAgaWYgKGNhY2hlU2l6ZSA+PSBNQVhfQ0FDSEVfU0laRSkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICAgICAgLS1jYWNoZVNpemU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29sb3IgPSBwYXJzZVJnYmEocyk7XG4gIGlmIChjb2xvci5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBcIicgKyBzICsgJ1wiIGFzIGNvbG9yJyk7XG4gIH1cbiAgZm9yIChjb25zdCBjIG9mIGNvbG9yKSB7XG4gICAgaWYgKGlzTmFOKGMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBcIicgKyBzICsgJ1wiIGFzIGNvbG9yJyk7XG4gICAgfVxuICB9XG4gIG5vcm1hbGl6ZShjb2xvcik7XG4gIGNhY2hlW3NdID0gY29sb3I7XG4gICsrY2FjaGVTaXplO1xuICByZXR1cm4gY29sb3I7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb2xvciBhcyBhbiBhcnJheS4gVGhpcyBmdW5jdGlvbiBtYWludGFpbnMgYSBjYWNoZSBvZiBjYWxjdWxhdGVkXG4gKiBhcnJheXMgd2hpY2ggbWVhbnMgdGhlIHJlc3VsdCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHtDb2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheShjb2xvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcoY29sb3IpO1xufVxuXG4vKipcbiAqIEV4cG9ydGVkIGZvciB0aGUgdGVzdHMuXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBDbGFtcGVkIGNvbG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKGNvbG9yKSB7XG4gIGNvbG9yWzBdID0gY2xhbXAoKGNvbG9yWzBdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzFdID0gY2xhbXAoKGNvbG9yWzFdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzJdID0gY2xhbXAoKGNvbG9yWzJdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzNdID0gY2xhbXAoY29sb3JbM10sIDAsIDEpO1xuICByZXR1cm4gY29sb3I7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbG9yKSB7XG4gIGxldCByID0gY29sb3JbMF07XG4gIGlmIChyICE9IChyIHwgMCkpIHtcbiAgICByID0gKHIgKyAwLjUpIHwgMDtcbiAgfVxuICBsZXQgZyA9IGNvbG9yWzFdO1xuICBpZiAoZyAhPSAoZyB8IDApKSB7XG4gICAgZyA9IChnICsgMC41KSB8IDA7XG4gIH1cbiAgbGV0IGIgPSBjb2xvclsyXTtcbiAgaWYgKGIgIT0gKGIgfCAwKSkge1xuICAgIGIgPSAoYiArIDAuNSkgfCAwO1xuICB9XG4gIGNvbnN0IGEgPSBjb2xvclszXSA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGgucm91bmQoY29sb3JbM10gKiAxMDAwKSAvIDEwMDA7XG4gIHJldHVybiAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgaXMgYWN0dWFsbHkgYSB2YWxpZCBjb2xvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdDb2xvcihzKSB7XG4gIHRyeSB7XG4gICAgZnJvbVN0cmluZyhzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbG9ybGlrZVxuICovXG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldEljb25JbWFnZX0gZnJvbSAnLi9zdHlsZS9JY29uSW1hZ2UuanMnO1xuaW1wb3J0IHtzaGFyZWQgYXMgaWNvbkNhY2hlfSBmcm9tICcuL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzJztcbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJy4vY29sb3IuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhdHRlcm5EZXNjcmlwdG9yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3JjIFBhdHRlcm4gaW1hZ2UgVVJMXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfSBbY29sb3JdIENvbG9yIHRvIHRpbnQgdGhlIHBhdHRlcm4gd2l0aC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBTaXplIG9mIHRoZSBkZXNpcmVkIHNsaWNlIGZyb20gdGhlIHBhdHRlcm4gaW1hZ2UuXG4gKiBVc2UgdGhpcyB0b2dldGhlciB3aXRoIGBvZmZzZXRgIHdoZW4gdGhlIHBhdHRlcm4gaW1hZ2UgaXMgYSBzcHJpdGUgc2hlZXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbb2Zmc2V0XSBPZmZzZXQgb2YgdGhlIGRlc2lyZWQgc2xpY2UgZnJvbSB0aGUgcGF0dGVybiBpbWFnZS5cbiAqIFVzZSB0aGlzIHRvZ2V0aGVyIHdpdGggYHNpemVgIHdoZW4gdGhlIHBhdHRlcm4gaW1hZ2UgaXMgYSBzcHJpdGUgc2hlZXQuXG4gKi9cblxuLyoqXG4gKiBBIHR5cGUgYWNjZXB0ZWQgYnkgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmZpbGxTdHlsZVxuICogb3IgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnN0cm9rZVN0eWxlLlxuICogUmVwcmVzZW50cyBhIGNvbG9yLCBbQ2FudmFzUGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1BhdHRlcm4pLFxuICogb3IgW0NhbnZhc0dyYWRpZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzR3JhZGllbnQpLiBUaGUgb3JpZ2luIGZvclxuICogcGF0dGVybnMgYW5kIGdyYWRpZW50cyBhcyBmaWxsIHN0eWxlIGlzIGFuIGluY3JlbWVudCBvZiA1MTIgY3NzIHBpeGVscyBmcm9tIG1hcCBjb29yZGluYXRlXG4gKiBgWzAsIDBdYC4gRm9yIHNlYW1sZXNzIHJlcGVhdCBwYXR0ZXJucywgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGF0dGVybiBpbWFnZVxuICogbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfENhbnZhc1BhdHRlcm58Q2FudmFzR3JhZGllbnR9IENvbG9yTGlrZVxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbG9yLmpzXCIpLkNvbG9yfENvbG9yTGlrZXxQYXR0ZXJuRGVzY3JpcHRvcnxudWxsfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yTGlrZXxudWxsfSBUaGUgY29sb3IgYXMgYW4ge0BsaW5rIG9sL2NvbG9ybGlrZX5Db2xvckxpa2V9LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNDb2xvckxpa2UoY29sb3IpIHtcbiAgaWYgKCFjb2xvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIHJldHVybiB0b1N0cmluZyhjb2xvcik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ29iamVjdCcgJiYgJ3NyYycgaW4gY29sb3IpIHtcbiAgICByZXR1cm4gYXNDYW52YXNQYXR0ZXJuKGNvbG9yKTtcbiAgfVxuICByZXR1cm4gY29sb3I7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQYXR0ZXJuRGVzY3JpcHRvcn0gcGF0dGVybiBQYXR0ZXJuIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufG51bGx9IENhbnZhcyBwYXR0ZXJuIG9yIG51bGwgaWYgdGhlIHBhdHRlcm4gcmVmZXJlbmNlZCBpbiB0aGVcbiAqIFBhdHRlcm5EZXNjcmlwdG9yIHdhcyBub3QgZm91bmQgaW4gdGhlIGljb24gaW1hZ2UgY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIGFzQ2FudmFzUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghcGF0dGVybi5vZmZzZXQgfHwgIXBhdHRlcm4uc2l6ZSkge1xuICAgIHJldHVybiBpY29uQ2FjaGUuZ2V0UGF0dGVybihwYXR0ZXJuLnNyYywgJ2Fub255bW91cycsIHBhdHRlcm4uY29sb3IpO1xuICB9XG5cbiAgY29uc3QgY2FjaGVLZXkgPSBwYXR0ZXJuLnNyYyArICc6JyArIHBhdHRlcm4ub2Zmc2V0O1xuXG4gIGNvbnN0IGNhbnZhc1BhdHRlcm4gPSBpY29uQ2FjaGUuZ2V0UGF0dGVybihcbiAgICBjYWNoZUtleSxcbiAgICB1bmRlZmluZWQsXG4gICAgcGF0dGVybi5jb2xvcixcbiAgKTtcbiAgaWYgKGNhbnZhc1BhdHRlcm4pIHtcbiAgICByZXR1cm4gY2FudmFzUGF0dGVybjtcbiAgfVxuXG4gIGNvbnN0IGljb25JbWFnZSA9IGljb25DYWNoZS5nZXQocGF0dGVybi5zcmMsICdhbm9ueW1vdXMnLCBudWxsKTtcbiAgaWYgKGljb25JbWFnZS5nZXRJbWFnZVN0YXRlKCkgIT09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcGF0dGVybkNhbnZhc0NvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgcGF0dGVybi5zaXplWzBdLFxuICAgIHBhdHRlcm4uc2l6ZVsxXSxcbiAgKTtcbiAgcGF0dGVybkNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKFxuICAgIGljb25JbWFnZS5nZXRJbWFnZSgxKSxcbiAgICBwYXR0ZXJuLm9mZnNldFswXSxcbiAgICBwYXR0ZXJuLm9mZnNldFsxXSxcbiAgICBwYXR0ZXJuLnNpemVbMF0sXG4gICAgcGF0dGVybi5zaXplWzFdLFxuICAgIDAsXG4gICAgMCxcbiAgICBwYXR0ZXJuLnNpemVbMF0sXG4gICAgcGF0dGVybi5zaXplWzFdLFxuICApO1xuICBnZXRJY29uSW1hZ2UoXG4gICAgcGF0dGVybkNhbnZhc0NvbnRleHQuY2FudmFzLFxuICAgIGNhY2hlS2V5LFxuICAgIHVuZGVmaW5lZCxcbiAgICBJbWFnZVN0YXRlLkxPQURFRCxcbiAgICBwYXR0ZXJuLmNvbG9yLFxuICAgIHRydWUsXG4gICk7XG4gIHJldHVybiBpY29uQ2FjaGUuZ2V0UGF0dGVybihjYWNoZUtleSwgdW5kZWZpbmVkLCBwYXR0ZXJuLmNvbG9yKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9jb25zb2xlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2luZm8nfCd3YXJuJ3wnZXJyb3InfCdub25lJ30gTGV2ZWxcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8TGV2ZWwsIG51bWJlcj59XG4gKi9cbmNvbnN0IGxldmVscyA9IHtcbiAgaW5mbzogMSxcbiAgd2FybjogMixcbiAgZXJyb3I6IDMsXG4gIG5vbmU6IDQsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBsZXZlbCA9IGxldmVscy5pbmZvO1xuXG4vKipcbiAqIFNldCB0aGUgbG9nZ2luZyBsZXZlbC4gIEJ5IGRlZmF1bHQsIHRoZSBsZXZlbCBpcyBzZXQgdG8gJ2luZm8nIGFuZCBhbGxcbiAqIG1lc3NhZ2VzIHdpbGwgYmUgbG9nZ2VkLiAgU2V0IHRvICd3YXJuJyB0byBvbmx5IGRpc3BsYXkgd2FybmluZ3MgYW5kIGVycm9ycy5cbiAqIFNldCB0byAnZXJyb3InIHRvIG9ubHkgZGlzcGxheSBlcnJvcnMuICBTZXQgdG8gJ25vbmUnIHRvIHNpbGVuY2UgYWxsIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7TGV2ZWx9IGwgVGhlIG5ldyBsZXZlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExldmVsKGwpIHtcbiAgbGV2ZWwgPSBsZXZlbHNbbF07XG59XG5cbi8qKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFyZ3VtZW50cyB0byBsb2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gIGlmIChsZXZlbCA+IGxldmVscy5pbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKC4uLmFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgQXJndW1lbnRzIHRvIGxvZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2FybiguLi5hcmdzKSB7XG4gIGlmIChsZXZlbCA+IGxldmVscy53YXJuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybiguLi5hcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5cbi8qKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFyZ3VtZW50cyB0byBsb2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKC4uLmFyZ3MpIHtcbiAgaWYgKGxldmVsID4gbGV2ZWxzLmVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvQXR0cmlidXRpb25cbiAqL1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi9Db250cm9sLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0NMQVNTX0NPTExBUFNFRCwgQ0xBU1NfQ09OVFJPTCwgQ0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7cmVtb3ZlQ2hpbGRyZW4sIHJlcGxhY2VOb2RlfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHt0b1Byb21pc2V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWF0dHJpYnV0aW9uJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gU3BlY2lmeSBhIHRhcmdldCBpZiB5b3VcbiAqIHdhbnQgdGhlIGNvbnRyb2wgdG8gYmUgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgbWFwJ3NcbiAqIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29sbGFwc2libGVdIFNwZWNpZnkgaWYgYXR0cmlidXRpb25zIGNhblxuICogYmUgY29sbGFwc2VkLiBJZiBub3Qgc3BlY2lmaWVkLCBzb3VyY2VzIGNvbnRyb2wgdGhpcyBiZWhhdmlvciB3aXRoIHRoZWlyXG4gKiBgYXR0cmlidXRpb25zQ29sbGFwc2libGVgIHNldHRpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb2xsYXBzZWQ9dHJ1ZV0gU3BlY2lmeSBpZiBhdHRyaWJ1dGlvbnMgc2hvdWxkXG4gKiBiZSBjb2xsYXBzZWQgYXQgc3RhcnR1cC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGlwTGFiZWw9J0F0dHJpYnV0aW9ucyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbbGFiZWw9J2knXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlXG4gKiBjb2xsYXBzZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtleHBhbmRDbGFzc05hbWU9Y2xhc3NOYW1lICsgJy1leHBhbmQnXSBDU1MgY2xhc3MgbmFtZSBmb3IgdGhlXG4gKiBjb2xsYXBzZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbY29sbGFwc2VMYWJlbD0n4oC6J10gVGV4dCBsYWJlbCB0byB1c2VcbiAqIGZvciB0aGUgZXhwYW5kZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xsYXBzZUNsYXNzTmFtZT1jbGFzc05hbWUgKyAnLWNvbGxhcHNlJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZVxuICogZXhwYW5kZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW3JlbmRlcl0gRnVuY3Rpb24gY2FsbGVkIHdoZW5cbiAqIHRoZSBjb250cm9sIHNob3VsZCBiZSByZS1yZW5kZXJlZC4gVGhpcyBpcyBjYWxsZWQgaW4gYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICogY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge3N0cmluZ3xBcnJheTxzdHJpbmc+fHVuZGVmaW5lZH0gW2F0dHJpYnV0aW9uc10gT3B0aW9uYWwgYXR0cmlidXRpb24ocykgdGhhdCB3aWxsIGFsd2F5cyBiZVxuICogZGlzcGxheWVkIHJlZ2FyZGxlc3Mgb2YgdGhlIGxheWVycyByZW5kZXJlZFxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ29udHJvbCB0byBzaG93IGFsbCB0aGUgYXR0cmlidXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGF5ZXIgc291cmNlc1xuICogaW4gdGhlIG1hcC4gVGhpcyBjb250cm9sIGlzIG9uZSBvZiB0aGUgZGVmYXVsdCBjb250cm9scyBpbmNsdWRlZCBpbiBtYXBzLlxuICogQnkgZGVmYXVsdCBpdCB3aWxsIHNob3cgaW4gdGhlIGJvdHRvbSByaWdodCBwb3J0aW9uIG9mIHRoZSBtYXAsIGJ1dCB0aGlzIGNhblxuICogYmUgY2hhbmdlZCBieSB1c2luZyBhIGNzcyBzZWxlY3RvciBmb3IgYC5vbC1hdHRyaWJ1dGlvbmAuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBBdHRyaWJ1dGlvbiBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gQXR0cmlidXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgcmVuZGVyOiBvcHRpb25zLnJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnVsRWxlbWVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNlZF8gPVxuICAgICAgb3B0aW9ucy5jb2xsYXBzZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGFwc2VkIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51c2VyQ29sbGFwc2VkXyA9IHRoaXMuY29sbGFwc2VkXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVycmlkZUNvbGxhcHNpYmxlXyA9IG9wdGlvbnMuY29sbGFwc2libGUgIT09IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb2xsYXBzaWJsZV8gPVxuICAgICAgb3B0aW9ucy5jb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzaWJsZSA6IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuY29sbGFwc2libGVfKSB7XG4gICAgICB0aGlzLmNvbGxhcHNlZF8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRpb25zXyA9IG9wdGlvbnMuYXR0cmlidXRpb25zO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1hdHRyaWJ1dGlvbic7XG5cbiAgICBjb25zdCB0aXBMYWJlbCA9XG4gICAgICBvcHRpb25zLnRpcExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpcExhYmVsIDogJ0F0dHJpYnV0aW9ucyc7XG5cbiAgICBjb25zdCBleHBhbmRDbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy5leHBhbmRDbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuZXhwYW5kQ2xhc3NOYW1lXG4gICAgICAgIDogY2xhc3NOYW1lICsgJy1leHBhbmQnO1xuXG4gICAgY29uc3QgY29sbGFwc2VMYWJlbCA9XG4gICAgICBvcHRpb25zLmNvbGxhcHNlTGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGFwc2VMYWJlbCA6ICdcXHUyMDNBJztcblxuICAgIGNvbnN0IGNvbGxhcHNlQ2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY29sbGFwc2VDbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuY29sbGFwc2VDbGFzc05hbWVcbiAgICAgICAgOiBjbGFzc05hbWUgKyAnLWNvbGxhcHNlJztcblxuICAgIGlmICh0eXBlb2YgY29sbGFwc2VMYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8udGV4dENvbnRlbnQgPSBjb2xsYXBzZUxhYmVsO1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXy5jbGFzc05hbWUgPSBjb2xsYXBzZUNsYXNzTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXyA9IGNvbGxhcHNlTGFiZWw7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWwgPSBvcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxhYmVsIDogJ2knO1xuXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy5sYWJlbF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICB0aGlzLmxhYmVsXy50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgdGhpcy5sYWJlbF8uY2xhc3NOYW1lID0gZXhwYW5kQ2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGxhYmVsO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZUxhYmVsID1cbiAgICAgIHRoaXMuY29sbGFwc2libGVfICYmICF0aGlzLmNvbGxhcHNlZF8gPyB0aGlzLmNvbGxhcHNlTGFiZWxfIDogdGhpcy5sYWJlbF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIHRoaXMudG9nZ2xlQnV0dG9uXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBTdHJpbmcoIXRoaXMuY29sbGFwc2VkXykpO1xuICAgIHRoaXMudG9nZ2xlQnV0dG9uXy50aXRsZSA9IHRpcExhYmVsO1xuICAgIHRoaXMudG9nZ2xlQnV0dG9uXy5hcHBlbmRDaGlsZChhY3RpdmVMYWJlbCk7XG5cbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcyksXG4gICAgICBmYWxzZSxcbiAgICApO1xuXG4gICAgY29uc3QgY3NzQ2xhc3NlcyA9XG4gICAgICBjbGFzc05hbWUgK1xuICAgICAgJyAnICtcbiAgICAgIENMQVNTX1VOU0VMRUNUQUJMRSArXG4gICAgICAnICcgK1xuICAgICAgQ0xBU1NfQ09OVFJPTCArXG4gICAgICAodGhpcy5jb2xsYXBzZWRfICYmIHRoaXMuY29sbGFwc2libGVfID8gJyAnICsgQ0xBU1NfQ09MTEFQU0VEIDogJycpICtcbiAgICAgICh0aGlzLmNvbGxhcHNpYmxlXyA/ICcnIDogJyBvbC11bmNvbGxhcHNpYmxlJyk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXM7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRvZ2dsZUJ1dHRvbl8pO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy51bEVsZW1lbnRfKTtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBjdXJyZW50bHkgcmVuZGVyZWQgcmVzb2x1dGlvbnMuXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3QgYSBsaXN0IG9mIHZpc2libGUgYXR0cmlidXRpb25zIGFuZCBzZXQgdGhlIGNvbGxhcHNpYmxlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBdHRyaWJ1dGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb2xsZWN0U291cmNlQXR0cmlidXRpb25zXyhmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRNYXAoKS5nZXRBbGxMYXllcnMoKTtcbiAgICBjb25zdCB2aXNpYmxlQXR0cmlidXRpb25zID0gbmV3IFNldChcbiAgICAgIGxheWVycy5mbGF0TWFwKChsYXllcikgPT4gbGF5ZXIuZ2V0QXR0cmlidXRpb25zKGZyYW1lU3RhdGUpKSxcbiAgICApO1xuICAgIGlmICh0aGlzLmF0dHJpYnV0aW9uc18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmF0dHJpYnV0aW9uc18pXG4gICAgICAgID8gdGhpcy5hdHRyaWJ1dGlvbnNfLmZvckVhY2goKGl0ZW0pID0+IHZpc2libGVBdHRyaWJ1dGlvbnMuYWRkKGl0ZW0pKVxuICAgICAgICA6IHZpc2libGVBdHRyaWJ1dGlvbnMuYWRkKHRoaXMuYXR0cmlidXRpb25zXyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm92ZXJyaWRlQ29sbGFwc2libGVfKSB7XG4gICAgICBjb25zdCBjb2xsYXBzaWJsZSA9ICFsYXllcnMuc29tZShcbiAgICAgICAgKGxheWVyKSA9PiBsYXllci5nZXRTb3VyY2UoKT8uZ2V0QXR0cmlidXRpb25zQ29sbGFwc2libGUoKSA9PT0gZmFsc2UsXG4gICAgICApO1xuICAgICAgdGhpcy5zZXRDb2xsYXBzaWJsZShjb2xsYXBzaWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZpc2libGVBdHRyaWJ1dGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlRWxlbWVudF8oZnJhbWVTdGF0ZSkge1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLmNvbGxlY3RTb3VyY2VBdHRyaWJ1dGlvbnNfKGZyYW1lU3RhdGUpLm1hcCgoYXR0cmlidXRpb24pID0+XG4gICAgICAgIHRvUHJvbWlzZSgoKSA9PiBhdHRyaWJ1dGlvbiksXG4gICAgICApLFxuICAgICk7XG5cbiAgICBjb25zdCB2aXNpYmxlID0gYXR0cmlidXRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXyAhPSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyhhdHRyaWJ1dGlvbnMsIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMudWxFbGVtZW50Xyk7XG5cbiAgICAvLyBhcHBlbmQgdGhlIGF0dHJpYnV0aW9uc1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGF0dHJpYnV0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gYXR0cmlidXRpb25zW2ldO1xuICAgICAgdGhpcy51bEVsZW1lbnRfLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfID0gYXR0cmlidXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2xpY2tfKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmhhbmRsZVRvZ2dsZV8oKTtcbiAgICB0aGlzLnVzZXJDb2xsYXBzZWRfID0gdGhpcy5jb2xsYXBzZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUb2dnbGVfKCkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX0NPTExBUFNFRCk7XG4gICAgaWYgKHRoaXMuY29sbGFwc2VkXykge1xuICAgICAgcmVwbGFjZU5vZGUodGhpcy5jb2xsYXBzZUxhYmVsXywgdGhpcy5sYWJlbF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlTm9kZSh0aGlzLmxhYmVsXywgdGhpcy5jb2xsYXBzZUxhYmVsXyk7XG4gICAgfVxuICAgIHRoaXMuY29sbGFwc2VkXyA9ICF0aGlzLmNvbGxhcHNlZF87XG4gICAgdGhpcy50b2dnbGVCdXR0b25fLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIFN0cmluZyghdGhpcy5jb2xsYXBzZWRfKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRpb24gaXMgY29sbGFwc2libGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2libGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbGxhcHNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhcHNpYmxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0aGUgYXR0cmlidXRpb24gc2hvdWxkIGJlIGNvbGxhcHNpYmxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNpYmxlIFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sbGFwc2libGUoY29sbGFwc2libGUpIHtcbiAgICBpZiAodGhpcy5jb2xsYXBzaWJsZV8gPT09IGNvbGxhcHNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29sbGFwc2libGVfID0gY29sbGFwc2libGU7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ29sLXVuY29sbGFwc2libGUnKTtcbiAgICBpZiAodGhpcy51c2VyQ29sbGFwc2VkXykge1xuICAgICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxhcHNlIG9yIGV4cGFuZCB0aGUgYXR0cmlidXRpb24gYWNjb3JkaW5nIHRvIHRoZSBwYXNzZWQgcGFyYW1ldGVyLiBXaWxsXG4gICAqIG5vdCBkbyBhbnl0aGluZyBpZiB0aGUgYXR0cmlidXRpb24gaXNuJ3QgY29sbGFwc2libGUgb3IgaWYgdGhlIGN1cnJlbnRcbiAgICogY29sbGFwc2VkIHN0YXRlIGlzIGFscmVhZHkgdGhlIG9uZSByZXF1ZXN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sbGFwc2VkIFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvbGxhcHNlZChjb2xsYXBzZWQpIHtcbiAgICB0aGlzLnVzZXJDb2xsYXBzZWRfID0gY29sbGFwc2VkO1xuICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZV8gfHwgdGhpcy5jb2xsYXBzZWRfID09PSBjb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCB3aGVuIHRoZSBhdHRyaWJ1dGlvbiBpcyBjdXJyZW50bHkgY29sbGFwc2VkIG9yIGBmYWxzZWBcbiAgICogb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2VkLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0aW9uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcihtYXBFdmVudCkge1xuICAgIHRoaXMudXBkYXRlRWxlbWVudF8obWFwRXZlbnQuZnJhbWVTdGF0ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9Db250cm9sXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4uL01hcEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbZWxlbWVudF0gVGhlIGVsZW1lbnQgaXMgdGhlIGNvbnRyb2wnc1xuICogY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgb25seSBuZWVkcyB0byBiZSBzcGVjaWZpZWQgaWYgeW91J3JlIGRldmVsb3BpbmdcbiAqIGEgY3VzdG9tIGNvbnRyb2wuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuXG4gKiB0aGUgY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnRcbiAqIHRoZSBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb250cm9sIGlzIGEgdmlzaWJsZSB3aWRnZXQgd2l0aCBhIERPTSBlbGVtZW50IGluIGEgZml4ZWQgcG9zaXRpb24gb24gdGhlXG4gKiBzY3JlZW4uIFRoZXkgY2FuIGludm9sdmUgdXNlciBpbnB1dCAoYnV0dG9ucyksIG9yIGJlIGluZm9ybWF0aW9uYWwgb25seTtcbiAqIHRoZSBwb3NpdGlvbiBpcyBkZXRlcm1pbmVkIHVzaW5nIENTUy4gQnkgZGVmYXVsdCB0aGVzZSBhcmUgcGxhY2VkIGluIHRoZVxuICogY29udGFpbmVyIHdpdGggQ1NTIGNsYXNzIG5hbWUgYG9sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50YCwgYnV0IGNhbiB1c2VcbiAqIGFueSBvdXRzaWRlIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGNvbnRyb2xzLiBZb3UgY2FuIHVzZSBpdCBmb3Igc2ltcGxlIGN1c3RvbVxuICogY29udHJvbHMgYnkgY3JlYXRpbmcgdGhlIGVsZW1lbnQgd2l0aCBsaXN0ZW5lcnMsIGNyZWF0aW5nIGFuIGluc3RhbmNlOlxuICogYGBganNcbiAqIGNvbnN0IG15Q29udHJvbCA9IG5ldyBDb250cm9sKHtlbGVtZW50OiBteUVsZW1lbnR9KTtcbiAqIGBgYFxuICogYW5kIHRoZW4gYWRkaW5nIHRoaXMgdG8gdGhlIG1hcC5cbiAqXG4gKiBUaGUgbWFpbiBhZHZhbnRhZ2Ugb2YgaGF2aW5nIHRoaXMgYXMgYSBjb250cm9sIHJhdGhlciB0aGFuIGEgc2ltcGxlIHNlcGFyYXRlXG4gKiBET00gZWxlbWVudCBpcyB0aGF0IHByZXZlbnRpbmcgcHJvcGFnYXRpb24gaXMgaGFuZGxlZCBmb3IgeW91LiBDb250cm9sc1xuICogd2lsbCBhbHNvIGJlIG9iamVjdHMgaW4gYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0sIHNvIHlvdSBjYW4gdXNlIHRoZWlyIG1ldGhvZHMuXG4gKlxuICogWW91IGNhbiBhbHNvIGV4dGVuZCB0aGlzIGJhc2UgZm9yIHlvdXIgb3duIGNvbnRyb2wgY2xhc3MuIFNlZVxuICogZXhhbXBsZXMvY3VzdG9tLWNvbnRyb2xzIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byBkbyB0aGlzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ29udHJvbCBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIENvbnRyb2wgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgICBpZiAoZWxlbWVudCAmJiAhb3B0aW9ucy50YXJnZXQgJiYgIWVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cykge1xuICAgICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudCA/IGVsZW1lbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJLZXlzID0gW107XG5cbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICB0aGlzLnNldFRhcmdldChvcHRpb25zLnRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICB0aGlzLmVsZW1lbnQ/LnJlbW92ZSgpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2wuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb250cm9sIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFBhc3MgYG51bGxgIHRvIGp1c3QgcmVtb3ZlIHRoZSBjb250cm9sIGZyb20gdGhlIGN1cnJlbnQgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IG1hcCBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICB0aGlzLmVsZW1lbnQ/LnJlbW92ZSgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmxpc3RlbmVyS2V5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubGlzdGVuZXJLZXlzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcktleXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gICAgaWYgKG1hcCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXRfID8/IG1hcC5nZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50KCk7XG4gICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVuZGVyICE9PSBWT0lEKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJLZXlzLnB1c2goXG4gICAgICAgICAgbGlzdGVuKG1hcCwgTWFwRXZlbnRUeXBlLlBPU1RSRU5ERVIsIHRoaXMucmVuZGVyLCB0aGlzKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1hcC5yZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udHJvbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBFdmVudCBNYXAgZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbmRlcihtYXBFdmVudCkge31cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHNldCBhIHRhcmdldCBlbGVtZW50IGZvciB0aGUgY29udHJvbC4gSXQgaGFzIG5vXG4gICAqIGVmZmVjdCBpZiBpdCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbnRyb2wgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIG1hcCAoaS5lLlxuICAgKiBhZnRlciBgc2V0TWFwYCBpcyBjYWxsZWQgb24gdGhlIGNvbnRyb2wpLiBJZiBubyBgdGFyZ2V0YCBpcyBzZXQgaW4gdGhlXG4gICAqIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBjb250cm9sIGNvbnN0cnVjdG9yIGFuZCBpZiBgc2V0VGFyZ2V0YCBpcyBub3QgY2FsbGVkXG4gICAqIHRoZW4gdGhlIGNvbnRyb2wgaXMgYWRkZWQgdG8gdGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHN0cmluZ30gdGFyZ2V0IFRhcmdldC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0XyA9XG4gICAgICB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkgOiB0YXJnZXQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL1JvdGF0ZVxuICovXG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfSElEREVOLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLXJvdGF0ZSddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtsYWJlbD0n4oenJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSByb3RhdGUgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpcExhYmVsPSdSZXNldCByb3RhdGlvbiddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgcm90YXRlIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29tcGFzc0NsYXNzTmFtZT0nb2wtY29tcGFzcyddIENTUyBjbGFzcyBuYW1lIGZvciB0aGUgY29tcGFzcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b0hpZGU9dHJ1ZV0gSGlkZSB0aGUgY29udHJvbCB3aGVuIHJvdGF0aW9uIGlzIDAuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIHNob3VsZFxuICogYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6dm9pZH0gW3Jlc2V0Tm9ydGhdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIGlzIGNsaWNrZWQuXG4gKiBUaGlzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYHJlc2V0Tm9ydGhgLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBidXR0b24gY29udHJvbCB0byByZXNldCByb3RhdGlvbiB0byAwLlxuICogVG8gc3R5bGUgdGhpcyBjb250cm9sIHVzZSBjc3Mgc2VsZWN0b3IgYC5vbC1yb3RhdGVgLiBBIGAub2wtaGlkZGVuYCBjc3NcbiAqIHNlbGVjdG9yIGlzIGFkZGVkIHRvIHRoZSBidXR0b24gd2hlbiB0aGUgcm90YXRpb24gaXMgMC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFJvdGF0ZSBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gUm90YXRlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHJlbmRlcjogb3B0aW9ucy5yZW5kZXIsXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1yb3RhdGUnO1xuXG4gICAgY29uc3QgbGFiZWwgPSBvcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxhYmVsIDogJ1xcdTIxRTcnO1xuXG4gICAgY29uc3QgY29tcGFzc0NsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNvbXBhc3NDbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuY29tcGFzc0NsYXNzTmFtZVxuICAgICAgICA6ICdvbC1jb21wYXNzJztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxfID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMubGFiZWxfLmNsYXNzTmFtZSA9IGNvbXBhc3NDbGFzc05hbWU7XG4gICAgICB0aGlzLmxhYmVsXy50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGxhYmVsO1xuICAgICAgdGhpcy5sYWJlbF8uY2xhc3NMaXN0LmFkZChjb21wYXNzQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aXBMYWJlbCA9IG9wdGlvbnMudGlwTGFiZWwgPyBvcHRpb25zLnRpcExhYmVsIDogJ1Jlc2V0IHJvdGF0aW9uJztcblxuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLXJlc2V0JztcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi50aXRsZSA9IHRpcExhYmVsO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsXyk7XG5cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcyksXG4gICAgICBmYWxzZSxcbiAgICApO1xuXG4gICAgY29uc3QgY3NzQ2xhc3NlcyA9XG4gICAgICBjbGFzc05hbWUgKyAnICcgKyBDTEFTU19VTlNFTEVDVEFCTEUgKyAnICcgKyBDTEFTU19DT05UUk9MO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYWxsUmVzZXROb3J0aF8gPSBvcHRpb25zLnJlc2V0Tm9ydGggPyBvcHRpb25zLnJlc2V0Tm9ydGggOiB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmF1dG9IaWRlXyA9IG9wdGlvbnMuYXV0b0hpZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0b0hpZGUgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmF1dG9IaWRlXykge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfSElEREVOKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGlja18oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLmNhbGxSZXNldE5vcnRoXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGxSZXNldE5vcnRoXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0Tm9ydGhfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldE5vcnRoXygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICghdmlldykge1xuICAgICAgLy8gdGhlIG1hcCBkb2VzIG5vdCBoYXZlIGEgdmlldywgc28gd2UgY2FuJ3QgYWN0XG4gICAgICAvLyB1cG9uIGl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwICYmIHJvdGF0aW9uICUgKDIgKiBNYXRoLlBJKSAhPT0gMCkge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRSb3RhdGlvbigwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSByb3RhdGUgY29udHJvbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXIobWFwRXZlbnQpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gbWFwRXZlbnQuZnJhbWVTdGF0ZTtcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT0gdGhpcy5yb3RhdGlvbl8pIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ3JhZCknO1xuICAgICAgaWYgKHRoaXMuYXV0b0hpZGVfKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19ISURERU4pO1xuICAgICAgICBpZiAoIWNvbnRhaW5zICYmIHJvdGF0aW9uID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfSElEREVOKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWlucyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX0hJRERFTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSb3RhdGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9ab29tXG4gKi9cbmltcG9ydCBDb250cm9sIGZyb20gJy4vQ29udHJvbC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtDTEFTU19DT05UUk9MLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtem9vbSddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tSW5DbGFzc05hbWU9Y2xhc3NOYW1lICsgJy1pbiddIENTUyBjbGFzcyBuYW1lIGZvciB0aGUgem9vbS1pbiBidXR0b24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb21PdXRDbGFzc05hbWU9Y2xhc3NOYW1lICsgJy1vdXQnXSBDU1MgY2xhc3MgbmFtZSBmb3IgdGhlIHpvb20tb3V0IGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbem9vbUluTGFiZWw9JysnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIHpvb20taW5cbiAqIGJ1dHRvbi4gSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW3pvb21PdXRMYWJlbD0n4oCTJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSB6b29tLW91dCBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbUluVGlwTGFiZWw9J1pvb20gaW4nXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb21PdXRUaXBMYWJlbD0nWm9vbSBvdXQnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gZWFjaCBjbGljay5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50IHRoZSBjb250cm9sIHRvIGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29udHJvbCB3aXRoIDIgYnV0dG9ucywgb25lIGZvciB6b29tIGluIGFuZCBvbmUgZm9yIHpvb20gb3V0LlxuICogVGhpcyBjb250cm9sIGlzIG9uZSBvZiB0aGUgZGVmYXVsdCBjb250cm9scyBvZiBhIG1hcC4gVG8gc3R5bGUgdGhpcyBjb250cm9sXG4gKiB1c2UgY3NzIHNlbGVjdG9ycyBgLm9sLXpvb20taW5gIGFuZCBgLm9sLXpvb20tb3V0YC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFpvb20gZXh0ZW5kcyBDb250cm9sIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIFpvb20gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbGFzc05hbWUgOiAnb2wtem9vbSc7XG5cbiAgICBjb25zdCBkZWx0YSA9IG9wdGlvbnMuZGVsdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgY29uc3Qgem9vbUluQ2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuem9vbUluQ2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnpvb21JbkNsYXNzTmFtZVxuICAgICAgICA6IGNsYXNzTmFtZSArICctaW4nO1xuXG4gICAgY29uc3Qgem9vbU91dENsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLnpvb21PdXRDbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuem9vbU91dENsYXNzTmFtZVxuICAgICAgICA6IGNsYXNzTmFtZSArICctb3V0JztcblxuICAgIGNvbnN0IHpvb21JbkxhYmVsID1cbiAgICAgIG9wdGlvbnMuem9vbUluTGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuem9vbUluTGFiZWwgOiAnKyc7XG4gICAgY29uc3Qgem9vbU91dExhYmVsID1cbiAgICAgIG9wdGlvbnMuem9vbU91dExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21PdXRMYWJlbCA6ICdcXHUyMDEzJztcblxuICAgIGNvbnN0IHpvb21JblRpcExhYmVsID1cbiAgICAgIG9wdGlvbnMuem9vbUluVGlwTGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuem9vbUluVGlwTGFiZWwgOiAnWm9vbSBpbic7XG4gICAgY29uc3Qgem9vbU91dFRpcExhYmVsID1cbiAgICAgIG9wdGlvbnMuem9vbU91dFRpcExhYmVsICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnpvb21PdXRUaXBMYWJlbFxuICAgICAgICA6ICdab29tIG91dCc7XG5cbiAgICBjb25zdCBpbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBpbkVsZW1lbnQuY2xhc3NOYW1lID0gem9vbUluQ2xhc3NOYW1lO1xuICAgIGluRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgaW5FbGVtZW50LnRpdGxlID0gem9vbUluVGlwTGFiZWw7XG4gICAgaW5FbGVtZW50LmFwcGVuZENoaWxkKFxuICAgICAgdHlwZW9mIHpvb21JbkxhYmVsID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHpvb21JbkxhYmVsKVxuICAgICAgICA6IHpvb21JbkxhYmVsLFxuICAgICk7XG5cbiAgICBpbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcywgZGVsdGEpLFxuICAgICAgZmFsc2UsXG4gICAgKTtcblxuICAgIGNvbnN0IG91dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBvdXRFbGVtZW50LmNsYXNzTmFtZSA9IHpvb21PdXRDbGFzc05hbWU7XG4gICAgb3V0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgb3V0RWxlbWVudC50aXRsZSA9IHpvb21PdXRUaXBMYWJlbDtcbiAgICBvdXRFbGVtZW50LmFwcGVuZENoaWxkKFxuICAgICAgdHlwZW9mIHpvb21PdXRMYWJlbCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh6b29tT3V0TGFiZWwpXG4gICAgICAgIDogem9vbU91dExhYmVsLFxuICAgICk7XG5cbiAgICBvdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICB0aGlzLmhhbmRsZUNsaWNrXy5iaW5kKHRoaXMsIC1kZWx0YSksXG4gICAgICBmYWxzZSxcbiAgICApO1xuXG4gICAgY29uc3QgY3NzQ2xhc3NlcyA9XG4gICAgICBjbGFzc05hbWUgKyAnICcgKyBDTEFTU19VTlNFTEVDVEFCTEUgKyAnICcgKyBDTEFTU19DT05UUk9MO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5FbGVtZW50KTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKG91dEVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgWm9vbSBkZWx0YS5cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGlja18oZGVsdGEsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnpvb21CeURlbHRhXyhkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFpvb20gZGVsdGEuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB6b29tQnlEZWx0YV8oZGVsdGEpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICghdmlldykge1xuICAgICAgLy8gdGhlIG1hcCBkb2VzIG5vdCBoYXZlIGEgdmlldywgc28gd2UgY2FuJ3QgYWN0XG4gICAgICAvLyB1cG9uIGl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRab29tID0gdmlldy5nZXRab29tKCk7XG4gICAgaWYgKGN1cnJlbnRab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5ld1pvb20gPSB2aWV3LmdldENvbnN0cmFpbmVkWm9vbShjdXJyZW50Wm9vbSArIGRlbHRhKTtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uXyA+IDApIHtcbiAgICAgICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHpvb206IG5ld1pvb20sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3LnNldFpvb20obmV3Wm9vbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpvb207XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9kZWZhdWx0c1xuICovXG5pbXBvcnQgQXR0cmlidXRpb24gZnJvbSAnLi9BdHRyaWJ1dGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBSb3RhdGUgZnJvbSAnLi9Sb3RhdGUuanMnO1xuaW1wb3J0IFpvb20gZnJvbSAnLi9ab29tLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uPXRydWVdIEluY2x1ZGVcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9BdHRyaWJ1dGlvbn5BdHRyaWJ1dGlvbn0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vQXR0cmlidXRpb24uanNcIikuT3B0aW9uc30gW2F0dHJpYnV0aW9uT3B0aW9uc11cbiAqIE9wdGlvbnMgZm9yIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9BdHRyaWJ1dGlvbn5BdHRyaWJ1dGlvbn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGU9dHJ1ZV0gSW5jbHVkZVxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX5Sb3RhdGV9LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1JvdGF0ZS5qc1wiKS5PcHRpb25zfSBbcm90YXRlT3B0aW9uc10gT3B0aW9uc1xuICogZm9yIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Sb3RhdGV+Um90YXRlfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3pvb21dIEluY2x1ZGUge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vWm9vbS5qc1wiKS5PcHRpb25zfSBbem9vbU9wdGlvbnNdIE9wdGlvbnMgZm9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfS5cbiAqL1xuXG4vKipcbiAqIFNldCBvZiBjb250cm9scyBpbmNsdWRlZCBpbiBtYXBzIGJ5IGRlZmF1bHQuIFVubGVzcyBjb25maWd1cmVkIG90aGVyd2lzZSxcbiAqIHRoaXMgcmV0dXJucyBhIGNvbGxlY3Rpb24gY29udGFpbmluZyBhbiBpbnN0YW5jZSBvZiBlYWNoIG9mIHRoZSBmb2xsb3dpbmdcbiAqIGNvbnRyb2xzOlxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufVxuICpcbiAqIEBwYXJhbSB7RGVmYXVsdHNPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGRlZmF1bHQgY29udHJvbHMuXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gQSBjb2xsZWN0aW9uIG9mIGNvbnRyb2xzXG4gKiB0byBiZSB1c2VkIHdpdGggdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gY29uc3RydWN0b3IncyBgY29udHJvbHNgIG9wdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgY29uc3QgY29udHJvbHMgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIGNvbnN0IHpvb21Db250cm9sID0gb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb20gOiB0cnVlO1xuICBpZiAoem9vbUNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBab29tKG9wdGlvbnMuem9vbU9wdGlvbnMpKTtcbiAgfVxuXG4gIGNvbnN0IHJvdGF0ZUNvbnRyb2wgPSBvcHRpb25zLnJvdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGUgOiB0cnVlO1xuICBpZiAocm90YXRlQ29udHJvbCkge1xuICAgIGNvbnRyb2xzLnB1c2gobmV3IFJvdGF0ZShvcHRpb25zLnJvdGF0ZU9wdGlvbnMpKTtcbiAgfVxuXG4gIGNvbnN0IGF0dHJpYnV0aW9uQ29udHJvbCA9XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hdHRyaWJ1dGlvbiA6IHRydWU7XG4gIGlmIChhdHRyaWJ1dGlvbkNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zLmF0dHJpYnV0aW9uT3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nvb3JkaW5hdGVcbiAqL1xuaW1wb3J0IHtnZXRXaWR0aH0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHttb2R1bG8sIHRvRml4ZWR9IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge3BhZE51bWJlcn0gZnJvbSAnLi9zdHJpbmcuanMnO1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGFuIGB4eWAsIGB4eXpgIG9yIGB4eXptYCBjb29yZGluYXRlLlxuICogRXhhbXBsZTogYFsxNiwgNDhdYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBDb29yZGluYXRlXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYW5kXG4gKiB0cmFuc2Zvcm1zIGl0IGludG8gYSBge3N0cmluZ31gLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoQ29vcmRpbmF0ZXx1bmRlZmluZWQpKTogc3RyaW5nfSBDb29yZGluYXRlRm9ybWF0XG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBBZGQgYGRlbHRhYCB0byBgY29vcmRpbmF0ZWAuIGBjb29yZGluYXRlYCBpcyBtb2RpZmllZCBpbiBwbGFjZSBhbmQgcmV0dXJuZWRcbiAqIGJ5IHRoZSBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge2FkZH0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgYWRkKGNvb3JkLCBbLTIsIDRdKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWzUuODUsIDUxLjk4MzMzM11cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gZGVsdGEgRGVsdGEuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBUaGUgaW5wdXQgY29vcmRpbmF0ZSBhZGp1c3RlZCBieVxuICogdGhlIGdpdmVuIGRlbHRhLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvb3JkaW5hdGUsIGRlbHRhKSB7XG4gIGNvb3JkaW5hdGVbMF0gKz0gK2RlbHRhWzBdO1xuICBjb29yZGluYXRlWzFdICs9ICtkZWx0YVsxXTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgb24gdGhlIHBhc3NlZCBjaXJjbGUuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZSBUaGUgY2lyY2xlLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gQ2xvc2VzdCBwb2ludCBvbiB0aGUgY2lyY3VtZmVyZW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RPbkNpcmNsZShjb29yZGluYXRlLCBjaXJjbGUpIHtcbiAgY29uc3QgciA9IGNpcmNsZS5nZXRSYWRpdXMoKTtcbiAgY29uc3QgY2VudGVyID0gY2lyY2xlLmdldENlbnRlcigpO1xuICBjb25zdCB4MCA9IGNlbnRlclswXTtcbiAgY29uc3QgeTAgPSBjZW50ZXJbMV07XG4gIGNvbnN0IHgxID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeTEgPSBjb29yZGluYXRlWzFdO1xuXG4gIGxldCBkeCA9IHgxIC0geDA7XG4gIGNvbnN0IGR5ID0geTEgLSB5MDtcbiAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgZHggPSAxO1xuICB9XG4gIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIGNvbnN0IHggPSB4MCArIChyICogZHgpIC8gZDtcbiAgY29uc3QgeSA9IHkwICsgKHIgKiBkeSkgLyBkO1xuXG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgb24gdGhlIHBhc3NlZCBzZWdtZW50LlxuICogVGhpcyBpcyB0aGUgZm9vdCBvZiB0aGUgcGVycGVuZGljdWxhciBvZiB0aGUgY29vcmRpbmF0ZSB0byB0aGUgc2VnbWVudCB3aGVuXG4gKiB0aGUgZm9vdCBpcyBvbiB0aGUgc2VnbWVudCwgb3IgdGhlIGNsb3Nlc3Qgc2VnbWVudCBjb29yZGluYXRlIHdoZW4gdGhlIGZvb3RcbiAqIGlzIG91dHNpZGUgdGhlIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gc2VnbWVudCBUaGUgdHdvIGNvb3JkaW5hdGVzXG4gKiBvZiB0aGUgc2VnbWVudC5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mXG4gKiB0aGUgY29vcmRpbmF0ZSB0byB0aGUgc2VnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RPblNlZ21lbnQoY29vcmRpbmF0ZSwgc2VnbWVudCkge1xuICBjb25zdCB4MCA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkwID0gY29vcmRpbmF0ZVsxXTtcbiAgY29uc3Qgc3RhcnQgPSBzZWdtZW50WzBdO1xuICBjb25zdCBlbmQgPSBzZWdtZW50WzFdO1xuICBjb25zdCB4MSA9IHN0YXJ0WzBdO1xuICBjb25zdCB5MSA9IHN0YXJ0WzFdO1xuICBjb25zdCB4MiA9IGVuZFswXTtcbiAgY29uc3QgeTIgPSBlbmRbMV07XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBjb25zdCBhbG9uZyA9XG4gICAgZHggPT09IDAgJiYgZHkgPT09IDBcbiAgICAgID8gMFxuICAgICAgOiAoZHggKiAoeDAgLSB4MSkgKyBkeSAqICh5MCAtIHkxKSkgLyAoZHggKiBkeCArIGR5ICogZHkgfHwgMCk7XG4gIGxldCB4LCB5O1xuICBpZiAoYWxvbmcgPD0gMCkge1xuICAgIHggPSB4MTtcbiAgICB5ID0geTE7XG4gIH0gZWxzZSBpZiAoYWxvbmcgPj0gMSkge1xuICAgIHggPSB4MjtcbiAgICB5ID0geTI7XG4gIH0gZWxzZSB7XG4gICAgeCA9IHgxICsgYWxvbmcgKiBkeDtcbiAgICB5ID0geTEgKyBhbG9uZyAqIGR5O1xuICB9XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlRm9ybWF0fSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICogdXNlZCB0byBmb3JtYXRcbiAqIGEge0Nvb3JkaW5hdGV9IHRvIGEgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtjcmVhdGVTdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgc3RyaW5naWZ5RnVuYyA9IGNyZWF0ZVN0cmluZ1hZKCk7XG4gKiAgICAgY29uc3Qgb3V0ID0gc3RyaW5naWZ5RnVuYyhjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnOCwgNDgnXG4gKlxuICogRXhhbXBsZSB3aXRoIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAyIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2NyZWF0ZVN0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBzdHJpbmdpZnlGdW5jID0gY3JlYXRlU3RyaW5nWFkoMik7XG4gKiAgICAgY29uc3Qgb3V0ID0gc3RyaW5naWZ5RnVuYyhjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNy44NSwgNDcuOTgnXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZUZvcm1hdH0gQ29vcmRpbmF0ZSBmb3JtYXQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJpbmdYWShmcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIFhZLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb29yZGluYXRlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmdYWShjb29yZGluYXRlLCBmcmFjdGlvbkRpZ2l0cyk7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZW1pc3BoZXJlcyBIZW1pc3BoZXJlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIERlZ3JlZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXNUb1N0cmluZ0hETVMoaGVtaXNwaGVyZXMsIGRlZ3JlZXMsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWREZWdyZWVzID0gbW9kdWxvKGRlZ3JlZXMgKyAxODAsIDM2MCkgLSAxODA7XG4gIGNvbnN0IHggPSBNYXRoLmFicygzNjAwICogbm9ybWFsaXplZERlZ3JlZXMpO1xuICBjb25zdCBkZWNpbWFscyA9IGZyYWN0aW9uRGlnaXRzIHx8IDA7XG5cbiAgbGV0IGRlZyA9IE1hdGguZmxvb3IoeCAvIDM2MDApO1xuICBsZXQgbWluID0gTWF0aC5mbG9vcigoeCAtIGRlZyAqIDM2MDApIC8gNjApO1xuICBsZXQgc2VjID0gdG9GaXhlZCh4IC0gZGVnICogMzYwMCAtIG1pbiAqIDYwLCBkZWNpbWFscyk7XG5cbiAgaWYgKHNlYyA+PSA2MCkge1xuICAgIHNlYyA9IDA7XG4gICAgbWluICs9IDE7XG4gIH1cblxuICBpZiAobWluID49IDYwKSB7XG4gICAgbWluID0gMDtcbiAgICBkZWcgKz0gMTtcbiAgfVxuXG4gIGxldCBoZG1zID0gZGVnICsgJ1xcdTAwYjAnO1xuICBpZiAobWluICE9PSAwIHx8IHNlYyAhPT0gMCkge1xuICAgIGhkbXMgKz0gJyAnICsgcGFkTnVtYmVyKG1pbiwgMikgKyAnXFx1MjAzMic7XG4gIH1cbiAgaWYgKHNlYyAhPT0gMCkge1xuICAgIGhkbXMgKz0gJyAnICsgcGFkTnVtYmVyKHNlYywgMiwgZGVjaW1hbHMpICsgJ1xcdTIwMzMnO1xuICB9XG4gIGlmIChub3JtYWxpemVkRGVncmVlcyAhPT0gMCkge1xuICAgIGhkbXMgKz0gJyAnICsgaGVtaXNwaGVyZXMuY2hhckF0KG5vcm1hbGl6ZWREZWdyZWVzIDwgMCA/IDEgOiAwKTtcbiAgfVxuXG4gIHJldHVybiBoZG1zO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSB0byBhIHN0cmluZ1xuICogdXNpbmcgdGhlIGdpdmVuIHN0cmluZyB0ZW1wbGF0ZS4gVGhlIHN0cmluZ3MgYHt4fWAgYW5kIGB7eX1gIGluIHRoZSB0ZW1wbGF0ZVxuICogd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNvb3JkaW5hdGUgdmFsdWVzIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyB0aGUgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Zm9ybWF0fSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCB0ZW1wbGF0ZSA9ICdDb29yZGluYXRlIGlzICh7eH18e3l9KS4nO1xuICogICAgIGNvbnN0IG91dCA9IGZvcm1hdChjb29yZCwgdGVtcGxhdGUpO1xuICogICAgIC8vIG91dCBpcyBub3cgJ0Nvb3JkaW5hdGUgaXMgKDh8NDgpLidcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyB0aGUgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Zm9ybWF0fSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCB0ZW1wbGF0ZSA9ICdDb29yZGluYXRlIGlzICh7eH18e3l9KS4nO1xuICogICAgIGNvbnN0IG91dCA9IGZvcm1hdChjb29yZCwgdGVtcGxhdGUsIDIpO1xuICogICAgIC8vIG91dCBpcyBub3cgJ0Nvb3JkaW5hdGUgaXMgKDcuODV8NDcuOTgpLidcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBBIHRlbXBsYXRlIHN0cmluZyB3aXRoIGB7eH1gIGFuZCBge3l9YCBwbGFjZWhvbGRlcnNcbiAqICAgICB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgYnkgZmlyc3QgYW5kIHNlY29uZCBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoY29vcmRpbmF0ZSwgdGVtcGxhdGUsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIGlmIChjb29yZGluYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlXG4gICAgICAucmVwbGFjZSgne3h9JywgY29vcmRpbmF0ZVswXS50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSlcbiAgICAgIC5yZXBsYWNlKCd7eX0nLCBjb29yZGluYXRlWzFdLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gY29vcmRpbmF0ZXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGNvb3JkaW5hdGUxLCBjb29yZGluYXRlMikge1xuICBsZXQgZXF1YWxzID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IGNvb3JkaW5hdGUxLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKGNvb3JkaW5hdGUxW2ldICE9IGNvb3JkaW5hdGUyW2ldKSB7XG4gICAgICBlcXVhbHMgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXF1YWxzO1xufVxuXG4vKipcbiAqIFJvdGF0ZSBgY29vcmRpbmF0ZWAgYnkgYGFuZ2xlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZFxuICogcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7cm90YXRlfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCByb3RhdGVSYWRpYW5zID0gTWF0aC5QSSAvIDI7IC8vIDkwIGRlZ3JlZXNcbiAqICAgICByb3RhdGUoY29vcmQsIHJvdGF0ZVJhZGlhbnMpO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbLTQ3Ljk4MzMzMywgNy44NV1cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiByYWRpYW4uXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGNvb3JkaW5hdGUsIGFuZ2xlKSB7XG4gIGNvbnN0IGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xuICBjb25zdCBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgY29uc3QgeCA9IGNvb3JkaW5hdGVbMF0gKiBjb3NBbmdsZSAtIGNvb3JkaW5hdGVbMV0gKiBzaW5BbmdsZTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV0gKiBjb3NBbmdsZSArIGNvb3JkaW5hdGVbMF0gKiBzaW5BbmdsZTtcbiAgY29vcmRpbmF0ZVswXSA9IHg7XG4gIGNvb3JkaW5hdGVbMV0gPSB5O1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBTY2FsZSBgY29vcmRpbmF0ZWAgYnkgYHNjYWxlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7c2NhbGUgYXMgc2NhbGVDb29yZGluYXRlfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBzY2FsZSA9IDEuMjtcbiAqICAgICBzY2FsZUNvb3JkaW5hdGUoY29vcmQsIHNjYWxlKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWzkuNDIsIDU3LjU3OTk5OTZdXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgU2NhbGUgZmFjdG9yLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKGNvb3JkaW5hdGUsIHNjYWxlKSB7XG4gIGNvb3JkaW5hdGVbMF0gKj0gc2NhbGU7XG4gIGNvb3JkaW5hdGVbMV0gKj0gc2NhbGU7XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGNvb3JkMSBhbmQgY29vcmQyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSB7XG4gIGNvbnN0IGR4ID0gY29vcmQxWzBdIC0gY29vcmQyWzBdO1xuICBjb25zdCBkeSA9IGNvb3JkMVsxXSAtIGNvb3JkMlsxXTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiBjb29yZDEgYW5kIGNvb3JkMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZERpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGZyb20gYSBjb29yZGluYXRlIHRvIGEgbGluZSBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8Q29vcmRpbmF0ZT59IHNlZ21lbnQgTGluZSBzZWdtZW50ICgyXG4gKiBjb29yZGluYXRlcykuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGxpbmUgc2VnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSB7XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoY29vcmRpbmF0ZSwgY2xvc2VzdE9uU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSk7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgZ2VvZ3JhcGhpYyBjb29yZGluYXRlIHdpdGggdGhlIGhlbWlzcGhlcmUsIGRlZ3JlZXMsIG1pbnV0ZXMsIGFuZFxuICogc2Vjb25kcy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ0hETVN9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IG91dCA9IHRvU3RyaW5nSERNUyhjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNDfCsCA1OOKAsiA2MOKAsyBOIDfCsCA1MOKAsiA2MOKAsyBFJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIDEgZnJhY3Rpb25hbCBkaWdpdDpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ0hETVN9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IG91dCA9IHRvU3RyaW5nSERNUyhjb29yZCwgMSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNDfCsCA1OOKAsiA2MC4w4oCzIE4gN8KwIDUw4oCyIDYwLjDigLMgRSdcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcyBhbmQgc2Vjb25kcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nSERNUyhjb29yZGluYXRlLCBmcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBkZWdyZWVzVG9TdHJpbmdIRE1TKCdOUycsIGNvb3JkaW5hdGVbMV0sIGZyYWN0aW9uRGlnaXRzKSArXG4gICAgICAnICcgK1xuICAgICAgZGVncmVlc1RvU3RyaW5nSERNUygnRVcnLCBjb29yZGluYXRlWzBdLCBmcmFjdGlvbkRpZ2l0cylcbiAgICApO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBjb29yZGluYXRlIGFzIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ1hZKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdYWShjb29yZCwgMSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNy44LCA0OC4wJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBYWS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nWFkoY29vcmRpbmF0ZSwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgcmV0dXJuIGZvcm1hdChjb29yZGluYXRlLCAne3h9LCB7eX0nLCBmcmFjdGlvbkRpZ2l0cyk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGUgaW4tcGxhY2UgdG8gYmUgd2l0aGluIHRoZSByZWFsIHdvcmxkXG4gKiBleHRlbnQuIFRoZSBsb3dlciBwcm9qZWN0aW9uIGV4dGVudCBib3VuZGFyeSBpcyBpbmNsdXNpdmUsIHRoZSB1cHBlciBvbmVcbiAqIGV4Y2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgd2l0aGluIHRoZSByZWFsIHdvcmxkIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKGNvb3JkaW5hdGUsIHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSkge1xuICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uLmdldEV4dGVudCgpKTtcbiAgICBjb25zdCB3b3JsZHNBd2F5ID0gZ2V0V29ybGRzQXdheShjb29yZGluYXRlLCBwcm9qZWN0aW9uLCB3b3JsZFdpZHRoKTtcbiAgICBpZiAod29ybGRzQXdheSkge1xuICAgICAgY29vcmRpbmF0ZVswXSAtPSB3b3JsZHNBd2F5ICogd29ybGRXaWR0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW3NvdXJjZUV4dGVudFdpZHRoXSBXaWR0aCBvZiB0aGUgc291cmNlIGV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gT2Zmc2V0IGluIHdvcmxkIHdpZHRocy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmxkc0F3YXkoY29vcmRpbmF0ZSwgcHJvamVjdGlvbiwgc291cmNlRXh0ZW50V2lkdGgpIHtcbiAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGxldCB3b3JsZHNBd2F5ID0gMDtcbiAgaWYgKFxuICAgIHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgIChjb29yZGluYXRlWzBdIDwgcHJvamVjdGlvbkV4dGVudFswXSB8fCBjb29yZGluYXRlWzBdID4gcHJvamVjdGlvbkV4dGVudFsyXSlcbiAgKSB7XG4gICAgc291cmNlRXh0ZW50V2lkdGggPSBzb3VyY2VFeHRlbnRXaWR0aCB8fCBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICB3b3JsZHNBd2F5ID0gTWF0aC5mbG9vcihcbiAgICAgIChjb29yZGluYXRlWzBdIC0gcHJvamVjdGlvbkV4dGVudFswXSkgLyBzb3VyY2VFeHRlbnRXaWR0aCxcbiAgICApO1xuICB9XG4gIHJldHVybiB3b3JsZHNBd2F5O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nzc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRm9udFBhcmFtZXRlcnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZSBTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YXJpYW50IFZhcmlhbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gd2VpZ2h0IFdlaWdodC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaXplIFNpemUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUhlaWdodCBMaW5lSGVpZ2h0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseSBGYW1pbHkuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGZhbWlsaWVzIEZhbWlsaWVzLlxuICovXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyBmb3IgaGlkZGVuIGZlYXR1cmUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfSElEREVOID0gJ29sLWhpZGRlbic7XG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0byBoYXZlIHRoZW0gc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19TRUxFQ1RBQkxFID0gJ29sLXNlbGVjdGFibGUnO1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdG8gaGF2ZSB0aGVtIHVuc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19VTlNFTEVDVEFCTEUgPSAnb2wtdW5zZWxlY3RhYmxlJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciB1bnN1cHBvcnRlZCBmZWF0dXJlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX1VOU1VQUE9SVEVEID0gJ29sLXVuc3VwcG9ydGVkJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciBjb250cm9scy5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19DT05UUk9MID0gJ29sLWNvbnRyb2wnO1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdGhhdCBhcmUgY29sbGFwc2VkLCBpLmUuXG4gKiB0byB0aG9zZSBlbGVtZW50cyB3aGljaCB1c3VhbGx5IGNhbiBiZSBleHBhbmRlZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19DT0xMQVBTRUQgPSAnb2wtY29sbGFwc2VkJztcblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMTM1Njk3L3JlZ2V4LXRvLXBhcnNlLWFueS1jc3MtZm9udFxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgZm9udFJlZ0V4ID0gbmV3IFJlZ0V4cChcbiAgW1xuICAgICdeXFxcXHMqKD89KD86KD86Wy1hLXpdK1xcXFxzKil7MCwyfShpdGFsaWN8b2JsaXF1ZSkpPyknLFxuICAgICcoPz0oPzooPzpbLWEtel0rXFxcXHMqKXswLDJ9KHNtYWxsLWNhcHMpKT8pJyxcbiAgICAnKD89KD86KD86Wy1hLXpdK1xcXFxzKil7MCwyfShib2xkKD86ZXIpP3xsaWdodGVyfFsxLTldMDAgKSk/KScsXG4gICAgJyg/Oig/Om5vcm1hbHxcXFxcMXxcXFxcMnxcXFxcMylcXFxccyopezAsM30oKD86eHg/LSk/JyxcbiAgICAnKD86c21hbGx8bGFyZ2UpfG1lZGl1bXxzbWFsbGVyfGxhcmdlcnxbXFxcXC5cXFxcZF0rKD86XFxcXCV8aW58W2NlbV1tfGV4fHBbY3R4XSkpJyxcbiAgICAnKD86XFxcXHMqXFxcXC9cXFxccyoobm9ybWFsfFtcXFxcLlxcXFxkXSsoPzpcXFxcJXxpbnxbY2VtXW18ZXh8cFtjdHhdKT8pKScsXG4gICAgJz9cXFxccyooWy0sXFxcXFwiXFxcXFxcJ1xcXFxzYS16XSs/KVxcXFxzKiQnLFxuICBdLmpvaW4oJycpLFxuICAnaScsXG4pO1xuLyoqIEB0eXBlIHtBcnJheTwnc3R5bGUnfCd2YXJpYW50J3wnd2VpZ2h0J3wnc2l6ZSd8J2xpbmVIZWlnaHQnfCdmYW1pbHknPn0gKi9cbmNvbnN0IGZvbnRSZWdFeE1hdGNoSW5kZXggPSBbXG4gICdzdHlsZScsXG4gICd2YXJpYW50JyxcbiAgJ3dlaWdodCcsXG4gICdzaXplJyxcbiAgJ2xpbmVIZWlnaHQnLFxuICAnZmFtaWx5Jyxcbl07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIGZvbnQgZmFtaWxpZXMgZnJvbSBhIGZvbnQgc3BlYy4gIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3Qgd29ya1xuICogZm9yIGZvbnQgZmFtaWxpZXMgdGhhdCBoYXZlIGNvbW1hcyBpbiB0aGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTcGVjIFRoZSBDU1MgZm9udCBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0ZvbnRQYXJhbWV0ZXJzfG51bGx9IFRoZSBmb250IHBhcmFtZXRlcnMgKG9yIG51bGwgaWYgdGhlIGlucHV0IHNwZWMgaXMgaW52YWxpZCkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGb250UGFyYW1ldGVycyA9IGZ1bmN0aW9uIChmb250U3BlYykge1xuICBjb25zdCBtYXRjaCA9IGZvbnRTcGVjLm1hdGNoKGZvbnRSZWdFeCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7Rm9udFBhcmFtZXRlcnN9ICovICh7XG4gICAgbGluZUhlaWdodDogJ25vcm1hbCcsXG4gICAgc2l6ZTogJzEuMmVtJyxcbiAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB2YXJpYW50OiAnbm9ybWFsJyxcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGZvbnRSZWdFeE1hdGNoSW5kZXgubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHlsZVtmb250UmVnRXhNYXRjaEluZGV4W2ldXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBzdHlsZS5mYW1pbGllcyA9IHN0eWxlLmZhbWlseS5zcGxpdCgvLFxccz8vKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcbiIsImltcG9ydCB7V09SS0VSX09GRlNDUkVFTl9DQU5WQVN9IGZyb20gJy4vaGFzLmpzJztcblxuLyoqXG4gKiBAbW9kdWxlIG9sL2RvbVxuICovXG5cbi8vRklYTUUgTW92ZSB0aGlzIGZ1bmN0aW9uIHRvIHRoZSBjYW52YXMgbW9kdWxlXG4vKipcbiAqIENyZWF0ZSBhbiBodG1sIGNhbnZhcyBlbGVtZW50IGFuZCByZXR1cm5zIGl0cyAyZCBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gQ2FudmFzIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIENhbnZhcyBoZWlnaHQuXG4gKiBAcGFyYW0ge0FycmF5PEhUTUxDYW52YXNFbGVtZW50Pn0gW2NhbnZhc1Bvb2xdIENhbnZhcyBwb29sIHRvIHRha2UgZXhpc3RpbmcgY2FudmFzIGZyb20uXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFNldHRpbmdzfSBbc2V0dGluZ3NdIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFNldHRpbmdzXG4gKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQsIGNhbnZhc1Bvb2wsIHNldHRpbmdzKSB7XG4gIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzfSAqL1xuICBsZXQgY2FudmFzO1xuICBpZiAoY2FudmFzUG9vbCAmJiBjYW52YXNQb29sLmxlbmd0aCkge1xuICAgIGNhbnZhcyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChjYW52YXNQb29sLnNoaWZ0KCkpO1xuICB9IGVsc2UgaWYgKFdPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTKSB7XG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCB8fCAzMDAsIGhlaWdodCB8fCAzMDApO1xuICB9IGVsc2Uge1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB9XG4gIGlmICh3aWR0aCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICB9XG4gIGlmIChoZWlnaHQpIHtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIC8vRklYTUUgQWxsb3cgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGFzIHJldHVybiB0eXBlXG4gIHJldHVybiAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi8gKFxuICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHNldHRpbmdzKVxuICApO1xufVxuXG4vKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi9cbmxldCBzaGFyZWRDYW52YXNDb250ZXh0O1xuXG4vKipcbiAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gU2hhcmVkIGNhbnZhcyBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkQ2FudmFzQ29udGV4dDJEKCkge1xuICBpZiAoIXNoYXJlZENhbnZhc0NvbnRleHQpIHtcbiAgICBzaGFyZWRDYW52YXNDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICB9XG4gIHJldHVybiBzaGFyZWRDYW52YXNDb250ZXh0O1xufVxuXG4vKipcbiAqIFJlbGVhc2VzIGNhbnZhcyBtZW1vcnkgdG8gYXZvaWQgZXhjZWVkaW5nIG1lbW9yeSBsaW1pdHMgaW4gU2FmYXJpLlxuICogU2VlIGh0dHBzOi8vcHFpbmEubmwvYmxvZy90b3RhbC1jYW52YXMtbWVtb3J5LXVzZS1leGNlZWRzLXRoZS1tYXhpbXVtLWxpbWl0L1xuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VDYW52YXMoY29udGV4dCkge1xuICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgY2FudmFzLndpZHRoID0gMTtcbiAgY2FudmFzLmhlaWdodCA9IDE7XG4gIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDEsIDEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBjb21wdXRlZCB3aWR0aCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVyV2lkdGgodHJ1ZSlgLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3V0ZXJXaWR0aChlbGVtZW50KSB7XG4gIGxldCB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgd2lkdGggKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCwgMTApICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQsIDEwKTtcblxuICByZXR1cm4gd2lkdGg7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIGhlaWdodCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVySGVpZ2h0KHRydWUpYC5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckhlaWdodChlbGVtZW50KSB7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBoZWlnaHQgKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20sIDEwKTtcblxuICByZXR1cm4gaGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBOb2RlIHRvIHJlcGxhY2Ugb2xkIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gb2xkTm9kZSBUaGUgbm9kZSB0byBiZSByZXBsYWNlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGUobmV3Tm9kZSwgb2xkTm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBvbGROb2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZSB0aGUgY2hpbGRyZW4gZnJvbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5sYXN0Q2hpbGQucmVtb3ZlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGNoaWxkcmVuIG9mIGEgcGFyZW50IG5vZGUgc28gdGhleSBtYXRjaCB0aGVcbiAqIHByb3ZpZGVkIGxpc3Qgb2YgY2hpbGRyZW4uICBUaGlzIGZ1bmN0aW9uIGFpbXMgdG8gZWZmaWNpZW50bHlcbiAqIHJlbW92ZSwgYWRkLCBhbmQgcmVvcmRlciBjaGlsZCBub2RlcyB3aGlsZSBtYWludGFpbmluZyBhIHNpbXBsZVxuICogaW1wbGVtZW50YXRpb24gKGl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIG1pbmltaXplIERPTSBvcGVyYXRpb25zKS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgcGFyZW50IG5vZGUgd2hvc2UgY2hpbGRyZW4gbmVlZCByZXdvcmtpbmcuXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBjaGlsZHJlbiBUaGUgZGVzaXJlZCBjaGlsZHJlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZHJlbihub2RlLCBjaGlsZHJlbikge1xuICBjb25zdCBvbGRDaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcblxuICBmb3IgKGxldCBpID0gMDsgdHJ1ZTsgKytpKSB7XG4gICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRDaGlsZHJlbltpXTtcbiAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgLy8gY2hlY2sgaWYgb3VyIHdvcmsgaXMgZG9uZVxuICAgIGlmICghb2xkQ2hpbGQgJiYgIW5ld0NoaWxkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBjaGlsZHJlbiBtYXRjaFxuICAgIGlmIChvbGRDaGlsZCA9PT0gbmV3Q2hpbGQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGEgbmV3IGNoaWxkIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgaWYgKCFvbGRDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbiBvbGQgY2hpbGQgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgIGlmICghbmV3Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQob2xkQ2hpbGQpO1xuICAgICAgLS1pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVvcmRlclxuICAgIG5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9lYXNpbmdcbiAqL1xuXG4vKipcbiAqIFN0YXJ0IHNsb3cgYW5kIHNwZWVkIHVwLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZUluKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDMpO1xufVxuXG4vKipcbiAqIFN0YXJ0IGZhc3QgYW5kIHNsb3cgZG93bi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhc2VPdXQodCkge1xuICByZXR1cm4gMSAtIGVhc2VJbigxIC0gdCk7XG59XG5cbi8qKlxuICogU3RhcnQgc2xvdywgc3BlZWQgdXAsIGFuZCB0aGVuIHNsb3cgZG93biBhZ2Fpbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluQW5kT3V0KHQpIHtcbiAgcmV0dXJuIDMgKiB0ICogdCAtIDIgKiB0ICogdCAqIHQ7XG59XG5cbi8qKlxuICogTWFpbnRhaW4gYSBjb25zdGFudCBzcGVlZCBvdmVyIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXIodCkge1xuICByZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBTdGFydCBzbG93LCBzcGVlZCB1cCwgYW5kIGF0IHRoZSB2ZXJ5IGVuZCBzbG93IGRvd24gYWdhaW4uICBUaGlzIGhhcyB0aGVcbiAqIHNhbWUgZ2VuZXJhbCBiZWhhdmlvciBhcyB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZy5pbkFuZE91dH0sIGJ1dCB0aGUgZmluYWxcbiAqIHNsb3dkb3duIGlzIGRlbGF5ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cEFuZERvd24odCkge1xuICBpZiAodCA8IDAuNSkge1xuICAgIHJldHVybiBpbkFuZE91dCgyICogdCk7XG4gIH1cbiAgcmV0dXJuIDEgLSBpbkFuZE91dCgyICogKHQgLSAwLjUpKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHNcbiAqL1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi9vYmouanMnO1xuXG4vKipcbiAqIEtleSB0byB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGUudW5CeUtleX0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudHNLZXlcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUeXBlLlxuICogQGFwaVxuICovXG5cbi8qKlxuICogTGlzdGVuZXIgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYW4gZXZlbnQgb2JqZWN0IGFzIGFyZ3VtZW50LlxuICogV2hlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCBldmVudCBwcm9wYWdhdGlvbiB3aWxsIHN0b3AuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KSk6ICh2b2lkfGJvb2xlYW4pfSBMaXN0ZW5lckZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaXN0ZW5lck9iamVjdFxuICogQHByb3BlcnR5IHtMaXN0ZW5lckZ1bmN0aW9ufSBoYW5kbGVFdmVudCBIYW5kbGVFdmVudCBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtMaXN0ZW5lckZ1bmN0aW9ufExpc3RlbmVyT2JqZWN0fSBMaXN0ZW5lclxuICovXG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIHRvIGEgYHRoaXNgIG9iamVjdCwgYW5kIHJldHVybnNcbiAqIGEga2V5IGZvciB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy51bmxpc3RlbkJ5S2V5fS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHtMaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc0FyZ10gT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29uY2VdIElmIHRydWUsIGFkZCB0aGUgbGlzdGVuZXIgYXMgb25lLW9mZiBsaXN0ZW5lci5cbiAqIEByZXR1cm4ge0V2ZW50c0tleX0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHRoaXNBcmcsIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICBjb25zdCBvcmlnaW5hbExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgLyoqXG4gICAgICogQHRoaXMge3R5cGVvZiB0YXJnZXR9XG4gICAgICovXG4gICAgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBvcmlnaW5hbExpc3RlbmVyLmFwcGx5KHRoaXNBcmcgPz8gdGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHRoaXNBcmcgJiYgdGhpc0FyZyAhPT0gdGFyZ2V0KSB7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5iaW5kKHRoaXNBcmcpO1xuICB9XG4gIGNvbnN0IGV2ZW50c0tleSA9IHtcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgfTtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICByZXR1cm4gZXZlbnRzS2V5O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG9uZS1vZmYgZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVGhpcyBmdW5jdGlvbiBlZmZpY2llbnRseSBiaW5kcyBhIGBsaXN0ZW5lcmAgYXMgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyXG4gKiB0byBhIGB0aGlzYCBvYmplY3QsIGFuZCByZXR1cm5zIGEga2V5IGZvciB1c2Ugd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMudW5saXN0ZW5CeUtleX0gaW4gY2FzZSB0aGUgbGlzdGVuZXIgbmVlZHMgdG8gYmVcbiAqIHVucmVnaXN0ZXJlZCBiZWZvcmUgaXQgaXMgY2FsbGVkLlxuICpcbiAqIFdoZW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMubGlzdGVufSBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYWZ0ZXIgdGhpc1xuICogZnVuY3Rpb24sIHRoZSBzZWxmLXVucmVnaXN0ZXJpbmcgbGlzdGVuZXIgd2lsbCBiZSB0dXJuZWQgaW50byBhIHBlcm1hbmVudFxuICogbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoaXNBcmddIE9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBgdGhpc2Aga2V5d29yZCBpbiB0aGVcbiAqICAgICBsaXN0ZW5lci4gRGVmYXVsdCBpcyB0aGUgYHRhcmdldGAuXG4gKiBAcmV0dXJuIHtFdmVudHNLZXl9IEtleSBmb3IgdW5saXN0ZW5CeUtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbk9uY2UodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgdGhpc0FyZykge1xuICByZXR1cm4gbGlzdGVuKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHRoaXNBcmcsIHRydWUpO1xufVxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIGtleSByZXR1cm5lZCBmcm9tXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy5saXN0ZW59IG9yIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzLmxpc3Rlbk9uY2V9LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRzS2V5fSBrZXkgVGhlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQnlLZXkoa2V5KSB7XG4gIGlmIChrZXkgJiYga2V5LnRhcmdldCkge1xuICAgIGtleS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXkudHlwZSwga2V5Lmxpc3RlbmVyKTtcbiAgICBjbGVhcihrZXkpO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTdHJpcHBlZCBkb3duIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLWludGVyZmFjZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9ubHkgcHJvdmlkZXMgYHR5cGVgIGFuZCBgdGFyZ2V0YCBwcm9wZXJ0aWVzLCBhbmRcbiAqIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG1ldGhvZHMuIEl0IGlzIG1lYW50IGFzIGJhc2UgY2xhc3NcbiAqIGZvciBoaWdoZXIgbGV2ZWwgZXZlbnRzIGRlZmluZWQgaW4gdGhlIGxpYnJhcnksIGFuZCB3b3JrcyB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9UYXJnZXR+VGFyZ2V0fS5cbiAqL1xuY2xhc3MgQmFzZUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudCBkZWZhdWx0LiBUaGlzIG1lYW5zIHRoYXQgbm8gZW11bGF0ZWQgYGNsaWNrYCwgYHNpbmdsZWNsaWNrYCBvciBgZG91YmxlY2xpY2tgIGV2ZW50c1xuICAgKiB3aWxsIGJlIGZpcmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZ0KSB7XG4gIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldnQpIHtcbiAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VFdmVudDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEdlbmVyaWMgY2hhbmdlIGV2ZW50LiBUcmlnZ2VyZWQgd2hlbiB0aGUgcmV2aXNpb24gY291bnRlciBpcyBpbmNyZWFzZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkJhc2VFdmVudCNjaGFuZ2VcbiAgICogQGFwaVxuICAgKi9cbiAgQ0hBTkdFOiAnY2hhbmdlJyxcblxuICAvKipcbiAgICogR2VuZXJpYyBlcnJvciBldmVudC4gVHJpZ2dlcmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5CYXNlRXZlbnQjZXJyb3JcbiAgICogQGFwaVxuICAgKi9cbiAgRVJST1I6ICdlcnJvcicsXG5cbiAgQkxVUjogJ2JsdXInLFxuICBDTEVBUjogJ2NsZWFyJyxcbiAgQ09OVEVYVE1FTlU6ICdjb250ZXh0bWVudScsXG4gIENMSUNLOiAnY2xpY2snLFxuICBEQkxDTElDSzogJ2RibGNsaWNrJyxcbiAgRFJBR0VOVEVSOiAnZHJhZ2VudGVyJyxcbiAgRFJBR09WRVI6ICdkcmFnb3ZlcicsXG4gIERST1A6ICdkcm9wJyxcbiAgRk9DVVM6ICdmb2N1cycsXG4gIEtFWURPV046ICdrZXlkb3duJyxcbiAgS0VZUFJFU1M6ICdrZXlwcmVzcycsXG4gIExPQUQ6ICdsb2FkJyxcbiAgUkVTSVpFOiAncmVzaXplJyxcbiAgVE9VQ0hNT1ZFOiAndG91Y2htb3ZlJyxcbiAgV0hFRUw6ICd3aGVlbCcsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9LZXlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBMRUZUOiAnQXJyb3dMZWZ0JyxcbiAgVVA6ICdBcnJvd1VwJyxcbiAgUklHSFQ6ICdBcnJvd1JpZ2h0JyxcbiAgRE9XTjogJ0Fycm93RG93bicsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9UYXJnZXRcbiAqL1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9FdmVudC5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFdmVudFRhcmdldHxUYXJnZXR9IEV2ZW50VGFyZ2V0TGlrZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnRUYXJnZXQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1FdmVudHMtMjAwMDExMTMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gaW1wb3J0YW50IHNpbXBsaWZpY2F0aW9ucyBjb21wYXJlZCB0byB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqXG4gKiAxLiBUaGUgaGFuZGxpbmcgb2YgYHVzZUNhcHR1cmVgIGluIGBhZGRFdmVudExpc3RlbmVyYCBhbmRcbiAqICAgIGByZW1vdmVFdmVudExpc3RlbmVyYC4gVGhlcmUgaXMgbm8gcmVhbCBjYXB0dXJlIG1vZGVsLlxuICogMi4gVGhlIGhhbmRsaW5nIG9mIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG9uIGBkaXNwYXRjaEV2ZW50YC5cbiAqICAgIFRoZXJlIGlzIG5vIGV2ZW50IHRhcmdldCBoaWVyYXJjaHkuIFdoZW4gYSBsaXN0ZW5lciBjYWxsc1xuICogICAgYHN0b3BQcm9wYWdhdGlvbmAgb3IgYHByZXZlbnREZWZhdWx0YCBvbiBhbiBldmVudCBvYmplY3QsIGl0IG1lYW5zIHRoYXQgbm9cbiAqICAgIG1vcmUgbGlzdGVuZXJzIGFmdGVyIHRoaXMgb25lIHdpbGwgYmUgY2FsbGVkLiBTYW1lIGFzIHdoZW4gdGhlIGxpc3RlbmVyXG4gKiAgICByZXR1cm5zIGZhbHNlLlxuICovXG5jbGFzcyBUYXJnZXQgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gW3RhcmdldF0gRGVmYXVsdCBldmVudCB0YXJnZXQgZm9yIGRpc3BhdGNoZWQgZXZlbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy5ldmVudFRhcmdldF8gPSB0YXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3BhdGNoaW5nXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXI+PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJzXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXJ9IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdHlwZSB8fCAhbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfIHx8ICh0aGlzLmxpc3RlbmVyc18gPSB7fSk7XG4gICAgY29uc3QgbGlzdGVuZXJzRm9yVHlwZSA9IGxpc3RlbmVyc1t0eXBlXSB8fCAobGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICAgIGlmICghbGlzdGVuZXJzRm9yVHlwZS5pbmNsdWRlcyhsaXN0ZW5lcikpIHtcbiAgICAgIGxpc3RlbmVyc0ZvclR5cGUucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIGNhbGxzIGFsbCBsaXN0ZW5lcnMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICogb2YgdGhpcyB0eXBlLiBUaGUgZXZlbnQgcGFyYW1ldGVyIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYW5cbiAgICogT2JqZWN0IHdpdGggYSBgdHlwZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fHN0cmluZ30gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gYGZhbHNlYCBpZiBhbnlvbmUgY2FsbGVkIHByZXZlbnREZWZhdWx0IG9uIHRoZVxuICAgKiAgICAgZXZlbnQgb2JqZWN0IG9yIGlmIGFueSBvZiB0aGUgbGlzdGVuZXJzIHJldHVybmVkIGZhbHNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0cmluZyA/IGV2ZW50IDogZXZlbnQudHlwZTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc18gJiYgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXZ0ID0gaXNTdHJpbmcgPyBuZXcgRXZlbnQoZXZlbnQpIDogLyoqIEB0eXBlIHtFdmVudH0gKi8gKGV2ZW50KTtcbiAgICBpZiAoIWV2dC50YXJnZXQpIHtcbiAgICAgIGV2dC50YXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0XyB8fCB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBkaXNwYXRjaGluZyA9IHRoaXMuZGlzcGF0Y2hpbmdfIHx8ICh0aGlzLmRpc3BhdGNoaW5nXyA9IHt9KTtcbiAgICBjb25zdCBwZW5kaW5nUmVtb3ZhbHMgPVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfIHx8ICh0aGlzLnBlbmRpbmdSZW1vdmFsc18gPSB7fSk7XG4gICAgaWYgKCEodHlwZSBpbiBkaXNwYXRjaGluZykpIHtcbiAgICAgIGRpc3BhdGNoaW5nW3R5cGVdID0gMDtcbiAgICAgIHBlbmRpbmdSZW1vdmFsc1t0eXBlXSA9IDA7XG4gICAgfVxuICAgICsrZGlzcGF0Y2hpbmdbdHlwZV07XG4gICAgbGV0IHByb3BhZ2F0ZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKCdoYW5kbGVFdmVudCcgaW4gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyT2JqZWN0fSAqLyAoXG4gICAgICAgICAgbGlzdGVuZXJzW2ldXG4gICAgICAgICkuaGFuZGxlRXZlbnQoZXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb259ICovIChcbiAgICAgICAgICBsaXN0ZW5lcnNbaV1cbiAgICAgICAgKS5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcGFnYXRlID09PSBmYWxzZSB8fCBldnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKC0tZGlzcGF0Y2hpbmdbdHlwZV0gPT09IDApIHtcbiAgICAgIGxldCBwciA9IHBlbmRpbmdSZW1vdmFsc1t0eXBlXTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVtb3ZhbHNbdHlwZV07XG4gICAgICB3aGlsZSAocHItLSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgVk9JRCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgZGlzcGF0Y2hpbmdbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiBwcm9wYWdhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMubGlzdGVuZXJzXyAmJiBjbGVhcih0aGlzLmxpc3RlbmVyc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLiBMaXN0ZW5lcnMgYXJlIHJldHVybmVkIGluIHRoZVxuICAgKiBvcmRlciB0aGF0IHRoZXkgd2lsbCBiZSBjYWxsZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lcj58dW5kZWZpbmVkfSBMaXN0ZW5lcnMuXG4gICAqL1xuICBnZXRMaXN0ZW5lcnModHlwZSkge1xuICAgIHJldHVybiAodGhpcy5saXN0ZW5lcnNfICYmIHRoaXMubGlzdGVuZXJzX1t0eXBlXSkgfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVHlwZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgYHRydWVgIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhpcyBldmVudCB0YXJnZXQgaGFzIGFueSBsaXN0ZW5lcnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEhhcyBsaXN0ZW5lcnMuXG4gICAqL1xuICBoYXNMaXN0ZW5lcih0eXBlKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc18pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVcbiAgICAgID8gdHlwZSBpbiB0aGlzLmxpc3RlbmVyc19cbiAgICAgIDogT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnNfKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ1JlbW92YWxzXyAmJiB0eXBlIGluIHRoaXMucGVuZGluZ1JlbW92YWxzXykge1xuICAgICAgICAvLyBtYWtlIGxpc3RlbmVyIGEgbm8tb3AsIGFuZCByZW1vdmUgbGF0ZXIgaW4gI2Rpc3BhdGNoRXZlbnQoKVxuICAgICAgICBsaXN0ZW5lcnNbaW5kZXhdID0gVk9JRDtcbiAgICAgICAgKyt0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRhcmdldDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvY29uZGl0aW9uXG4gKi9cbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtGQUxTRSwgVFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7TUFDLCBXRUJLSVR9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBge2Jvb2xlYW59YC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQsIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbih0aGlzOiA/LCBpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IENvbmRpdGlvblxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IHBhc3NlcyB3aGVuIGFsbCBwcm92aWRlZCBjb25kaXRpb25zIHBhc3MuXG4gKiBAcGFyYW0gey4uLkNvbmRpdGlvbn0gdmFyX2FyZ3MgQ29uZGl0aW9ucyB0byBjaGVjay5cbiAqIEByZXR1cm4ge0NvbmRpdGlvbn0gQ29uZGl0aW9uIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsKHZhcl9hcmdzKSB7XG4gIGNvbnN0IGNvbmRpdGlvbnMgPSBhcmd1bWVudHM7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQWxsIGNvbmRpdGlvbnMgcGFzc2VkLlxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGxldCBwYXNzID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb25kaXRpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHBhc3MgPSBwYXNzICYmIGNvbmRpdGlvbnNbaV0oZXZlbnQpO1xuICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFzcztcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIGFsdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlblxuICogYWRkaXRpb25hbGx5IHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBhbHRLZXlPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgIW9yaWdpbmFsRXZlbnQuc2hpZnRLZXlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBhbHQta2V5IGFuZCBzaGlmdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIChlLmcuIHdoZW4gYWRkaXRpb25hbGx5IHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQgYW5kIHNoaWZ0IGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBhbHRTaGlmdEtleXNPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBtYXAgaGFzIHRoZSBmb2N1cy4gVGhpcyBjb25kaXRpb24gcmVxdWlyZXMgYSBtYXAgdGFyZ2V0XG4gKiBlbGVtZW50IHdpdGggYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSwgZS5nLiBgPGRpdiBpZD1cIm1hcFwiIHRhYmluZGV4PVwiMVwiPmAuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbWFwIGhhcyB0aGUgZm9jdXMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBmb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZXZlbnQubWFwLmdldFRhcmdldEVsZW1lbnQoKTtcbiAgY29uc3Qgcm9vdE5vZGUgPSB0YXJnZXRFbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBldmVudC5tYXAuZ2V0T3duZXJEb2N1bWVudCgpLmFjdGl2ZUVsZW1lbnQ7XG5cbiAgcmV0dXJuIHJvb3ROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdFxuICAgID8gcm9vdE5vZGUuaG9zdC5jb250YWlucyhhY3RpdmVFbGVtZW50KVxuICAgIDogdGFyZ2V0RWxlbWVudC5jb250YWlucyhhY3RpdmVFbGVtZW50KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgbWFwIGhhcyB0aGUgZm9jdXMgb3Igbm8gJ3RhYmluZGV4JyBhdHRyaWJ1dGUgc2V0LlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG1hcCBjb250YWluZXIgaGFzIHRoZSBmb2N1cyBvciBubyAndGFiaW5kZXgnIGF0dHJpYnV0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGZvY3VzV2l0aFRhYmluZGV4ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBldmVudC5tYXAuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuICBjb25zdCByb290Tm9kZSA9IHRhcmdldEVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgY29uc3QgdGFiSW5kZXhDYW5kaWRhdGUgPVxuICAgIHJvb3ROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3ROb2RlLmhvc3QgOiB0YXJnZXRFbGVtZW50O1xuXG4gIHJldHVybiB0YWJJbmRleENhbmRpZGF0ZS5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPyBmb2N1cyhldmVudCkgOiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYWx3YXlzIHRydWUuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGFsd2F5cyA9IFRSVUU7XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaXMgYSBgY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgY2xpY2tgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgY2xpY2sgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkNMSUNLO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBoYXMgYW4gXCJhY3Rpb25cIi1wcm9kdWNpbmcgbW91c2UgYnV0dG9uLlxuICpcbiAqIEJ5IGRlZmluaXRpb24sIHRoaXMgaW5jbHVkZXMgbGVmdC1jbGljayBvbiB3aW5kb3dzL2xpbnV4LCBhbmQgbGVmdC1jbGlja1xuICogd2l0aG91dCB0aGUgY3RybCBrZXkgb24gTWFjcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVzdWx0LlxuICovXG5leHBvcnQgY29uc3QgbW91c2VBY3Rpb25CdXR0b24gPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gb3JpZ2luYWxFdmVudC5idXR0b24gPT0gMCAmJiAhKFdFQktJVCAmJiBNQUMgJiYgb3JpZ2luYWxFdmVudC5jdHJsS2V5KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFsd2F5cyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IG5ldmVyID0gRkFMU0U7XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBldmVudCBpcyBhIGBwb2ludGVybW92ZWAgZXZlbnQsIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBicm93c2VyIGV2ZW50IGlzIGEgYHBvaW50ZXJtb3ZlYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gJ3BvaW50ZXJtb3ZlJztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYHNpbmdsZWNsaWNrYCBldmVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYHNpbmdsZWNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHNpbmdsZUNsaWNrID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYGRibGNsaWNrYCBldmVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYGRibGNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGRvdWJsZUNsaWNrID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBubyBtb2RpZmllciBrZXkgKGFsdC0sIHNoaWZ0LSBvciBwbGF0Zm9ybS1tb2RpZmllci1rZXkpIGlzXG4gKiBwcmVzc2VkLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb25seSBpZiB0aGVyZSBubyBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgbm9Nb2RpZmllcktleXMgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgcmV0dXJuIChcbiAgICAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgIW9yaWdpbmFsRXZlbnQuc2hpZnRLZXlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgKHRoZSBtZXRhLWtleSBvbiBNYWMsXG4gKiBjdHJsLWtleSBvdGhlcndpc2UpIGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW4gYWRkaXRpb25hbGx5XG4gKiB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgcGxhdGZvcm0gbW9kaWZpZXIga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBwbGF0Zm9ybU1vZGlmaWVyS2V5T25seSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gKFxuICAgICFvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgIChNQUMgPyBvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgOiBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgIW9yaWdpbmFsRXZlbnQuc2hpZnRLZXlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGxhdGZvcm0tbW9kaWZpZXIta2V5ICh0aGUgbWV0YS1rZXkgb24gTWFjLFxuICogY3RybC1rZXkgb3RoZXJ3aXNlKSBpcyBwcmVzc2VkLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXRmb3JtIG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgcGxhdGZvcm1Nb2RpZmllcktleSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gTUFDID8gb3JpZ2luYWxFdmVudC5tZXRhS2V5IDogb3JpZ2luYWxFdmVudC5jdHJsS2V5O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHNoaWZ0LWtleSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZSAoZS5nLiB3aGVuXG4gKiBhZGRpdGlvbmFsbHkgdGhlIGFsdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHNoaWZ0S2V5T25seSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gKFxuICAgICFvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5XG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBlZGl0YWJsZSwgaS5lLiBub3QgYW4gYGlucHV0YCxcbiAqIGBzZWxlY3RgLCBvciBgdGV4dGFyZWFgIGVsZW1lbnQgYW5kIG5vIGBjb250ZW50ZWRpdGFibGVgIGF0dHJpYnV0ZSBpc1xuICogc2V0IG9yIGluaGVyaXRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvbmx5IGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBub3QgZWRpdGFibGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCB0YXJnZXROb3RFZGl0YWJsZSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICBjb25zdCB0YWdOYW1lID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAob3JpZ2luYWxFdmVudC50YXJnZXQpLnRhZ05hbWU7XG4gIHJldHVybiAoXG4gICAgdGFnTmFtZSAhPT0gJ0lOUFVUJyAmJlxuICAgIHRhZ05hbWUgIT09ICdTRUxFQ1QnICYmXG4gICAgdGFnTmFtZSAhPT0gJ1RFWFRBUkVBJyAmJlxuICAgIC8vIGBpc0NvbnRlbnRFZGl0YWJsZWAgaXMgb25seSBhdmFpbGFibGUgb24gYEhUTUxFbGVtZW50YCwgYnV0IGl0IG1heSBhbHNvIGJlIGFcbiAgICAvLyBkaWZmZXJlbnQgdHlwZSBsaWtlIGBTVkdFbGVtZW50YC5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgIW9yaWdpbmFsRXZlbnQudGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlXG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIG1vdXNlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBtb3VzZSBkZXZpY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBtb3VzZU9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdmVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50XCIpLmRlZmF1bHR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnRcbiAgKS5vcmlnaW5hbEV2ZW50O1xuICBhc3NlcnQoXG4gICAgcG9pbnRlckV2ZW50ICE9PSB1bmRlZmluZWQsXG4gICAgJ21hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudCcsXG4gICk7XG4gIC8vIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jd2lkbC1Qb2ludGVyRXZlbnQtcG9pbnRlclR5cGVcbiAgcmV0dXJuIHBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PSAnbW91c2UnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSB0b3VjaGFibGUgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHRvdWNoYWJsZSBkZXZpY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCB0b3VjaE9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50XG4gICkub3JpZ2luYWxFdmVudDtcbiAgYXNzZXJ0KFxuICAgIHBvaW50ZXJFdnQgIT09IHVuZGVmaW5lZCxcbiAgICAnbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50JyxcbiAgKTtcbiAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN3aWRsLVBvaW50ZXJFdmVudC1wb2ludGVyVHlwZVxuICByZXR1cm4gcG9pbnRlckV2dC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgZGlnaXRhbCBwZW4uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgZGlnaXRhbCBwZW4uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBwZW5Pbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBwb2ludGVyRXZ0ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnRcIikuZGVmYXVsdH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudFxuICApLm9yaWdpbmFsRXZlbnQ7XG4gIGFzc2VydChcbiAgICBwb2ludGVyRXZ0ICE9PSB1bmRlZmluZWQsXG4gICAgJ21hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudCcsXG4gICk7XG4gIC8vIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jd2lkbC1Qb2ludGVyRXZlbnQtcG9pbnRlclR5cGVcbiAgcmV0dXJuIHBvaW50ZXJFdnQucG9pbnRlclR5cGUgPT09ICdwZW4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBwcmltYXJ5IHBvaW50ZXIgaW5cbiAqIGNvbnRhY3Qgd2l0aCB0aGUgc3VyZmFjZSBvciBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC5cbiAqIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jYnV0dG9uLXN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBwcmltYXJ5IHBvaW50ZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBwcmltYXJ5QWN0aW9uID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBwb2ludGVyRXZlbnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50XG4gICkub3JpZ2luYWxFdmVudDtcbiAgYXNzZXJ0KFxuICAgIHBvaW50ZXJFdmVudCAhPT0gdW5kZWZpbmVkLFxuICAgICdtYXBCcm93c2VyRXZlbnQgbXVzdCBvcmlnaW5hdGUgZnJvbSBhIHBvaW50ZXIgZXZlbnQnLFxuICApO1xuICByZXR1cm4gcG9pbnRlckV2ZW50LmlzUHJpbWFyeSAmJiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9leHByL2NwdVxuICovXG5cbmltcG9ydCB7Q29sb3JUeXBlLCBMaXRlcmFsRXhwcmVzc2lvbiwgT3BzLCBwYXJzZX0gZnJvbSAnLi9leHByZXNzaW9uLmpzJztcbmltcG9ydCB7XG4gIGZyb21TdHJpbmcsXG4gIGxjaGFUb1JnYmEsXG4gIG5vcm1hbGl6ZSxcbiAgcmdiYVRvTGNoYSxcbiAgdG9TdHJpbmcsXG4gIHdpdGhBbHBoYSxcbn0gZnJvbSAnLi4vY29sb3IuanMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaW5jbHVkZXMgZnVuY3Rpb25zIHRvIGJ1aWxkIGV4cHJlc3Npb25zIGZvciBldmFsdWF0aW9uIG9uIHRoZSBDUFUuXG4gKiBCdWlsZGluZyBpcyBjb21wb3NlZCBvZiB0d28gc3RlcHM6IHBhcnNpbmcgYW5kIGNvbXBpbGluZy4gIFRoZSBwYXJzaW5nIHN0ZXAgdGFrZXMgYW4gZW5jb2RlZFxuICogZXhwcmVzc2lvbiBhbmQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBvbmUgb2YgdGhlIGV4cHJlc3Npb24gY2xhc3Nlcy4gIFRoZSBjb21waWxpbmcgc3RlcCB0YWtlc1xuICogdGhlIGV4cHJlc3Npb24gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgaW4gdG8gcmV0dXJuIGEgbGl0ZXJhbFxuICogdmFsdWUuICBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uIHNob3VsZCBkbyBhcyBsaXR0bGUgYWxsb2NhdGlvbiBhbmQgd29yayBhcyBwb3NzaWJsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2YWx1YXRpb25Db250ZXh0XG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydGllcyBUaGUgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHVzZWQgaW4gJ2dldCcgZXhwcmVzc2lvbnMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gdmFyaWFibGVzIFRoZSB2YWx1ZXMgZm9yIHZhcmlhYmxlcyB1c2VkIGluICd2YXInIGV4cHJlc3Npb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIG1hcCByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfG51bGx9IGZlYXR1cmVJZCBUaGUgZmVhdHVyZSBpZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnZW9tZXRyeVR5cGUgR2VvbWV0cnkgdHlwZSBvZiB0aGUgY3VycmVudCBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtFdmFsdWF0aW9uQ29udGV4dH0gQSBuZXcgZXZhbHVhdGlvbiBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmV3RXZhbHVhdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgdmFyaWFibGVzOiB7fSxcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICByZXNvbHV0aW9uOiBOYU4sXG4gICAgZmVhdHVyZUlkOiBudWxsLFxuICAgIGdlb21ldHJ5VHlwZTogJycsXG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTppbXBvcnQoXCIuL2V4cHJlc3Npb24uanNcIikuTGl0ZXJhbFZhbHVlfSBFeHByZXNzaW9uRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOmJvb2xlYW59IEJvb2xlYW5FdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6bnVtYmVyfSBOdW1iZXJFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6c3RyaW5nfSBTdHJpbmdFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6KEFycmF5PG51bWJlcj58c3RyaW5nKX0gQ29sb3JMaWtlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOkFycmF5PG51bWJlcj59IE51bWJlckFycmF5RXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOkFycmF5PG51bWJlcj59IENvb3JkaW5hdGVFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6KEFycmF5PG51bWJlcj4pfSBTaXplRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOihBcnJheTxudW1iZXI+fG51bWJlcil9IFNpemVMaWtlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuRW5jb2RlZEV4cHJlc3Npb259IGVuY29kZWQgVGhlIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZW5jb2RlZCwgdHlwZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UoZW5jb2RlZCwgdHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXhwcmVzc2lvbi5qc1wiKS5FeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pIHtcbiAgICAvLyBjb252ZXJ0IGNvbG9ycyB0byBhcnJheSBpZiBwb3NzaWJsZVxuICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IENvbG9yVHlwZSAmJiB0eXBlb2YgZXhwcmVzc2lvbi52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBmcm9tU3RyaW5nKGV4cHJlc3Npb24udmFsdWUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yVmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcGVyYXRvciA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlIE9wcy5OdW1iZXI6XG4gICAgY2FzZSBPcHMuU3RyaW5nOlxuICAgIGNhc2UgT3BzLkNvYWxlc2NlOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUFzc2VydGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdldDpcbiAgICBjYXNlIE9wcy5WYXI6XG4gICAgY2FzZSBPcHMuSGFzOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUFjY2Vzc29yRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuSWQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gY29udGV4dC5mZWF0dXJlSWQ7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdlb21ldHJ5VHlwZToge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBjb250ZXh0Lmdlb21ldHJ5VHlwZTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQ29uY2F0OiB7XG4gICAgICBjb25zdCBhcmdzID0gZXhwcmVzc2lvbi5hcmdzLm1hcCgoZSkgPT4gY29tcGlsZUV4cHJlc3Npb24oZSwgY29udGV4dCkpO1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PlxuICAgICAgICAnJy5jb25jYXQoLi4uYXJncy5tYXAoKGFyZykgPT4gYXJnKGNvbnRleHQpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuUmVzb2x1dGlvbjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBjb250ZXh0LnJlc29sdXRpb247XG4gICAgfVxuICAgIGNhc2UgT3BzLkFueTpcbiAgICBjYXNlIE9wcy5BbGw6XG4gICAgY2FzZSBPcHMuQmV0d2VlbjpcbiAgICBjYXNlIE9wcy5JbjpcbiAgICBjYXNlIE9wcy5Ob3Q6IHtcbiAgICAgIHJldHVybiBjb21waWxlTG9naWNhbEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkVxdWFsOlxuICAgIGNhc2UgT3BzLk5vdEVxdWFsOlxuICAgIGNhc2UgT3BzLkxlc3NUaGFuOlxuICAgIGNhc2UgT3BzLkxlc3NUaGFuT3JFcXVhbFRvOlxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuOlxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUNvbXBhcmlzb25FeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5NdWx0aXBseTpcbiAgICBjYXNlIE9wcy5EaXZpZGU6XG4gICAgY2FzZSBPcHMuQWRkOlxuICAgIGNhc2UgT3BzLlN1YnRyYWN0OlxuICAgIGNhc2UgT3BzLkNsYW1wOlxuICAgIGNhc2UgT3BzLk1vZDpcbiAgICBjYXNlIE9wcy5Qb3c6XG4gICAgY2FzZSBPcHMuQWJzOlxuICAgIGNhc2UgT3BzLkZsb29yOlxuICAgIGNhc2UgT3BzLkNlaWw6XG4gICAgY2FzZSBPcHMuUm91bmQ6XG4gICAgY2FzZSBPcHMuU2luOlxuICAgIGNhc2UgT3BzLkNvczpcbiAgICBjYXNlIE9wcy5BdGFuOlxuICAgIGNhc2UgT3BzLlNxcnQ6IHtcbiAgICAgIHJldHVybiBjb21waWxlTnVtZXJpY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkNhc2U6IHtcbiAgICAgIHJldHVybiBjb21waWxlQ2FzZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLk1hdGNoOiB7XG4gICAgICByZXR1cm4gY29tcGlsZU1hdGNoRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuSW50ZXJwb2xhdGU6IHtcbiAgICAgIHJldHVybiBjb21waWxlSW50ZXJwb2xhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Ub1N0cmluZzoge1xuICAgICAgcmV0dXJuIGNvbXBpbGVDb252ZXJ0RXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRvciAke29wZXJhdG9yfWApO1xuICAgIH1cbiAgICAvLyBUT0RPOiB1bmltcGxlbWVudGVkXG4gICAgLy8gT3BzLlpvb21cbiAgICAvLyBPcHMuVGltZVxuICAgIC8vIE9wcy5BcnJheVxuICAgIC8vIE9wcy5Db2xvclxuICAgIC8vIE9wcy5CYW5kXG4gICAgLy8gT3BzLlBhbGV0dGVcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQXNzZXJ0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBleHByZXNzaW9uLm9wZXJhdG9yO1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3NbaV0sIGNvbnRleHQpO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgT3BzLkNvYWxlc2NlOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG9uZSBvZiB0aGUgdmFsdWVzIHRvIGJlIG5vbi1udWxsJyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5OdW1iZXI6XG4gICAgY2FzZSBPcHMuU3RyaW5nOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgb25lIG9mIHRoZSB2YWx1ZXMgdG8gYmUgYSAke3R5cGV9YCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFzc2VydGlvbiBvcGVyYXRvciAke3R5cGV9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVBY2Nlc3NvckV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBuYW1lRXhwcmVzc2lvbiA9IC8qKiBAdHlwZSB7TGl0ZXJhbEV4cHJlc3Npb259ICovIChleHByZXNzaW9uLmFyZ3NbMF0pO1xuICBjb25zdCBuYW1lID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChuYW1lRXhwcmVzc2lvbi52YWx1ZSk7XG4gIHN3aXRjaCAoZXhwcmVzc2lvbi5vcGVyYXRvcikge1xuICAgIGNhc2UgT3BzLkdldDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBleHByZXNzaW9uLmFyZ3M7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvbnRleHQucHJvcGVydGllc1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgY29uc3Qga2V5RXhwcmVzc2lvbiA9IC8qKiBAdHlwZSB7TGl0ZXJhbEV4cHJlc3Npb259ICovIChhcmdzW2ldKTtcbiAgICAgICAgICBjb25zdCBrZXkgPSAvKiogQHR5cGUge3N0cmluZ3xudW1iZXJ9ICovIChrZXlFeHByZXNzaW9uLnZhbHVlKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuVmFyOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGNvbnRleHQudmFyaWFibGVzW25hbWVdO1xuICAgIH1cbiAgICBjYXNlIE9wcy5IYXM6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBhcmdzID0gZXhwcmVzc2lvbi5hcmdzO1xuICAgICAgICBpZiAoIShuYW1lIGluIGNvbnRleHQucHJvcGVydGllcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlID0gY29udGV4dC5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgICBmb3IgKGxldCBpID0gMSwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBrZXlFeHByZXNzaW9uID0gLyoqIEB0eXBlIHtMaXRlcmFsRXhwcmVzc2lvbn0gKi8gKGFyZ3NbaV0pO1xuICAgICAgICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfG51bWJlcn0gKi8gKGtleUV4cHJlc3Npb24udmFsdWUpO1xuICAgICAgICAgIGlmICghdmFsdWUgfHwgIU9iamVjdC5oYXNPd24odmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhY2Nlc3NvciBvcGVyYXRvciAke2V4cHJlc3Npb24ub3BlcmF0b3J9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0Jvb2xlYW5FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDb21wYXJpc29uRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wID0gZXhwcmVzc2lvbi5vcGVyYXRvcjtcbiAgY29uc3QgbGVmdCA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1swXSwgY29udGV4dCk7XG4gIGNvbnN0IHJpZ2h0ID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzWzFdLCBjb250ZXh0KTtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLkVxdWFsOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGxlZnQoY29udGV4dCkgPT09IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Ob3RFcXVhbDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpICE9PSByaWdodChjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTGVzc1RoYW46IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gbGVmdChjb250ZXh0KSA8IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5MZXNzVGhhbk9yRXF1YWxUbzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpIDw9IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5HcmVhdGVyVGhhbjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpID4gcmlnaHQoY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGxlZnQoY29udGV4dCkgPj0gcmlnaHQoY29udGV4dCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcGFyaXNvbiBvcGVyYXRvciAke29wfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtCb29sZWFuRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlTG9naWNhbEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBvcCA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLkFueToge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoYXJnc1tpXShjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgT3BzLkFsbDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWFyZ3NbaV0oY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5CZXR3ZWVuOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzBdKGNvbnRleHQpO1xuICAgICAgICBjb25zdCBtaW4gPSBhcmdzWzFdKGNvbnRleHQpO1xuICAgICAgICBjb25zdCBtYXggPSBhcmdzWzJdKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgT3BzLkluOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzBdKGNvbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBhcmdzW2ldKGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTm90OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+ICFhcmdzWzBdKGNvbnRleHQpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2ljYWwgb3BlcmF0b3IgJHtvcH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7TnVtYmVyRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlTnVtZXJpY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBvcCA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLk11bHRpcGx5OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhbHVlICo9IGFyZ3NbaV0oY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuRGl2aWRlOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGFyZ3NbMF0oY29udGV4dCkgLyBhcmdzWzFdKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5BZGQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFsdWUgKz0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5TdWJ0cmFjdDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBhcmdzWzBdKGNvbnRleHQpIC0gYXJnc1sxXShjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQ2xhbXA6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF0oY29udGV4dCk7XG4gICAgICAgIGNvbnN0IG1pbiA9IGFyZ3NbMV0oY29udGV4dCk7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4ID0gYXJnc1syXShjb250ZXh0KTtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5Nb2Q6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gYXJnc1swXShjb250ZXh0KSAlIGFyZ3NbMV0oY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLlBvdzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLnBvdyhhcmdzWzBdKGNvbnRleHQpLCBhcmdzWzFdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQWJzOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguYWJzKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5GbG9vcjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmZsb29yKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5DZWlsOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguY2VpbChhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuUm91bmQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5yb3VuZChhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuU2luOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguc2luKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Db3M6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5jb3MoYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkF0YW46IHtcbiAgICAgIGlmIChsZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmF0YW4yKGFyZ3NbMF0oY29udGV4dCksIGFyZ3NbMV0oY29udGV4dCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmF0YW4oYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLlNxcnQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5zcXJ0KGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG51bWVyaWMgb3BlcmF0b3IgJHtvcH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbkV2YWx1YXRvcn0gVGhlIGV2YWx1YXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUNhc2VFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbi5hcmdzLmxlbmd0aDtcbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGFyZ3NbaV0oY29udGV4dCk7XG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2kgKyAxXShjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3NbbGVuZ3RoIC0gMV0oY29udGV4dCk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVNYXRjaEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2ldID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzW2ldLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF0oY29udGV4dCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKHZhbHVlID09PSBhcmdzW2ldKGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2kgKyAxXShjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3NbbGVuZ3RoIC0gMV0oY29udGV4dCk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVJbnRlcnBvbGF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2ldID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzW2ldLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBiYXNlID0gYXJnc1swXShjb250ZXh0KTtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMV0oY29udGV4dCk7XG5cbiAgICBsZXQgcHJldmlvdXNJbnB1dDtcbiAgICBsZXQgcHJldmlvdXNPdXRwdXQ7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBhcmdzW2ldKGNvbnRleHQpO1xuICAgICAgbGV0IG91dHB1dCA9IGFyZ3NbaSArIDFdKGNvbnRleHQpO1xuICAgICAgY29uc3QgaXNDb2xvciA9IEFycmF5LmlzQXJyYXkob3V0cHV0KTtcbiAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgIG91dHB1dCA9IHdpdGhBbHBoYShvdXRwdXQpO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0ID49IHZhbHVlKSB7XG4gICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUNvbG9yKFxuICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcHJldmlvdXNJbnB1dCxcbiAgICAgICAgICAgIHByZXZpb3VzT3V0cHV0LFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVOdW1iZXIoXG4gICAgICAgICAgYmFzZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91c0lucHV0LFxuICAgICAgICAgIHByZXZpb3VzT3V0cHV0LFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzSW5wdXQgPSBpbnB1dDtcbiAgICAgIHByZXZpb3VzT3V0cHV0ID0gb3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNPdXRwdXQ7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDb252ZXJ0RXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wID0gZXhwcmVzc2lvbi5vcGVyYXRvcjtcbiAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbi5hcmdzLmxlbmd0aDtcblxuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2ldID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzW2ldLCBjb250ZXh0KTtcbiAgfVxuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSBPcHMuVG9TdHJpbmc6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF0oY29udGV4dCk7XG4gICAgICAgIGlmIChleHByZXNzaW9uLmFyZ3NbMF0udHlwZSA9PT0gQ29sb3JUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29udmVydCBvcGVyYXRvciAke29wfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlIFRoZSBiYXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dDEgVGhlIGZpcnN0IGlucHV0IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IG91dHB1dDEgVGhlIGZpcnN0IG91dHB1dCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dDIgVGhlIHNlY29uZCBpbnB1dCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRwdXQyIFRoZSBzZWNvbmQgb3V0cHV0IHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCBvdXRwdXQxLCBpbnB1dDIsIG91dHB1dDIpIHtcbiAgY29uc3QgZGVsdGEgPSBpbnB1dDIgLSBpbnB1dDE7XG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIHJldHVybiBvdXRwdXQxO1xuICB9XG4gIGNvbnN0IGFsb25nID0gdmFsdWUgLSBpbnB1dDE7XG4gIGNvbnN0IGZhY3RvciA9XG4gICAgYmFzZSA9PT0gMVxuICAgICAgPyBhbG9uZyAvIGRlbHRhXG4gICAgICA6IChNYXRoLnBvdyhiYXNlLCBhbG9uZykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkZWx0YSkgLSAxKTtcbiAgcmV0dXJuIG91dHB1dDEgKyBmYWN0b3IgKiAob3V0cHV0MiAtIG91dHB1dDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlIFRoZSBiYXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dDEgVGhlIGZpcnN0IGlucHV0IHZhbHVlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvbG9yLmpzJykuQ29sb3J9IHJnYmExIFRoZSBmaXJzdCBvdXRwdXQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXQyIFRoZSBzZWNvbmQgaW5wdXQgdmFsdWUuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29sb3IuanMnKS5Db2xvcn0gcmdiYTIgVGhlIHNlY29uZCBvdXRwdXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uL2NvbG9yLmpzJykuQ29sb3J9IFRoZSBpbnRlcnBvbGF0ZWQgY29sb3IuXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoYmFzZSwgdmFsdWUsIGlucHV0MSwgcmdiYTEsIGlucHV0MiwgcmdiYTIpIHtcbiAgY29uc3QgZGVsdGEgPSBpbnB1dDIgLSBpbnB1dDE7XG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIHJldHVybiByZ2JhMTtcbiAgfVxuICBjb25zdCBsY2hhMSA9IHJnYmFUb0xjaGEocmdiYTEpO1xuICBjb25zdCBsY2hhMiA9IHJnYmFUb0xjaGEocmdiYTIpO1xuICBsZXQgZGVsdGFIdWUgPSBsY2hhMlsyXSAtIGxjaGExWzJdO1xuICBpZiAoZGVsdGFIdWUgPiAxODApIHtcbiAgICBkZWx0YUh1ZSAtPSAzNjA7XG4gIH0gZWxzZSBpZiAoZGVsdGFIdWUgPCAtMTgwKSB7XG4gICAgZGVsdGFIdWUgKz0gMzYwO1xuICB9XG5cbiAgY29uc3QgbGNoYSA9IFtcbiAgICBpbnRlcnBvbGF0ZU51bWJlcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCBsY2hhMVswXSwgaW5wdXQyLCBsY2hhMlswXSksXG4gICAgaW50ZXJwb2xhdGVOdW1iZXIoYmFzZSwgdmFsdWUsIGlucHV0MSwgbGNoYTFbMV0sIGlucHV0MiwgbGNoYTJbMV0pLFxuICAgIGxjaGExWzJdICsgaW50ZXJwb2xhdGVOdW1iZXIoYmFzZSwgdmFsdWUsIGlucHV0MSwgMCwgaW5wdXQyLCBkZWx0YUh1ZSksXG4gICAgaW50ZXJwb2xhdGVOdW1iZXIoYmFzZSwgdmFsdWUsIGlucHV0MSwgcmdiYTFbM10sIGlucHV0MiwgcmdiYTJbM10pLFxuICBdO1xuICByZXR1cm4gbm9ybWFsaXplKGxjaGFUb1JnYmEobGNoYSkpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4cHIvZXhwcmVzc2lvblxuICovXG5pbXBvcnQge2FzY2VuZGluZ30gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtmcm9tU3RyaW5nIGFzIGNvbG9yRnJvbVN0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaW5jbHVkZXMgdHlwZXMgYW5kIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBhcnJheSBlbmNvZGVkIGV4cHJlc3Npb25zLlxuICogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIGFuIGVuY29kZWQgZXhwcmVzc2lvbiBpcyBvbmUgb2YgdGhlIHNwZWNpZmljIGV4cHJlc3Npb24gY2xhc3Nlcy5cbiAqIER1cmluZyBwYXJzaW5nLCBpbmZvcm1hdGlvbiBpcyBhZGRlZCB0byB0aGUgcGFyc2luZyBjb250ZXh0IGFib3V0IHRoZSBkYXRhIGFjY2Vzc2VkIGJ5IHRoZVxuICogZXhwcmVzc2lvbi5cbiAqL1xuXG4vKipcbiAqIEJhc2UgdHlwZSB1c2VkIGZvciBsaXRlcmFsIHN0eWxlIHBhcmFtZXRlcnM7IGNhbiBiZSBhIG51bWJlciBsaXRlcmFsIG9yIHRoZSBvdXRwdXQgb2YgYW4gb3BlcmF0b3IsXG4gKiB3aGljaCBpbiB0dXJucyB0YWtlcyB7QGxpbmsgaW1wb3J0KFwiLi9leHByZXNzaW9uLmpzXCIpLkV4cHJlc3Npb25WYWx1ZX0gYXJndW1lbnRzLlxuICpcbiAqIFNlZSBiZWxvdyBmb3IgZGV0YWlscyBvbiB0aGUgYXZhaWxhYmxlIG9wZXJhdG9ycyAod2l0aCBub3RlcyBmb3IgdGhvc2UgdGhhdCBhcmUgV2ViR0wgb3IgQ2FudmFzIG9ubHkpLlxuICpcbiAqICogUmVhZGluZyBvcGVyYXRvcnM6XG4gKiAgICogYFsnYmFuZCcsIGJhbmRJbmRleCwgeE9mZnNldCwgeU9mZnNldF1gIEZvciB0aWxlIGxheWVycyBvbmx5LiBGZXRjaGVzIHBpeGVsIHZhbHVlcyBmcm9tIGJhbmRcbiAqICAgICBgYmFuZEluZGV4YCBvZiB0aGUgc291cmNlJ3MgZGF0YS4gVGhlIGZpcnN0IGBiYW5kSW5kZXhgIG9mIHRoZSBzb3VyY2UgZGF0YSBpcyBgMWAuIEZldGNoZWQgdmFsdWVzXG4gKiAgICAgYXJlIGluIHRoZSAwLi4xIHJhbmdlLiB7QGxpbmsgaW1wb3J0KFwiLi4vc291cmNlL1RpbGVJbWFnZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2VzIGhhdmUgNCBiYW5kczogcmVkLFxuICogICAgIGdyZWVuLCBibHVlIGFuZCBhbHBoYS4ge0BsaW5rIGltcG9ydChcIi4uL3NvdXJjZS9EYXRhVGlsZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2VzIGNhbiBoYXZlIGFueSBudW1iZXJcbiAqICAgICBvZiBiYW5kcywgZGVwZW5kaW5nIG9uIHRoZSB1bmRlcmx5aW5nIGRhdGEgc291cmNlIGFuZFxuICogICAgIHtAbGluayBpbXBvcnQoXCIuLi9zb3VyY2UvR2VvVElGRi5qc1wiKS5PcHRpb25zIGNvbmZpZ3VyYXRpb259LiBgeE9mZnNldGAgYW5kIGB5T2Zmc2V0YCBhcmUgb3B0aW9uYWxcbiAqICAgICBhbmQgYWxsb3cgc3BlY2lmeWluZyBwaXhlbCBvZmZzZXRzIGZvciB4IGFuZCB5LiBUaGlzIGlzIHVzZWQgZm9yIHNhbXBsaW5nIGRhdGEgZnJvbSBuZWlnaGJvcmluZyBwaXhlbHMgKFdlYkdMIG9ubHkpLlxuICogICAqIGBbJ2dldCcsIGF0dHJpYnV0ZU5hbWVdYCBmZXRjaGVzIGEgZmVhdHVyZSBwcm9wZXJ0eSB2YWx1ZSwgc2ltaWxhciB0byBgZmVhdHVyZS5nZXQoJ2F0dHJpYnV0ZU5hbWUnKWAuXG4gKiAgICogYFsnZ2V0JywgYXR0cmlidXRlTmFtZSwga2V5T3JBcnJheUluZGV4LCAuLi5dYCAoQ2FudmFzIG9ubHkpIEFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcyBhbmQgYXJyYXkgaXRlbXMgb2YgYVxuICogICAgIGZlYXR1cmUgcHJvcGVydHkuIFRoZSByZXN1bHQgaXMgYHVuZGVmaW5lZGAgd2hlbiB0aGVyZSBpcyBub3RoaW5nIGF0IHRoZSBzcGVjaWZpZWQga2V5IG9yIGluZGV4LlxuICogICAqIGBbJ2dlb21ldHJ5LXR5cGUnXWAgcmV0dXJucyBhIGZlYXR1cmUncyBnZW9tZXRyeSB0eXBlIGFzIHN0cmluZywgZWl0aGVyOiAnTGluZVN0cmluZycsICdQb2ludCcgb3IgJ1BvbHlnb24nXG4gKiAgICAgYE11bHRpKmAgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyB0aGVpciBzaW5ndWxhciBlcXVpdmFsZW50XG4gKiAgICAgYENpcmNsZWAgZ2VvbWV0cmllcyBhcmUgcmV0dXJuZWQgYXMgJ1BvbHlnb24nXG4gKiAgICAgYEdlb21ldHJ5Q29sbGVjdGlvbmAgZ2VvbWV0cmllcyBhcmUgcmV0dXJuZWQgYXMgdGhlIHR5cGUgb2YgdGhlIGZpcnN0IGdlb21ldHJ5IGZvdW5kIGluIHRoZSBjb2xsZWN0aW9uIChXZWJHTCBvbmx5KS5cbiAqICAgKiBgWydyZXNvbHV0aW9uJ11gIHJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvblxuICogICAqIGBbJ3RpbWUnXWAgVGhlIHRpbWUgaW4gc2Vjb25kcyBzaW5jZSB0aGUgY3JlYXRpb24gb2YgdGhlIGxheWVyIChXZWJHTCBvbmx5KS5cbiAqICAgKiBgWyd2YXInLCAndmFyTmFtZSddYCBmZXRjaGVzIGEgdmFsdWUgZnJvbSB0aGUgc3R5bGUgdmFyaWFibGVzOyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoYXQgdmFyaWFibGUgaXMgdW5kZWZpbmVkXG4gKiAgICogYFsnem9vbSddYCBUaGUgY3VycmVudCB6b29tIGxldmVsIChXZWJHTCBvbmx5KS5cbiAqICAgKiBgWydsaW5lLW1ldHJpYyddYCByZXR1cm5zIHRoZSBNIGNvbXBvbmVudCBvZiB0aGUgY3VycmVudCBwb2ludCBvbiBhIGxpbmUgKFdlYkdMIG9ubHkpOyBpbiBjYXNlIHdoZXJlIHRoZSBnZW9tZXRyeSBsYXlvdXQgb2YgdGhlIGxpbmVcbiAqICAgICAgZG9lcyBub3QgY29udGFpbiBhbiBNIGNvbXBvbmVudCAoZS5nLiBYWSBvciBYWVopLCAwIGlzIHJldHVybmVkOyAwIGlzIGFsc28gcmV0dXJuZWQgZm9yIGdlb21ldHJpZXMgb3RoZXIgdGhhbiBsaW5lcy5cbiAqICAgICAgUGxlYXNlIG5vdGUgdGhhdCB0aGUgTSBjb21wb25lbnQgd2lsbCBiZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB0aGUgdHdvIHBvaW50cyBjb21wb3NpbmcgYSBzZWdtZW50LlxuICpcbiAqICogTWF0aCBvcGVyYXRvcnM6XG4gKiAgICogYFsnKicsIHZhbHVlMSwgdmFsdWUyLCAuLi5dYCBtdWx0aXBsaWVzIHRoZSB2YWx1ZXMgKGVpdGhlciBudW1iZXJzIG9yIGNvbG9ycylcbiAqICAgKiBgWycvJywgdmFsdWUxLCB2YWx1ZTJdYCBkaXZpZGVzIGB2YWx1ZTFgIGJ5IGB2YWx1ZTJgXG4gKiAgICogYFsnKycsIHZhbHVlMSwgdmFsdWUyLCAuLi5dYCBhZGRzIHRoZSB2YWx1ZXNcbiAqICAgKiBgWyctJywgdmFsdWUxLCB2YWx1ZTJdYCBzdWJ0cmFjdHMgYHZhbHVlMmAgZnJvbSBgdmFsdWUxYFxuICogICAqIGBbJ2NsYW1wJywgdmFsdWUsIGxvdywgaGlnaF1gIGNsYW1wcyBgdmFsdWVgIGJldHdlZW4gYGxvd2AgYW5kIGBoaWdoYFxuICogICAqIGBbJyUnLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgdGhlIHJlc3VsdCBvZiBgdmFsdWUxICUgdmFsdWUyYCAobW9kdWxvKVxuICogICAqIGBbJ14nLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgdGhlIHZhbHVlIG9mIGB2YWx1ZTFgIHJhaXNlZCB0byB0aGUgYHZhbHVlMmAgcG93ZXJcbiAqICAgKiBgWydhYnMnLCB2YWx1ZTFdYCByZXR1cm5zIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgdmFsdWUxYFxuICogICAqIGBbJ2Zsb29yJywgdmFsdWUxXWAgcmV0dXJucyB0aGUgbmVhcmVzdCBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWUxYFxuICogICAqIGBbJ3JvdW5kJywgdmFsdWUxXWAgcmV0dXJucyB0aGUgbmVhcmVzdCBpbnRlZ2VyIHRvIGB2YWx1ZTFgXG4gKiAgICogYFsnY2VpbCcsIHZhbHVlMV1gIHJldHVybnMgdGhlIG5lYXJlc3QgaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlMWBcbiAqICAgKiBgWydzaW4nLCB2YWx1ZTFdYCByZXR1cm5zIHRoZSBzaW5lIG9mIGB2YWx1ZTFgXG4gKiAgICogYFsnY29zJywgdmFsdWUxXWAgcmV0dXJucyB0aGUgY29zaW5lIG9mIGB2YWx1ZTFgXG4gKiAgICogYFsnYXRhbicsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyBgYXRhbjIodmFsdWUxLCB2YWx1ZTIpYC4gSWYgYHZhbHVlMmAgaXMgbm90IHByb3ZpZGVkLCByZXR1cm5zIGBhdGFuKHZhbHVlMSlgXG4gKiAgICogYFsnc3FydCcsIHZhbHVlMV1gIHJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIGB2YWx1ZTFgXG4gKlxuICogKiBUcmFuc2Zvcm0gb3BlcmF0b3JzOlxuICogICAqIGBbJ2Nhc2UnLCBjb25kaXRpb24xLCBvdXRwdXQxLCAuLi5jb25kaXRpb25OLCBvdXRwdXROLCBmYWxsYmFja11gIHNlbGVjdHMgdGhlIGZpcnN0IG91dHB1dCB3aG9zZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgY29uZGl0aW9uIGV2YWx1YXRlcyB0byBgdHJ1ZWAuIElmIG5vIG1hdGNoIGlzIGZvdW5kLCByZXR1cm5zIHRoZSBgZmFsbGJhY2tgIHZhbHVlLlxuICogICAgIEFsbCBjb25kaXRpb25zIHNob3VsZCBiZSBgYm9vbGVhbmAsIG91dHB1dCBhbmQgZmFsbGJhY2sgY2FuIGJlIGFueSBraW5kLlxuICogICAqIGBbJ21hdGNoJywgaW5wdXQsIG1hdGNoMSwgb3V0cHV0MSwgLi4ubWF0Y2hOLCBvdXRwdXROLCBmYWxsYmFja11gIGNvbXBhcmVzIHRoZSBgaW5wdXRgIHZhbHVlIGFnYWluc3QgYWxsXG4gKiAgICAgcHJvdmlkZWQgYG1hdGNoWGAgdmFsdWVzLCByZXR1cm5pbmcgdGhlIG91dHB1dCBhc3NvY2lhdGVkIHdpdGggdGhlIGZpcnN0IHZhbGlkIG1hdGNoLiBJZiBubyBtYXRjaCBpcyBmb3VuZCxcbiAqICAgICByZXR1cm5zIHRoZSBgZmFsbGJhY2tgIHZhbHVlLlxuICogICAgIGBpbnB1dGAgYW5kIGBtYXRjaFhgIHZhbHVlcyBtdXN0IGFsbCBiZSBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgY2FuIGJlIGBudW1iZXJgIG9yIGBzdHJpbmdgLiBgb3V0cHV0WGAgYW5kXG4gKiAgICAgYGZhbGxiYWNrYCB2YWx1ZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgY2FuIGJlIG9mIGFueSBraW5kLlxuICogICAqIGBbJ2ludGVycG9sYXRlJywgaW50ZXJwb2xhdGlvbiwgaW5wdXQsIHN0b3AxLCBvdXRwdXQxLCAuLi5zdG9wTiwgb3V0cHV0Tl1gIHJldHVybnMgYSB2YWx1ZSBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW5cbiAqICAgICBwYWlycyBvZiBpbnB1dHMgYW5kIG91dHB1dHM7IGBpbnRlcnBvbGF0aW9uYCBjYW4gZWl0aGVyIGJlIGBbJ2xpbmVhciddYCBvciBgWydleHBvbmVudGlhbCcsIGJhc2VdYCB3aGVyZSBgYmFzZWAgaXNcbiAqICAgICB0aGUgcmF0ZSBvZiBpbmNyZWFzZSBmcm9tIHN0b3AgQSB0byBzdG9wIEIgKGkuZS4gcG93ZXIgdG8gd2hpY2ggdGhlIGludGVycG9sYXRpb24gcmF0aW8gaXMgcmFpc2VkKTsgYSB2YWx1ZVxuICogICAgIG9mIDEgaXMgZXF1aXZhbGVudCB0byBgWydsaW5lYXInXWAuXG4gKiAgICAgYGlucHV0YCBhbmQgYHN0b3BYYCB2YWx1ZXMgbXVzdCBhbGwgYmUgb2YgdHlwZSBgbnVtYmVyYC4gYG91dHB1dFhgIHZhbHVlcyBjYW4gYmUgYG51bWJlcmAgb3IgYGNvbG9yYCB2YWx1ZXMuXG4gKiAgICAgTm90ZTogYGlucHV0YCB3aWxsIGJlIGNsYW1wZWQgYmV0d2VlbiBgc3RvcDFgIGFuZCBgc3RvcE5gLCBtZWFuaW5nIHRoYXQgYWxsIG91dHB1dCB2YWx1ZXMgd2lsbCBiZSBjb21wcmlzZWRcbiAqICAgICBiZXR3ZWVuIGBvdXRwdXQxYCBhbmQgYG91dHB1dE5gLlxuICogICAqIGBbJ3N0cmluZycsIHZhbHVlMSwgdmFsdWUyLCAuLi5dYCByZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgbGlzdCB0aGF0IGV2YWx1YXRlcyB0byBhIHN0cmluZy5cbiAqICAgICBBbiBleGFtcGxlIHdvdWxkIGJlIHRvIHByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGZvciBnZXQ6IGBbJ3N0cmluZycsIFsnZ2V0JywgJ3Byb3BlcnR5bmFtZSddLCAnZGVmYXVsdCB2YWx1ZSddXWBcbiAqICAgICAoQ2FudmFzIG9ubHkpLlxuICogICAqIGBbJ251bWJlcicsIHZhbHVlMSwgdmFsdWUyLCAuLi5dYCByZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgbGlzdCB0aGF0IGV2YWx1YXRlcyB0byBhIG51bWJlci5cbiAqICAgICBBbiBleGFtcGxlIHdvdWxkIGJlIHRvIHByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGZvciBnZXQ6IGBbJ3N0cmluZycsIFsnZ2V0JywgJ3Byb3BlcnR5bmFtZSddLCA0Ml1dYFxuICogICAgIChDYW52YXMgb25seSkuXG4gKiAgICogYFsnY29hbGVzY2UnLCB2YWx1ZTEsIHZhbHVlMiwgLi4uXWAgcmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGxpc3Qgd2hpY2ggaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkLlxuICogICAgIEFuIGV4YW1wbGUgd291bGQgYmUgdG8gcHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgZm9yIGdldDogYFsnY29hbGVzY2UnLCBbJ2dldCcsJ3Byb3BlcnR5bmFtZSddLCAnZGVmYXVsdCB2YWx1ZSddXWBcbiAqICAgICAoQ2FudmFzIG9ubHkpLlxuICpcbiAqICogTG9naWNhbCBvcGVyYXRvcnM6XG4gKiAgICogYFsnPCcsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlMWAgaXMgc3RyaWN0bHkgbG93ZXIgdGhhbiBgdmFsdWUyYCwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnPD0nLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgYHRydWVgIGlmIGB2YWx1ZTFgIGlzIGxvd2VyIHRoYW4gb3IgZXF1YWxzIGB2YWx1ZTJgLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWyc+JywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gYHZhbHVlMmAsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJz49JywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWxzIGB2YWx1ZTJgLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWyc9PScsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlMWAgZXF1YWxzIGB2YWx1ZTJgLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWychPScsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlMWAgZG9lcyBub3QgZXF1YWwgYHZhbHVlMmAsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJyEnLCB2YWx1ZTFdYCByZXR1cm5zIGBmYWxzZWAgaWYgYHZhbHVlMWAgaXMgYHRydWVgIG9yIGdyZWF0ZXIgdGhhbiBgMGAsIG9yIGB0cnVlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnYWxsJywgdmFsdWUxLCB2YWx1ZTIsIC4uLl1gIHJldHVybnMgYHRydWVgIGlmIGFsbCB0aGUgaW5wdXRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJ2FueScsIHZhbHVlMSwgdmFsdWUyLCAuLi5dYCByZXR1cm5zIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWydoYXMnLCBhdHRyaWJ1dGVOYW1lLCBrZXlPckFycmF5SW5kZXgsIC4uLl1gIHJldHVybnMgYHRydWVgIGlmIGZlYXR1cmUgcHJvcGVydGllcyBpbmNsdWRlIHRoZSAobmVzdGVkKSBrZXkgYGF0dHJpYnV0ZU5hbWVgLFxuICogICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJ2JldHdlZW4nLCB2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlMWAgaXMgY29udGFpbmVkIGJldHdlZW4gYHZhbHVlMmAgYW5kIGB2YWx1ZTNgXG4gKiAgICAgKGluY2x1c2l2ZWx5KSwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnaW4nLCBuZWVkbGUsIGhheXN0YWNrXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYG5lZWRsZWAgaXMgZm91bmQgaW4gYGhheXN0YWNrYCwgYW5kXG4gKiAgICAgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICAgVGhpcyBvcGVyYXRvciBoYXMgdGhlIGZvbGxvd2luZyBsaW1pdGF0aW9uczpcbiAqICAgICAqIGBoYXlzdGFja2AgaGFzIHRvIGJlIGFuIGFycmF5IG9mIG51bWJlcnMgb3Igc3RyaW5ncyAoc2VhcmNoaW5nIGZvciBhIHN1YnN0cmluZyBpbiBhIHN0cmluZyBpcyBub3Qgc3VwcG9ydGVkIHlldClcbiAqICAgICAqIE9ubHkgbGl0ZXJhbCBhcnJheXMgYXJlIHN1cHBvcnRlZCBhcyBgaGF5c3RhY2tgIGZvciBub3c7IHRoaXMgbWVhbnMgdGhhdCBgaGF5c3RhY2tgIGNhbm5vdCBiZSB0aGUgcmVzdWx0IG9mIGFuXG4gKiAgICAgZXhwcmVzc2lvbi4gSWYgYGhheXN0YWNrYCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCB1c2UgdGhlIGBsaXRlcmFsYCBvcGVyYXRvciB0byBkaXNhbWJpZ3VhdGUgZnJvbSBhbiBleHByZXNzaW9uOlxuICogICAgIGBbJ2xpdGVyYWwnLCBbJ2FiYycsICdkZWYnLCAnZ2hpJ11dYFxuICpcbiAqICogQ29udmVyc2lvbiBvcGVyYXRvcnM6XG4gKiAgICogYFsnYXJyYXknLCB2YWx1ZTEsIC4uLnZhbHVlTl1gIGNyZWF0ZXMgYSBudW1lcmljYWwgYXJyYXkgZnJvbSBgbnVtYmVyYCB2YWx1ZXM7IHBsZWFzZSBub3RlIHRoYXQgdGhlIGFtb3VudCBvZlxuICogICAgIHZhbHVlcyBjYW4gY3VycmVudGx5IG9ubHkgYmUgMiwgMyBvciA0IChXZWJHTCBvbmx5KS5cbiAqICAgKiBgWydjb2xvcicsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXWAgb3IgYFsnY29sb3InLCBzaGFkZSwgYWxwaGFdYCBjcmVhdGVzIGEgYGNvbG9yYCB2YWx1ZSBmcm9tIGBudW1iZXJgIHZhbHVlcztcbiAqICAgICB0aGUgYGFscGhhYCBwYXJhbWV0ZXIgaXMgb3B0aW9uYWw7IGlmIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgc2V0IHRvIDEgKFdlYkdMIG9ubHkpLlxuICogICAgIE5vdGU6IGByZWRgLCBgZ3JlZW5gIGFuZCBgYmx1ZWAgb3IgYHNoYWRlYCBjb21wb25lbnRzIG11c3QgYmUgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjU1OyBgYWxwaGFgIGJldHdlZW4gMCBhbmQgMS5cbiAqICAgKiBgWydwYWxldHRlJywgaW5kZXgsIGNvbG9yc11gIHBpY2tzIGEgYGNvbG9yYCB2YWx1ZSBmcm9tIGFuIGFycmF5IG9mIGNvbG9ycyB1c2luZyB0aGUgZ2l2ZW4gaW5kZXg7IHRoZSBgaW5kZXhgXG4gKiAgICAgZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIGEgbnVtYmVyOyB0aGUgaXRlbXMgaW4gdGhlIGBjb2xvcnNgIGFycmF5IG11c3QgYmUgc3RyaW5ncyB3aXRoIGhleCBjb2xvcnNcbiAqICAgICAoZS5nLiBgJyM4NkExMzYnYCksIGNvbG9ycyB1c2luZyB0aGUgcmdiYVthXSBmdW5jdGlvbmFsIG5vdGF0aW9uIChlLmcuIGAncmdiKDEzNCwgMTYxLCA1NCknYCBvciBgJ3JnYmEoMTM0LCAxNjEsIDU0LCAxKSdgKSxcbiAqICAgICBuYW1lZCBjb2xvcnMgKGUuZy4gYCdyZWQnYCksIG9yIGFycmF5IGxpdGVyYWxzIHdpdGggMyAoW3IsIGcsIGJdKSBvciA0IChbciwgZywgYiwgYV0pIHZhbHVlcyAod2l0aCByLCBnLCBhbmQgYlxuICogICAgIGluIHRoZSAwLTI1NSByYW5nZSBhbmQgYSBpbiB0aGUgMC0xIHJhbmdlKSAoV2ViR0wgb25seSkuXG4gKiAgICogYFsndG8tc3RyaW5nJywgdmFsdWVdYCBjb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgdG8gYSBzdHJpbmcuIElmIHRoZSBpbnB1dCBpcyBhIGJvb2xlYW4sIHRoZSByZXN1bHQgaXMgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLlxuICogICAgIElmIHRoZSBpbnB1dCBpcyBhIG51bWJlciwgaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGFzIHNwZWNpZmllZCBieSB0aGUgXCJOdW1iZXJUb1N0cmluZ1wiIGFsZ29yaXRobSBvZiB0aGUgRUNNQVNjcmlwdFxuICogICAgIExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIHRoZSBpbnB1dCBpcyBhIGNvbG9yLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgb2YgdGhlIGZvcm0gXCJyZ2JhKHIsZyxiLGEpXCIuIChDYW52YXMgb25seSlcbiAqXG4gKiBWYWx1ZXMgY2FuIGVpdGhlciBiZSBsaXRlcmFscyBvciBhbm90aGVyIG9wZXJhdG9yLCBhcyB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHJlY3Vyc2l2ZWx5LlxuICogTGl0ZXJhbCB2YWx1ZXMgY2FuIGJlIG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6XG4gKiAqIGBib29sZWFuYFxuICogKiBgbnVtYmVyYFxuICogKiBgbnVtYmVyW11gIChudW1iZXIgYXJyYXlzIGNhbiBvbmx5IGhhdmUgYSBsZW5ndGggb2YgMiwgMyBvciA0KVxuICogKiBgc3RyaW5nYFxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbG9yfkNvbG9yfVxuICpcbiAqIEB0eXBlZGVmIHtBcnJheTwqPnxpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxzdHJpbmd8bnVtYmVyfGJvb2xlYW59IEV4cHJlc3Npb25WYWx1ZVxuICogQGFwaVxuICovXG5cbmxldCBudW1UeXBlcyA9IDA7XG5leHBvcnQgY29uc3QgTm9uZVR5cGUgPSAwO1xuZXhwb3J0IGNvbnN0IEJvb2xlYW5UeXBlID0gMSA8PCBudW1UeXBlcysrO1xuZXhwb3J0IGNvbnN0IE51bWJlclR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgU3RyaW5nVHlwZSA9IDEgPDwgbnVtVHlwZXMrKztcbmV4cG9ydCBjb25zdCBDb2xvclR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgTnVtYmVyQXJyYXlUeXBlID0gMSA8PCBudW1UeXBlcysrO1xuZXhwb3J0IGNvbnN0IFNpemVUeXBlID0gMSA8PCBudW1UeXBlcysrO1xuZXhwb3J0IGNvbnN0IEFueVR5cGUgPSBNYXRoLnBvdygyLCBudW1UeXBlcykgLSAxO1xuXG5jb25zdCB0eXBlTmFtZXMgPSB7XG4gIFtCb29sZWFuVHlwZV06ICdib29sZWFuJyxcbiAgW051bWJlclR5cGVdOiAnbnVtYmVyJyxcbiAgW1N0cmluZ1R5cGVdOiAnc3RyaW5nJyxcbiAgW0NvbG9yVHlwZV06ICdjb2xvcicsXG4gIFtOdW1iZXJBcnJheVR5cGVdOiAnbnVtYmVyW10nLFxuICBbU2l6ZVR5cGVdOiAnc2l6ZScsXG59O1xuXG5jb25zdCBuYW1lZFR5cGVzID0gT2JqZWN0LmtleXModHlwZU5hbWVzKS5tYXAoTnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHlwZSBpcyBvbmUgb2YgdGhlIHNwZWNpZmljIHR5cGVzIChub3QgYW55IG9yIGEgdW5pb24gdHlwZSkuXG4gKi9cbmZ1bmN0aW9uIGlzU3BlY2lmaWModHlwZSkge1xuICByZXR1cm4gdHlwZSBpbiB0eXBlTmFtZXM7XG59XG5cbi8qKlxuICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBhIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdHlwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHR5cGUgbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVOYW1lKHR5cGUpIHtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lZFR5cGUgb2YgbmFtZWRUeXBlcykge1xuICAgIGlmIChpbmNsdWRlc1R5cGUodHlwZSwgbmFtZWRUeXBlKSkge1xuICAgICAgbmFtZXMucHVzaCh0eXBlTmFtZXNbbmFtZWRUeXBlXSk7XG4gICAgfVxuICB9XG4gIGlmIChuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3VudHlwZWQnO1xuICB9XG4gIGlmIChuYW1lcy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmpvaW4oJyBvciAnKTtcbiAgfVxuICByZXR1cm4gbmFtZXMuc2xpY2UoMCwgLTEpLmpvaW4oJywgJykgKyAnLCBvciAnICsgbmFtZXNbbmFtZXMubGVuZ3RoIC0gMV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJyb2FkIFRoZSBicm9hZCB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNwZWNpZmljIFRoZSBzcGVjaWZpYyB0eXBlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGJyb2FkIHR5cGUgaW5jbHVkZXMgdGhlIHNwZWNpZmljIHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlc1R5cGUoYnJvYWQsIHNwZWNpZmljKSB7XG4gIHJldHVybiAoYnJvYWQgJiBzcGVjaWZpYykgPT09IHNwZWNpZmljO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvbmVUeXBlIE9uZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IG90aGVyVHlwZSBBbm90aGVyIHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2V0IG9mIHR5cGVzIG92ZXJsYXAgKHNoYXJlIGEgY29tbW9uIHNwZWNpZmljIHR5cGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdmVybGFwc1R5cGUob25lVHlwZSwgb3RoZXJUeXBlKSB7XG4gIHJldHVybiAhIShvbmVUeXBlICYgb3RoZXJUeXBlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCBUaGUgZXhwZWN0ZWQgdHlwZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBnaXZlbiB0eXBlIGlzIGV4YWN0bHkgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGUodHlwZSwgZXhwZWN0ZWQpIHtcbiAgcmV0dXJuIHR5cGUgPT09IGV4cGVjdGVkO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtib29sZWFufG51bWJlcnxzdHJpbmd8QXJyYXk8bnVtYmVyPn0gTGl0ZXJhbFZhbHVlXG4gKi9cblxuZXhwb3J0IGNsYXNzIExpdGVyYWxFeHByZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSB2YWx1ZSB0eXBlLlxuICAgKiBAcGFyYW0ge0xpdGVyYWxWYWx1ZX0gdmFsdWUgVGhlIGxpdGVyYWwgdmFsdWUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICghaXNTcGVjaWZpYyh0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgbGl0ZXJhbCBleHByZXNzaW9ucyBtdXN0IGhhdmUgYSBzcGVjaWZpYyB0eXBlLCBnb3QgJHt0eXBlTmFtZSh0eXBlKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENhbGxFeHByZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSByZXR1cm4gdHlwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBvcGVyYXRvci5cbiAgICogQHBhcmFtIHsuLi5FeHByZXNzaW9ufSBhcmdzIFRoZSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcGVyYXRvciwgLi4uYXJncykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7TGl0ZXJhbEV4cHJlc3Npb258Q2FsbEV4cHJlc3Npb259IEV4cHJlc3Npb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnNpbmdDb250ZXh0XG4gKiBAcHJvcGVydHkge1NldDxzdHJpbmc+fSB2YXJpYWJsZXMgVmFyaWFibGVzIHJlZmVyZW5jZWQgd2l0aCB0aGUgJ3Zhcicgb3BlcmF0b3IuXG4gKiBAcHJvcGVydHkge1NldDxzdHJpbmc+fSBwcm9wZXJ0aWVzIFByb3BlcnRpZXMgcmVmZXJlbmNlZCB3aXRoIHRoZSAnZ2V0JyBvcGVyYXRvci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmVhdHVyZUlkIFRoZSBzdHlsZSB1c2VzIHRoZSBmZWF0dXJlIGlkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBnZW9tZXRyeVR5cGUgVGhlIHN0eWxlIHVzZXMgdGhlIGZlYXR1cmUgZ2VvbWV0cnkgdHlwZS5cbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge1BhcnNpbmdDb250ZXh0fSBBIG5ldyBwYXJzaW5nIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZXdQYXJzaW5nQ29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICB2YXJpYWJsZXM6IG5ldyBTZXQoKSxcbiAgICBwcm9wZXJ0aWVzOiBuZXcgU2V0KCksXG4gICAgZmVhdHVyZUlkOiBmYWxzZSxcbiAgICBnZW9tZXRyeVR5cGU6IGZhbHNlLFxuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtMaXRlcmFsVmFsdWV8QXJyYXl9IEVuY29kZWRFeHByZXNzaW9uXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZWRFeHByZXNzaW9ufSBlbmNvZGVkIFRoZSBlbmNvZGVkIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWRUeXBlIFRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbn0gVGhlIHBhcnNlZCBleHByZXNzaW9uIHJlc3VsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKGVuY29kZWQsIGV4cGVjdGVkVHlwZSwgY29udGV4dCkge1xuICBzd2l0Y2ggKHR5cGVvZiBlbmNvZGVkKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6IHtcbiAgICAgIGlmIChpc1R5cGUoZXhwZWN0ZWRUeXBlLCBTdHJpbmdUeXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKFN0cmluZ1R5cGUsIGVuY29kZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5jbHVkZXNUeXBlKGV4cGVjdGVkVHlwZSwgQm9vbGVhblR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgZ290IGEgYm9vbGVhbiwgYnV0IGV4cGVjdGVkICR7dHlwZU5hbWUoZXhwZWN0ZWRUeXBlKX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihCb29sZWFuVHlwZSwgZW5jb2RlZCk7XG4gICAgfVxuICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgIGlmIChpc1R5cGUoZXhwZWN0ZWRUeXBlLCBTaXplVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihTaXplVHlwZSwgdG9TaXplKGVuY29kZWQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1R5cGUoZXhwZWN0ZWRUeXBlLCBCb29sZWFuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihCb29sZWFuVHlwZSwgISFlbmNvZGVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1R5cGUoZXhwZWN0ZWRUeXBlLCBTdHJpbmdUeXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKFN0cmluZ1R5cGUsIGVuY29kZWQudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWluY2x1ZGVzVHlwZShleHBlY3RlZFR5cGUsIE51bWJlclR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ290IGEgbnVtYmVyLCBidXQgZXhwZWN0ZWQgJHt0eXBlTmFtZShleHBlY3RlZFR5cGUpfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihOdW1iZXJUeXBlLCBlbmNvZGVkKTtcbiAgICB9XG4gICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgaWYgKGlzVHlwZShleHBlY3RlZFR5cGUsIENvbG9yVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihDb2xvclR5cGUsIGNvbG9yRnJvbVN0cmluZyhlbmNvZGVkKSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUeXBlKGV4cGVjdGVkVHlwZSwgQm9vbGVhblR5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oQm9vbGVhblR5cGUsICEhZW5jb2RlZCk7XG4gICAgICB9XG4gICAgICBpZiAoIWluY2x1ZGVzVHlwZShleHBlY3RlZFR5cGUsIFN0cmluZ1R5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ290IGEgc3RyaW5nLCBidXQgZXhwZWN0ZWQgJHt0eXBlTmFtZShleHBlY3RlZFR5cGUpfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihTdHJpbmdUeXBlLCBlbmNvZGVkKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgLy8gcGFzc1xuICAgIH1cbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShlbmNvZGVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwcmVzc2lvbiBtdXN0IGJlIGFuIGFycmF5IG9yIGEgcHJpbWl0aXZlIHZhbHVlJyk7XG4gIH1cblxuICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VtcHR5IGV4cHJlc3Npb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RlZFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VDYWxsRXhwcmVzc2lvbihlbmNvZGVkLCBleHBlY3RlZFR5cGUsIGNvbnRleHQpO1xuICB9XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGVuY29kZWQpIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNUeXBlKGV4cGVjdGVkVHlwZSwgU2l6ZVR5cGUpKSB7XG4gICAgaWYgKGVuY29kZWQubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBleHBlY3RlZCBhbiBhcnJheSBvZiB0d28gdmFsdWVzIGZvciBhIHNpemUsIGdvdCAke2VuY29kZWQubGVuZ3RofWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKFNpemVUeXBlLCBlbmNvZGVkKTtcbiAgfVxuXG4gIGlmIChpc1R5cGUoZXhwZWN0ZWRUeXBlLCBDb2xvclR5cGUpKSB7XG4gICAgaWYgKGVuY29kZWQubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKENvbG9yVHlwZSwgWy4uLmVuY29kZWQsIDFdKTtcbiAgICB9XG4gICAgaWYgKGVuY29kZWQubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKENvbG9yVHlwZSwgZW5jb2RlZCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBleHBlY3RlZCBhbiBhcnJheSBvZiAzIG9yIDQgdmFsdWVzIGZvciBhIGNvbG9yLCBnb3QgJHtlbmNvZGVkLmxlbmd0aH1gLFxuICAgICk7XG4gIH1cblxuICBpZiAoIWluY2x1ZGVzVHlwZShleHBlY3RlZFR5cGUsIE51bWJlckFycmF5VHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgZ290IGFuIGFycmF5IG9mIG51bWJlcnMsIGJ1dCBleHBlY3RlZCAke3R5cGVOYW1lKGV4cGVjdGVkVHlwZSl9YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihOdW1iZXJBcnJheVR5cGUsIGVuY29kZWQpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgT3BzID0ge1xuICBHZXQ6ICdnZXQnLFxuICBWYXI6ICd2YXInLFxuICBDb25jYXQ6ICdjb25jYXQnLFxuICBHZW9tZXRyeVR5cGU6ICdnZW9tZXRyeS10eXBlJyxcbiAgTGluZU1ldHJpYzogJ2xpbmUtbWV0cmljJyxcbiAgQW55OiAnYW55JyxcbiAgQWxsOiAnYWxsJyxcbiAgTm90OiAnIScsXG4gIFJlc29sdXRpb246ICdyZXNvbHV0aW9uJyxcbiAgWm9vbTogJ3pvb20nLFxuICBUaW1lOiAndGltZScsXG4gIEVxdWFsOiAnPT0nLFxuICBOb3RFcXVhbDogJyE9JyxcbiAgR3JlYXRlclRoYW46ICc+JyxcbiAgR3JlYXRlclRoYW5PckVxdWFsVG86ICc+PScsXG4gIExlc3NUaGFuOiAnPCcsXG4gIExlc3NUaGFuT3JFcXVhbFRvOiAnPD0nLFxuICBNdWx0aXBseTogJyonLFxuICBEaXZpZGU6ICcvJyxcbiAgQWRkOiAnKycsXG4gIFN1YnRyYWN0OiAnLScsXG4gIENsYW1wOiAnY2xhbXAnLFxuICBNb2Q6ICclJyxcbiAgUG93OiAnXicsXG4gIEFiczogJ2FicycsXG4gIEZsb29yOiAnZmxvb3InLFxuICBDZWlsOiAnY2VpbCcsXG4gIFJvdW5kOiAncm91bmQnLFxuICBTaW46ICdzaW4nLFxuICBDb3M6ICdjb3MnLFxuICBBdGFuOiAnYXRhbicsXG4gIFNxcnQ6ICdzcXJ0JyxcbiAgTWF0Y2g6ICdtYXRjaCcsXG4gIEJldHdlZW46ICdiZXR3ZWVuJyxcbiAgSW50ZXJwb2xhdGU6ICdpbnRlcnBvbGF0ZScsXG4gIENvYWxlc2NlOiAnY29hbGVzY2UnLFxuICBDYXNlOiAnY2FzZScsXG4gIEluOiAnaW4nLFxuICBOdW1iZXI6ICdudW1iZXInLFxuICBTdHJpbmc6ICdzdHJpbmcnLFxuICBBcnJheTogJ2FycmF5JyxcbiAgQ29sb3I6ICdjb2xvcicsXG4gIElkOiAnaWQnLFxuICBCYW5kOiAnYmFuZCcsXG4gIFBhbGV0dGU6ICdwYWxldHRlJyxcbiAgVG9TdHJpbmc6ICd0by1zdHJpbmcnLFxuICBIYXM6ICdoYXMnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXksIG51bWJlciwgUGFyc2luZ0NvbnRleHQpOkV4cHJlc3Npb259IFBhcnNlclxuICpcbiAqIFNlY29uZCBhcmd1bWVudCBpcyB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBQYXJzZXI+fVxuICovXG5jb25zdCBwYXJzZXJzID0ge1xuICBbT3BzLkdldF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKGhhc0FyZ3NDb3VudCgxLCBJbmZpbml0eSksIHdpdGhHZXRBcmdzKSxcbiAgW09wcy5WYXJdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihoYXNBcmdzQ291bnQoMSwgMSksIHdpdGhWYXJBcmdzKSxcbiAgW09wcy5IYXNdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihoYXNBcmdzQ291bnQoMSwgSW5maW5pdHkpLCB3aXRoR2V0QXJncyksXG4gIFtPcHMuSWRdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcih1c2VzRmVhdHVyZUlkLCB3aXRoTm9BcmdzKSxcbiAgW09wcy5Db25jYXRdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgSW5maW5pdHkpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKFN0cmluZ1R5cGUpLFxuICApLFxuICBbT3BzLkdlb21ldHJ5VHlwZV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKHVzZXNHZW9tZXRyeVR5cGUsIHdpdGhOb0FyZ3MpLFxuICBbT3BzLkxpbmVNZXRyaWNdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcih3aXRoTm9BcmdzKSxcbiAgW09wcy5SZXNvbHV0aW9uXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIod2l0aE5vQXJncyksXG4gIFtPcHMuWm9vbV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKHdpdGhOb0FyZ3MpLFxuICBbT3BzLlRpbWVdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcih3aXRoTm9BcmdzKSxcbiAgW09wcy5BbnldOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgSW5maW5pdHkpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKEJvb2xlYW5UeXBlKSxcbiAgKSxcbiAgW09wcy5BbGxdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgSW5maW5pdHkpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKEJvb2xlYW5UeXBlKSxcbiAgKSxcbiAgW09wcy5Ob3RdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQm9vbGVhblR5cGUpLFxuICApLFxuICBbT3BzLkVxdWFsXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKEFueVR5cGUpLFxuICApLFxuICBbT3BzLk5vdEVxdWFsXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKEFueVR5cGUpLFxuICApLFxuICBbT3BzLkdyZWF0ZXJUaGFuXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkxlc3NUaGFuXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkxlc3NUaGFuT3JFcXVhbFRvXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLk11bHRpcGx5XTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIEluZmluaXR5KSxcbiAgICB3aXRoQXJnc09mUmV0dXJuVHlwZSxcbiAgKSxcbiAgW09wcy5Db2FsZXNjZV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlJldHVyblR5cGUsXG4gICksXG4gIFtPcHMuRGl2aWRlXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkFkZF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuU3VidHJhY3RdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuQ2xhbXBdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMywgMyksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuTW9kXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLlBvd106IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCAyKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5BYnNdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuRmxvb3JdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuQ2VpbF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5Sb3VuZF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5TaW5dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuQ29zXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDEsIDEpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkF0YW5dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuU3FydF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5NYXRjaF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCg0LCBJbmZpbml0eSksXG4gICAgaGFzRXZlbkFyZ3MsXG4gICAgd2l0aE1hdGNoQXJncyxcbiAgKSxcbiAgW09wcy5CZXR3ZWVuXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDMsIDMpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkludGVycG9sYXRlXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDYsIEluZmluaXR5KSxcbiAgICBoYXNFdmVuQXJncyxcbiAgICB3aXRoSW50ZXJwb2xhdGVBcmdzLFxuICApLFxuICBbT3BzLkNhc2VdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMywgSW5maW5pdHkpLFxuICAgIGhhc09kZEFyZ3MsXG4gICAgd2l0aENhc2VBcmdzLFxuICApLFxuICBbT3BzLkluXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoaGFzQXJnc0NvdW50KDIsIDIpLCB3aXRoSW5BcmdzKSxcbiAgW09wcy5OdW1iZXJdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgSW5maW5pdHkpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKEFueVR5cGUpLFxuICApLFxuICBbT3BzLlN0cmluZ106IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQW55VHlwZSksXG4gICksXG4gIFtPcHMuQXJyYXldOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgSW5maW5pdHkpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkNvbG9yXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDEsIDQpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkJhbmRdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMyksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuUGFsZXR0ZV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCAyKSxcbiAgICB3aXRoUGFsZXR0ZUFyZ3MsXG4gICksXG4gIFtPcHMuVG9TdHJpbmddOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQm9vbGVhblR5cGUgfCBOdW1iZXJUeXBlIHwgU3RyaW5nVHlwZSB8IENvbG9yVHlwZSksXG4gICksXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihBcnJheTxFbmNvZGVkRXhwcmVzc2lvbj4sIG51bWJlciwgUGFyc2luZ0NvbnRleHQpOkFycmF5PEV4cHJlc3Npb24+fHZvaWR9IEFyZ1ZhbGlkYXRvclxuICpcbiAqIEFuIGFyZ3VtZW50IHZhbGlkYXRvciBhcHBsaWVzIHZhcmlvdXMgY2hlY2tzIHRvIGFuIGVuY29kZWQgZXhwcmVzc2lvbiBhcmd1bWVudHMgYW5kXG4gKiByZXR1cm5zIHRoZSBwYXJzZWQgYXJndW1lbnRzIGlmIGFueS4gIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKi9cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aEdldEFyZ3MoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb25zdCBhcmdzQ291bnQgPSBlbmNvZGVkLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJnc0NvdW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzQ291bnQ7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGVuY29kZWRbaSArIDFdO1xuICAgIHN3aXRjaCAodHlwZW9mIGtleSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICBhcmdzW2ldID0gbmV3IExpdGVyYWxFeHByZXNzaW9uKE51bWJlclR5cGUsIGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICBhcmdzW2ldID0gbmV3IExpdGVyYWxFeHByZXNzaW9uKFN0cmluZ1R5cGUsIGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYGV4cGVjdGVkIGEgc3RyaW5nIGtleSBvciBudW1lcmljIGFycmF5IGluZGV4IGZvciBhIGdldCBvcGVyYXRpb24sIGdvdCAke2tleX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29udGV4dC5wcm9wZXJ0aWVzLmFkZChTdHJpbmcoa2V5KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB3aXRoVmFyQXJncyhlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSBlbmNvZGVkWzFdO1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhIHN0cmluZyBhcmd1bWVudCBmb3IgdmFyIG9wZXJhdGlvbicpO1xuICB9XG4gIGNvbnRleHQudmFyaWFibGVzLmFkZChuYW1lKTtcblxuICByZXR1cm4gW25ldyBMaXRlcmFsRXhwcmVzc2lvbihTdHJpbmdUeXBlLCBuYW1lKV07XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHVzZXNGZWF0dXJlSWQoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb250ZXh0LmZlYXR1cmVJZCA9IHRydWU7XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHVzZXNHZW9tZXRyeVR5cGUoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb250ZXh0Lmdlb21ldHJ5VHlwZSA9IHRydWU7XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhOb0FyZ3MoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb25zdCBvcGVyYXRpb24gPSBlbmNvZGVkWzBdO1xuICBpZiAoZW5jb2RlZC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIG5vIGFyZ3VtZW50cyBmb3IgJHtvcGVyYXRpb259IG9wZXJhdGlvbmApO1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluQXJncyBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFyZ3MgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAqIEByZXR1cm4ge0FyZ1ZhbGlkYXRvcn0gVGhlIGFyZ3VtZW50IHZhbGlkYXRvclxuICovXG5mdW5jdGlvbiBoYXNBcmdzQ291bnQobWluQXJncywgbWF4QXJncykge1xuICByZXR1cm4gZnVuY3Rpb24gKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSBlbmNvZGVkWzBdO1xuICAgIGNvbnN0IGFyZ0NvdW50ID0gZW5jb2RlZC5sZW5ndGggLSAxO1xuICAgIGlmIChtaW5BcmdzID09PSBtYXhBcmdzKSB7XG4gICAgICBpZiAoYXJnQ291bnQgIT09IG1pbkFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGx1cmFsID0gbWluQXJncyA9PT0gMSA/ICcnIDogJ3MnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYGV4cGVjdGVkICR7bWluQXJnc30gYXJndW1lbnQke3BsdXJhbH0gZm9yICR7b3BlcmF0aW9ufSwgZ290ICR7YXJnQ291bnR9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ0NvdW50IDwgbWluQXJncyB8fCBhcmdDb3VudCA+IG1heEFyZ3MpIHtcbiAgICAgIGNvbnN0IHJhbmdlID1cbiAgICAgICAgbWF4QXJncyA9PT0gSW5maW5pdHlcbiAgICAgICAgICA/IGAke21pbkFyZ3N9IG9yIG1vcmVgXG4gICAgICAgICAgOiBgJHttaW5BcmdzfSB0byAke21heEFyZ3N9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGV4cGVjdGVkICR7cmFuZ2V9IGFyZ3VtZW50cyBmb3IgJHtvcGVyYXRpb259LCBnb3QgJHthcmdDb3VudH1gLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGUge0FyZ1ZhbGlkYXRvcn1cbiAqL1xuZnVuY3Rpb24gd2l0aEFyZ3NPZlJldHVyblR5cGUoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb25zdCBhcmdDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxFeHByZXNzaW9uPn1cbiAgICovXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJnQ291bnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ0NvdW50OyArK2kpIHtcbiAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UoZW5jb2RlZFtpICsgMV0sIHJldHVyblR5cGUsIGNvbnRleHQpO1xuICAgIGFyZ3NbaV0gPSBleHByZXNzaW9uO1xuICB9XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdUeXBlIFRoZSBhcmd1bWVudCB0eXBlLlxuICogQHJldHVybiB7QXJnVmFsaWRhdG9yfSBUaGUgYXJndW1lbnQgdmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhBcmdzT2ZUeXBlKGFyZ1R5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYXJnQ291bnQgPSBlbmNvZGVkLmxlbmd0aCAtIDE7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEV4cHJlc3Npb24+fVxuICAgICAqL1xuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJnQ291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKGVuY29kZWRbaSArIDFdLCBhcmdUeXBlLCBjb250ZXh0KTtcbiAgICAgIGFyZ3NbaV0gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJnVmFsaWRhdG9yfVxuICovXG5mdW5jdGlvbiBoYXNPZGRBcmdzKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3BlcmF0aW9uID0gZW5jb2RlZFswXTtcbiAgY29uc3QgYXJnQ291bnQgPSBlbmNvZGVkLmxlbmd0aCAtIDE7XG4gIGlmIChhcmdDb3VudCAlIDIgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgZXhwZWN0ZWQgYW4gb2RkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yICR7b3BlcmF0aW9ufSwgZ290ICR7YXJnQ291bnR9IGluc3RlYWRgLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJnVmFsaWRhdG9yfVxuICovXG5mdW5jdGlvbiBoYXNFdmVuQXJncyhlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wZXJhdGlvbiA9IGVuY29kZWRbMF07XG4gIGNvbnN0IGFyZ0NvdW50ID0gZW5jb2RlZC5sZW5ndGggLSAxO1xuICBpZiAoYXJnQ291bnQgJSAyID09PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3Igb3BlcmF0aW9uICR7b3BlcmF0aW9ufSwgZ290ICR7YXJnQ291bnR9IGluc3RlYWRgLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aE1hdGNoQXJncyhlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3NDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcblxuICBjb25zdCBpbnB1dFR5cGUgPSBTdHJpbmdUeXBlIHwgTnVtYmVyVHlwZSB8IEJvb2xlYW5UeXBlO1xuXG4gIGNvbnN0IGlucHV0ID0gcGFyc2UoZW5jb2RlZFsxXSwgaW5wdXRUeXBlLCBjb250ZXh0KTtcblxuICBjb25zdCBmYWxsYmFjayA9IHBhcnNlKGVuY29kZWRbZW5jb2RlZC5sZW5ndGggLSAxXSwgcmV0dXJuVHlwZSwgY29udGV4dCk7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmdzQ291bnQgLSAyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzQ291bnQgLSAyOyBpICs9IDIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBwYXJzZShlbmNvZGVkW2kgKyAyXSwgaW5wdXQudHlwZSwgY29udGV4dCk7XG4gICAgICBhcmdzW2ldID0gbWF0Y2g7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gcGFyc2UgYXJndW1lbnQgJHtpICsgMX0gb2YgbWF0Y2ggZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHBhcnNlKGVuY29kZWRbaSArIDNdLCBmYWxsYmFjay50eXBlLCBjb250ZXh0KTtcbiAgICAgIGFyZ3NbaSArIDFdID0gb3V0cHV0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZmFpbGVkIHRvIHBhcnNlIGFyZ3VtZW50ICR7aSArIDJ9IG9mIG1hdGNoIGV4cHJlc3Npb246ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtpbnB1dCwgLi4uYXJncywgZmFsbGJhY2tdO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB3aXRoSW50ZXJwb2xhdGVBcmdzKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGlvblR5cGUgPSBlbmNvZGVkWzFdO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxldCBiYXNlO1xuICBzd2l0Y2ggKGludGVycG9sYXRpb25UeXBlWzBdKSB7XG4gICAgY2FzZSAnbGluZWFyJzpcbiAgICAgIGJhc2UgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZXhwb25lbnRpYWwnOlxuICAgICAgY29uc3QgYiA9IGludGVycG9sYXRpb25UeXBlWzFdO1xuICAgICAgaWYgKHR5cGVvZiBiICE9PSAnbnVtYmVyJyB8fCBiIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBleHBlY3RlZCBhIG51bWJlciBiYXNlIGZvciBleHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uYCArXG4gICAgICAgICAgICBgLCBnb3QgJHtKU09OLnN0cmluZ2lmeShiKX0gaW5zdGVhZGAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBiYXNlID0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBpbnZhbGlkIGludGVycG9sYXRpb24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShpbnRlcnBvbGF0aW9uVHlwZSl9YCxcbiAgICAgICk7XG4gIH1cblxuICBjb25zdCBpbnRlcnBvbGF0aW9uID0gbmV3IExpdGVyYWxFeHByZXNzaW9uKE51bWJlclR5cGUsIGJhc2UpO1xuXG4gIGxldCBpbnB1dDtcbiAgdHJ5IHtcbiAgICBpbnB1dCA9IHBhcnNlKGVuY29kZWRbMl0sIE51bWJlclR5cGUsIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgZmFpbGVkIHRvIHBhcnNlIGFyZ3VtZW50IDEgaW4gaW50ZXJwb2xhdGUgZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGVuY29kZWQubGVuZ3RoIC0gMyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9wID0gcGFyc2UoZW5jb2RlZFtpICsgM10sIE51bWJlclR5cGUsIGNvbnRleHQpO1xuICAgICAgYXJnc1tpXSA9IHN0b3A7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gcGFyc2UgYXJndW1lbnQgJHtpICsgMn0gZm9yIGludGVycG9sYXRlIGV4cHJlc3Npb246ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBwYXJzZShlbmNvZGVkW2kgKyA0XSwgcmV0dXJuVHlwZSwgY29udGV4dCk7XG4gICAgICBhcmdzW2kgKyAxXSA9IG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBwYXJzZSBhcmd1bWVudCAke2kgKyAzfSBmb3IgaW50ZXJwb2xhdGUgZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2ludGVycG9sYXRpb24sIGlucHV0LCAuLi5hcmdzXTtcbn1cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aENhc2VBcmdzKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZmFsbGJhY2sgPSBwYXJzZShlbmNvZGVkW2VuY29kZWQubGVuZ3RoIC0gMV0sIHJldHVyblR5cGUsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoZW5jb2RlZC5sZW5ndGggLSAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwYXJzZShlbmNvZGVkW2kgKyAxXSwgQm9vbGVhblR5cGUsIGNvbnRleHQpO1xuICAgICAgYXJnc1tpXSA9IGNvbmRpdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBwYXJzZSBhcmd1bWVudCAke2l9IG9mIGNhc2UgZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHBhcnNlKGVuY29kZWRbaSArIDJdLCBmYWxsYmFjay50eXBlLCBjb250ZXh0KTtcbiAgICAgIGFyZ3NbaSArIDFdID0gb3V0cHV0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZmFpbGVkIHRvIHBhcnNlIGFyZ3VtZW50ICR7aSArIDF9IG9mIGNhc2UgZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBmYWxsYmFjaztcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhJbkFyZ3MoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBsZXQgaGF5c3RhY2sgPSBlbmNvZGVkWzJdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaGF5c3RhY2spKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHRoZSBzZWNvbmQgYXJndW1lbnQgZm9yIHRoZSBcImluXCIgb3BlcmF0b3IgbXVzdCBiZSBhbiBhcnJheWAsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxldCBuZWVkbGVUeXBlO1xuICBpZiAodHlwZW9mIGhheXN0YWNrWzBdID09PSAnc3RyaW5nJykge1xuICAgIGlmIChoYXlzdGFja1swXSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmb3IgdGhlIFwiaW5cIiBvcGVyYXRvciwgYSBzdHJpbmcgYXJyYXkgc2hvdWxkIGJlIHdyYXBwZWQgaW4gYSBcImxpdGVyYWxcIiBvcGVyYXRvciB0byBkaXNhbWJpZ3VhdGUgZnJvbSBleHByZXNzaW9uc2AsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGF5c3RhY2tbMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gcGFyc2UgXCJpblwiIGV4cHJlc3Npb246IHRoZSBsaXRlcmFsIG9wZXJhdG9yIG11c3QgYmUgZm9sbG93ZWQgYnkgYW4gYXJyYXlgLFxuICAgICAgKTtcbiAgICB9XG4gICAgaGF5c3RhY2sgPSBoYXlzdGFja1sxXTtcbiAgICBuZWVkbGVUeXBlID0gU3RyaW5nVHlwZTtcbiAgfSBlbHNlIHtcbiAgICBuZWVkbGVUeXBlID0gTnVtYmVyVHlwZTtcbiAgfVxuXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoaGF5c3RhY2subGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFyZyA9IHBhcnNlKGhheXN0YWNrW2ldLCBuZWVkbGVUeXBlLCBjb250ZXh0KTtcbiAgICAgIGFyZ3NbaV0gPSBhcmc7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gcGFyc2UgaGF5c3RhY2sgaXRlbSAke2l9IGZvciBcImluXCIgZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZWVkbGUgPSBwYXJzZShlbmNvZGVkWzFdLCBuZWVkbGVUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIFtuZWVkbGUsIC4uLmFyZ3NdO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB3aXRoUGFsZXR0ZUFyZ3MoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBsZXQgaW5kZXg7XG4gIHRyeSB7XG4gICAgaW5kZXggPSBwYXJzZShlbmNvZGVkWzFdLCBOdW1iZXJUeXBlLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGZhaWxlZCB0byBwYXJzZSBmaXJzdCBhcmd1bWVudCBpbiBwYWxldHRlIGV4cHJlc3Npb246ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICApO1xuICB9XG4gIGNvbnN0IGNvbG9ycyA9IGVuY29kZWRbMl07XG4gIGlmICghQXJyYXkuaXNBcnJheShjb2xvcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIHBhbGV0dGUgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG4gIGNvbnN0IHBhcnNlZENvbG9ycyA9IG5ldyBBcnJheShjb2xvcnMubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRDb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY29sb3I7XG4gICAgdHJ5IHtcbiAgICAgIGNvbG9yID0gcGFyc2UoY29sb3JzW2ldLCBDb2xvclR5cGUsIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZmFpbGVkIHRvIHBhcnNlIGNvbG9yIGF0IGluZGV4ICR7aX0gaW4gcGFsZXR0ZSBleHByZXNzaW9uOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIShjb2xvciBpbnN0YW5jZW9mIExpdGVyYWxFeHByZXNzaW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgdGhlIHBhbGV0dGUgY29sb3IgYXQgaW5kZXggJHtpfSBtdXN0IGJlIGEgbGl0ZXJhbCB2YWx1ZWAsXG4gICAgICApO1xuICAgIH1cbiAgICBwYXJzZWRDb2xvcnNbaV0gPSBjb2xvcjtcbiAgfVxuICByZXR1cm4gW2luZGV4LCAuLi5wYXJzZWRDb2xvcnNdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJnVmFsaWRhdG9yPn0gdmFsaWRhdG9ycyBBIGNoYWluIG9mIGFyZ3VtZW50IHZhbGlkYXRvcnMuICBUaGUgbGFzdCB2YWxpZGF0b3IgaXMgZXhwZWN0ZWRcbiAqIHRvIHJldHVybiB0aGUgcGFyc2VkIGFyZ3VtZW50cy5cbiAqIEByZXR1cm4ge1BhcnNlcn0gVGhlIHBhcnNlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoLi4udmFsaWRhdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBvcGVyYXRvciA9IGVuY29kZWRbMF07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59XG4gICAgICovXG4gICAgbGV0IGFyZ3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZGF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB2YWxpZGF0b3JzW2ldKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpO1xuICAgICAgaWYgKGkgPT0gdmFsaWRhdG9ycy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2V4cGVjdGVkIGxhc3QgYXJndW1lbnQgdmFsaWRhdG9yIHRvIHJldHVybiB0aGUgcGFyc2VkIGFyZ3MnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncyA9IHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDYWxsRXhwcmVzc2lvbihyZXR1cm5UeXBlLCBvcGVyYXRvciwgLi4uYXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gZW5jb2RlZCBUaGUgZW5jb2RlZCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJldHVyblR5cGUgVGhlIGV4cGVjdGVkIHJldHVybiB0eXBlIG9mIHRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9ufSBUaGUgcGFyc2VkIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FsbEV4cHJlc3Npb24oZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb25zdCBvcGVyYXRvciA9IGVuY29kZWRbMF07XG5cbiAgY29uc3QgcGFyc2VyID0gcGFyc2Vyc1tvcGVyYXRvcl07XG4gIGlmICghcGFyc2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG9wZXJhdG9yOiAke29wZXJhdG9yfWApO1xuICB9XG4gIHJldHVybiBwYXJzZXIoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHNpbXBsaWZpZWQgZ2VvbWV0cnkgdHlwZSBzdWl0ZWQgZm9yIHRoZSBgZ2VvbWV0cnktdHlwZWAgb3BlcmF0b3JcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9nZW9tL0dlb21ldHJ5LmpzJykuZGVmYXVsdHxpbXBvcnQoJy4uL3JlbmRlci9GZWF0dXJlLmpzJykuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkgb2JqZWN0XG4gKiBAcmV0dXJuIHsnUG9pbnQnfCdMaW5lU3RyaW5nJ3wnUG9seWdvbid8Jyd9IFNpbXBsaWZpZWQgZ2VvbWV0cnkgdHlwZTsgZW1wdHkgc3RyaW5nIG9mIG5vIGdlb21ldHJ5IGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlR2VvbWV0cnlUeXBlKGdlb21ldHJ5KSB7XG4gIGlmICghZ2VvbWV0cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7J1BvaW50J3wnTGluZVN0cmluZyd8J1BvbHlnb24nfSAqLyAodHlwZS5zdWJzdHJpbmcoNSkpO1xuICAgIGNhc2UgJ0NpcmNsZSc6XG4gICAgICByZXR1cm4gJ1BvbHlnb24nO1xuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICByZXR1cm4gY29tcHV0ZUdlb21ldHJ5VHlwZShcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgKS5nZXRHZW9tZXRyaWVzKClbMF0sXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnRcbiAqL1xuaW1wb3J0IFJlbGF0aW9uc2hpcCBmcm9tICcuL2V4dGVudC9SZWxhdGlvbnNoaXAuanMnO1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGFuIGV4dGVudDogYFttaW54LCBtaW55LCBtYXh4LCBtYXh5XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gRXh0ZW50XG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBFeHRlbnQgY29ybmVyLlxuICogQHR5cGVkZWYgeydib3R0b20tbGVmdCcgfCAnYm90dG9tLXJpZ2h0JyB8ICd0b3AtbGVmdCcgfCAndG9wLXJpZ2h0J30gQ29ybmVyXG4gKi9cblxuLyoqXG4gKiBCdWlsZCBhbiBleHRlbnQgdGhhdCBpbmNsdWRlcyBhbGwgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7RXh0ZW50fSBCb3VuZGluZyBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuZGluZ0V4dGVudChjb29yZGluYXRlcykge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geHMgWHMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHlzIFlzLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmZ1bmN0aW9uIF9ib3VuZGluZ0V4dGVudFhZcyh4cywgeXMsIGRlc3QpIHtcbiAgY29uc3QgbWluWCA9IE1hdGgubWluLmFwcGx5KG51bGwsIHhzKTtcbiAgY29uc3QgbWluWSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHlzKTtcbiAgY29uc3QgbWF4WCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHhzKTtcbiAgY29uc3QgbWF4WSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHlzKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIGRlc3QpO1xufVxuXG4vKipcbiAqIFJldHVybiBleHRlbnQgaW5jcmVhc2VkIGJ5IHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIGV4dGVudCBzaG91bGQgYmUgYnVmZmVyZWQuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyKGV4dGVudCwgdmFsdWUsIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gZXh0ZW50WzBdIC0gdmFsdWU7XG4gICAgZGVzdFsxXSA9IGV4dGVudFsxXSAtIHZhbHVlO1xuICAgIGRlc3RbMl0gPSBleHRlbnRbMl0gKyB2YWx1ZTtcbiAgICBkZXN0WzNdID0gZXh0ZW50WzNdICsgdmFsdWU7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBleHRlbnRbMF0gLSB2YWx1ZSxcbiAgICBleHRlbnRbMV0gLSB2YWx1ZSxcbiAgICBleHRlbnRbMl0gKyB2YWx1ZSxcbiAgICBleHRlbnRbM10gKyB2YWx1ZSxcbiAgXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50IHRvIGNsb25lLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IFRoZSBjbG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGV4dGVudCwgZGVzdCkge1xuICBpZiAoZGVzdCkge1xuICAgIGRlc3RbMF0gPSBleHRlbnRbMF07XG4gICAgZGVzdFsxXSA9IGV4dGVudFsxXTtcbiAgICBkZXN0WzJdID0gZXh0ZW50WzJdO1xuICAgIGRlc3RbM10gPSBleHRlbnRbM107XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgcmV0dXJuIGV4dGVudC5zbGljZSgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IENsb3Nlc3Qgc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWShleHRlbnQsIHgsIHkpIHtcbiAgbGV0IGR4LCBkeTtcbiAgaWYgKHggPCBleHRlbnRbMF0pIHtcbiAgICBkeCA9IGV4dGVudFswXSAtIHg7XG4gIH0gZWxzZSBpZiAoZXh0ZW50WzJdIDwgeCkge1xuICAgIGR4ID0geCAtIGV4dGVudFsyXTtcbiAgfSBlbHNlIHtcbiAgICBkeCA9IDA7XG4gIH1cbiAgaWYgKHkgPCBleHRlbnRbMV0pIHtcbiAgICBkeSA9IGV4dGVudFsxXSAtIHk7XG4gIH0gZWxzZSBpZiAoZXh0ZW50WzNdIDwgeSkge1xuICAgIGR5ID0geSAtIGV4dGVudFszXTtcbiAgfSBlbHNlIHtcbiAgICBkeSA9IDA7XG4gIH1cbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBpbiB0aGUgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICByZXR1cm4gY29udGFpbnNYWShleHRlbnQsIGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIG9uZSBleHRlbnQgY29udGFpbnMgYW5vdGhlci5cbiAqXG4gKiBBbiBleHRlbnQgaXMgZGVlbWVkIGNvbnRhaW5lZCBpZiBpdCBsaWVzIGNvbXBsZXRlbHkgd2l0aGluIHRoZSBvdGhlciBleHRlbnQsXG4gKiBpbmNsdWRpbmcgaWYgdGhleSBzaGFyZSBvbmUgb3IgbW9yZSBlZGdlcy5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNlY29uZCBleHRlbnQgaXMgY29udGFpbmVkIGJ5IG9yIG9uIHRoZSBlZGdlIG9mIHRoZVxuICogICAgIGZpcnN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNFeHRlbnQoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gKFxuICAgIGV4dGVudDFbMF0gPD0gZXh0ZW50MlswXSAmJlxuICAgIGV4dGVudDJbMl0gPD0gZXh0ZW50MVsyXSAmJlxuICAgIGV4dGVudDFbMV0gPD0gZXh0ZW50MlsxXSAmJlxuICAgIGV4dGVudDJbM10gPD0gZXh0ZW50MVszXVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB4LCB5IHZhbHVlcyBhcmUgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1hZKGV4dGVudCwgeCwgeSkge1xuICByZXR1cm4gZXh0ZW50WzBdIDw9IHggJiYgeCA8PSBleHRlbnRbMl0gJiYgZXh0ZW50WzFdIDw9IHkgJiYgeSA8PSBleHRlbnRbM107XG59XG5cbi8qKlxuICogR2V0IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIGNvb3JkaW5hdGUgYW5kIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC9SZWxhdGlvbnNoaXAuanNcIikuZGVmYXVsdH0gVGhlIHJlbGF0aW9uc2hpcCAoYml0d2lzZSBjb21wYXJlIHdpdGhcbiAqICAgICBpbXBvcnQoXCIuL2V4dGVudC9SZWxhdGlvbnNoaXAuanNcIikuUmVsYXRpb25zaGlwKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gIGNvbnN0IG1pblkgPSBleHRlbnRbMV07XG4gIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgbGV0IHJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcC5VTktOT1dOO1xuICBpZiAoeCA8IG1pblgpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuTEVGVDtcbiAgfSBlbHNlIGlmICh4ID4gbWF4WCkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5SSUdIVDtcbiAgfVxuICBpZiAoeSA8IG1pblkpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuQkVMT1c7XG4gIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuQUJPVkU7XG4gIH1cbiAgaWYgKHJlbGF0aW9uc2hpcCA9PT0gUmVsYXRpb25zaGlwLlVOS05PV04pIHtcbiAgICByZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HO1xuICB9XG4gIHJldHVybiByZWxhdGlvbnNoaXA7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVtcHR5IGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRW1wdHkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHkoKSB7XG4gIHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV4dGVudCBvciB1cGRhdGUgdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBkZXN0KSB7XG4gIGlmIChkZXN0KSB7XG4gICAgZGVzdFswXSA9IG1pblg7XG4gICAgZGVzdFsxXSA9IG1pblk7XG4gICAgZGVzdFsyXSA9IG1heFg7XG4gICAgZGVzdFszXSA9IG1heFk7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgcmV0dXJuIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZW1wdHkgZXh0ZW50IG9yIG1ha2UgdGhlIHByb3ZpZGVkIG9uZSBlbXB0eS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlc3QpIHtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKEluZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHksIGRlc3QpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKGNvb3JkaW5hdGUsIGRlc3QpIHtcbiAgY29uc3QgeCA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoeCwgeSwgeCwgeSwgZGVzdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBkZXN0KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIHJldHVybiBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIGNvb3JkaW5hdGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBkZXN0LFxuKSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIHJldHVybiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tUmluZ3MocmluZ3MsIGRlc3QpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KTtcbiAgcmV0dXJuIGV4dGVuZFJpbmdzKGV4dGVudCwgcmluZ3MpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0d28gZXh0ZW50cyBhcmUgZXF1aXZhbGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gKFxuICAgIGV4dGVudDFbMF0gPT0gZXh0ZW50MlswXSAmJlxuICAgIGV4dGVudDFbMl0gPT0gZXh0ZW50MlsyXSAmJlxuICAgIGV4dGVudDFbMV0gPT0gZXh0ZW50MlsxXSAmJlxuICAgIGV4dGVudDFbM10gPT0gZXh0ZW50MlszXVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0d28gZXh0ZW50cyBhcmUgYXBwcm94aW1hdGVseSBlcXVpdmFsZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlIGluIGV4dGVudCBjb29yZGluYXRlIHVuaXRzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGRpZmZlciBieSBsZXNzIHRoYW4gdGhlIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcHJveGltYXRlbHlFcXVhbHMoZXh0ZW50MSwgZXh0ZW50MiwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiAoXG4gICAgTWF0aC5hYnMoZXh0ZW50MVswXSAtIGV4dGVudDJbMF0pIDwgdG9sZXJhbmNlICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50MVsyXSAtIGV4dGVudDJbMl0pIDwgdG9sZXJhbmNlICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50MVsxXSAtIGV4dGVudDJbMV0pIDwgdG9sZXJhbmNlICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50MVszXSAtIGV4dGVudDJbM10pIDwgdG9sZXJhbmNlXG4gICk7XG59XG5cbi8qKlxuICogTW9kaWZ5IGFuIGV4dGVudCB0byBpbmNsdWRlIGFub3RoZXIgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgVGhlIGV4dGVudCB0byBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIFRoZSBleHRlbnQgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdC5cbiAqIEByZXR1cm4ge0V4dGVudH0gQSByZWZlcmVuY2UgdG8gdGhlIGZpcnN0IChleHRlbmRlZCkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgaWYgKGV4dGVudDJbMF0gPCBleHRlbnQxWzBdKSB7XG4gICAgZXh0ZW50MVswXSA9IGV4dGVudDJbMF07XG4gIH1cbiAgaWYgKGV4dGVudDJbMl0gPiBleHRlbnQxWzJdKSB7XG4gICAgZXh0ZW50MVsyXSA9IGV4dGVudDJbMl07XG4gIH1cbiAgaWYgKGV4dGVudDJbMV0gPCBleHRlbnQxWzFdKSB7XG4gICAgZXh0ZW50MVsxXSA9IGV4dGVudDJbMV07XG4gIH1cbiAgaWYgKGV4dGVudDJbM10gPiBleHRlbnQxWzNdKSB7XG4gICAgZXh0ZW50MVszXSA9IGV4dGVudDJbM107XG4gIH1cbiAgcmV0dXJuIGV4dGVudDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICBpZiAoY29vcmRpbmF0ZVswXSA8IGV4dGVudFswXSkge1xuICAgIGV4dGVudFswXSA9IGNvb3JkaW5hdGVbMF07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMF0gPiBleHRlbnRbMl0pIHtcbiAgICBleHRlbnRbMl0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzFdIDwgZXh0ZW50WzFdKSB7XG4gICAgZXh0ZW50WzFdID0gY29vcmRpbmF0ZVsxXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA+IGV4dGVudFszXSkge1xuICAgIGV4dGVudFszXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCBjb29yZGluYXRlcykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKFxuICBleHRlbnQsXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbikge1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgZXh0ZW5kWFkoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSByaW5ncyBSaW5ncy5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kUmluZ3MoZXh0ZW50LCByaW5ncykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSByaW5ncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCByaW5nc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGV4dGVudFswXSA9IE1hdGgubWluKGV4dGVudFswXSwgeCk7XG4gIGV4dGVudFsxXSA9IE1hdGgubWluKGV4dGVudFsxXSwgeSk7XG4gIGV4dGVudFsyXSA9IE1hdGgubWF4KGV4dGVudFsyXSwgeCk7XG4gIGV4dGVudFszXSA9IE1hdGgubWF4KGV4dGVudFszXSwgeSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50LiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdCB2YWx1ZVxuICogaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogU30gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcmV0dXJuIHtTfGJvb2xlYW59IFZhbHVlLlxuICogQHRlbXBsYXRlIFNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hDb3JuZXIoZXh0ZW50LCBjYWxsYmFjaykge1xuICBsZXQgdmFsO1xuICB2YWwgPSBjYWxsYmFjayhnZXRCb3R0b21MZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjayhnZXRCb3R0b21SaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2soZ2V0VG9wUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrKGdldFRvcExlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGV4dGVudCkge1xuICBsZXQgYXJlYSA9IDA7XG4gIGlmICghaXNFbXB0eShleHRlbnQpKSB7XG4gICAgYXJlYSA9IGdldFdpZHRoKGV4dGVudCkgKiBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbUxlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbMV1dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21SaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFsxXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDZW50ZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDZW50ZXIoZXh0ZW50KSB7XG4gIHJldHVybiBbKGV4dGVudFswXSArIGV4dGVudFsyXSkgLyAyLCAoZXh0ZW50WzFdICsgZXh0ZW50WzNdKSAvIDJdO1xufVxuXG4vKipcbiAqIEdldCBhIGNvcm5lciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBDb3JuZXIuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29ybmVyIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpIHtcbiAgbGV0IGNvb3JkaW5hdGU7XG4gIGlmIChjb3JuZXIgPT09ICdib3R0b20tbGVmdCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gJ2JvdHRvbS1yaWdodCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09ICd0b3AtbGVmdCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gJ3RvcC1yaWdodCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29ybmVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5sYXJnZWQgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVubGFyZ2VkQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbihleHRlbnQxWzBdLCBleHRlbnQyWzBdKTtcbiAgY29uc3QgbWluWSA9IE1hdGgubWluKGV4dGVudDFbMV0sIGV4dGVudDJbMV0pO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXgoZXh0ZW50MVsyXSwgZXh0ZW50MlsyXSk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heChleHRlbnQxWzNdLCBleHRlbnQyWzNdKTtcbiAgcmV0dXJuIChtYXhYIC0gbWluWCkgKiAobWF4WSAtIG1pblkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUsIGRlc3QpIHtcbiAgY29uc3QgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5M10gPSBnZXRSb3RhdGVkVmlld3BvcnQoXG4gICAgY2VudGVyLFxuICAgIHJlc29sdXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgc2l6ZSxcbiAgKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKFxuICAgIE1hdGgubWluKHgwLCB4MSwgeDIsIHgzKSxcbiAgICBNYXRoLm1pbih5MCwgeTEsIHkyLCB5MyksXG4gICAgTWF0aC5tYXgoeDAsIHgxLCB4MiwgeDMpLFxuICAgIE1hdGgubWF4KHkwLCB5MSwgeTIsIHkzKSxcbiAgICBkZXN0LFxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gTGluZWFyIHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2aWV3cG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0ZWRWaWV3cG9ydChjZW50ZXIsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBzaXplKSB7XG4gIGNvbnN0IGR4ID0gKHJlc29sdXRpb24gKiBzaXplWzBdKSAvIDI7XG4gIGNvbnN0IGR5ID0gKHJlc29sdXRpb24gKiBzaXplWzFdKSAvIDI7XG4gIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgY29uc3QgeENvcyA9IGR4ICogY29zUm90YXRpb247XG4gIGNvbnN0IHhTaW4gPSBkeCAqIHNpblJvdGF0aW9uO1xuICBjb25zdCB5Q29zID0gZHkgKiBjb3NSb3RhdGlvbjtcbiAgY29uc3QgeVNpbiA9IGR5ICogc2luUm90YXRpb247XG4gIGNvbnN0IHggPSBjZW50ZXJbMF07XG4gIGNvbnN0IHkgPSBjZW50ZXJbMV07XG4gIHJldHVybiBbXG4gICAgeCAtIHhDb3MgKyB5U2luLFxuICAgIHkgLSB4U2luIC0geUNvcyxcbiAgICB4IC0geENvcyAtIHlTaW4sXG4gICAgeSAtIHhTaW4gKyB5Q29zLFxuICAgIHggKyB4Q29zIC0geVNpbixcbiAgICB5ICsgeFNpbiArIHlDb3MsXG4gICAgeCArIHhDb3MgKyB5U2luLFxuICAgIHkgKyB4U2luIC0geUNvcyxcbiAgICB4IC0geENvcyArIHlTaW4sXG4gICAgeSAtIHhTaW4gLSB5Q29zLFxuICBdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbM10gLSBleHRlbnRbMV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gSW50ZXJzZWN0aW9uIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BcmVhKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIpO1xuICByZXR1cm4gZ2V0QXJlYShpbnRlcnNlY3Rpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBleHRlbnRzLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gT3B0aW9uYWwgZXh0ZW50IHRvIHBvcHVsYXRlIHdpdGggaW50ZXJzZWN0aW9uLlxuICogQHJldHVybiB7RXh0ZW50fSBJbnRlcnNlY3RpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIsIGRlc3QpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gZGVzdCA/IGRlc3QgOiBjcmVhdGVFbXB0eSgpO1xuICBpZiAoaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSkge1xuICAgIGlmIChleHRlbnQxWzBdID4gZXh0ZW50MlswXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MlswXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMV0gPiBleHRlbnQyWzFdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQxWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQyWzFdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVsyXSA8IGV4dGVudDJbMl0pIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDFbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDJbMl07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzNdIDwgZXh0ZW50MlszXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MlszXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlT3JVcGRhdGVFbXB0eShpbnRlcnNlY3Rpb24pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb247XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1hcmdpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmdpbihleHRlbnQpIHtcbiAgcmV0dXJuIGdldFdpZHRoKGV4dGVudCkgKyBnZXRIZWlnaHQoZXh0ZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgKHdpZHRoLCBoZWlnaHQpIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBUaGUgZXh0ZW50IHNpemUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSAtIGV4dGVudFswXSwgZXh0ZW50WzNdIC0gZXh0ZW50WzFdXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVG9wIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcExlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbM11dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdG9wIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVG9wIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BSaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFszXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaWR0aChleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFsyXSAtIGV4dGVudFswXTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgb25lIGV4dGVudCBpbnRlcnNlY3RzIGFub3RoZXIuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBpbnRlcnNlY3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIChcbiAgICBleHRlbnQxWzBdIDw9IGV4dGVudDJbMl0gJiZcbiAgICBleHRlbnQxWzJdID49IGV4dGVudDJbMF0gJiZcbiAgICBleHRlbnQxWzFdIDw9IGV4dGVudDJbM10gJiZcbiAgICBleHRlbnQxWzNdID49IGV4dGVudDJbMV1cbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZXh0ZW50IGlzIGVtcHR5LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gPCBleHRlbnRbMF0gfHwgZXh0ZW50WzNdIDwgZXh0ZW50WzFdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk9yVXBkYXRlKGV4dGVudCwgZGVzdCkge1xuICBpZiAoZGVzdCkge1xuICAgIGRlc3RbMF0gPSBleHRlbnRbMF07XG4gICAgZGVzdFsxXSA9IGV4dGVudFsxXTtcbiAgICBkZXN0WzJdID0gZXh0ZW50WzJdO1xuICAgIGRlc3RbM10gPSBleHRlbnRbM107XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlRnJvbUNlbnRlcihleHRlbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRlbHRhWCA9ICgoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIGNvbnN0IGRlbHRhWSA9ICgoZXh0ZW50WzNdIC0gZXh0ZW50WzFdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIGV4dGVudFswXSAtPSBkZWx0YVg7XG4gIGV4dGVudFsyXSArPSBkZWx0YVg7XG4gIGV4dGVudFsxXSAtPSBkZWx0YVk7XG4gIGV4dGVudFszXSArPSBkZWx0YVk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBzZWdtZW50IGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzIGludGVyc2VjdHMgKGNyb3NzZXMsXG4gKiB0b3VjaGVzLCBvciBpcyBjb250YWluZWQgYnkpIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBzdGFydCBTZWdtZW50IHN0YXJ0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBlbmQgU2VnbWVudCBlbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgc3RhcnQsIGVuZCkge1xuICBsZXQgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICBjb25zdCBzdGFydFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBzdGFydCk7XG4gIGNvbnN0IGVuZFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBlbmQpO1xuICBpZiAoXG4gICAgc3RhcnRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcgfHxcbiAgICBlbmRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkdcbiAgKSB7XG4gICAgaW50ZXJzZWN0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgICBjb25zdCBtaW5ZID0gZXh0ZW50WzFdO1xuICAgIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gICAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgICBjb25zdCBzdGFydFggPSBzdGFydFswXTtcbiAgICBjb25zdCBzdGFydFkgPSBzdGFydFsxXTtcbiAgICBjb25zdCBlbmRYID0gZW5kWzBdO1xuICAgIGNvbnN0IGVuZFkgPSBlbmRbMV07XG4gICAgY29uc3Qgc2xvcGUgPSAoZW5kWSAtIHN0YXJ0WSkgLyAoZW5kWCAtIHN0YXJ0WCk7XG4gICAgbGV0IHgsIHk7XG4gICAgaWYgKCEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkgJiYgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgdG9wXG4gICAgICB4ID0gZW5kWCAtIChlbmRZIC0gbWF4WSkgLyBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSAmJlxuICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5SSUdIVClcbiAgICApIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgcmlnaHRcbiAgICAgIHkgPSBlbmRZIC0gKGVuZFggLSBtYXhYKSAqIHNsb3BlO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFpbnRlcnNlY3RzICYmXG4gICAgICAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpICYmXG4gICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKVxuICAgICkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyBib3R0b21cbiAgICAgIHggPSBlbmRYIC0gKGVuZFkgLSBtaW5ZKSAvIHNsb3BlO1xuICAgICAgaW50ZXJzZWN0cyA9IHggPj0gbWluWCAmJiB4IDw9IG1heFg7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFpbnRlcnNlY3RzICYmXG4gICAgICAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuTEVGVCkgJiZcbiAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuTEVGVClcbiAgICApIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgbGVmdFxuICAgICAgeSA9IGVuZFkgLSAoZW5kWCAtIG1pblgpICogc2xvcGU7XG4gICAgICBpbnRlcnNlY3RzID0geSA+PSBtaW5ZICYmIHkgPD0gbWF4WTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdHM7XG59XG5cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIENhbGxlZCB3aXRoIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1gIGV4dGVudCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wc10gTnVtYmVyIG9mIHN0b3BzIHBlciBzaWRlIHVzZWQgZm9yIHRoZSB0cmFuc2Zvcm0uXG4gKiBCeSBkZWZhdWx0IG9ubHkgdGhlIGNvcm5lcnMgYXJlIHVzZWQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGV4dGVudCwgdHJhbnNmb3JtRm4sIGRlc3QsIHN0b3BzKSB7XG4gIGlmIChpc0VtcHR5KGV4dGVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KTtcbiAgfVxuICBsZXQgY29vcmRpbmF0ZXMgPSBbXTtcbiAgaWYgKHN0b3BzID4gMSkge1xuICAgIGNvbnN0IHdpZHRoID0gZXh0ZW50WzJdIC0gZXh0ZW50WzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGV4dGVudFszXSAtIGV4dGVudFsxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BzOyArK2kpIHtcbiAgICAgIGNvb3JkaW5hdGVzLnB1c2goXG4gICAgICAgIGV4dGVudFswXSArICh3aWR0aCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFsxXSxcbiAgICAgICAgZXh0ZW50WzJdLFxuICAgICAgICBleHRlbnRbMV0gKyAoaGVpZ2h0ICogaSkgLyBzdG9wcyxcbiAgICAgICAgZXh0ZW50WzJdIC0gKHdpZHRoICogaSkgLyBzdG9wcyxcbiAgICAgICAgZXh0ZW50WzNdLFxuICAgICAgICBleHRlbnRbMF0sXG4gICAgICAgIGV4dGVudFszXSAtIChoZWlnaHQgKiBpKSAvIHN0b3BzLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29vcmRpbmF0ZXMgPSBbXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbM10sXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbM10sXG4gICAgXTtcbiAgfVxuICB0cmFuc2Zvcm1Gbihjb29yZGluYXRlcywgY29vcmRpbmF0ZXMsIDIpO1xuICBjb25zdCB4cyA9IFtdO1xuICBjb25zdCB5cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHhzLnB1c2goY29vcmRpbmF0ZXNbaV0pO1xuICAgIHlzLnB1c2goY29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgfVxuICByZXR1cm4gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgZGVzdCk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHByb3ZpZGVkIGV4dGVudCBpbi1wbGFjZSB0byBiZSB3aXRoaW4gdGhlIHJlYWwgd29ybGRcbiAqIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uXG4gKiBAcmV0dXJuIHtFeHRlbnR9IFRoZSBleHRlbnQgd2l0aGluIHRoZSByZWFsIHdvcmxkIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKGV4dGVudCwgcHJvamVjdGlvbikge1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgY29uc3QgY2VudGVyID0gZ2V0Q2VudGVyKGV4dGVudCk7XG4gIGlmIChcbiAgICBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAoY2VudGVyWzBdIDwgcHJvamVjdGlvbkV4dGVudFswXSB8fCBjZW50ZXJbMF0gPj0gcHJvamVjdGlvbkV4dGVudFsyXSlcbiAgKSB7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgIGNvbnN0IHdvcmxkc0F3YXkgPSBNYXRoLmZsb29yKFxuICAgICAgKGNlbnRlclswXSAtIHByb2plY3Rpb25FeHRlbnRbMF0pIC8gd29ybGRXaWR0aCxcbiAgICApO1xuICAgIGNvbnN0IG9mZnNldCA9IHdvcmxkc0F3YXkgKiB3b3JsZFdpZHRoO1xuICAgIGV4dGVudFswXSAtPSBvZmZzZXQ7XG4gICAgZXh0ZW50WzJdIC09IG9mZnNldDtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEZpdHMgdGhlIGV4dGVudCB0byB0aGUgcmVhbCB3b3JsZFxuICpcbiAqIElmIHRoZSBleHRlbnQgZG9lcyBub3QgY3Jvc3MgdGhlIGFudGkgbWVyaWRpYW4sIHRoaXMgd2lsbCByZXR1cm4gdGhlIGV4dGVudCBpbiBhbiBhcnJheVxuICogSWYgdGhlIGV4dGVudCBjcm9zc2VzIHRoZSBhbnRpIG1lcmlkaWFuLCB0aGUgZXh0ZW50IHdpbGwgYmUgc2xpY2VkLCBzbyBlYWNoIHBhcnQgZml0cyB3aXRoaW4gdGhlXG4gKiByZWFsIHdvcmxkXG4gKlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpV29ybGRdIFJldHVybiBhbGwgd29ybGRzXG4gKiBAcmV0dXJuIHtBcnJheTxFeHRlbnQ+fSBUaGUgZXh0ZW50IHdpdGhpbiB0aGUgcmVhbCB3b3JsZCBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQW5kU2xpY2VYKGV4dGVudCwgcHJvamVjdGlvbiwgbXVsdGlXb3JsZCkge1xuICBpZiAocHJvamVjdGlvbi5jYW5XcmFwWCgpKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG5cbiAgICBpZiAoIWlzRmluaXRlKGV4dGVudFswXSkgfHwgIWlzRmluaXRlKGV4dGVudFsyXSkpIHtcbiAgICAgIHJldHVybiBbW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXV07XG4gICAgfVxuXG4gICAgd3JhcFgoZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG5cbiAgICBpZiAoZ2V0V2lkdGgoZXh0ZW50KSA+IHdvcmxkV2lkdGggJiYgIW11bHRpV29ybGQpIHtcbiAgICAgIC8vIHRoZSBleHRlbnQgd3JhcHMgYXJvdW5kIG9uIGl0c2VsZlxuICAgICAgcmV0dXJuIFtbcHJvamVjdGlvbkV4dGVudFswXSwgZXh0ZW50WzFdLCBwcm9qZWN0aW9uRXh0ZW50WzJdLCBleHRlbnRbM11dXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudFswXSA8IHByb2plY3Rpb25FeHRlbnRbMF0pIHtcbiAgICAgIC8vIHRoZSBleHRlbnQgY3Jvc3NlcyB0aGUgYW50aSBtZXJpZGlhbiwgc28gaXQgbmVlZHMgdG8gYmUgc2xpY2VkXG4gICAgICByZXR1cm4gW1xuICAgICAgICBbZXh0ZW50WzBdICsgd29ybGRXaWR0aCwgZXh0ZW50WzFdLCBwcm9qZWN0aW9uRXh0ZW50WzJdLCBleHRlbnRbM11dLFxuICAgICAgICBbcHJvamVjdGlvbkV4dGVudFswXSwgZXh0ZW50WzFdLCBleHRlbnRbMl0sIGV4dGVudFszXV0sXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50WzJdID4gcHJvamVjdGlvbkV4dGVudFsyXSkge1xuICAgICAgLy8gdGhlIGV4dGVudCBjcm9zc2VzIHRoZSBhbnRpIG1lcmlkaWFuLCBzbyBpdCBuZWVkcyB0byBiZSBzbGljZWRcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtleHRlbnRbMF0sIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXSxcbiAgICAgICAgW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgZXh0ZW50WzJdIC0gd29ybGRXaWR0aCwgZXh0ZW50WzNdXSxcbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtleHRlbnRdO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudC9SZWxhdGlvbnNoaXBcbiAqL1xuXG4vKipcbiAqIFJlbGF0aW9uc2hpcCB0byBhbiBleHRlbnQuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVOS05PV046IDAsXG4gIElOVEVSU0VDVElORzogMSxcbiAgQUJPVkU6IDIsXG4gIFJJR0hUOiA0LFxuICBCRUxPVzogOCxcbiAgTEVGVDogMTYsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Z1bmN0aW9uc1xuICovXG5cbmltcG9ydCB7ZXF1YWxzIGFzIGFycmF5RXF1YWxzfSBmcm9tICcuL2FycmF5LmpzJztcblxuLyoqXG4gKiBBbHdheXMgcmV0dXJucyB0cnVlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRSVUUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gZmFsc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGQUxTRSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgcmV1c2FibGUgZnVuY3Rpb24sIHVzZWQgZS5nLiBhcyBhIGRlZmF1bHQgZm9yIGNhbGxiYWNrcy5cbiAqXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gVk9JRCgpIHt9XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIGluIGFub3RoZXIgZnVuY3Rpb24gdGhhdCByZW1lbWJlcnMgdGhlIGxhc3QgcmV0dXJuLiAgSWYgdGhlXG4gKiByZXR1cm5lZCBmdW5jdGlvbiBpcyBjYWxsZWQgdHdpY2UgaW4gYSByb3cgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYW5kIHRoZSBzYW1lXG4gKiB0aGlzIG9iamVjdCwgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IGNhbGwgaW4gdGhlIHNlY29uZCBjYWxsLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55KTogUmV0dXJuVHlwZX0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5hbnkpOiBSZXR1cm5UeXBlfSBUaGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgUmV0dXJuVHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZU9uZShmbikge1xuICAvKiogQHR5cGUge1JldHVyblR5cGV9ICovXG4gIGxldCBsYXN0UmVzdWx0O1xuXG4gIC8qKiBAdHlwZSB7QXJyYXk8YW55Pnx1bmRlZmluZWR9ICovXG4gIGxldCBsYXN0QXJncztcblxuICBsZXQgbGFzdFRoaXM7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHsqfSBPbmx5IG5lZWQgdG8ga25vdyBpZiBgdGhpc2AgY2hhbmdlZCwgZG9uJ3QgY2FyZSB3aGF0IHR5cGVcbiAgICogQHJldHVybiB7UmV0dXJuVHlwZX0gTWVtb2l6ZWQgdmFsdWVcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgbmV4dEFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICghbGFzdEFyZ3MgfHwgdGhpcyAhPT0gbGFzdFRoaXMgfHwgIWFycmF5RXF1YWxzKG5leHRBcmdzLCBsYXN0QXJncykpIHtcbiAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgIGxhc3RBcmdzID0gbmV4dEFyZ3M7XG4gICAgICBsYXN0UmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogKFQgfCBQcm9taXNlPFQ+KX0gZ2V0dGVyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdmFsdWUgb3IgYSBwcm9taXNlIGZvciBhIHZhbHVlLlxuICogQHJldHVybiB7UHJvbWlzZTxUPn0gQSBwcm9taXNlIGZvciB0aGUgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1Byb21pc2UoZ2V0dGVyKSB7XG4gIGZ1bmN0aW9uIHByb21pc2VHZXR0ZXIoKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGdldHRlcigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2VHZXR0ZXIoKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5XG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7XG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZUVtcHR5LFxuICBjcmVhdGVPclVwZGF0ZUVtcHR5LFxuICBnZXRIZWlnaHQsXG4gIHJldHVybk9yVXBkYXRlLFxufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbiwgZ2V0VHJhbnNmb3JtfSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7bWVtb2l6ZU9uZX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4vZmxhdC90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnWFknIHwgJ1hZWicgfCAnWFlNJyB8ICdYWVpNJ30gR2VvbWV0cnlMYXlvdXRcbiAqIFRoZSBjb29yZGluYXRlIGxheW91dCBmb3IgZ2VvbWV0cmllcywgaW5kaWNhdGluZyB3aGV0aGVyIGEgM3JkIG9yIDR0aCB6ICgnWicpXG4gKiBvciBtZWFzdXJlICgnTScpIGNvb3JkaW5hdGUgaXMgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydQb2ludCcgfCAnTGluZVN0cmluZycgfCAnTGluZWFyUmluZycgfCAnUG9seWdvbicgfCAnTXVsdGlQb2ludCcgfCAnTXVsdGlMaW5lU3RyaW5nJyB8ICdNdWx0aVBvbHlnb24nIHwgJ0dlb21ldHJ5Q29sbGVjdGlvbicgfCAnQ2lyY2xlJ30gVHlwZVxuICogVGhlIGdlb21ldHJ5IHR5cGUuICBPbmUgb2YgYCdQb2ludCdgLCBgJ0xpbmVTdHJpbmcnYCwgYCdMaW5lYXJSaW5nJ2AsXG4gKiBgJ1BvbHlnb24nYCwgYCdNdWx0aVBvaW50J2AsIGAnTXVsdGlMaW5lU3RyaW5nJ2AsIGAnTXVsdGlQb2x5Z29uJ2AsXG4gKiBgJ0dlb21ldHJ5Q29sbGVjdGlvbidgLCBvciBgJ0NpcmNsZSdgLlxuICovXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gKi9cbmNvbnN0IHRtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFRvIGdldCBub3RpZmllZCBvZiBjaGFuZ2VzIHRvIHRoZSBnZW9tZXRyeSwgcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgdGhlXG4gKiBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IG9uIHlvdXIgZ2VvbWV0cnkgaW5zdGFuY2UuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEdlb21ldHJ5IGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHRyYW5zZm9ybWVkIGFuZCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhlIGdlb21ldHJ5LlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXZpc2lvbiBUaGUgZ2VvbWV0cnkgcmV2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdHJhbnNmb3JtXSBPcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAgICovXG4gICAgdGhpcy5zaW1wbGlmeVRyYW5zZm9ybWVkSW50ZXJuYWwgPSBtZW1vaXplT25lKFxuICAgICAgKHJldmlzaW9uLCBzcXVhcmVkVG9sZXJhbmNlLCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGNsb25lLmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJldHVybiBjbG9uZS5nZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSk7XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdHJhbnNmb3JtZWQgYW5kIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdHJhbnNmb3JtXSBPcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgc2ltcGxpZnlUcmFuc2Zvcm1lZChzcXVhcmVkVG9sZXJhbmNlLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdGhpcy5zaW1wbGlmeVRyYW5zZm9ybWVkSW50ZXJuYWwoXG4gICAgICB0aGlzLmdldFJldmlzaW9uKCksXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7IUdlb21ldHJ5fSBDbG9uZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICAgKi9cbiAgY29udGFpbnNYWSh4LCB5KSB7XG4gICAgY29uc3QgY29vcmQgPSB0aGlzLmdldENsb3Nlc3RQb2ludChbeCwgeV0pO1xuICAgIHJldHVybiBjb29yZFswXSA9PT0geCAmJiBjb29yZFsxXSA9PT0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNsb3Nlc3QgcG9pbnQgb2YgdGhlIGdlb21ldHJ5IHRvIHRoZSBwYXNzZWQgcG9pbnQgYXNcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUgY29vcmRpbmF0ZX0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjbG9zZXN0UG9pbnRdIENsb3Nlc3QgcG9pbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ2xvc2VzdCBwb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q2xvc2VzdFBvaW50KHBvaW50LCBjbG9zZXN0UG9pbnQpIHtcbiAgICBjbG9zZXN0UG9pbnQgPSBjbG9zZXN0UG9pbnQgPyBjbG9zZXN0UG9pbnQgOiBbTmFOLCBOYU5dO1xuICAgIHRoaXMuY2xvc2VzdFBvaW50WFkocG9pbnRbMF0sIHBvaW50WzFdLCBjbG9zZXN0UG9pbnQsIEluZmluaXR5KTtcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGdlb21ldHJ5IGluY2x1ZGVzIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZS4gSWYgdGhlXG4gICAqIGNvb3JkaW5hdGUgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBnZW9tZXRyeSwgcmV0dXJucyBmYWxzZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0Nvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zWFkoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKi9cbiAgY29tcHV0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoZXh0ZW50KSB7XG4gICAgaWYgKHRoaXMuZXh0ZW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY29uc3QgZXh0ZW50ID0gdGhpcy5jb21wdXRlRXh0ZW50KHRoaXMuZXh0ZW50Xyk7XG4gICAgICBpZiAoaXNOYU4oZXh0ZW50WzBdKSB8fCBpc05hTihleHRlbnRbMV0pKSB7XG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZXh0ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXh0ZW50UmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuT3JVcGRhdGUodGhpcy5leHRlbnRfLCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICByb3RhdGUoYW5nbGUsIGFuY2hvcikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhlIGdlb21ldHJ5ICh3aXRoIGFuIG9wdGlvbmFsIG9yaWdpbikuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHgtZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N5XSBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHktZGlyZWN0aW9uIChkZWZhdWx0cyB0byBzeCkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgc2NhbGUgb3JpZ2luIChkZWZhdWx0cyB0byB0aGUgY2VudGVyXG4gICAqICAgICBvZiB0aGUgZ2VvbWV0cnkgZXh0ZW50KS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2NhbGUoc3gsIHN5LCBhbmNob3IpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGlzIGdlb21ldHJ5LiAgRm9yIGxpbmVzdHJpbmdzLCB0aGlzIHVzZXNcbiAgICogdGhlIFtEb3VnbGFzIFBldWNrZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pXG4gICAqIGFsZ29yaXRobS4gIEZvciBwb2x5Z29ucywgYSBxdWFudGl6YXRpb24tYmFzZWRcbiAgICogc2ltcGxpZmljYXRpb24gaXMgdXNlZCB0byBwcmVzZXJ2ZSB0b3BvbG9neS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUaGUgdG9sZXJhbmNlIGRpc3RhbmNlIGZvciBzaW1wbGlmaWNhdGlvbi5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IEEgbmV3LCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhlIG9yaWdpbmFsIGdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqL1xuICBzaW1wbGlmeSh0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnkodG9sZXJhbmNlICogdG9sZXJhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeSB1c2luZyB0aGUgRG91Z2xhcyBQZXVja2VyXG4gICAqIGFsZ29yaXRobS5cbiAgICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7VHlwZX0gR2VvbWV0cnkgdHlwZS5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogVGhlIGdlb21ldHJ5IGlzIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBgY2xvbmUoKWAgaXQgYW5kXG4gICAqIHRoZW4gdXNlIHRoaXMgZnVuY3Rpb24gb24gdGhlIGNsb25lLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAqIENhbGxlZCB3aXRoIGEgZmxhdCBhcnJheSBvZiBnZW9tZXRyeSBjb29yZGluYXRlcy5cbiAgICovXG4gIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybUZuKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIHBhc3NlZCBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIHRoZSBnZW9tZXRyeS4gIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5IGNvb3JkaW5hdGVzIGluIHBsYWNlLiAgSWZcbiAgICogaW5zdGVhZCB5b3Ugd2FudCBhIG5ldyBnZW9tZXRyeSwgZmlyc3QgYGNsb25lKClgIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIERlbHRhIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVkgRGVsdGEgWS5cbiAgICogQGFwaVxuICAgKi9cbiAgdHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gZWFjaCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeSBmcm9tIG9uZSBjb29yZGluYXRlIHJlZmVyZW5jZVxuICAgKiBzeXN0ZW0gdG8gYW5vdGhlci4gVGhlIGdlb21ldHJ5IGlzIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBGb3IgZXhhbXBsZSwgYSBsaW5lIHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gYSBsaW5lIGFuZCBhIGNpcmNsZSB0byBhIGNpcmNsZS5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRoZSBnZW9tZXRyeSBtb2RpZmllZCBpbiBwbGFjZSwgZmlyc3QgYGNsb25lKClgIGl0IGFuZFxuICAgKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBzb3VyY2UgVGhlIGN1cnJlbnQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gICAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBUaGUgZGVzaXJlZCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAgICogICAgIHN0cmluZyBpZGVudGlmaWVyIG9yIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0LlxuICAgKiBAcmV0dXJuIHt0aGlzfSBUaGlzIGdlb21ldHJ5LiAgTm90ZSB0aGF0IG9yaWdpbmFsIGdlb21ldHJ5IGlzXG4gICAqICAgICBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogQGFwaVxuICAgKi9cbiAgdHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIGNvbnN0IHNvdXJjZVByb2ogPSBnZXRQcm9qZWN0aW9uKHNvdXJjZSk7XG4gICAgY29uc3QgdHJhbnNmb3JtRm4gPVxuICAgICAgc291cmNlUHJvai5nZXRVbml0cygpID09ICd0aWxlLXBpeGVscydcbiAgICAgICAgPyBmdW5jdGlvbiAoaW5Db29yZGluYXRlcywgb3V0Q29vcmRpbmF0ZXMsIHN0cmlkZSkge1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdGVkRXh0ZW50ID0gc291cmNlUHJvai5nZXRXb3JsZEV4dGVudCgpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBnZXRIZWlnaHQocHJvamVjdGVkRXh0ZW50KSAvIGdldEhlaWdodChwaXhlbEV4dGVudCk7XG4gICAgICAgICAgICBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgICAgICAgICB0bXBUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgIHByb2plY3RlZEV4dGVudFswXSxcbiAgICAgICAgICAgICAgcHJvamVjdGVkRXh0ZW50WzNdLFxuICAgICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgICAgLXNjYWxlLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtMkQoXG4gICAgICAgICAgICAgIGluQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIGluQ29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgIHRtcFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgb3V0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcHJvalRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybShzb3VyY2VQcm9qLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBpZiAocHJvalRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvalRyYW5zZm9ybSh0cmFuc2Zvcm1lZCwgdHJhbnNmb3JtZWQsIHN0cmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgICAgfVxuICAgICAgICA6IGdldFRyYW5zZm9ybShzb3VyY2VQcm9qLCBkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnk7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9MaW5lYXJSaW5nXG4gKi9cbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdFBvaW50LCBtYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7ZG91Z2xhc1BldWNrZXJ9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nIGFzIGxpbmVhclJpbmdBcmVhfSBmcm9tICcuL2ZsYXQvYXJlYS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGluZWFyIHJpbmcgZ2VvbWV0cnkuIE9ubHkgdXNlZCBhcyBwYXJ0IG9mIHBvbHlnb247IGNhbm5vdCBiZSByZW5kZXJlZFxuICogb24gaXRzIG93bi5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIExpbmVhclJpbmcgZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqICAgICBGb3IgaW50ZXJuYWwgdXNlLCBmbGF0IGNvb3JkaW5hdGVzIGluIGNvbWJpbmF0aW9uIHdpdGggYGxheW91dGAgYXJlIGFsc28gYWNjZXB0ZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAobGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcyksXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovIChcbiAgICAgICAgICBjb29yZGluYXRlc1xuICAgICAgICApLFxuICAgICAgICBsYXlvdXQsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFMaW5lYXJSaW5nfSBDbG9uZS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhEZWx0YVJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMubWF4RGVsdGFfID0gTWF0aC5zcXJ0KFxuICAgICAgICBtYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICAgICAgMCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXyxcbiAgICAgIHRydWUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYXJlYSBvZiB0aGUgbGluZWFyIHJpbmcgb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdBcmVhKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7TGluZWFyUmluZ30gU2ltcGxpZmllZCBMaW5lYXJSaW5nLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlcihcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsICdYWScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLlR5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnTGluZWFyUmluZyc7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxpbmVhciByaW5nLlxuICAgKiBAcGFyYW0geyFBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICApO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmVhclJpbmc7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2ludFxuICovXG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zWFksIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGV9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkRHh9IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFBvaW50IGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFQb2ludH0gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCk7XG4gICAgcG9pbnQuYXBwbHlQcm9wZXJ0aWVzKHRoaXMpO1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeChcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzBdLFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzFdLFxuICAgICk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLlR5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnUG9pbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBjb250YWluc1hZKGV4dGVudCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMF0sIHRoaXMuZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCwgY29vcmRpbmF0ZXMsIDApO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICApO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vUG9seWdvblxuICovXG5pbXBvcnQgTGluZWFyUmluZyBmcm9tICcuL0xpbmVhclJpbmcuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4vUG9pbnQuanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHthcnJheU1heFNxdWFyZWREZWx0YSwgYXNzaWduQ2xvc2VzdEFycmF5UG9pbnR9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZLCBnZXRDZW50ZXIsIGlzRW1wdHl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtnZXRJbnRlcmlvclBvaW50T2ZBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyaW9ycG9pbnQuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzQXJlT3JpZW50ZWQsIG9yaWVudExpbmVhclJpbmdzfSBmcm9tICcuL2ZsYXQvb3JpZW50LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3MgYXMgbGluZWFyUmluZ3NBcmVhfSBmcm9tICcuL2ZsYXQvYXJlYS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzQ29udGFpbnNYWX0gZnJvbSAnLi9mbGF0L2NvbnRhaW5zLmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7cXVhbnRpemVBcnJheX0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcbmltcG9ydCB7b2Zmc2V0IGFzIHNwaGVyZU9mZnNldH0gZnJvbSAnLi4vc3BoZXJlLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQb2x5Z29uIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUG9seWdvbiBleHRlbmRzIFNpbXBsZUdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fCFBcnJheTxudW1iZXI+fSBjb29yZGluYXRlc1xuICAgKiAgICAgQXJyYXkgb2YgbGluZWFyIHJpbmdzIHRoYXQgZGVmaW5lIHRoZSBwb2x5Z29uLiBUaGUgZmlyc3QgbGluZWFyIHJpbmcgb2YgdGhlXG4gICAqICAgICBhcnJheSBkZWZpbmVzIHRoZSBvdXRlci1ib3VuZGFyeSBvciBzdXJmYWNlIG9mIHRoZSBwb2x5Z29uLiBFYWNoIHN1YnNlcXVlbnRcbiAgICogICAgIGxpbmVhciByaW5nIGRlZmluZXMgYSBob2xlIGluIHRoZSBzdXJmYWNlIG9mIHRoZSBwb2x5Z29uLiBBIGxpbmVhciByaW5nIGlzXG4gICAqICAgICBhbiBhcnJheSBvZiB2ZXJ0aWNlcycgY29vcmRpbmF0ZXMgd2hlcmUgdGhlIGZpcnN0IGNvb3JkaW5hdGUgYW5kIHRoZSBsYXN0IGFyZVxuICAgKiAgICAgZXF1aXZhbGVudC4gKEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aFxuICAgKiAgICAgYGxheW91dGAgYW5kIGBlbmRzYCBhcmUgYWxzbyBhY2NlcHRlZC4pXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbmRzXSBFbmRzIChmb3IgaW50ZXJuYWwgdXNlIHdpdGggZmxhdCBjb29yZGluYXRlcykuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgbGF5b3V0LCBlbmRzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbmRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBudWxsO1xuXG4gICAgaWYgKGxheW91dCAhPT0gdW5kZWZpbmVkICYmIGVuZHMpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGNvb3JkaW5hdGVzKSxcbiAgICAgICk7XG4gICAgICB0aGlzLmVuZHNfID0gZW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gKi8gKFxuICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICksXG4gICAgICAgIGxheW91dCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIGxpbmVhciByaW5nIHRvIHRoaXMgcG9seWdvbi5cbiAgICogQHBhcmFtIHtMaW5lYXJSaW5nfSBsaW5lYXJSaW5nIExpbmVhciByaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBlbmRMaW5lYXJSaW5nKGxpbmVhclJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGxpbmVhclJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBsaW5lYXJSaW5nLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICB9XG4gICAgdGhpcy5lbmRzXy5wdXNoKHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshUG9seWdvbn0gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24oXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLFxuICAgICAgdGhpcy5sYXlvdXQsXG4gICAgICB0aGlzLmVuZHNfLnNsaWNlKCksXG4gICAgKTtcbiAgICBwb2x5Z29uLmFwcGx5UHJvcGVydGllcyh0aGlzKTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoXG4gICAgICAgIGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5lbmRzXyxcbiAgICAgICAgICB0aGlzLnN0cmlkZSxcbiAgICAgICAgICAwLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLFxuICAgICAgdHJ1ZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgbWluU3F1YXJlZERpc3RhbmNlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xuICAgIHJldHVybiBsaW5lYXJSaW5nc0NvbnRhaW5zWFkoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIHBvbHlnb24gb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzQXJlYShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgYXJyYXkgZm9yIHRoaXMgZ2VvbWV0cnkuICBUaGlzIGFycmF5IGhhcyB0aGUgc3RydWN0dXJlXG4gICAqIG9mIGEgR2VvSlNPTiBjb29yZGluYXRlIGFycmF5IGZvciBwb2x5Z29ucy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIE9yaWVudCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0LWhhbmRcbiAgICogICAgIHJ1bGUgKGNvdW50ZXItY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBJZiBgZmFsc2VgLCBjb29yZGluYXRlcyB3aWxsIGJlIG9yaWVudGVkIGFjY29yZGluZyB0byB0aGUgbGVmdC1oYW5kIHJ1bGVcbiAgICogICAgIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgQnkgZGVmYXVsdCwgY29vcmRpbmF0ZSBvcmllbnRhdGlvbiB3aWxsIGRlcGVuZCBvbiBob3cgdGhlIGdlb21ldHJ5IHdhc1xuICAgKiAgICAgY29uc3RydWN0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKHJpZ2h0KSB7XG4gICAgbGV0IGZsYXRDb29yZGluYXRlcztcbiAgICBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgICBvcmllbnRMaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIH1cblxuICAgIHJldHVybiBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheShmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBFbmRzLlxuICAgKi9cbiAgZ2V0RW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBJbnRlcmlvciBwb2ludC5cbiAgICovXG4gIGdldEZsYXRJbnRlcmlvclBvaW50KCkge1xuICAgIGlmICh0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY29uc3QgZmxhdENlbnRlciA9IGdldENlbnRlcih0aGlzLmdldEV4dGVudCgpKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfID0gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoXG4gICAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5lbmRzXyxcbiAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICAgIGZsYXRDZW50ZXIsXG4gICAgICAgIDAsXG4gICAgICApO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqLyAoXG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50X1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGludGVyaW9yIHBvaW50IG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtQb2ludH0gSW50ZXJpb3IgcG9pbnQgYXMgWFlNIGNvb3JkaW5hdGUsIHdoZXJlIE0gaXMgdGhlXG4gICAqIGxlbmd0aCBvZiB0aGUgaG9yaXpvbnRhbCBpbnRlcnNlY3Rpb24gdGhhdCB0aGUgcG9pbnQgYmVsb25ncyB0by5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJpb3JQb2ludCgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuZ2V0RmxhdEludGVyaW9yUG9pbnQoKSwgJ1hZTScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHJpbmdzIG9mIHRoZSBwb2x5Z29uLCAgdGhpcyBpbmNsdWRlcyB0aGUgZXh0ZXJpb3JcbiAgICogcmluZyBhbmQgYW55IGludGVyaW9yIHJpbmdzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiByaW5ncy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZWFyUmluZ0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNfLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIE50aCBsaW5lYXIgcmluZyBvZiB0aGUgcG9seWdvbiBnZW9tZXRyeS4gUmV0dXJuIGBudWxsYCBpZiB0aGVcbiAgICogZ2l2ZW4gaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgKiBUaGUgZXh0ZXJpb3IgbGluZWFyIHJpbmcgaXMgYXZhaWxhYmxlIGF0IGluZGV4IGAwYCBhbmQgdGhlIGludGVyaW9yIHJpbmdzXG4gICAqIGF0IGluZGV4IGAxYCBhbmQgYmV5b25kLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge0xpbmVhclJpbmd8bnVsbH0gTGluZWFyIHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVhclJpbmcoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuZW5kc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICAgIGluZGV4ID09PSAwID8gMCA6IHRoaXMuZW5kc19baW5kZXggLSAxXSxcbiAgICAgICAgdGhpcy5lbmRzX1tpbmRleF0sXG4gICAgICApLFxuICAgICAgdGhpcy5sYXlvdXQsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpbmVhciByaW5ncyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7QXJyYXk8TGluZWFyUmluZz59IExpbmVhciByaW5ncy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZWFyUmluZ3MoKSB7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3QgZW5kcyA9IHRoaXMuZW5kc187XG4gICAgY29uc3QgbGluZWFyUmluZ3MgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgICBjb25zdCBsaW5lYXJSaW5nID0gbmV3IExpbmVhclJpbmcoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIGVuZCksXG4gICAgICAgIGxheW91dCxcbiAgICAgICk7XG4gICAgICBsaW5lYXJSaW5ncy5wdXNoKGxpbmVhclJpbmcpO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gbGluZWFyUmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZW50ZWQgZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIGdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGVkUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgICBpZiAobGluZWFyUmluZ3NBcmVPcmllbnRlZChmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKSkge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLmxlbmd0aCA9IG9yaWVudExpbmVhclJpbmdzKFxuICAgICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5lbmRzXyxcbiAgICAgICAgICB0aGlzLnN0cmlkZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovICh0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1BvbHlnb259IFNpbXBsaWZpZWQgUG9seWdvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCBzaW1wbGlmaWVkRW5kcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gcXVhbnRpemVBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIE1hdGguc3FydChzcXVhcmVkVG9sZXJhbmNlKSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgc2ltcGxpZmllZEVuZHMsXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24oc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgJ1hZJywgc2ltcGxpZmllZEVuZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLlR5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnUG9seWdvbic7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXkoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgZXh0ZW50LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHshQXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBjb29yZGluYXRlcyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICApO1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGVuZHMubGVuZ3RoID09PSAwID8gMCA6IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb2x5Z29uO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcHByb3hpbWF0aW9uIG9mIGEgY2lyY2xlIG9uIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIgKGBbbG9uLCBsYXRdYCBpbiBkZWdyZWVzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG9cbiAqICAgICB0aGUgcG9seWdvbiB2ZXJ0aWNlcyBpbiBtZXRlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW25dIE9wdGlvbmFsIG51bWJlciBvZiB2ZXJ0aWNlcyBmb3IgdGhlIHJlc3VsdGluZ1xuICogICAgIHBvbHlnb24uIERlZmF1bHQgaXMgYDMyYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3BoZXJlUmFkaXVzXSBPcHRpb25hbCByYWRpdXMgZm9yIHRoZSBzcGhlcmUgKGRlZmF1bHRzIHRvXG4gKiAgICAgdGhlIEVhcnRoJ3MgbWVhbiByYWRpdXMgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZCkuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBUaGUgXCJjaXJjdWxhclwiIHBvbHlnb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjdWxhcihjZW50ZXIsIHJhZGl1cywgbiwgc3BoZXJlUmFkaXVzKSB7XG4gIG4gPSBuID8gbiA6IDMyO1xuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGV4dGVuZChcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNwaGVyZU9mZnNldChjZW50ZXIsIHJhZGl1cywgKDIgKiBNYXRoLlBJICogaSkgLyBuLCBzcGhlcmVSYWRpdXMpLFxuICAgICk7XG4gIH1cbiAgZmxhdENvb3JkaW5hdGVzLnB1c2goZmxhdENvb3JkaW5hdGVzWzBdLCBmbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCAnWFknLCBbZmxhdENvb3JkaW5hdGVzLmxlbmd0aF0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhbiBleHRlbnQuIFRoZSBsYXlvdXQgdXNlZCBpcyBgWFlgLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEByZXR1cm4ge1BvbHlnb259IFRoZSBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV4dGVudChleHRlbnQpIHtcbiAgaWYgKGlzRW1wdHkoZXh0ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBwb2x5Z29uIGZyb20gZW1wdHkgZXh0ZW50Jyk7XG4gIH1cbiAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgY29uc3QgbWF4WCA9IGV4dGVudFsyXTtcbiAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gW1xuICAgIG1pblgsXG4gICAgbWluWSxcbiAgICBtaW5YLFxuICAgIG1heFksXG4gICAgbWF4WCxcbiAgICBtYXhZLFxuICAgIG1heFgsXG4gICAgbWluWSxcbiAgICBtaW5YLFxuICAgIG1pblksXG4gIF07XG4gIHJldHVybiBuZXcgUG9seWdvbihmbGF0Q29vcmRpbmF0ZXMsICdYWScsIFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBwb2x5Z29uIGZyb20gYSBjaXJjbGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZSBDaXJjbGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpZGVzXSBOdW1iZXIgb2Ygc2lkZXMgb2YgdGhlIHBvbHlnb24uIERlZmF1bHQgaXMgMzIuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FuZ2xlXSBTdGFydCBhbmdsZSBmb3IgdGhlIGZpcnN0IHZlcnRleCBvZiB0aGUgcG9seWdvbiBpblxuICogICAgIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMuIDAgbWVhbnMgRWFzdC4gRGVmYXVsdCBpcyAwLlxuICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21DaXJjbGUoY2lyY2xlLCBzaWRlcywgYW5nbGUpIHtcbiAgc2lkZXMgPSBzaWRlcyA/IHNpZGVzIDogMzI7XG4gIGNvbnN0IHN0cmlkZSA9IGNpcmNsZS5nZXRTdHJpZGUoKTtcbiAgY29uc3QgbGF5b3V0ID0gY2lyY2xlLmdldExheW91dCgpO1xuICBjb25zdCBjZW50ZXIgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gc3RyaWRlICogKHNpZGVzICsgMSk7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IG5ldyBBcnJheShhcnJheUxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgZmxhdENvb3JkaW5hdGVzW2ldID0gMDtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdID0gMDtcbiAgICBmb3IgKGxldCBqID0gMjsgaiA8IHN0cmlkZTsgaisrKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbaSArIGpdID0gY2VudGVyW2pdO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbmRzID0gW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdO1xuICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCBsYXlvdXQsIGVuZHMpO1xuICBtYWtlUmVndWxhcihwb2x5Z29uLCBjZW50ZXIsIGNpcmNsZS5nZXRSYWRpdXMoKSwgYW5nbGUpO1xuICByZXR1cm4gcG9seWdvbjtcbn1cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9seWdvbiB0byBtYWtlIGl0IGEgcmVndWxhciBwb2x5Z29uLlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5Z29uIFBvbHlnb24gZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciBvZiB0aGUgcmVndWxhciBwb2x5Z29uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYW5nbGVdIFN0YXJ0IGFuZ2xlIGZvciB0aGUgZmlyc3QgdmVydGV4IG9mIHRoZSBwb2x5Z29uIGluXG4gKiAgICAgY291bnRlci1jbG9ja3dpc2UgcmFkaWFucy4gMCBtZWFucyBFYXN0LiBEZWZhdWx0IGlzIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVndWxhcihwb2x5Z29uLCBjZW50ZXIsIHJhZGl1cywgYW5nbGUpIHtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gcG9seWdvbi5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgY29uc3Qgc3RyaWRlID0gcG9seWdvbi5nZXRTdHJpZGUoKTtcbiAgY29uc3Qgc2lkZXMgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC8gc3RyaWRlIC0gMTtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IGFuZ2xlID8gYW5nbGUgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBzaWRlczsgKytpKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaSAqIHN0cmlkZTtcbiAgICBjb25zdCBhbmdsZSA9IHN0YXJ0QW5nbGUgKyAobW9kdWxvKGksIHNpZGVzKSAqIDIgKiBNYXRoLlBJKSAvIHNpZGVzO1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdID0gY2VudGVyWzBdICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSA9IGNlbnRlclsxXSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgfVxuICBwb2x5Z29uLmNoYW5nZWQoKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1NpbXBsZUdlb21ldHJ5XG4gKi9cbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuL0dlb21ldHJ5LmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMsIGdldENlbnRlcn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7cm90YXRlLCBzY2FsZSwgdHJhbnNmb3JtMkQsIHRyYW5zbGF0ZX0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzOyBkbyBub3QgaW5zdGFudGlhdGVcbiAqIGluIGFwcHMsIGFzIGNhbm5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU2ltcGxlR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9XG4gICAgICovXG4gICAgdGhpcy5sYXlvdXQgPSAnWFknO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdHJpZGUgPSAyO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbXB1dGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgZXh0ZW50LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PCo+IHwgbnVsbH0gQ29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpcnN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRGbGF0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBMYXN0IHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggLSB0aGlzLnN0cmlkZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIGltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXQgbGF5b3V0fSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeSB1c2luZyB0aGUgRG91Z2xhcyBQZXVja2VyIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1NpbXBsZUdlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgaWYgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gIT09IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gMDtcbiAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIC8vIElmIHNxdWFyZWRUb2xlcmFuY2UgaXMgbmVnYXRpdmUgb3IgaWYgd2Uga25vdyB0aGF0IHNpbXBsaWZpY2F0aW9uIHdpbGwgbm90XG4gICAgLy8gaGF2ZSBhbnkgZWZmZWN0IHRoZW4ganVzdCByZXR1cm4gdGhpcy5cbiAgICBpZiAoXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlIDwgMCB8fFxuICAgICAgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSAhPT0gMCAmJlxuICAgICAgICBzcXVhcmVkVG9sZXJhbmNlIDw9IHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHNpbXBsaWZpZWRHZW9tZXRyeSA9XG4gICAgICB0aGlzLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGlmaWVkR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIDwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2ltcGxpZmllZEdlb21ldHJ5O1xuICAgIH1cbiAgICAvLyBTaW1wbGlmaWNhdGlvbiBkaWQgbm90IGFjdHVhbGx5IHJlbW92ZSBhbnkgY29vcmRpbmF0ZXMuICBXZSBub3cga25vd1xuICAgIC8vIHRoYXQgYW55IGNhbGxzIHRvIGdldFNpbXBsaWZpZWRHZW9tZXRyeSB3aXRoIGEgc3F1YXJlZFRvbGVyYW5jZSBsZXNzXG4gICAgLy8gdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBzcXVhcmVkVG9sZXJhbmNlIHdpbGwgYWxzbyBub3QgaGF2ZSBhbnlcbiAgICAvLyBlZmZlY3QuICBUaGlzIGFsbG93cyB1cyB0byBzaG9ydCBjaXJjdWl0IHNpbXBsaWZpY2F0aW9uIChzYXZpbmcgQ1BVXG4gICAgLy8gY3ljbGVzKSBhbmQgcHJldmVudHMgdGhlIGNhY2hlIG9mIHNpbXBsaWZpZWQgZ2VvbWV0cmllcyBmcm9tIGZpbGxpbmdcbiAgICAvLyB1cCB3aXRoIHVzZWxlc3MgaWRlbnRpY2FsIGNvcGllcyBvZiB0aGlzIGdlb21ldHJ5IChzYXZpbmcgbWVtb3J5KS5cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSBzcXVhcmVkVG9sZXJhbmNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtTaW1wbGVHZW9tZXRyeX0gU2ltcGxpZmllZCBnZW9tZXRyeS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gU3RyaWRlLlxuICAgKi9cbiAgZ2V0U3RyaWRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmlkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBzZXRGbGF0Q29vcmRpbmF0ZXMobGF5b3V0LCBmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICB0aGlzLnN0cmlkZSA9IGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpO1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fHVuZGVmaW5lZH0gbGF5b3V0IExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXN0aW5nIE5lc3RpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCBuZXN0aW5nKSB7XG4gICAgbGV0IHN0cmlkZTtcbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBzdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQobGF5b3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXN0aW5nOyArK2kpIHtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubGF5b3V0ID0gJ1hZJztcbiAgICAgICAgICB0aGlzLnN0cmlkZSA9IDI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtBcnJheTx1bmtub3duPn0gKi8gKGNvb3JkaW5hdGVzWzBdKTtcbiAgICAgIH1cbiAgICAgIHN0cmlkZSA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGxheW91dCA9IGdldExheW91dEZvclN0cmlkZShzdHJpZGUpO1xuICAgIH1cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgKiBDYWxsZWQgd2l0aCBhIGZsYXQgYXJyYXkgb2YgZ2VvbWV0cnkgY29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIGlmICh0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdHJhbnNmb3JtRm4oXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgdGhpcy5sYXlvdXQuc3RhcnRzV2l0aCgnWFlaJykgPyAzIDogMixcbiAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiBhbmdsZSBpbiBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByb3RhdGUoYW5nbGUsIGFuY2hvcikge1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcykge1xuICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHJvdGF0ZShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAwLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGFuZ2xlLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhlIGdlb21ldHJ5ICh3aXRoIGFuIG9wdGlvbmFsIG9yaWdpbikuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3ldIFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeS1kaXJlY3Rpb24gKGRlZmF1bHRzIHRvIHN4KS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBzY2FsZSBvcmlnaW4gKGRlZmF1bHRzIHRvIHRoZSBjZW50ZXJcbiAgICogICAgIG9mIHRoZSBnZW9tZXRyeSBleHRlbnQpLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2NhbGUoc3gsIHN5LCBhbmNob3IpIHtcbiAgICBpZiAoc3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3kgPSBzeDtcbiAgICB9XG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIGFuY2hvciA9IGdldENlbnRlcih0aGlzLmdldEV4dGVudCgpKTtcbiAgICB9XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgc2NhbGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBzeCxcbiAgICAgICAgc3ksXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIGdlb21ldHJ5LiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgaW4gcGxhY2UuICBJZlxuICAgKiBpbnN0ZWFkIHlvdSB3YW50IGEgbmV3IGdlb21ldHJ5LCBmaXJzdCBgY2xvbmUoKWAgdGhpcyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0cmFuc2xhdGUoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICB0cmFuc2xhdGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWSxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExheW91dEZvclN0cmlkZShzdHJpZGUpIHtcbiAgbGV0IGxheW91dDtcbiAgaWYgKHN0cmlkZSA9PSAyKSB7XG4gICAgbGF5b3V0ID0gJ1hZJztcbiAgfSBlbHNlIGlmIChzdHJpZGUgPT0gMykge1xuICAgIGxheW91dCA9ICdYWVonO1xuICB9IGVsc2UgaWYgKHN0cmlkZSA9PSA0KSB7XG4gICAgbGF5b3V0ID0gJ1hZWk0nO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9ICovIChsYXlvdXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqIEByZXR1cm4ge251bWJlcn0gU3RyaWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaWRlRm9yTGF5b3V0KGxheW91dCkge1xuICBsZXQgc3RyaWRlO1xuICBpZiAobGF5b3V0ID09ICdYWScpIHtcbiAgICBzdHJpZGUgPSAyO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PSAnWFlaJyB8fCBsYXlvdXQgPT0gJ1hZTScpIHtcbiAgICBzdHJpZGUgPSAzO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PSAnWFlaTScpIHtcbiAgICBzdHJpZGUgPSA0O1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHN0cmlkZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaW1wbGVHZW9tZXRyeX0gc2ltcGxlR2VvbWV0cnkgU2ltcGxlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBmbGF0IGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtR2VvbTJEKHNpbXBsZUdlb21ldHJ5LCB0cmFuc2Zvcm0sIGRlc3QpIHtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gc2ltcGxlR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gIGlmICghZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RyaWRlID0gc2ltcGxlR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gIHJldHVybiB0cmFuc2Zvcm0yRChcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgMCxcbiAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgIHN0cmlkZSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgZGVzdCxcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2ltcGxlR2VvbWV0cnk7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2FyZWFcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBsZXQgdHdpY2VBcmVhID0gMDtcbiAgY29uc3QgeDAgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgY29uc3QgeTAgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGxldCBkeDEgPSAwO1xuICBsZXQgZHkxID0gMDtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IGR4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdIC0geDA7XG4gICAgY29uc3QgZHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdIC0geTA7XG4gICAgdHdpY2VBcmVhICs9IGR5MSAqIGR4MiAtIGR4MSAqIGR5MjtcbiAgICBkeDEgPSBkeDI7XG4gICAgZHkxID0gZHkyO1xuICB9XG4gIHJldHVybiB0d2ljZUFyZWEgLyAyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBhcmVhICs9IGxpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSkge1xuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgYXJlYSArPSBsaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2Nsb3Nlc3RcbiAqL1xuaW1wb3J0IHtsZXJwLCBzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZER4fSBmcm9tICcuLi8uLi9tYXRoLmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgMkQgbGluZSBzZWdtZW50IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXSB0b1xuICogZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcG9pbnQgKHgsIHkpLiAgRXh0cmFcbiAqIGRpbWVuc2lvbnMgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0MSBPZmZzZXQgMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQyIE9mZnNldCAyLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3QoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0MSxcbiAgb2Zmc2V0MixcbiAgc3RyaWRlLFxuICB4LFxuICB5LFxuICBjbG9zZXN0UG9pbnQsXG4pIHtcbiAgY29uc3QgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MV07XG4gIGNvbnN0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDEgKyAxXTtcbiAgY29uc3QgZHggPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0Ml0gLSB4MTtcbiAgY29uc3QgZHkgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MiArIDFdIC0geTE7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgIG9mZnNldCA9IG9mZnNldDE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGlmICh0ID4gMSkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGxlcnAoXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldDEgKyBpXSxcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MiArIGldLFxuICAgICAgICAgIHQsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQxO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldO1xuICB9XG4gIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzcXVhcmVkIG9mIHRoZSBsYXJnZXN0IGRpc3RhbmNlIGJldHdlZW4gYW55IHBhaXIgb2YgY29uc2VjdXRpdmVcbiAqIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbWF4KSB7XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBzcXVhcmVkRGVsdGEgPSBzcXVhcmVkRHgoeDEsIHkxLCB4MiwgeTIpO1xuICAgIGlmIChzcXVhcmVkRGVsdGEgPiBtYXgpIHtcbiAgICAgIG1heCA9IHNxdWFyZWREZWx0YTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIG1heCxcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIG1heCA9IG1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG1heCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlBcnJheU1heFNxdWFyZWREZWx0YShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIG1heCxcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIG1heCA9IGFycmF5TWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG1heCk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEZWx0YSBNYXggZGVsdGEuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmluZyBJcyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFt0bXBQb2ludF0gVGVtcG9yYXJ5IHBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduQ2xvc2VzdFBvaW50KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIG1heERlbHRhLFxuICBpc1JpbmcsXG4gIHgsXG4gIHksXG4gIGNsb3Nlc3RQb2ludCxcbiAgbWluU3F1YXJlZERpc3RhbmNlLFxuICB0bXBQb2ludCxcbikge1xuICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cbiAgbGV0IGksIHNxdWFyZWREaXN0YW5jZTtcbiAgaWYgKG1heERlbHRhID09PSAwKSB7XG4gICAgLy8gQWxsIHBvaW50cyBhcmUgaWRlbnRpY2FsLCBzbyBqdXN0IHRlc3QgdGhlIGZpcnN0IHBvaW50LlxuICAgIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeChcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldF0sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sXG4gICAgKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybiBzcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cbiAgdG1wUG9pbnQgPSB0bXBQb2ludCA/IHRtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgbGV0IGluZGV4ID0gb2Zmc2V0ICsgc3RyaWRlO1xuICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICBhc3NpZ25DbG9zZXN0KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgaW5kZXggLSBzdHJpZGUsXG4gICAgICBpbmRleCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdG1wUG9pbnQsXG4gICAgKTtcbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoeCwgeSwgdG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gdG1wUG9pbnRbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgaW5kZXggKz0gc3RyaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTa2lwIGFoZWFkIG11bHRpcGxlIHBvaW50cywgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYWxsIHRoZSBza2lwcGVkXG4gICAgICAvLyBwb2ludHMgY2Fubm90IGJlIGFueSBjbG9zZXIgdGhhbiB0aGUgY2xvc2VzdCBwb2ludCB3ZSBoYXZlIGZvdW5kIHNvXG4gICAgICAvLyBmYXIuICBXZSBrbm93IHRoaXMgYmVjYXVzZSB3ZSBrbm93IGhvdyBjbG9zZSB0aGUgY3VycmVudCBwb2ludCBpcywgaG93XG4gICAgICAvLyBjbG9zZSB0aGUgY2xvc2VzdCBwb2ludCB3ZSBoYXZlIGZvdW5kIHNvIGZhciBpcywgYW5kIHRoZSBtYXhpbXVtXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIHBvaW50cy4gIEZvciBleGFtcGxlLCBpZiB3ZSdyZSBjdXJyZW50bHlcbiAgICAgIC8vIGF0IGRpc3RhbmNlIDEwLCB0aGUgYmVzdCB3ZSd2ZSBmb3VuZCBzbyBmYXIgaXMgMywgYW5kIHRoYXQgdGhlIG1heGltdW1cbiAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgcG9pbnRzIGlzIDIsIHRoZW4gd2UnbGwgbmVlZCB0byBza2lwIGF0XG4gICAgICAvLyBsZWFzdCAoMTAgLSAzKSAvIDIgPT0gMyAocm91bmRlZCBkb3duKSBwb2ludHMgdG8gaGF2ZSBhbnkgY2hhbmNlIG9mXG4gICAgICAvLyBmaW5kaW5nIGEgY2xvc2VyIHBvaW50LiAgV2UgdXNlIE1hdGgubWF4KC4uLiwgMSkgdG8gZW5zdXJlIHRoYXQgd2VcbiAgICAgIC8vIGFsd2F5cyBhZHZhbmNlIGF0IGxlYXN0IG9uZSBwb2ludCwgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgIGluZGV4ICs9XG4gICAgICAgIHN0cmlkZSAqXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICgoTWF0aC5zcXJ0KHNxdWFyZWREaXN0YW5jZSkgLSBNYXRoLnNxcnQobWluU3F1YXJlZERpc3RhbmNlKSkgL1xuICAgICAgICAgICAgbWF4RGVsdGEpIHxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUmluZykge1xuICAgIC8vIENoZWNrIHRoZSBjbG9zaW5nIHNlZ21lbnQuXG4gICAgYXNzaWduQ2xvc2VzdChcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIGVuZCAtIHN0cmlkZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdG1wUG9pbnQsXG4gICAgKTtcbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoeCwgeSwgdG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gdG1wUG9pbnRbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbdG1wUG9pbnRdIFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBtYXhEZWx0YSxcbiAgaXNSaW5nLFxuICB4LFxuICB5LFxuICBjbG9zZXN0UG9pbnQsXG4gIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgdG1wUG9pbnQsXG4pIHtcbiAgdG1wUG9pbnQgPSB0bXBQb2ludCA/IHRtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBhc3NpZ25DbG9zZXN0UG9pbnQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBtYXhEZWx0YSxcbiAgICAgIGlzUmluZyxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgbWluU3F1YXJlZERpc3RhbmNlLFxuICAgICAgdG1wUG9pbnQsXG4gICAgKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3RtcFBvaW50XSBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0TXVsdGlBcnJheVBvaW50KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgbWF4RGVsdGEsXG4gIGlzUmluZyxcbiAgeCxcbiAgeSxcbiAgY2xvc2VzdFBvaW50LFxuICBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gIHRtcFBvaW50LFxuKSB7XG4gIHRtcFBvaW50ID0gdG1wUG9pbnQgPyB0bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgbWluU3F1YXJlZERpc3RhbmNlID0gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzLFxuICAgICAgc3RyaWRlLFxuICAgICAgbWF4RGVsdGEsXG4gICAgICBpc1JpbmcsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgICAgIHRtcFBvaW50LFxuICAgICk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2NvbnRhaW5zXG4gKi9cbmltcG9ydCB7Zm9yRWFjaENvcm5lcn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGV4dGVudCxcbikge1xuICBjb25zdCBvdXRzaWRlID0gZm9yRWFjaENvcm5lcihcbiAgICBleHRlbnQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiAhbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgY29vcmRpbmF0ZVswXSxcbiAgICAgICAgY29vcmRpbmF0ZVsxXSxcbiAgICAgICk7XG4gICAgfSxcbiAgKTtcbiAgcmV0dXJuICFvdXRzaWRlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdDb250YWluc1hZKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHgsXG4gIHksXG4pIHtcbiAgLy8gaHR0cHM6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTAzLV9pbmNsdXNpb24uaHRtbFxuICAvLyBDb3B5cmlnaHQgMjAwMCBzb2Z0U3VyZmVyLCAyMDEyIERhbiBTdW5kYXlcbiAgLy8gVGhpcyBjb2RlIG1heSBiZSBmcmVlbHkgdXNlZCBhbmQgbW9kaWZpZWQgZm9yIGFueSBwdXJwb3NlXG4gIC8vIHByb3ZpZGluZyB0aGF0IHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBpbmNsdWRlZCB3aXRoIGl0LlxuICAvLyBTb2Z0U3VyZmVyIG1ha2VzIG5vIHdhcnJhbnR5IGZvciB0aGlzIGNvZGUsIGFuZCBjYW5ub3QgYmUgaGVsZFxuICAvLyBsaWFibGUgZm9yIGFueSByZWFsIG9yIGltYWdpbmVkIGRhbWFnZSByZXN1bHRpbmcgZnJvbSBpdHMgdXNlLlxuICAvLyBVc2VycyBvZiB0aGlzIGNvZGUgbXVzdCB2ZXJpZnkgY29ycmVjdG5lc3MgZm9yIHRoZWlyIGFwcGxpY2F0aW9uLlxuICBsZXQgd24gPSAwO1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBpZiAoeTEgPD0geSkge1xuICAgICAgaWYgKHkyID4geSAmJiAoeDIgLSB4MSkgKiAoeSAtIHkxKSAtICh4IC0geDEpICogKHkyIC0geTEpID4gMCkge1xuICAgICAgICB3bisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeTIgPD0geSAmJiAoeDIgLSB4MSkgKiAoeSAtIHkxKSAtICh4IC0geDEpICogKHkyIC0geTEpIDwgMCkge1xuICAgICAgd24tLTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiB3biAhPT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc0NvbnRhaW5zWFkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIHgsXG4gIHksXG4pIHtcbiAgaWYgKGVuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghbGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbMF0sIHN0cmlkZSwgeCwgeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDEsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKFxuICAgICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBlbmRzW2kgLSAxXSwgZW5kc1tpXSwgc3RyaWRlLCB4LCB5KVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3NDb250YWluc1hZKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgeCxcbiAgeSxcbikge1xuICBpZiAoZW5kc3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgaWYgKGxpbmVhclJpbmdzQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2RlZmxhdGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlLCBzdHJpZGUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGNvb3JkaW5hdGVbaV07XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXMoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBjb29yZGluYXRlcyxcbiAgc3RyaWRlLFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHJpZGU7ICsraikge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGNvb3JkaW5hdGVbal07XG4gICAgfVxuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gY29vcmRpbmF0ZXNzIENvb3JkaW5hdGVzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW5kc10gRW5kcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEVuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGNvb3JkaW5hdGVzcyxcbiAgc3RyaWRlLFxuICBlbmRzLFxuKSB7XG4gIGVuZHMgPSBlbmRzID8gZW5kcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgY29uc3QgZW5kID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgY29vcmRpbmF0ZXNzW2pdLFxuICAgICAgc3RyaWRlLFxuICAgICk7XG4gICAgZW5kc1tpKytdID0gZW5kO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICBlbmRzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBjb29yZGluYXRlc3NzIENvb3JkaW5hdGVzc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtlbmRzc10gRW5kc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gRW5kc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgY29vcmRpbmF0ZXNzcyxcbiAgc3RyaWRlLFxuICBlbmRzcyxcbikge1xuICBlbmRzcyA9IGVuZHNzID8gZW5kc3MgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gMCwgamogPSBjb29yZGluYXRlc3NzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBjb29yZGluYXRlc3NzW2pdLFxuICAgICAgc3RyaWRlLFxuICAgICAgZW5kc3NbaV0sXG4gICAgKTtcbiAgICBpZiAoZW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGVuZHNbMF0gPSBvZmZzZXQ7XG4gICAgfVxuICAgIGVuZHNzW2krK10gPSBlbmRzO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICBlbmRzcy5sZW5ndGggPSBpO1xuICByZXR1cm4gZW5kc3M7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2luZmxhdGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IFtjb29yZGluYXRlc10gQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBDb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVDb29yZGluYXRlcyhcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBjb29yZGluYXRlcyxcbikge1xuICBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQgPyBjb29yZGluYXRlcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgY29vcmRpbmF0ZXNbaSsrXSA9IGZsYXRDb29yZGluYXRlcy5zbGljZShqLCBqICsgc3RyaWRlKTtcbiAgfVxuICBjb29yZGluYXRlcy5sZW5ndGggPSBpO1xuICByZXR1cm4gY29vcmRpbmF0ZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IFtjb29yZGluYXRlc3NdIENvb3JkaW5hdGVzcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgY29vcmRpbmF0ZXNzLFxuKSB7XG4gIGNvb3JkaW5hdGVzcyA9IGNvb3JkaW5hdGVzcyAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXNzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tqXTtcbiAgICBjb29yZGluYXRlc3NbaSsrXSA9IGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIGNvb3JkaW5hdGVzc1tpXSxcbiAgICApO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICBjb29yZGluYXRlc3MubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGNvb3JkaW5hdGVzcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IFtjb29yZGluYXRlc3NzXVxuICogICAgIENvb3JkaW5hdGVzc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IENvb3JkaW5hdGVzc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgY29vcmRpbmF0ZXNzcyxcbikge1xuICBjb29yZGluYXRlc3NzID0gY29vcmRpbmF0ZXNzcyAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXNzcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSAwLCBqaiA9IGVuZHNzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3Nbal07XG4gICAgY29vcmRpbmF0ZXNzc1tpKytdID1cbiAgICAgIGVuZHMubGVuZ3RoID09PSAxICYmIGVuZHNbMF0gPT09IG9mZnNldFxuICAgICAgICA/IFtdXG4gICAgICAgIDogaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBlbmRzLFxuICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXNzc1tpXSxcbiAgICAgICAgICApO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICBjb29yZGluYXRlc3NzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3NzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcmlvcnBvaW50XG4gKi9cbmltcG9ydCB7YXNjZW5kaW5nfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzQ29udGFpbnNYWX0gZnJvbSAnLi9jb250YWlucy5qcyc7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIHBvaW50IHRoYXQgaXMgbGlrZWx5IHRvIGxpZSBpbiB0aGUgaW50ZXJpb3Igb2YgdGhlIGxpbmVhciByaW5ncy5cbiAqIEluc3BpcmVkIGJ5IEpUUydzIGNvbS52aXZpZHNvbHV0aW9ucy5qdHMuZ2VvbS5HZW9tZXRyeSNnZXRJbnRlcmlvclBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENlbnRlcnMgRmxhdCBjZW50ZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYXRDZW50ZXJzT2Zmc2V0IEZsYXQgY2VudGVyIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRGVzdGluYXRpb24gcG9pbnQgYXMgWFlNIGNvb3JkaW5hdGUsIHdoZXJlIE0gaXMgdGhlXG4gKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmlvclBvaW50T2ZBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgZmxhdENlbnRlcnMsXG4gIGZsYXRDZW50ZXJzT2Zmc2V0LFxuICBkZXN0LFxuKSB7XG4gIGxldCBpLCBpaSwgeCwgeDEsIHgyLCB5MSwgeTI7XG4gIGNvbnN0IHkgPSBmbGF0Q2VudGVyc1tmbGF0Q2VudGVyc09mZnNldCArIDFdO1xuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lXG4gIGZvciAobGV0IHIgPSAwLCByciA9IGVuZHMubGVuZ3RoOyByIDwgcnI7ICsrcikge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbcl07XG4gICAgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgICB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIHkyID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGlmICgoeSA8PSB5MSAmJiB5MiA8PSB5KSB8fCAoeTEgPD0geSAmJiB5IDw9IHkyKSkge1xuICAgICAgICB4ID0gKCh5IC0geTEpIC8gKHkyIC0geTEpKSAqICh4MiAtIHgxKSArIHgxO1xuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goeCk7XG4gICAgICB9XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9XG4gIH1cbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBob3Jpem9udGFsIGxpbmUgdGhhdCBoYXMgaXRzIGNlbnRlciBwb2ludFxuICAvLyBpbnNpZGUgdGhlIGxpbmVhciByaW5nLlxuICBsZXQgcG9pbnRYID0gTmFOO1xuICBsZXQgbWF4U2VnbWVudExlbmd0aCA9IC1JbmZpbml0eTtcbiAgaW50ZXJzZWN0aW9ucy5zb3J0KGFzY2VuZGluZyk7XG4gIHgxID0gaW50ZXJzZWN0aW9uc1swXTtcbiAgZm9yIChpID0gMSwgaWkgPSBpbnRlcnNlY3Rpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB4MiA9IGludGVyc2VjdGlvbnNbaV07XG4gICAgY29uc3Qgc2VnbWVudExlbmd0aCA9IE1hdGguYWJzKHgyIC0geDEpO1xuICAgIGlmIChzZWdtZW50TGVuZ3RoID4gbWF4U2VnbWVudExlbmd0aCkge1xuICAgICAgeCA9ICh4MSArIHgyKSAvIDI7XG4gICAgICBpZiAobGluZWFyUmluZ3NDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHgsIHkpKSB7XG4gICAgICAgIHBvaW50WCA9IHg7XG4gICAgICAgIG1heFNlZ21lbnRMZW5ndGggPSBzZWdtZW50TGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICB4MSA9IHgyO1xuICB9XG4gIGlmIChpc05hTihwb2ludFgpKSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gaG9yaXpvbnRhbCBsaW5lIHRoYXQgaGFzIGl0cyBjZW50ZXIgcG9pbnQgaW5zaWRlIHRoZSBsaW5lYXJcbiAgICAvLyByaW5nLiAgVXNlIHRoZSBjZW50ZXIgb2YgdGhlIHRoZSBsaW5lYXIgcmluZydzIGV4dGVudC5cbiAgICBwb2ludFggPSBmbGF0Q2VudGVyc1tmbGF0Q2VudGVyc09mZnNldF07XG4gIH1cbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0LnB1c2gocG9pbnRYLCB5LCBtYXhTZWdtZW50TGVuZ3RoKTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICByZXR1cm4gW3BvaW50WCwgeSwgbWF4U2VnbWVudExlbmd0aF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENlbnRlcnMgRmxhdCBjZW50ZXJzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW50ZXJpb3IgcG9pbnRzIGFzIFhZTSBjb29yZGluYXRlcywgd2hlcmUgTSBpcyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgaG9yaXpvbnRhbCBpbnRlcnNlY3Rpb24gdGhhdCB0aGUgcG9pbnQgYmVsb25ncyB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyaW9yUG9pbnRzT2ZNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgZmxhdENlbnRlcnMsXG4pIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBsZXQgaW50ZXJpb3JQb2ludHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpbnRlcmlvclBvaW50cyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kcyxcbiAgICAgIHN0cmlkZSxcbiAgICAgIGZsYXRDZW50ZXJzLFxuICAgICAgMiAqIGksXG4gICAgICBpbnRlcmlvclBvaW50cyxcbiAgICApO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gaW50ZXJpb3JQb2ludHM7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ludGVyc2VjdHNleHRlbnRcbiAqL1xuaW1wb3J0IHtcbiAgY29udGFpbnNFeHRlbnQsXG4gIGNyZWF0ZUVtcHR5LFxuICBleHRlbmRGbGF0Q29vcmRpbmF0ZXMsXG4gIGludGVyc2VjdHMsXG4gIGludGVyc2VjdHNTZWdtZW50LFxufSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtmb3JFYWNoIGFzIGZvckVhY2hTZWdtZW50fSBmcm9tICcuL3NlZ21lbnRzLmpzJztcbmltcG9ydCB7bGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50LCBsaW5lYXJSaW5nQ29udGFpbnNYWX0gZnJvbSAnLi9jb250YWlucy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lU3RyaW5nKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGV4dGVudCxcbikge1xuICBjb25zdCBjb29yZGluYXRlc0V4dGVudCA9IGV4dGVuZEZsYXRDb29yZGluYXRlcyhcbiAgICBjcmVhdGVFbXB0eSgpLFxuICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICBvZmZzZXQsXG4gICAgZW5kLFxuICAgIHN0cmlkZSxcbiAgKTtcbiAgaWYgKCFpbnRlcnNlY3RzKGV4dGVudCwgY29vcmRpbmF0ZXNFeHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjb250YWluc0V4dGVudChleHRlbnQsIGNvb3JkaW5hdGVzRXh0ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFswXSA+PSBleHRlbnRbMF0gJiYgY29vcmRpbmF0ZXNFeHRlbnRbMl0gPD0gZXh0ZW50WzJdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVzRXh0ZW50WzFdID49IGV4dGVudFsxXSAmJiBjb29yZGluYXRlc0V4dGVudFszXSA8PSBleHRlbnRbM10pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZm9yRWFjaFNlZ21lbnQoXG4gICAgZmxhdENvb3JkaW5hdGVzLFxuICAgIG9mZnNldCxcbiAgICBlbmQsXG4gICAgc3RyaWRlLFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludDEgU3RhcnQgcG9pbnQuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50MiBFbmQgcG9pbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBzZWdtZW50IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdCxcbiAgICAgKiAgICAgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0c1NlZ21lbnQoZXh0ZW50LCBwb2ludDEsIHBvaW50Mik7XG4gICAgfSxcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVTdHJpbmdBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgZXh0ZW50LFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChcbiAgICAgIGludGVyc2VjdHNMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIGV4dGVudClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2ldO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVhclJpbmcoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgZXh0ZW50LFxuKSB7XG4gIGlmIChpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbM10sXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbM10sXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIGV4dGVudCxcbikge1xuICBpZiAoIWludGVyc2VjdHNMaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzWzBdLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDEsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKFxuICAgICAgbGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50KFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIGVuZHNbaSAtIDFdLFxuICAgICAgICBlbmRzW2ldLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGV4dGVudCxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWludGVyc2VjdHNMaW5lU3RyaW5nKFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICBlbmRzW2kgLSAxXSxcbiAgICAgICAgICBlbmRzW2ldLFxuICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICBleHRlbnQsXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZ011bHRpQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICBleHRlbnQsXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpZiAoXG4gICAgICBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIGV4dGVudClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9vcmllbnRcbiAqL1xuaW1wb3J0IHtjb29yZGluYXRlcyBhcyByZXZlcnNlQ29vcmRpbmF0ZXN9IGZyb20gJy4vcmV2ZXJzZS5qcyc7XG5cbi8qKlxuICogSXMgdGhlIGxpbmVhciByaW5nIG9yaWVudGVkIGNsb2Nrd2lzZSBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggYSBib3R0b20tbGVmdFxuICogY29vcmRpbmF0ZSBvcmlnaW4/IEZvciBhIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggYSB0b3AtbGVmdCBjb29yZGluYXRlIG9yaWdpbixcbiAqIHRoZSByaW5nJ3Mgb3JpZW50YXRpb24gaXMgY2xvY2t3aXNlIHdoZW4gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBJcyBjbG9ja3dpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nSXNDbG9ja3dpc2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xMTY1NjQ3L2Nsb2Nrd2lzZS1tZXRob2QjMTE2NTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vT1NHZW8vZ2RhbC9ibG9iL21hc3Rlci9nZGFsL29nci9vZ3JsaW5lYXJyaW5nLmNwcFxuICBsZXQgZWRnZSA9IDA7XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIGVkZ2UgKz0gKHgyIC0geDEpICogKHkyICsgeTEpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gZWRnZSA9PT0gMCA/IHVuZGVmaW5lZCA6IGVkZ2UgPiAwO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbGluZWFyIHJpbmdzIGFyZSBvcmllbnRlZC4gIEJ5IGRlZmF1bHQsIGxlZnQtaGFuZCBvcmllbnRhdGlvblxuICogaXMgdGVzdGVkIChmaXJzdCByaW5nIG11c3QgYmUgY2xvY2t3aXNlLCByZW1haW5pbmcgcmluZ3MgY291bnRlci1jbG9ja3dpc2UpLlxuICogVG8gdGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvbiwgdXNlIHRoZSBgcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBBcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc0FyZU9yaWVudGVkKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICByaWdodCxcbikge1xuICByaWdodCA9IHJpZ2h0ICE9PSB1bmRlZmluZWQgPyByaWdodCA6IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIGNvbnN0IGlzQ2xvY2t3aXNlID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICk7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGlmICgocmlnaHQgJiYgaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGxpbmVhciByaW5ncyBhcmUgb3JpZW50ZWQuICBCeSBkZWZhdWx0LCBsZWZ0LWhhbmQgb3JpZW50YXRpb25cbiAqIGlzIHRlc3RlZCAoZmlyc3QgcmluZyBtdXN0IGJlIGNsb2Nrd2lzZSwgcmVtYWluaW5nIHJpbmdzIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqIFRvIHRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb24sIHVzZSB0aGUgYHJpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBBcnJheSBvZiBhcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3NBcmVPcmllbnRlZChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIHJpZ2h0LFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgaWYgKCFsaW5lYXJSaW5nc0FyZU9yaWVudGVkKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHJpZ2h0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZW5kcy5sZW5ndGgpIHtcbiAgICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogT3JpZW50IGNvb3JkaW5hdGVzIGluIGEgZmxhdCBhcnJheSBvZiBsaW5lYXIgcmluZ3MuICBCeSBkZWZhdWx0LCByaW5nc1xuICogYXJlIG9yaWVudGVkIGZvbGxvd2luZyB0aGUgbGVmdC1oYW5kIHJ1bGUgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kXG4gKiBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLiAgVG8gb3JpZW50IGFjY29yZGluZyB0byB0aGVcbiAqIHJpZ2h0LWhhbmQgcnVsZSwgdXNlIHRoZSBgcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyaWdodF0gRm9sbG93IHRoZSByaWdodC1oYW5kIHJ1bGUgZm9yIG9yaWVudGF0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmllbnRMaW5lYXJSaW5ncyhcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgcmlnaHQsXG4pIHtcbiAgcmlnaHQgPSByaWdodCAhPT0gdW5kZWZpbmVkID8gcmlnaHQgOiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBjb25zdCBpc0Nsb2Nrd2lzZSA9IGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICApO1xuICAgIGNvbnN0IHJldmVyc2UgPVxuICAgICAgaSA9PT0gMFxuICAgICAgICA/IChyaWdodCAmJiBpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiAhaXNDbG9ja3dpc2UpXG4gICAgICAgIDogKHJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiBpc0Nsb2Nrd2lzZSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldmVyc2VDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBPcmllbnQgY29vcmRpbmF0ZXMgaW4gYSBmbGF0IGFycmF5IG9mIGxpbmVhciByaW5ncy4gIEJ5IGRlZmF1bHQsIHJpbmdzXG4gKiBhcmUgb3JpZW50ZWQgZm9sbG93aW5nIHRoZSBsZWZ0LWhhbmQgcnVsZSAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmRcbiAqIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuICBUbyBvcmllbnQgYWNjb3JkaW5nIHRvIHRoZVxuICogcmlnaHQtaGFuZCBydWxlLCB1c2UgdGhlIGByaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgQXJyYXkgb2YgYXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0XSBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICByaWdodCxcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgb2Zmc2V0ID0gb3JpZW50TGluZWFyUmluZ3MoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzc1tpXSxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHJpZ2h0LFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSB0d28tZGltZW5zaW9uYWwgZW5kc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBMaW5lYXIgcmluZyBlbmQgaW5kZXhlc1xuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFR3byBkaW1lbnNpb25hbCBlbmRzcyBhcnJheSB0aGF0IGNhblxuICogYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBNdWx0aVBvbHlnb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVFbmRzKGZsYXRDb29yZGluYXRlcywgZW5kcykge1xuICBjb25zdCBlbmRzcyA9IFtdO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgbGV0IHByZXZFbmRJbmRleCA9IDA7XG4gIGxldCBzdGFydE9yaWVudGF0aW9uO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIC8vIGNsYXNzaWZpZXMgYW4gYXJyYXkgb2YgcmluZ3MgaW50byBwb2x5Z29ucyB3aXRoIG91dGVyIHJpbmdzIGFuZCBob2xlc1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIDIpO1xuICAgIGlmIChzdGFydE9yaWVudGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXJ0T3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB9XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSBzdGFydE9yaWVudGF0aW9uKSB7XG4gICAgICBlbmRzcy5wdXNoKGVuZHMuc2xpY2UocHJldkVuZEluZGV4LCBpICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZW5kc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZW5kc3NbZW5kc3MubGVuZ3RoIC0gMV0ucHVzaChlbmRzW3ByZXZFbmRJbmRleF0pO1xuICAgIH1cbiAgICBwcmV2RW5kSW5kZXggPSBpICsgMTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIGVuZHNzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9yZXZlcnNlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQgLSBzdHJpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICBjb25zdCB0bXAgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaV07XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaV0gPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgaV07XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgaV0gPSB0bXA7XG4gICAgfVxuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgZW5kIC09IHN0cmlkZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9zZWdtZW50c1xuICovXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIHNlZ21lbnQgb2YgdGhlIGZsYXQgY29vcmRpbmF0ZXNcbiAqIGFycmF5LiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0XG4gKiB2YWx1ZSBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUsIGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IFR9IGNhbGxiYWNrIEZ1bmN0aW9uXG4gKiAgICAgY2FsbGVkIGZvciBlYWNoIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtUfGJvb2xlYW59IFZhbHVlLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2goZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBjYWxsYmFjaykge1xuICBsZXQgcmV0O1xuICBvZmZzZXQgKz0gc3RyaWRlO1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgcmV0ID0gY2FsbGJhY2soXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0IC0gc3RyaWRlLCBvZmZzZXQpLFxuICAgICAgZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3RyaWRlKSxcbiAgICApO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc2ltcGxpZnlcbiAqL1xuLy8gQmFzZWQgb24gc2ltcGxpZnktanMgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvc2ltcGxpZnktanNcbi8vIENvcHlyaWdodCAoYykgMjAxMiwgVmxhZGltaXIgQWdhZm9ua2luXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vL1xuLy8gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuLy8gICAgICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vXG4vLyAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuLy8gQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuLy8gSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0Vcbi8vIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbi8vIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1Jcbi8vIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4vLyBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1Ncbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4vLyBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuLy8gQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbi8vIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSwgc3F1YXJlZFNlZ21lbnREaXN0YW5jZX0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtib29sZWFufSBoaWdoUXVhbGl0eSBIaWdoZXN0IHF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzXSBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFNpbXBsaWZpZWQgbGluZSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeUxpbmVTdHJpbmcoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgaGlnaFF1YWxpdHksXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4pIHtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkID8gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA6IFtdO1xuICBpZiAoIWhpZ2hRdWFsaXR5KSB7XG4gICAgZW5kID0gcmFkaWFsRGlzdGFuY2UoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzO1xuICAgIG9mZnNldCA9IDA7XG4gICAgc3RyaWRlID0gMjtcbiAgfVxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICBvZmZzZXQsXG4gICAgZW5kLFxuICAgIHN0cmlkZSxcbiAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgMCxcbiAgKTtcbiAgcmV0dXJuIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXIoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbikge1xuICBjb25zdCBuID0gKGVuZCAtIG9mZnNldCkgLyBzdHJpZGU7XG4gIGlmIChuIDwgMykge1xuICAgIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IG1hcmtlcnMgPSBuZXcgQXJyYXkobik7XG4gIG1hcmtlcnNbMF0gPSAxO1xuICBtYXJrZXJzW24gLSAxXSA9IDE7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3Qgc3RhY2sgPSBbb2Zmc2V0LCBlbmQgLSBzdHJpZGVdO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgIGxldCBtYXhTcXVhcmVkRGlzdGFuY2UgPSAwO1xuICAgIGNvbnN0IHgxID0gZmxhdENvb3JkaW5hdGVzW2ZpcnN0XTtcbiAgICBjb25zdCB5MSA9IGZsYXRDb29yZGluYXRlc1tmaXJzdCArIDFdO1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW2xhc3RdO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW2xhc3QgKyAxXTtcbiAgICBmb3IgKGxldCBpID0gZmlyc3QgKyBzdHJpZGU7IGkgPCBsYXN0OyBpICs9IHN0cmlkZSkge1xuICAgICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIGNvbnN0IHkgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgY29uc3Qgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZFNlZ21lbnREaXN0YW5jZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlID4gbWF4U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgbWF4U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF4U3F1YXJlZERpc3RhbmNlID4gc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgICAgbWFya2Vyc1soaW5kZXggLSBvZmZzZXQpIC8gc3RyaWRlXSA9IDE7XG4gICAgICBpZiAoZmlyc3QgKyBzdHJpZGUgPCBpbmRleCkge1xuICAgICAgICBzdGFjay5wdXNoKGZpcnN0LCBpbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggKyBzdHJpZGUgPCBsYXN0KSB7XG4gICAgICAgIHN0YWNrLnB1c2goaW5kZXgsIGxhc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChtYXJrZXJzW2ldKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaSAqIHN0cmlkZV07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaSAqIHN0cmlkZSArIDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEVuZHMgU2ltcGxpZmllZCBlbmRzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXQsXG4gIHNpbXBsaWZpZWRFbmRzLFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBzaW1wbGlmaWVkT2Zmc2V0LFxuICAgICk7XG4gICAgc2ltcGxpZmllZEVuZHMucHVzaChzaW1wbGlmaWVkT2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBzaW1wbGlmaWVkRW5kc3MgU2ltcGxpZmllZCBlbmRzcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3VnbGFzUGV1Y2tlck11bHRpQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICBzcXVhcmVkVG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kc3MsXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3Qgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gZG91Z2xhc1BldWNrZXJBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZHMsXG4gICAgICBzdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNpbXBsaWZpZWRPZmZzZXQsXG4gICAgICBzaW1wbGlmaWVkRW5kcyxcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzcy5wdXNoKHNpbXBsaWZpZWRFbmRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFsRGlzdGFuY2UoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbikge1xuICBpZiAoZW5kIDw9IG9mZnNldCArIHN0cmlkZSkge1xuICAgIC8vIHplcm8gb3Igb25lIHBvaW50LCBubyBzaW1wbGlmaWNhdGlvbiBwb3NzaWJsZSwgc28gY29weSBhbmQgcmV0dXJuXG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIC8vIGNvcHkgZmlyc3QgcG9pbnRcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDE7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkxO1xuICBsZXQgeDIgPSB4MTtcbiAgbGV0IHkyID0geTE7XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSA+IHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICAgIC8vIGNvcHkgcG9pbnQgYXQgb2Zmc2V0XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfVxuICB9XG4gIGlmICh4MiAhPSB4MSB8fCB5MiAhPSB5MSkge1xuICAgIC8vIGNvcHkgbGFzdCBwb2ludFxuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHJldHVybiB7bnVtYmVyfSBSb3VuZGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcCh2YWx1ZSwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiB0b2xlcmFuY2UgKiBNYXRoLnJvdW5kKHZhbHVlIC8gdG9sZXJhbmNlKTtcbn1cblxuLyoqXG4gKiBTaW1wbGlmaWVzIGEgbGluZSBzdHJpbmcgdXNpbmcgYW4gYWxnb3JpdGhtIGRlc2lnbmVkIGJ5IFRpbSBTY2hhdWIuXG4gKiBDb29yZGluYXRlcyBhcmUgc25hcHBlZCB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhIHZpcnR1YWwgZ3JpZCBhbmRcbiAqIGNvbnNlY3V0aXZlIGR1cGxpY2F0ZSBjb29yZGluYXRlcyBhcmUgZGlzY2FyZGVkLiAgVGhpcyBlZmZlY3RpdmVseSBwcmVzZXJ2ZXNcbiAqIHRvcG9sb2d5IGFzIHRoZSBzaW1wbGlmaWNhdGlvbiBvZiBhbnkgc3Vic2VjdGlvbiBvZiBhIGxpbmUgc3RyaW5nIGlzXG4gKiBpbmRlcGVuZGVudCBvZiB0aGUgcmVzdCBvZiB0aGUgbGluZSBzdHJpbmcuICBUaGlzIG1lYW5zIHRoYXQsIGZvciBleGFtcGxlcyxcbiAqIHRoZSBjb21tb24gZWRnZSBiZXR3ZWVuIHR3byBwb2x5Z29ucyB3aWxsIGJlIHNpbXBsaWZpZWQgdG8gdGhlIHNhbWUgbGluZVxuICogc3RyaW5nIGluZGVwZW5kZW50bHkgaW4gYm90aCBwb2x5Z29ucy4gIFRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyBhIHNpbmdsZVxuICogcGFzcyBvdmVyIHRoZSBjb29yZGluYXRlcyBhbmQgZWxpbWluYXRlcyBpbnRlcm1lZGlhdGUgY29sbGluZWFyIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbikge1xuICAvLyBkbyBub3RoaW5nIGlmIHRoZSBsaW5lIGlzIGVtcHR5XG4gIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gIH1cbiAgLy8gc25hcCB0aGUgZmlyc3QgY29vcmRpbmF0ZSAoUDEpXG4gIGxldCB4MSA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gIGxldCB5MSA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICBvZmZzZXQgKz0gc3RyaWRlO1xuICAvLyBhZGQgdGhlIGZpcnN0IGNvb3JkaW5hdGUgdG8gdGhlIG91dHB1dFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MTtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTE7XG4gIC8vIGZpbmQgdGhlIG5leHQgY29vcmRpbmF0ZSB0aGF0IGRvZXMgbm90IHNuYXAgdG8gdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGZpcnN0XG4gIC8vIGNvb3JkaW5hdGUgKFAyKVxuICBsZXQgeDIsIHkyO1xuICBkbyB7XG4gICAgeDIgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCB0b2xlcmFuY2UpO1xuICAgIHkyID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgICAgLy8gYWxsIGNvb3JkaW5hdGVzIHNuYXAgdG8gdGhlIHNhbWUgdmFsdWUsIHRoZSBsaW5lIGNvbGxhcHNlcyB0byBhIHBvaW50XG4gICAgICAvLyBwdXNoIHRoZSBsYXN0IHNuYXBwZWQgdmFsdWUgYW55d2F5IHRvIGVuc3VyZSB0aGF0IHRoZSBvdXRwdXQgY29udGFpbnNcbiAgICAgIC8vIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgIC8vIEZJWE1FIHNob3VsZCB3ZSByZWFsbHkgcmV0dXJuIGF0IGxlYXN0IHR3byBwb2ludHMgYW55d2F5P1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICAgIH1cbiAgfSB3aGlsZSAoeDIgPT0geDEgJiYgeTIgPT0geTEpO1xuICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgLy8gc25hcCB0aGUgbmV4dCBjb29yZGluYXRlIChQMylcbiAgICBjb25zdCB4MyA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gICAgY29uc3QgeTMgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIC8vIHNraXAgUDMgaWYgaXQgaXMgZXF1YWwgdG8gUDJcbiAgICBpZiAoeDMgPT0geDIgJiYgeTMgPT0geTIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRlbHRhIGJldHdlZW4gUDEgYW5kIFAyXG4gICAgY29uc3QgZHgxID0geDIgLSB4MTtcbiAgICBjb25zdCBkeTEgPSB5MiAtIHkxO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiBQMyBhbmQgUDFcbiAgICBjb25zdCBkeDIgPSB4MyAtIHgxO1xuICAgIGNvbnN0IGR5MiA9IHkzIC0geTE7XG4gICAgLy8gaWYgUDEsIFAyLCBhbmQgUDMgYXJlIGNvbGluZWFyIGFuZCBQMyBpcyBmdXJ0aGVyIGZyb20gUDEgdGhhbiBQMiBpcyBmcm9tXG4gICAgLy8gUDEgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIHRoZW4gUDIgaXMgb24gdGhlIHN0cmFpZ2h0IGxpbmUgYmV0d2VlbiBQMSBhbmRcbiAgICAvLyBQM1xuICAgIGlmIChcbiAgICAgIGR4MSAqIGR5MiA9PSBkeTEgKiBkeDIgJiZcbiAgICAgICgoZHgxIDwgMCAmJiBkeDIgPCBkeDEpIHx8IGR4MSA9PSBkeDIgfHwgKGR4MSA+IDAgJiYgZHgyID4gZHgxKSkgJiZcbiAgICAgICgoZHkxIDwgMCAmJiBkeTIgPCBkeTEpIHx8IGR5MSA9PSBkeTIgfHwgKGR5MSA+IDAgJiYgZHkyID4gZHkxKSlcbiAgICApIHtcbiAgICAgIC8vIGRpc2NhcmQgUDIgYW5kIHNldCBQMiA9IFAzXG4gICAgICB4MiA9IHgzO1xuICAgICAgeTIgPSB5MztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBlaXRoZXIgUDEsIFAyLCBhbmQgUDMgYXJlIG5vdCBjb2xpbmVhciwgb3IgdGhleSBhcmUgY29saW5lYXIgYnV0IFAzIGlzXG4gICAgLy8gYmV0d2VlbiBQMyBhbmQgUDEgb3Igb24gdGhlIG9wcG9zaXRlIGhhbGYgb2YgdGhlIGxpbmUgdG8gUDIuICBhZGQgUDIsXG4gICAgLy8gYW5kIGNvbnRpbnVlIHdpdGggUDEgPSBQMiBhbmQgUDIgPSBQM1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICB4MiA9IHgzO1xuICAgIHkyID0geTM7XG4gIH1cbiAgLy8gYWRkIHRoZSBsYXN0IHBvaW50IChQMilcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEVuZHMgU2ltcGxpZmllZCBlbmRzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIHRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbiAgc2ltcGxpZmllZEVuZHMsXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gcXVhbnRpemUoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICB0b2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgc2ltcGxpZmllZE9mZnNldCxcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kc3MsXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3Qgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gcXVhbnRpemVBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZHMsXG4gICAgICBzdHJpZGUsXG4gICAgICB0b2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgc2ltcGxpZmllZE9mZnNldCxcbiAgICAgIHNpbXBsaWZpZWRFbmRzLFxuICAgICk7XG4gICAgc2ltcGxpZmllZEVuZHNzLnB1c2goc2ltcGxpZmllZEVuZHMpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvdHJhbnNmb3JtXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Rlc3RpbmF0aW9uU3RyaWRlXSBTdHJpZGUgb2YgZGVzdGluYXRpb24gY29vcmRpbmF0ZXM7IGlmIHVuc3BlY2lmaWVkLCBhc3N1bWVkIHRvIGJlIDIuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybTJEKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHRyYW5zZm9ybSxcbiAgZGVzdCxcbiAgZGVzdGluYXRpb25TdHJpZGUsXG4pIHtcbiAgZGVzdCA9IGRlc3QgPyBkZXN0IDogW107XG4gIGRlc3RpbmF0aW9uU3RyaWRlID0gZGVzdGluYXRpb25TdHJpZGUgPyBkZXN0aW5hdGlvblN0cmlkZSA6IDI7XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4ID0gZmxhdENvb3JkaW5hdGVzW2pdO1xuICAgIGNvbnN0IHkgPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdO1xuICAgIGRlc3RbaSsrXSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdO1xuICAgIGRlc3RbaSsrXSA9IHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bM10gKiB5ICsgdHJhbnNmb3JtWzVdO1xuXG4gICAgZm9yIChsZXQgayA9IDI7IGsgPCBkZXN0aW5hdGlvblN0cmlkZTsgaysrKSB7XG4gICAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNbaiArIGtdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYW5jaG9yIFJvdGF0aW9uIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgYW5nbGUsXG4gIGFuY2hvcixcbiAgZGVzdCxcbikge1xuICBkZXN0ID0gZGVzdCA/IGRlc3QgOiBbXTtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IGFuY2hvclggPSBhbmNob3JbMF07XG4gIGNvbnN0IGFuY2hvclkgPSBhbmNob3JbMV07XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb25zdCBkZWx0YVggPSBmbGF0Q29vcmRpbmF0ZXNbal0gLSBhbmNob3JYO1xuICAgIGNvbnN0IGRlbHRhWSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gLSBhbmNob3JZO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclggKyBkZWx0YVggKiBjb3MgLSBkZWx0YVkgKiBzaW47XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIGRlbHRhWCAqIHNpbiArIGRlbHRhWSAqIGNvcztcbiAgICBmb3IgKGxldCBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBTY2FsZSB0aGUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN4IFNjYWxlIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIGluIHRoZSB5LWRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYW5jaG9yIFNjYWxlIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBzeCxcbiAgc3ksXG4gIGFuY2hvcixcbiAgZGVzdCxcbikge1xuICBkZXN0ID0gZGVzdCA/IGRlc3QgOiBbXTtcbiAgY29uc3QgYW5jaG9yWCA9IGFuY2hvclswXTtcbiAgY29uc3QgYW5jaG9yWSA9IGFuY2hvclsxXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IGRlbHRhWCA9IGZsYXRDb29yZGluYXRlc1tqXSAtIGFuY2hvclg7XG4gICAgY29uc3QgZGVsdGFZID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSAtIGFuY2hvclk7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWCArIHN4ICogZGVsdGFYO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclkgKyBzeSAqIGRlbHRhWTtcbiAgICBmb3IgKGxldCBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBkZWx0YVgsXG4gIGRlbHRhWSxcbiAgZGVzdCxcbikge1xuICBkZXN0ID0gZGVzdCA/IGRlc3QgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1tqXSArIGRlbHRhWDtcbiAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdICsgZGVsdGFZO1xuICAgIGZvciAobGV0IGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2hhc1xuICovXG5cbmNvbnN0IHVhID1cbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgIT09ICd1bmRlZmluZWQnXG4gICAgPyBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKClcbiAgICA6ICcnO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBGaXJlZm94IGFzIGJyb3dzZXIuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IEZJUkVGT1ggPSB1YS5pbmNsdWRlcygnZmlyZWZveCcpO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBTYWZhcmkgYXMgYnJvd3Nlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgU0FGQVJJID0gdWEuaW5jbHVkZXMoJ3NhZmFyaScpICYmICF1YS5pbmNsdWRlcygnY2hyb20nKTtcblxuLyoqXG4gKiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjM3OTA2XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFNBRkFSSV9CVUdfMjM3OTA2ID1cbiAgU0FGQVJJICYmXG4gICh1YS5pbmNsdWRlcygndmVyc2lvbi8xNS40JykgfHxcbiAgICAvY3B1IChvc3xpcGhvbmUgb3MpIDE1XzQgbGlrZSBtYWMgb3MgeC8udGVzdCh1YSkpO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIFdlYktpdCBlbmdpbmUuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFdFQktJVCA9IHVhLmluY2x1ZGVzKCd3ZWJraXQnKSAmJiAhdWEuaW5jbHVkZXMoJ2VkZ2UnKTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBNYWMgYXMgcGxhdGZvcm0uXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IE1BQyA9IHVhLmluY2x1ZGVzKCdtYWNpbnRvc2gnKTtcblxuLyoqXG4gKiBUaGUgcmF0aW8gYmV0d2VlbiBwaHlzaWNhbCBwaXhlbHMgYW5kIGRldmljZS1pbmRlcGVuZGVudCBwaXhlbHNcbiAqIChkaXBzKSBvbiB0aGUgZGV2aWNlIChgd2luZG93LmRldmljZVBpeGVsUmF0aW9gKS5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IERFVklDRV9QSVhFTF9SQVRJTyA9XG4gIHR5cGVvZiBkZXZpY2VQaXhlbFJhdGlvICE9PSAndW5kZWZpbmVkJyA/IGRldmljZVBpeGVsUmF0aW8gOiAxO1xuXG4vKipcbiAqIFRoZSBleGVjdXRpb24gY29udGV4dCBpcyBhIHdvcmtlciB3aXRoIE9mZnNjcmVlbkNhbnZhcyBhdmFpbGFibGUuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgV09SS0VSX09GRlNDUkVFTl9DQU5WQVMgPVxuICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmXG4gIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogSW1hZ2UucHJvdG90eXBlLmRlY29kZSgpIGlzIHN1cHBvcnRlZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgSU1BR0VfREVDT0RFID1cbiAgdHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJyAmJiBJbWFnZS5wcm90b3R5cGUuZGVjb2RlO1xuXG4vKipcbiAqIGNyZWF0ZUltYWdlQml0bWFwKCkgaXMgc3VwcG9ydGVkLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBDUkVBVEVfSU1BR0VfQklUTUFQID0gdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgUEFTU0lWRV9FVkVOVF9MSVNURU5FUlMgPSAoZnVuY3Rpb24gKCkge1xuICBsZXQgcGFzc2l2ZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhc3NpdmUgPSB0cnVlO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIEB0cy1pZ25vcmUgSWdub3JlIGludmFsaWQgZXZlbnQgdHlwZSAnXydcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignXycsIG51bGwsIG9wdGlvbnMpO1xuICAgIC8vIEB0cy1pZ25vcmUgSWdub3JlIGludmFsaWQgZXZlbnQgdHlwZSAnXydcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignXycsIG51bGwsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIHBhc3NpdmUgbm90IHN1cHBvcnRlZFxuICB9XG4gIHJldHVybiBwYXNzaXZlO1xufSkoKTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb21cbiAqL1xuaW1wb3J0IEludGVyYWN0aW9uLCB7em9vbUJ5RGVsdGF9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gZWFjaCBkb3VibGUgY2xpY2suXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSBieSBkb3VibGUtY2xpY2tpbmcgb24gdGhlIG1hcC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRG91YmxlQ2xpY2tab29tIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YV8gPSBvcHRpb25zLmRlbHRhID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhXG4gICAqIGRvdWJsZWNsaWNrKSBhbmQgZXZlbnR1YWxseSB6b29tcyB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0spIHtcbiAgICAgIGNvbnN0IGJyb3dzZXJFdmVudCA9IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8gKFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBjb25zdCBhbmNob3IgPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICAgIGNvbnN0IGRlbHRhID0gYnJvd3NlckV2ZW50LnNoaWZ0S2V5ID8gLXRoaXMuZGVsdGFfIDogdGhpcy5kZWx0YV87XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCBhbmNob3IsIHRoaXMuZHVyYXRpb25fKTtcbiAgICAgIGJyb3dzZXJFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RvcEV2ZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRG91YmxlQ2xpY2tab29tO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdCb3hcbiAqL1xuLy8gRklYTUUgZHJhdyBkcmFnIGJveFxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgUmVuZGVyQm94IGZyb20gJy4uL3JlbmRlci9Cb3guanMnO1xuaW1wb3J0IHttb3VzZUFjdGlvbkJ1dHRvbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgdHdvXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3BpeGVsflBpeGVsfXMgYW5kIHJldHVybnMgYSBge2Jvb2xlYW59YC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQsXG4gKiB0cnVlIHNob3VsZCBiZSByZXR1cm5lZC5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbih0aGlzOiA/LCBpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWwsIGltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsKTpib29sZWFufSBFbmRDb25kaXRpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1kcmFnYm94J10gQ1NTIGNsYXNzIG5hbWUgZm9yIHN0eWxpbmcgdGhlIGJveC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBvbC9ldmVudHMvY29uZGl0aW9ufm1vdXNlQWN0aW9uQnV0dG9ufS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluQXJlYT02NF0gVGhlIG1pbmltdW0gYXJlYSBvZiB0aGUgYm94IGluIHBpeGVsLCB0aGlzIHZhbHVlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcbiAqIGBib3hFbmRDb25kaXRpb25gIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtFbmRDb25kaXRpb259IFtib3hFbmRDb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHR3b1xuICoge0BsaW5rIG1vZHVsZTpvbC9waXhlbH5QaXhlbH1zIHRvIGluZGljYXRlIHdoZXRoZXIgYSBgYm94ZW5kYCBldmVudCBzaG91bGQgYmUgZmlyZWQuXG4gKiBEZWZhdWx0IGlzIGB0cnVlYCBpZiB0aGUgYXJlYSBvZiB0aGUgYm94IGlzIGJpZ2dlciB0aGFuIHRoZSBgbWluQXJlYWAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbih0aGlzOkRyYWdCb3gsIGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbb25Cb3hFbmRdIENvZGUgdG8gZXhlY3V0ZSBqdXN0XG4gKiBiZWZvcmUgYGJveGVuZGAgaXMgZmlyZWQuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBEcmFnQm94RXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZHJhZyBib3ggc3RhcnQuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94c3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YU1RBUlQ6ICdib3hzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBvbiBkcmFnIHdoZW4gYm94IGlzIGFjdGl2ZS5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hkcmFnXG4gICAqIEBhcGlcbiAgICovXG4gIEJPWERSQUc6ICdib3hkcmFnJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZHJhZyBib3ggZW5kLlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveGVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBCT1hFTkQ6ICdib3hlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBkcmFnIGJveCBjYW5jZWxlZC5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hjYW5jZWxcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YQ0FOQ0VMOiAnYm94Y2FuY2VsJyxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQm94fkRyYWdCb3h9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mXG4gKiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBEcmFnQm94RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGV2ZW50IGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBPcmlnaW5hdGluZyBldmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNvb3JkaW5hdGUsIG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGRyYWcgZXZlbnQuXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlID0gY29vcmRpbmF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnQgPSBtYXBCcm93c2VyRXZlbnQ7XG4gIH1cbn1cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTwnYm94Y2FuY2VsJ3wnYm94ZHJhZyd8J2JveGVuZCd8J2JveHN0YXJ0JywgRHJhZ0JveEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnfCdib3hjYW5jZWwnfCdib3hkcmFnJ3wnYm94ZW5kJywgUmV0dXJuPn0gRHJhZ0JveE9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gZHJhdyBhIHZlY3RvciBib3ggYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAsXG4gKiBub3JtYWxseSBjb21iaW5lZCB3aXRoIGEge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiB0aGUgc2hpZnQgb3Igb3RoZXIga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyB1c2VkLCBmb3IgZXhhbXBsZSxcbiAqIGZvciB6b29taW5nIHRvIGEgc3BlY2lmaWMgYXJlYSBvZiB0aGUgbWFwXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21+RHJhZ1pvb219IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbX5EcmFnUm90YXRlQW5kWm9vbX0pLlxuICpcbiAqIEBmaXJlcyBEcmFnQm94RXZlbnRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ0JveCBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0RyYWdCb3hPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQm94T25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQm94T25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9Cb3guanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm94XyA9IG5ldyBSZW5kZXJCb3gob3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWdib3gnKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1pbkFyZWFfID0gb3B0aW9ucy5taW5BcmVhID8/IDY0O1xuXG4gICAgaWYgKG9wdGlvbnMub25Cb3hFbmQpIHtcbiAgICAgIHRoaXMub25Cb3hFbmQgPSBvcHRpb25zLm9uQm94RW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRQaXhlbF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPz8gbW91c2VBY3Rpb25CdXR0b247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtFbmRDb25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5ib3hFbmRDb25kaXRpb25fID1cbiAgICAgIG9wdGlvbnMuYm94RW5kQ29uZGl0aW9uID8/IHRoaXMuZGVmYXVsdEJveEVuZENvbmRpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjb25kaXRpb24gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGJveGVuZCBldmVudFxuICAgKiBzaG91bGQgZmlyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IFRoZSBvcmlnaW5hdGluZyBNYXBCcm93c2VyRXZlbnRcbiAgICogICAgIGxlYWRpbmcgdG8gdGhlIGJveCBlbmQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHN0YXJ0UGl4ZWwgVGhlIHN0YXJ0aW5nIHBpeGVsIG9mIHRoZSBib3guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IGVuZFBpeGVsIFRoZSBlbmQgcGl4ZWwgb2YgdGhlIGJveC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGJveGVuZCBjb25kaXRpb24gc2hvdWxkIGJlIGZpcmVkLlxuICAgKi9cbiAgZGVmYXVsdEJveEVuZENvbmRpdGlvbihtYXBCcm93c2VyRXZlbnQsIHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKSB7XG4gICAgY29uc3Qgd2lkdGggPSBlbmRQaXhlbFswXSAtIHN0YXJ0UGl4ZWxbMF07XG4gICAgY29uc3QgaGVpZ2h0ID0gZW5kUGl4ZWxbMV0gLSBzdGFydFBpeGVsWzFdO1xuICAgIHJldHVybiB3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0ID49IHRoaXMubWluQXJlYV87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBnZW9tZXRyeSBvZiBsYXN0IGRyYXduIGJveC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRHZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3hfLmdldEdlb21ldHJ5KCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0UGl4ZWxfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ib3hfLnNldFBpeGVscyh0aGlzLnN0YXJ0UGl4ZWxfLCBtYXBCcm93c2VyRXZlbnQucGl4ZWwpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IERyYWdCb3hFdmVudChcbiAgICAgICAgRHJhZ0JveEV2ZW50VHlwZS5CT1hEUkFHLFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0UGl4ZWxfKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGVCb3ggPSB0aGlzLmJveEVuZENvbmRpdGlvbl8oXG4gICAgICBtYXBCcm93c2VyRXZlbnQsXG4gICAgICB0aGlzLnN0YXJ0UGl4ZWxfLFxuICAgICAgbWFwQnJvd3NlckV2ZW50LnBpeGVsLFxuICAgICk7XG4gICAgaWYgKGNvbXBsZXRlQm94KSB7XG4gICAgICB0aGlzLm9uQm94RW5kKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBEcmFnQm94RXZlbnQoXG4gICAgICAgIGNvbXBsZXRlQm94ID8gRHJhZ0JveEV2ZW50VHlwZS5CT1hFTkQgOiBEcmFnQm94RXZlbnRUeXBlLkJPWENBTkNFTCxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudCxcbiAgICAgICksXG4gICAgKTtcblxuICAgIHRoaXMuYm94Xy5zZXRNYXAobnVsbCk7XG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgICAgdGhpcy5ib3hfLnNldE1hcChtYXBCcm93c2VyRXZlbnQubWFwKTtcbiAgICAgIHRoaXMuYm94Xy5zZXRQaXhlbHModGhpcy5zdGFydFBpeGVsXywgdGhpcy5zdGFydFBpeGVsXyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBEcmFnQm94RXZlbnQoXG4gICAgICAgICAgRHJhZ0JveEV2ZW50VHlwZS5CT1hTVEFSVCxcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnQsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBleGVjdXRlIGp1c3QgYmVmb3JlIGBvbmJveGVuZGAgaXMgZmlyZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqL1xuICBvbkJveEVuZChldmVudCkge31cblxuICAvKipcbiAgICogQWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0aGUgaW50ZXJhY3Rpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlIEFjdGl2ZS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgdGhpcy5ib3hfLnNldE1hcChudWxsKTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0UGl4ZWxfKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgRHJhZ0JveEV2ZW50KERyYWdCb3hFdmVudFR5cGUuQk9YQ0FOQ0VMLCB0aGlzLnN0YXJ0UGl4ZWxfLCBudWxsKSxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXIuc2V0QWN0aXZlKGFjdGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBtYXAgTWFwLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBjb25zdCBvbGRNYXAgPSB0aGlzLmdldE1hcCgpO1xuXG4gICAgaWYgKG9sZE1hcCkge1xuICAgICAgdGhpcy5ib3hfLnNldE1hcChudWxsKTtcblxuICAgICAgaWYgKHRoaXMuc3RhcnRQaXhlbF8pIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hDQU5DRUwsIHRoaXMuc3RhcnRQaXhlbF8sIG51bGwpLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlci5zZXRNYXAobWFwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnQm94O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdQYW5cbiAqL1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiwge1xuICBjZW50cm9pZCBhcyBjZW50cm9pZEZyb21Qb2ludGVycyxcbn0gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge1xuICBhbGwsXG4gIGZvY3VzV2l0aFRhYmluZGV4LFxuICBub01vZGlmaWVyS2V5cyxcbiAgcHJpbWFyeUFjdGlvbixcbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge1xuICByb3RhdGUgYXMgcm90YXRlQ29vcmRpbmF0ZSxcbiAgc2NhbGUgYXMgc2NhbGVDb29yZGluYXRlLFxufSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGEgYm9vbGVhblxuICogdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ubm9Nb2RpZmllcktleXN9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ucHJpbWFyeUFjdGlvbn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbkZvY3VzT25seT1mYWxzZV0gV2hlbiB0aGUgbWFwJ3MgdGFyZ2V0IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlIHNldCxcbiAqIHRoZSBpbnRlcmFjdGlvbiB3aWxsIG9ubHkgaGFuZGxlIGV2ZW50cyB3aGVuIHRoZSBtYXAgaGFzIHRoZSBmb2N1cy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vS2luZXRpYy5qc1wiKS5kZWZhdWx0fSBba2luZXRpY10gS2luZXRpYyBpbmVydGlhIHRvIGFwcGx5IHRvIHRoZSBwYW4uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgYnkgZHJhZ2dpbmcgdGhlIG1hcC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ1BhbiBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIHN0b3BEb3duOiBGQUxTRSxcbiAgICB9KTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vS2luZXRpYy5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmtpbmV0aWNfID0gb3B0aW9ucy5raW5ldGljO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqL1xuICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQb2ludGVyc0NvdW50XztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wYW5uaW5nXyA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29uZGl0aW9uID0gb3B0aW9ucy5jb25kaXRpb25cbiAgICAgID8gb3B0aW9ucy5jb25kaXRpb25cbiAgICAgIDogYWxsKG5vTW9kaWZpZXJLZXlzLCBwcmltYXJ5QWN0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMub25Gb2N1c09ubHlcbiAgICAgID8gYWxsKGZvY3VzV2l0aFRhYmluZGV4LCBjb25kaXRpb24pXG4gICAgICA6IGNvbmRpdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5ub0tpbmV0aWNfID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBpZiAoIXRoaXMucGFubmluZ18pIHtcbiAgICAgIHRoaXMucGFubmluZ18gPSB0cnVlO1xuICAgICAgbWFwLmdldFZpZXcoKS5iZWdpbkludGVyYWN0aW9uKCk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFBvaW50ZXJzID0gdGhpcy50YXJnZXRQb2ludGVycztcbiAgICBjb25zdCBjZW50cm9pZCA9IG1hcC5nZXRFdmVudFBpeGVsKGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRhcmdldFBvaW50ZXJzKSk7XG4gICAgaWYgKHRhcmdldFBvaW50ZXJzLmxlbmd0aCA9PSB0aGlzLmxhc3RQb2ludGVyc0NvdW50Xykge1xuICAgICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgICAgdGhpcy5raW5ldGljXy51cGRhdGUoY2VudHJvaWRbMF0sIGNlbnRyb2lkWzFdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxhc3RDZW50cm9pZCkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IFtcbiAgICAgICAgICB0aGlzLmxhc3RDZW50cm9pZFswXSAtIGNlbnRyb2lkWzBdLFxuICAgICAgICAgIGNlbnRyb2lkWzFdIC0gdGhpcy5sYXN0Q2VudHJvaWRbMV0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgICBzY2FsZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICAgICAgcm90YXRlQ29vcmRpbmF0ZShkZWx0YSwgdmlldy5nZXRSb3RhdGlvbigpKTtcbiAgICAgICAgdmlldy5hZGp1c3RDZW50ZXJJbnRlcm5hbChkZWx0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAvLyByZXNldCBzbyB3ZSBkb24ndCBvdmVyZXN0aW1hdGUgdGhlIGtpbmV0aWMgZW5lcmd5IGFmdGVyXG4gICAgICAvLyBhZnRlciBvbmUgZmluZ2VyIGRvd24sIHRpbnkgZHJhZywgc2Vjb25kIGZpbmdlciBkb3duXG4gICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENlbnRyb2lkID0gY2VudHJvaWQ7XG4gICAgdGhpcy5sYXN0UG9pbnRlcnNDb3VudF8gPSB0YXJnZXRQb2ludGVycy5sZW5ndGg7XG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMubm9LaW5ldGljXyAmJiB0aGlzLmtpbmV0aWNfICYmIHRoaXMua2luZXRpY18uZW5kKCkpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmtpbmV0aWNfLmdldERpc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5raW5ldGljXy5nZXRBbmdsZSgpO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB2aWV3LmdldENlbnRlckludGVybmFsKCk7XG4gICAgICAgIGNvbnN0IGNlbnRlcnB4ID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGVJbnRlcm5hbChjZW50ZXIpO1xuICAgICAgICBjb25zdCBkZXN0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChbXG4gICAgICAgICAgY2VudGVycHhbMF0gLSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICBjZW50ZXJweFsxXSAtIGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBdKTtcbiAgICAgICAgdmlldy5hbmltYXRlSW50ZXJuYWwoe1xuICAgICAgICAgIGNlbnRlcjogdmlldy5nZXRDb25zdHJhaW5lZENlbnRlcihkZXN0KSxcbiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYW5uaW5nXykge1xuICAgICAgICB0aGlzLnBhbm5pbmdfID0gZmFsc2U7XG4gICAgICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgIC8vIHJlc2V0IHNvIHdlIGRvbid0IG92ZXJlc3RpbWF0ZSB0aGUga2luZXRpYyBlbmVyZ3kgYWZ0ZXJcbiAgICAgIC8vIGFmdGVyIG9uZSBmaW5nZXIgdXAsIHRpbnkgZHJhZywgc2Vjb25kIGZpbmdlciB1cFxuICAgICAgdGhpcy5raW5ldGljXy5iZWdpbigpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID4gMCAmJiB0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgdGhpcy5sYXN0Q2VudHJvaWQgPSBudWxsO1xuICAgICAgLy8gc3RvcCBhbnkgY3VycmVudCBhbmltYXRpb25cbiAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgICAgdGhpcy5raW5ldGljXy5iZWdpbigpO1xuICAgICAgfVxuICAgICAgLy8gTm8ga2luZXRpYyBhcyBzb29uIGFzIG1vcmUgdGhhbiBvbmUgcG9pbnRlciBvbiB0aGUgc2NyZWVuIGlzXG4gICAgICAvLyBkZXRlY3RlZC4gVGhpcyBpcyB0byBwcmV2ZW50IG5hc3R5IHBhbnMgYWZ0ZXIgcGluY2guXG4gICAgICB0aGlzLm5vS2luZXRpY18gPSB0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdQYW47XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZVxuICovXG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYWx0U2hpZnRLZXlzT25seSxcbiAgbW91c2VBY3Rpb25CdXR0b24sXG4gIG1vdXNlT25seSxcbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge2Rpc2FibGV9IGZyb20gJy4uL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFcbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5hbHRTaGlmdEtleXNPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHJvdGF0ZSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLFxuICogbm9ybWFsbHkgY29tYmluZWQgd2l0aCBhIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn0gdGhhdCBsaW1pdHNcbiAqIGl0IHRvIHdoZW4gdGhlIGFsdCBhbmQgc2hpZnQga2V5cyBhcmUgaGVsZCBkb3duLlxuICpcbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIERyYWdSb3RhdGUgZXh0ZW5kcyBQb2ludGVySW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIHN0b3BEb3duOiBGQUxTRSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBhbHRTaGlmdEtleXNPbmx5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpbnRzKCkucm90YXRpb24gPT09IGRpc2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IG1hcC5nZXRTaXplKCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hdGFuMihzaXplWzFdIC8gMiAtIG9mZnNldFsxXSwgb2Zmc2V0WzBdIC0gc2l6ZVswXSAvIDIpO1xuICAgIGlmICh0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVsdGEgPSB0aGV0YSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICAgIHZpZXcuYWRqdXN0Um90YXRpb25JbnRlcm5hbCgtZGVsdGEpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB0aGV0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgdmlldy5lbmRJbnRlcmFjdGlvbih0aGlzLmR1cmF0aW9uXyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBtb3VzZUFjdGlvbkJ1dHRvbihtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICB0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KVxuICAgICkge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnUm90YXRlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdab29tXG4gKi9cbmltcG9ydCBEcmFnQm94IGZyb20gJy4vRHJhZ0JveC5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge3NoaWZ0S2V5T25seX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWRyYWd6b29tJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHN0eWxpbmcgdGhlXG4gKiBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLnNoaWZ0S2V5T25seX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dD1mYWxzZV0gVXNlIGludGVyYWN0aW9uIGZvciB6b29taW5nIG91dC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluQXJlYT02NF0gVGhlIG1pbmltdW0gYXJlYSBvZiB0aGUgYm94IGluIHBpeGVsLCB0aGlzIHZhbHVlIGlzIHVzZWQgYnkgdGhlIHBhcmVudCBkZWZhdWx0XG4gKiBgYm94RW5kQ29uZGl0aW9uYCBmdW5jdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAsXG4gKiBub3JtYWxseSBjb21iaW5lZCB3aXRoIGEge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiBhIGtleSwgc2hpZnQgYnkgZGVmYXVsdCwgaXMgaGVsZCBkb3duLlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIGJveCwgdXNlIENTUyBhbmQgdGhlIGAub2wtZHJhZ3pvb21gIHNlbGVjdG9yLCBvclxuICogeW91ciBjdXN0b20gb25lIGNvbmZpZ3VyZWQgd2l0aCBgY2xhc3NOYW1lYC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ1pvb20gZXh0ZW5kcyBEcmFnQm94IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBjb25kaXRpb24gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogc2hpZnRLZXlPbmx5O1xuXG4gICAgc3VwZXIoe1xuICAgICAgY29uZGl0aW9uOiBjb25kaXRpb24sXG4gICAgICBjbGFzc05hbWU6IG9wdGlvbnMuY2xhc3NOYW1lIHx8ICdvbC1kcmFnem9vbScsXG4gICAgICBtaW5BcmVhOiBvcHRpb25zLm1pbkFyZWEsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm91dF8gPSBvcHRpb25zLm91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vdXQgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBleGVjdXRlIGp1c3QgYmVmb3JlIGBvbmJveGVuZGAgaXMgZmlyZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb25Cb3hFbmQoZXZlbnQpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IHZpZXcgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9ICovIChtYXAuZ2V0VmlldygpKTtcbiAgICBsZXQgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG5cbiAgICBpZiAodGhpcy5vdXRfKSB7XG4gICAgICBjb25zdCByb3RhdGVkRXh0ZW50ID0gdmlldy5yb3RhdGVkRXh0ZW50Rm9yR2VvbWV0cnkoZ2VvbWV0cnkpO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHZpZXcuZ2V0UmVzb2x1dGlvbkZvckV4dGVudEludGVybmFsKHJvdGF0ZWRFeHRlbnQpO1xuICAgICAgY29uc3QgZmFjdG9yID0gdmlldy5nZXRSZXNvbHV0aW9uKCkgLyByZXNvbHV0aW9uO1xuICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgICAgZ2VvbWV0cnkuc2NhbGUoZmFjdG9yICogZmFjdG9yKTtcbiAgICB9XG5cbiAgICB2aWV3LmZpdEludGVybmFsKGdlb21ldHJ5LCB7XG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbl8sXG4gICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1pvb207XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25cbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCBJbnRlcmFjdGlvblByb3BlcnR5IGZyb20gJy4vUHJvcGVydHkuanMnO1xuaW1wb3J0IHtlYXNlT3V0LCBsaW5lYXJ9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZScsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJywgUmV0dXJuPn0gSW50ZXJhY3Rpb25PblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBjb25maWcgb3B0aW9ucyBmb3IgaW50ZXJhY3Rpb25zLlxuICogQHR5cGVkZWYge09iamVjdH0gSW50ZXJhY3Rpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTpib29sZWFufSBbaGFuZGxlRXZlbnRdXG4gKiBNZXRob2QgY2FsbGVkIGJ5IHRoZSBtYXAgdG8gbm90aWZ5IHRoZSBpbnRlcmFjdGlvbiB0aGF0IGEgYnJvd3NlciBldmVudCB3YXNcbiAqIGRpc3BhdGNoZWQgdG8gdGhlIG1hcC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgcHJvcGFnYXRpb24gb2ZcbiAqIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9ucyBjaGFpbiB3aWxsIGJlXG4gKiBwcmV2ZW50ZWQgKHRoaXMgaW5jbHVkZXMgZnVuY3Rpb25zIHdpdGggbm8gZXhwbGljaXQgcmV0dXJuKS4gVGhlIGludGVyYWN0aW9uc1xuICogYXJlIHRyYXZlcnNlZCBpbiByZXZlcnNlIG9yZGVyIG9mIHRoZSBpbnRlcmFjdGlvbnMgY29sbGVjdGlvbiBvZiB0aGUgbWFwLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogVXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgbWFwLiBTb21lIGFyZSBzaW1pbGFyIHRvIGNvbnRyb2xzLFxuICogYnV0IGFyZSBub3QgYXNzb2NpYXRlZCB3aXRoIGEgRE9NIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfSBpc1xuICogZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219LCBidXQgdHJpZ2dlcmVkXG4gKiBieSBhIGtleWJvYXJkIGV2ZW50IG5vdCBhIGJ1dHRvbiBlbGVtZW50IGV2ZW50LlxuICogQWx0aG91Z2ggaW50ZXJhY3Rpb25zIGRvIG5vdCBoYXZlIGEgRE9NIGVsZW1lbnQsIHNvbWUgb2YgdGhlbSBkbyByZW5kZXJcbiAqIHZlY3RvcnMgYW5kIHNvIGFyZSB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEludGVyYWN0aW9uIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7SW50ZXJhY3Rpb25PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtJbnRlcmFjdGlvbk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7SW50ZXJhY3Rpb25PblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IG9wdGlvbnMuaGFuZGxlRXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgdGhpcy5zZXRBY3RpdmUodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGludGVyYWN0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW50ZXJhY3Rpb24gaXMgYWN0aXZlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QWN0aXZlKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2Jvb2xlYW59ICovICh0aGlzLmdldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGludGVyYWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSBpbnRlcmFjdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgQWN0aXZlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBY3RpdmUoYWN0aXZlKSB7XG4gICAgdGhpcy5zZXQoSW50ZXJhY3Rpb25Qcm9wZXJ0eS5BQ1RJVkUsIGFjdGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBpbnRlcmFjdGlvbiBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IG1hcCBNYXAuXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFuKHZpZXcsIGRlbHRhLCBkdXJhdGlvbikge1xuICBjb25zdCBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICBpZiAoY3VycmVudENlbnRlcikge1xuICAgIGNvbnN0IGNlbnRlciA9IFtjdXJyZW50Q2VudGVyWzBdICsgZGVsdGFbMF0sIGN1cnJlbnRDZW50ZXJbMV0gKyBkZWx0YVsxXV07XG4gICAgdmlldy5hbmltYXRlSW50ZXJuYWwoe1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBkdXJhdGlvbiA6IDI1MCxcbiAgICAgIGVhc2luZzogbGluZWFyLFxuICAgICAgY2VudGVyOiB2aWV3LmdldENvbnN0cmFpbmVkQ2VudGVyKGNlbnRlciksXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhIGZyb20gcHJldmlvdXMgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBBbmNob3IgY29vcmRpbmF0ZSBpbiB0aGUgdXNlciBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6b29tQnlEZWx0YSh2aWV3LCBkZWx0YSwgYW5jaG9yLCBkdXJhdGlvbikge1xuICBjb25zdCBjdXJyZW50Wm9vbSA9IHZpZXcuZ2V0Wm9vbSgpO1xuXG4gIGlmIChjdXJyZW50Wm9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbmV3Wm9vbSA9IHZpZXcuZ2V0Q29uc3RyYWluZWRab29tKGN1cnJlbnRab29tICsgZGVsdGEpO1xuICBjb25zdCBuZXdSZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uRm9yWm9vbShuZXdab29tKTtcblxuICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICB9XG4gIHZpZXcuYW5pbWF0ZSh7XG4gICAgcmVzb2x1dGlvbjogbmV3UmVzb2x1dGlvbixcbiAgICBhbmNob3I6IGFuY2hvcixcbiAgICBkdXJhdGlvbjogZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGR1cmF0aW9uIDogMjUwLFxuICAgIGVhc2luZzogZWFzZU91dCxcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyYWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHtwYW59IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IEtleSBmcm9tICcuLi9ldmVudHMvS2V5LmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXMsIHRhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7cm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBEZWZhdWx0IGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ubm9Nb2RpZmllcktleXN9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLnRhcmdldE5vdEVkaXRhYmxlfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbERlbHRhPTEyOF0gVGhlIGFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIG9uIGVhY2gga2V5XG4gKiBwcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBwYW4gdGhlIG1hcCB1c2luZyBrZXlib2FyZCBhcnJvd3MuXG4gKiBOb3RlIHRoYXQsIGFsdGhvdWdoIHRoaXMgaW50ZXJhY3Rpb24gaXMgYnkgZGVmYXVsdCBpbmNsdWRlZCBpbiBtYXBzLFxuICogdGhlIGtleXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGJyb3dzZXIgZm9jdXMgaXMgb24gdGhlIGVsZW1lbnQgdG8gd2hpY2hcbiAqIHRoZSBrZXlib2FyZCBldmVudHMgYXJlIGF0dGFjaGVkLiBCeSBkZWZhdWx0LCB0aGlzIGlzIHRoZSBtYXAgZGl2LFxuICogdGhvdWdoIHlvdSBjYW4gY2hhbmdlIHRoaXMgd2l0aCB0aGUgYGtleWJvYXJkRXZlbnRUYXJnZXRgIGluXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9LiBgZG9jdW1lbnRgIG5ldmVyIGxvc2VzIGZvY3VzIGJ1dCwgZm9yIGFueSBvdGhlclxuICogZWxlbWVudCwgZm9jdXMgd2lsbCBoYXZlIHRvIGJlIG9uLCBhbmQgcmV0dXJuZWQgdG8sIHRoaXMgZWxlbWVudCBpZiB0aGUga2V5c1xuICogYXJlIHRvIGZ1bmN0aW9uLlxuICogU2VlIGFsc28ge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgS2V5Ym9hcmRQYW4gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb25kaXRpb25fID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbm9Nb2RpZmllcktleXMobWFwQnJvd3NlckV2ZW50KSAmJiB0YXJnZXROb3RFZGl0YWJsZShtYXBCcm93c2VyRXZlbnQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPVxuICAgICAgb3B0aW9ucy5jb25kaXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICAgIDogdGhpcy5kZWZhdWx0Q29uZGl0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbERlbHRhXyA9XG4gICAgICBvcHRpb25zLnBpeGVsRGVsdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGl4ZWxEZWx0YSA6IDEyODtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGlmIGl0IHdhcyBhXG4gICAqIGBLZXlFdmVudGAsIGFuZCBkZWNpZGVzIHRoZSBkaXJlY3Rpb24gdG8gcGFuIHRvIChpZiBhbiBhcnJvdyBrZXkgd2FzXG4gICAqIHByZXNzZWQpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOKSB7XG4gICAgICBjb25zdCBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGtleSA9IGtleUV2ZW50LmtleTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgKGtleSA9PSBLZXkuRE9XTiB8fFxuICAgICAgICAgIGtleSA9PSBLZXkuTEVGVCB8fFxuICAgICAgICAgIGtleSA9PSBLZXkuUklHSFQgfHxcbiAgICAgICAgICBrZXkgPT0gS2V5LlVQKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgICBjb25zdCBtYXBVbml0c0RlbHRhID0gdmlldy5nZXRSZXNvbHV0aW9uKCkgKiB0aGlzLnBpeGVsRGVsdGFfO1xuICAgICAgICBsZXQgZGVsdGFYID0gMCxcbiAgICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBpZiAoa2V5ID09IEtleS5ET1dOKSB7XG4gICAgICAgICAgZGVsdGFZID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09IEtleS5MRUZUKSB7XG4gICAgICAgICAgZGVsdGFYID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09IEtleS5SSUdIVCkge1xuICAgICAgICAgIGRlbHRhWCA9IG1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFZID0gbWFwVW5pdHNEZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IFtkZWx0YVgsIGRlbHRhWV07XG4gICAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIHBhbih2aWV3LCBkZWx0YSwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgICBrZXlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFBhbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7cGxhdGZvcm1Nb2RpZmllcktleSwgdGFyZ2V0Tm90RWRpdGFibGV9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIFRoZSBkZWZhdWx0IGNvbmRpdGlvbiBpc1xuICogdGhhdCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24udGFyZ2V0Tm90RWRpdGFibGV9IGlzIGZ1bGZpbGxlZCBhbmQgdGhhdFxuICogdGhlIHBsYXRmb3JtIG1vZGlmaWVyIGtleSBpc24ndCBwcmVzc2VkXG4gKiAoIXtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5wbGF0Zm9ybU1vZGlmaWVyS2V5fSkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGxldmVsIGRlbHRhIG9uIGVhY2gga2V5IHByZXNzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCB1c2luZyBrZXlib2FyZCArIGFuZCAtLlxuICogTm90ZSB0aGF0LCBhbHRob3VnaCB0aGlzIGludGVyYWN0aW9uIGlzIGJ5IGRlZmF1bHQgaW5jbHVkZWQgaW4gbWFwcyxcbiAqIHRoZSBrZXlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBicm93c2VyIGZvY3VzIGlzIG9uIHRoZSBlbGVtZW50IHRvIHdoaWNoXG4gKiB0aGUga2V5Ym9hcmQgZXZlbnRzIGFyZSBhdHRhY2hlZC4gQnkgZGVmYXVsdCwgdGhpcyBpcyB0aGUgbWFwIGRpdixcbiAqIHRob3VnaCB5b3UgY2FuIGNoYW5nZSB0aGlzIHdpdGggdGhlIGBrZXlib2FyZEV2ZW50VGFyZ2V0YCBpblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfS4gYGRvY3VtZW50YCBuZXZlciBsb3NlcyBmb2N1cyBidXQsIGZvciBhbnkgb3RoZXJcbiAqIGVsZW1lbnQsIGZvY3VzIHdpbGwgaGF2ZSB0byBiZSBvbiwgYW5kIHJldHVybmVkIHRvLCB0aGlzIGVsZW1lbnQgaWYgdGhlIGtleXNcbiAqIGFyZSB0byBmdW5jdGlvbi5cbiAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW5+S2V5Ym9hcmRQYW59LlxuICogQGFwaVxuICovXG5jbGFzcyBLZXlib2FyZFpvb20gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICA/IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICA6IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgIXBsYXRmb3JtTW9kaWZpZXJLZXkobWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm90RWRpdGFibGUobWFwQnJvd3NlckV2ZW50KVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YV8gPSBvcHRpb25zLmRlbHRhID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMTAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gaWYgaXQgd2FzIGFcbiAgICogYEtleUV2ZW50YCwgYW5kIGRlY2lkZXMgd2hldGhlciB0byB6b29tIGluIG9yIG91dCAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG4gICAqIGtleSBwcmVzc2VkIHdhcyAnKycgb3IgJy0nKS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOIHx8XG4gICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZUFJFU1NcbiAgICApIHtcbiAgICAgIGNvbnN0IGtleUV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fSAqLyAoXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICApO1xuICAgICAgY29uc3Qga2V5ID0ga2V5RXZlbnQua2V5O1xuICAgICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmIChrZXkgPT09ICcrJyB8fCBrZXkgPT09ICctJykpIHtcbiAgICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBrZXkgPT09ICcrJyA/IHRoaXMuZGVsdGFfIDogLXRoaXMuZGVsdGFfO1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIHVuZGVmaW5lZCwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgICBrZXlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFpvb207XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb21cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPLCBGSVJFRk9YfSBmcm9tICcuLi9oYXMuanMnO1xuaW1wb3J0IHthbGwsIGFsd2F5cywgZm9jdXNXaXRoVGFiaW5kZXh9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyd0cmFja3BhZCcgfCAnd2hlZWwnfSBNb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gRGVmYXVsdCBpc1xuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLmFsd2F5c30uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbkZvY3VzT25seT1mYWxzZV0gV2hlbiB0aGUgbWFwJ3MgdGFyZ2V0IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlIHNldCxcbiAqIHRoZSBpbnRlcmFjdGlvbiB3aWxsIG9ubHkgaGFuZGxlIGV2ZW50cyB3aGVuIHRoZSBtYXAgaGFzIHRoZSBmb2N1cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4RGVsdGE9MV0gTWF4aW11bSBtb3VzZSB3aGVlbCBkZWx0YS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aW1lb3V0PTgwXSBNb3VzZSB3aGVlbCB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VzZUFuY2hvcj10cnVlXSBFbmFibGUgem9vbWluZyB1c2luZyB0aGUgbW91c2Unc1xuICogbG9jYXRpb24gYXMgdGhlIGFuY2hvci4gV2hlbiBzZXQgdG8gYGZhbHNlYCwgem9vbWluZyBpbiBhbmQgb3V0IHdpbGwgem9vbSB0b1xuICogdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuIGluc3RlYWQgb2Ygem9vbWluZyBvbiB0aGUgbW91c2UncyBsb2NhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnN0cmFpblJlc29sdXRpb249ZmFsc2VdIElmIHRydWUsIHRoZSBtb3VzZSB3aGVlbCB6b29tXG4gKiBldmVudCB3aWxsIGFsd2F5cyBhbmltYXRlIHRvIHRoZSBjbG9zZXN0IHpvb20gbGV2ZWwgYWZ0ZXIgYW4gaW50ZXJhY3Rpb247XG4gKiBmYWxzZSBtZWFucyBpbnRlcm1lZGlhcnkgem9vbSBsZXZlbHMgYXJlIGFsbG93ZWQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IHNjcm9sbGluZyB0aGUgbW91c2Ugd2hlZWwuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE1vdXNlV2hlZWxab29tIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ludGVyYWN0aW9uLmpzXCIpLkludGVyYWN0aW9uT3B0aW9uc30gKi8gKG9wdGlvbnMpLFxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b3RhbERlbHRhXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0RGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IG9wdGlvbnMubWF4RGVsdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4RGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRfID0gb3B0aW9ucy50aW1lb3V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbWVvdXQgOiA4MDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51c2VBbmNob3JfID1cbiAgICAgIG9wdGlvbnMudXNlQW5jaG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVzZUFuY2hvciA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8gPVxuICAgICAgb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb25cbiAgICAgICAgOiBmYWxzZTtcblxuICAgIGNvbnN0IGNvbmRpdGlvbiA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBhbHdheXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLm9uRm9jdXNPbmx5XG4gICAgICA/IGFsbChmb2N1c1dpdGhUYWJpbmRleCwgY29uZGl0aW9uKVxuICAgICAgOiBjb25kaXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRUaW1lXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+fVxuICAgICAqL1xuICAgIHRoaXMudGltZW91dElkXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge01vZGV8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubW9kZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUcmFja3BhZCBldmVudHMgc2VwYXJhdGVkIGJ5IHRoaXMgZGVsYXkgd2lsbCBiZSBjb25zaWRlcmVkIHNlcGFyYXRlXG4gICAgICogaW50ZXJhY3Rpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcGFkRXZlbnRHYXBfID0gNDAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD59XG4gICAgICovXG4gICAgdGhpcy50cmFja3BhZFRpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlbHRhIHZhbHVlcyBwZXIgem9vbSBsZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhUGVyWm9vbV8gPSAzMDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVuZEludGVyYWN0aW9uXygpIHtcbiAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmICghbWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24oXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLmxhc3REZWx0YV8gPyAodGhpcy5sYXN0RGVsdGFfID4gMCA/IDEgOiAtMSkgOiAwLFxuICAgICAgdGhpcy5sYXN0QW5jaG9yXyA/IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMubGFzdEFuY2hvcl8pIDogbnVsbCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhIG1vdXNld2hlZWwtZXZlbnQpIGFuZCBldmVudHVhbGx5XG4gICAqIHpvb21zIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gbWFwQnJvd3NlckV2ZW50LnR5cGU7XG4gICAgaWYgKHR5cGUgIT09IEV2ZW50VHlwZS5XSEVFTCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB3aGVlbEV2ZW50ID0gLyoqIEB0eXBlIHtXaGVlbEV2ZW50fSAqLyAoXG4gICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICk7XG4gICAgd2hlZWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKHRoaXMudXNlQW5jaG9yXykge1xuICAgICAgdGhpcy5sYXN0QW5jaG9yXyA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICB9XG5cbiAgICAvLyBEZWx0YSBub3JtYWxpc2F0aW9uIGluc3BpcmVkIGJ5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvYmxvYi8wMDFjN2I5L2pzL3VpL2hhbmRsZXIvc2Nyb2xsX3pvb20uanNcbiAgICBsZXQgZGVsdGE7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5XSEVFTCkge1xuICAgICAgZGVsdGEgPSB3aGVlbEV2ZW50LmRlbHRhWTtcbiAgICAgIGlmIChGSVJFRk9YICYmIHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgICBkZWx0YSAvPSBERVZJQ0VfUElYRUxfUkFUSU87XG4gICAgICB9XG4gICAgICBpZiAod2hlZWxFdmVudC5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgZGVsdGEgKj0gNDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubGFzdERlbHRhXyA9IGRlbHRhO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmICh0aGlzLnN0YXJ0VGltZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGFydFRpbWVfID0gbm93O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tb2RlXyB8fCBub3cgLSB0aGlzLnN0YXJ0VGltZV8gPiB0aGlzLnRyYWNrcGFkRXZlbnRHYXBfKSB7XG4gICAgICB0aGlzLm1vZGVfID0gTWF0aC5hYnMoZGVsdGEpIDwgNCA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuICAgIH1cblxuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmIChcbiAgICAgIHRoaXMubW9kZV8gPT09ICd0cmFja3BhZCcgJiZcbiAgICAgICEodmlldy5nZXRDb25zdHJhaW5SZXNvbHV0aW9uKCkgfHwgdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXylcbiAgICApIHtcbiAgICAgIGlmICh0aGlzLnRyYWNrcGFkVGltZW91dElkXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmJlZ2luSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfID0gc2V0VGltZW91dChcbiAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbl8uYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy50aW1lb3V0XyxcbiAgICAgICk7XG4gICAgICB2aWV3LmFkanVzdFpvb20oXG4gICAgICAgIC1kZWx0YSAvIHRoaXMuZGVsdGFQZXJab29tXyxcbiAgICAgICAgdGhpcy5sYXN0QW5jaG9yXyA/IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMubGFzdEFuY2hvcl8pIDogbnVsbCxcbiAgICAgICk7XG4gICAgICB0aGlzLnN0YXJ0VGltZV8gPSBub3c7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy50b3RhbERlbHRhXyArPSBkZWx0YTtcblxuICAgIGNvbnN0IHRpbWVMZWZ0ID0gTWF0aC5tYXgodGhpcy50aW1lb3V0XyAtIChub3cgLSB0aGlzLnN0YXJ0VGltZV8pLCAwKTtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQoXG4gICAgICB0aGlzLmhhbmRsZVdoZWVsWm9vbV8uYmluZCh0aGlzLCBtYXApLFxuICAgICAgdGltZUxlZnQsXG4gICAgKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgaGFuZGxlV2hlZWxab29tXyhtYXApIHtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIGxldCBkZWx0YSA9XG4gICAgICAtY2xhbXAoXG4gICAgICAgIHRoaXMudG90YWxEZWx0YV8sXG4gICAgICAgIC10aGlzLm1heERlbHRhXyAqIHRoaXMuZGVsdGFQZXJab29tXyxcbiAgICAgICAgdGhpcy5tYXhEZWx0YV8gKiB0aGlzLmRlbHRhUGVyWm9vbV8sXG4gICAgICApIC8gdGhpcy5kZWx0YVBlclpvb21fO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpblJlc29sdXRpb24oKSB8fCB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fKSB7XG4gICAgICAvLyB2aWV3IGhhcyBhIHpvb20gY29uc3RyYWludCwgem9vbSBieSAxXG4gICAgICBkZWx0YSA9IGRlbHRhID8gKGRlbHRhID4gMCA/IDEgOiAtMSkgOiAwO1xuICAgIH1cbiAgICB6b29tQnlEZWx0YShcbiAgICAgIHZpZXcsXG4gICAgICBkZWx0YSxcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPyBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLmxhc3RBbmNob3JfKSA6IG51bGwsXG4gICAgICB0aGlzLmR1cmF0aW9uXyxcbiAgICApO1xuXG4gICAgdGhpcy5tb2RlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvdGFsRGVsdGFfID0gMDtcbiAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIHVzaW5nIHRoZSBtb3VzZSdzIGxvY2F0aW9uIGFzIGFuIGFuY2hvciB3aGVuIHpvb21pbmdcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBbmNob3IgdHJ1ZSB0byB6b29tIHRvIHRoZSBtb3VzZSdzIGxvY2F0aW9uLCBmYWxzZVxuICAgKiB0byB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIG1hcFxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNb3VzZUFuY2hvcih1c2VBbmNob3IpIHtcbiAgICB0aGlzLnVzZUFuY2hvcl8gPSB1c2VBbmNob3I7XG4gICAgaWYgKCF1c2VBbmNob3IpIHtcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVdoZWVsWm9vbTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZVxuICovXG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7XG4gIGNlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzLFxufSBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7ZGlzYWJsZX0gZnJvbSAnLi4vcm90YXRpb25jb25zdHJhaW50LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGhyZXNob2xkPTAuM10gTWluaW1hbCBhbmdsZSBpbiByYWRpYW5zIHRvIHN0YXJ0IGEgcm90YXRpb24uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcm90YXRlIHRoZSBtYXAgYnkgdHdpc3Rpbmcgd2l0aCB0d28gZmluZ2Vyc1xuICogb24gYSB0b3VjaCBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBpbmNoUm90YXRlIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBzdXBlcihwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25EZWx0YV8gPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aHJlc2hvbGRfID0gb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGhyZXNob2xkIDogMC4zO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgcm90YXRpb25EZWx0YSA9IDAuMDtcblxuICAgIGNvbnN0IHRvdWNoMCA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMF07XG4gICAgY29uc3QgdG91Y2gxID0gdGhpcy50YXJnZXRQb2ludGVyc1sxXTtcblxuICAgIC8vIGFuZ2xlIGJldHdlZW4gdG91Y2hlc1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihcbiAgICAgIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gwLmNsaWVudFksXG4gICAgICB0b3VjaDEuY2xpZW50WCAtIHRvdWNoMC5jbGllbnRYLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy5sYXN0QW5nbGVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gYW5nbGUgLSB0aGlzLmxhc3RBbmdsZV87XG4gICAgICB0aGlzLnJvdGF0aW9uRGVsdGFfICs9IGRlbHRhO1xuICAgICAgaWYgKCF0aGlzLnJvdGF0aW5nXyAmJiBNYXRoLmFicyh0aGlzLnJvdGF0aW9uRGVsdGFfKSA+IHRoaXMudGhyZXNob2xkXykge1xuICAgICAgICB0aGlzLnJvdGF0aW5nXyA9IHRydWU7XG4gICAgICB9XG4gICAgICByb3RhdGlvbkRlbHRhID0gZGVsdGE7XG4gICAgfVxuICAgIHRoaXMubGFzdEFuZ2xlXyA9IGFuZ2xlO1xuXG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAodmlldy5nZXRDb25zdHJhaW50cygpLnJvdGF0aW9uID09PSBkaXNhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcm90YXRlIGFuY2hvciBwb2ludC5cbiAgICAvLyBGSVhNRTogc2hvdWxkIGJlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgYmV0d2VlbiB0aGUgbGluZXM6XG4gICAgLy8gICAgIHRvdWNoMCx0b3VjaDEgYW5kIHByZXZpb3VzVG91Y2gwLHByZXZpb3VzVG91Y2gxXG4gICAgdGhpcy5hbmNob3JfID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChcbiAgICAgIG1hcC5nZXRFdmVudFBpeGVsKGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRoaXMudGFyZ2V0UG9pbnRlcnMpKSxcbiAgICApO1xuXG4gICAgLy8gcm90YXRlXG4gICAgaWYgKHRoaXMucm90YXRpbmdfKSB7XG4gICAgICBtYXAucmVuZGVyKCk7XG4gICAgICB2aWV3LmFkanVzdFJvdGF0aW9uSW50ZXJuYWwocm90YXRpb25EZWx0YSwgdGhpcy5hbmNob3JfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB2aWV3LmVuZEludGVyYWN0aW9uKHRoaXMuZHVyYXRpb25fKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID49IDIpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuICAgICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yb3RhdGluZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMucm90YXRpb25EZWx0YV8gPSAwLjA7XG4gICAgICBpZiAoIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgICBtYXAuZ2V0VmlldygpLmJlZ2luSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGluY2hSb3RhdGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUGluY2hab29tXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtcbiAgY2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnMsXG59IGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249NDAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBwaW5jaGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgUGluY2hab29tIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBzdXBlcihwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiA0MDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHNjYWxlRGVsdGEgPSAxLjA7XG5cbiAgICBjb25zdCB0b3VjaDAgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzBdO1xuICAgIGNvbnN0IHRvdWNoMSA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMV07XG4gICAgY29uc3QgZHggPSB0b3VjaDAuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYO1xuICAgIGNvbnN0IGR5ID0gdG91Y2gwLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdG91Y2hlc1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgIGlmICh0aGlzLmxhc3REaXN0YW5jZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NhbGVEZWx0YSA9IHRoaXMubGFzdERpc3RhbmNlXyAvIGRpc3RhbmNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSBkaXN0YW5jZTtcblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG5cbiAgICBpZiAoc2NhbGVEZWx0YSAhPSAxLjApIHtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gc2NhbGVEZWx0YTtcbiAgICB9XG5cbiAgICAvLyBzY2FsZSBhbmNob3IgcG9pbnQuXG4gICAgdGhpcy5hbmNob3JfID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChcbiAgICAgIG1hcC5nZXRFdmVudFBpeGVsKGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRoaXMudGFyZ2V0UG9pbnRlcnMpKSxcbiAgICApO1xuXG4gICAgLy8gc2NhbGUsIGJ5cGFzcyB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50XG4gICAgbWFwLnJlbmRlcigpO1xuICAgIHZpZXcuYWRqdXN0UmVzb2x1dGlvbkludGVybmFsKHNjYWxlRGVsdGEsIHRoaXMuYW5jaG9yXyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxhc3RTY2FsZURlbHRhXyA+IDEgPyAxIDogLTE7XG4gICAgICB2aWV3LmVuZEludGVyYWN0aW9uKHRoaXMuZHVyYXRpb25fLCBkaXJlY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gICAgICBpZiAoIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgICBtYXAuZ2V0VmlldygpLmJlZ2luSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGluY2hab29tO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BvaW50ZXJcbiAqL1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZURvd25FdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZG93blwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIHRoZW4gYSBkcmFnXG4gKiBzZXF1ZW5jZSBpcyBzdGFydGVkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW2hhbmRsZURyYWdFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZHJhZ1wiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzXG4gKiBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZUV2ZW50XVxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIFRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCB0aGVcbiAqIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9uc1xuICogY2hhaW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbaGFuZGxlTW92ZUV2ZW50XVxuICogRnVuY3Rpb24gaGFuZGxpbmcgXCJtb3ZlXCIgZXZlbnRzLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBcIm1vdmVcIiBldmVudHMuXG4gKiBUaGlzIGZ1bmN0aW9ucyBpcyBhbHNvIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLCBzbyBkdXJpbmcgYSBkcmFnXG4gKiBzZXF1ZW5jZSBib3RoIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCBmdW5jdGlvbiBhbmQgdGhpcyBmdW5jdGlvbiBhcmUgY2FsbGVkLlxuICogSWYgYGhhbmRsZURvd25FdmVudGAgaXMgZGVmaW5lZCBhbmQgaXQgcmV0dXJucyB0cnVlIHRoaXMgZnVuY3Rpb24gd2lsbCBub3RcbiAqIGJlIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZVVwRXZlbnRdXG4gKiAgRnVuY3Rpb24gaGFuZGxpbmcgXCJ1cFwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGVuIHRoZVxuICogY3VycmVudCBkcmFnIHNlcXVlbmNlIGlzIHN0b3BwZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOmJvb2xlYW59IFtzdG9wRG93bl1cbiAqIFNob3VsZCB0aGUgZG93biBldmVudCBiZSBwcm9wYWdhdGVkIHRvIG90aGVyIGludGVyYWN0aW9ucywgb3Igc2hvdWxkIGJlXG4gKiBzdG9wcGVkP1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyB0aGF0IGNhbGxzIHVzZXItZGVmaW5lZCBmdW5jdGlvbnMgb24gYGRvd25gLCBgbW92ZWAgYW5kIGB1cGBcbiAqIGV2ZW50cy4gVGhpcyBjbGFzcyBhbHNvIG1hbmFnZXMgXCJkcmFnIHNlcXVlbmNlc1wiLlxuICpcbiAqIFdoZW4gdGhlIGBoYW5kbGVEb3duRXZlbnRgIHVzZXIgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgYSBkcmFnIHNlcXVlbmNlIGlzXG4gKiBzdGFydGVkLiBEdXJpbmcgYSBkcmFnIHNlcXVlbmNlIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCB1c2VyIGZ1bmN0aW9uIGlzXG4gKiBjYWxsZWQgb24gYG1vdmVgIGV2ZW50cy4gVGhlIGRyYWcgc2VxdWVuY2UgZW5kcyB3aGVuIHRoZSBgaGFuZGxlVXBFdmVudGBcbiAqIHVzZXIgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBvaW50ZXJJbnRlcmFjdGlvbiBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIChvcHRpb25zKSxcbiAgICApO1xuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRG93bkV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZURvd25FdmVudCA9IG9wdGlvbnMuaGFuZGxlRG93bkV2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZURyYWdFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVEcmFnRXZlbnQgPSBvcHRpb25zLmhhbmRsZURyYWdFdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVNb3ZlRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50ID0gb3B0aW9ucy5oYW5kbGVNb3ZlRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlVXBFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVVcEV2ZW50ID0gb3B0aW9ucy5oYW5kbGVVcEV2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICB0aGlzLnN0b3BEb3duID0gb3B0aW9ucy5zdG9wRG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9pbnRlckV2ZW50Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQb2ludGVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBvaW50ZXJzIGludm9sdmVkIGluIHRoZSBpbnRlcmFjdGlvbixcbiAgICogZS5nLiBgMmAgd2hlbiB0d28gZmluZ2VycyBhcmUgdXNlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBvaW50ZXJzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQb2ludGVyQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge31cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IGNhbGwgaW50b1xuICAgKiBvdGhlciBmdW5jdGlvbnMsIGlmIGV2ZW50IHNlcXVlbmNlcyBsaWtlIGUuZy4gJ2RyYWcnIG9yICdkb3duLXVwJyBldGMuIGFyZVxuICAgKiBkZXRlY3RlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVUcmFja2VkUG9pbnRlcnNfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgaWYgKHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgICAgLy8gcHJldmVudCBwYWdlIHNjcm9sbGluZyBkdXJpbmcgZHJhZ2dpbmdcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVApIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZFVwID0gdGhpcy5oYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSA9XG4gICAgICAgICAgaGFuZGxlZFVwICYmIHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04pIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZCA9IHRoaXMuaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSA9IGhhbmRsZWQ7XG4gICAgICAgIHN0b3BFdmVudCA9IHRoaXMuc3RvcERvd24oaGFuZGxlZCk7XG4gICAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgbW92ZSBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlTW92ZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge31cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgXCJkb3duXCIgZXZlbnRzIHNob3VsZCBiZSBwcm9wYWdhdGVkXG4gICAqIHRvIG90aGVyIGludGVyYWN0aW9ucyBvciBzaG91bGQgYmUgc3RvcHBlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBoYW5kbGVkIFdhcyB0aGUgZXZlbnQgaGFuZGxlZCBieSB0aGUgaW50ZXJhY3Rpb24/XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFNob3VsZCB0aGUgYGRvd25gIGV2ZW50IGJlIHN0b3BwZWQ/XG4gICAqL1xuICBzdG9wRG93bihoYW5kbGVkKSB7XG4gICAgcmV0dXJuIGhhbmRsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlVHJhY2tlZFBvaW50ZXJzXyhtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAobWFwQnJvd3NlckV2ZW50LmFjdGl2ZVBvaW50ZXJzKSB7XG4gICAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gbWFwQnJvd3NlckV2ZW50LmFjdGl2ZVBvaW50ZXJzO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnRlckV2ZW50Pn0gcG9pbnRlckV2ZW50cyBMaXN0IG9mIGV2ZW50cy5cbiAqIEByZXR1cm4ge3tjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn19IENlbnRyb2lkIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VudHJvaWQocG9pbnRlckV2ZW50cykge1xuICBjb25zdCBsZW5ndGggPSBwb2ludGVyRXZlbnRzLmxlbmd0aDtcbiAgbGV0IGNsaWVudFggPSAwO1xuICBsZXQgY2xpZW50WSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjbGllbnRYICs9IHBvaW50ZXJFdmVudHNbaV0uY2xpZW50WDtcbiAgICBjbGllbnRZICs9IHBvaW50ZXJFdmVudHNbaV0uY2xpZW50WTtcbiAgfVxuICByZXR1cm4ge2NsaWVudFg6IGNsaWVudFggLyBsZW5ndGgsIGNsaWVudFk6IGNsaWVudFkgLyBsZW5ndGh9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBQb2ludGVySW50ZXJhY3Rpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQUNUSVZFOiAnYWN0aXZlJyxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vZGVmYXVsdHNcbiAqL1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgRG91YmxlQ2xpY2tab29tIGZyb20gJy4vRG91YmxlQ2xpY2tab29tLmpzJztcbmltcG9ydCBEcmFnUGFuIGZyb20gJy4vRHJhZ1Bhbi5qcyc7XG5pbXBvcnQgRHJhZ1JvdGF0ZSBmcm9tICcuL0RyYWdSb3RhdGUuanMnO1xuaW1wb3J0IERyYWdab29tIGZyb20gJy4vRHJhZ1pvb20uanMnO1xuaW1wb3J0IEtleWJvYXJkUGFuIGZyb20gJy4vS2V5Ym9hcmRQYW4uanMnO1xuaW1wb3J0IEtleWJvYXJkWm9vbSBmcm9tICcuL0tleWJvYXJkWm9vbS5qcyc7XG5pbXBvcnQgS2luZXRpYyBmcm9tICcuLi9LaW5ldGljLmpzJztcbmltcG9ydCBNb3VzZVdoZWVsWm9vbSBmcm9tICcuL01vdXNlV2hlZWxab29tLmpzJztcbmltcG9ydCBQaW5jaFJvdGF0ZSBmcm9tICcuL1BpbmNoUm90YXRlLmpzJztcbmltcG9ydCBQaW5jaFpvb20gZnJvbSAnLi9QaW5jaFpvb20uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRzT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbYWx0U2hpZnREcmFnUm90YXRlPXRydWVdIFdoZXRoZXIgQWx0LVNoaWZ0LWRyYWcgcm90YXRlIGlzXG4gKiBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25Gb2N1c09ubHk9ZmFsc2VdIEludGVyYWN0IG9ubHkgd2hlbiB0aGUgbWFwIGhhcyB0aGVcbiAqIGZvY3VzLiBUaGlzIGFmZmVjdHMgdGhlIGBNb3VzZVdoZWVsWm9vbWAgYW5kIGBEcmFnUGFuYCBpbnRlcmFjdGlvbnMgYW5kIGlzXG4gKiB1c2VmdWwgd2hlbiBwYWdlIHNjcm9sbCBpcyBkZXNpcmVkIGZvciBtYXBzIHRoYXQgZG8gbm90IGhhdmUgdGhlIGJyb3dzZXInc1xuICogZm9jdXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb3VibGVDbGlja1pvb209dHJ1ZV0gV2hldGhlciBkb3VibGUgY2xpY2sgem9vbSBpc1xuICogZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tleWJvYXJkPXRydWVdIFdoZXRoZXIga2V5Ym9hcmQgaW50ZXJhY3Rpb24gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21vdXNlV2hlZWxab29tPXRydWVdIFdoZXRoZXIgbW91c2V3aGVlbCB6b29tIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaGlmdERyYWdab29tPXRydWVdIFdoZXRoZXIgU2hpZnQtZHJhZyB6b29tIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkcmFnUGFuPXRydWVdIFdoZXRoZXIgZHJhZyBwYW4gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BpbmNoUm90YXRlPXRydWVdIFdoZXRoZXIgcGluY2ggcm90YXRlIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwaW5jaFpvb209dHJ1ZV0gV2hldGhlciBwaW5jaCB6b29tIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21EZWx0YV0gWm9vbSBsZXZlbCBkZWx0YSB3aGVuIHVzaW5nIGtleWJvYXJkIG9yIGRvdWJsZSBjbGljayB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tRHVyYXRpb25dIER1cmF0aW9uIG9mIHRoZSB6b29tIGFuaW1hdGlvbiBpblxuICogbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogU2V0IG9mIGludGVyYWN0aW9ucyBpbmNsdWRlZCBpbiBtYXBzIGJ5IGRlZmF1bHQuIFNwZWNpZmljIGludGVyYWN0aW9ucyBjYW4gYmVcbiAqIGV4Y2x1ZGVkIGJ5IHNldHRpbmcgdGhlIGFwcHJvcHJpYXRlIG9wdGlvbiB0byBmYWxzZSBpbiB0aGUgY29uc3RydWN0b3JcbiAqIG9wdGlvbnMsIGJ1dCB0aGUgb3JkZXIgb2YgdGhlIGludGVyYWN0aW9ucyBpcyBmaXhlZC4gIElmIHlvdSB3YW50IHRvIHNwZWNpZnlcbiAqIGEgZGlmZmVyZW50IG9yZGVyIGZvciBpbnRlcmFjdGlvbnMsIHlvdSB3aWxsIG5lZWQgdG8gY3JlYXRlIHlvdXIgb3duXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9ufkludGVyYWN0aW9ufSBpbnN0YW5jZXMgYW5kIGluc2VydFxuICogdGhlbSBpbnRvIGEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IGluIHRoZSBvcmRlciB5b3Ugd2FudFxuICogYmVmb3JlIGNyZWF0aW5nIHlvdXIge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfSBpbnN0YW5jZS4gQ2hhbmdpbmcgdGhlIG9yZGVyIGNhblxuICogYmUgb2YgaW50ZXJlc3QgaWYgdGhlIGV2ZW50IHByb3BhZ2F0aW9uIG5lZWRzIHRvIGJlIHN0b3BwZWQgYXQgYSBwb2ludC5cbiAqIFRoZSBkZWZhdWx0IHNldCBvZiBpbnRlcmFjdGlvbnMsIGluIHNlcXVlbmNlLCBpczpcbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlfkRyYWdSb3RhdGV9XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tfkRvdWJsZUNsaWNrWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUGFufkRyYWdQYW59XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vUGluY2hSb3RhdGV+UGluY2hSb3RhdGV9XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vUGluY2hab29tflBpbmNoWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFBhbn5LZXlib2FyZFBhbn1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tfk1vdXNlV2hlZWxab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdab29tfkRyYWdab29tfVxuICpcbiAqIEBwYXJhbSB7RGVmYXVsdHNPcHRpb25zfSBbb3B0aW9uc10gRGVmYXVsdHMgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqIEEgY29sbGVjdGlvbiBvZiBpbnRlcmFjdGlvbnMgdG8gYmUgdXNlZCB3aXRoIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9XG4gKiBjb25zdHJ1Y3RvcidzIGBpbnRlcmFjdGlvbnNgIG9wdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59ICovXG4gIGNvbnN0IGludGVyYWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgY29uc3Qga2luZXRpYyA9IG5ldyBLaW5ldGljKC0wLjAwNSwgMC4wNSwgMTAwKTtcblxuICBjb25zdCBhbHRTaGlmdERyYWdSb3RhdGUgPVxuICAgIG9wdGlvbnMuYWx0U2hpZnREcmFnUm90YXRlICE9PSB1bmRlZmluZWRcbiAgICAgID8gb3B0aW9ucy5hbHRTaGlmdERyYWdSb3RhdGVcbiAgICAgIDogdHJ1ZTtcbiAgaWYgKGFsdFNoaWZ0RHJhZ1JvdGF0ZSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBEcmFnUm90YXRlKCkpO1xuICB9XG5cbiAgY29uc3QgZG91YmxlQ2xpY2tab29tID1cbiAgICBvcHRpb25zLmRvdWJsZUNsaWNrWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kb3VibGVDbGlja1pvb20gOiB0cnVlO1xuICBpZiAoZG91YmxlQ2xpY2tab29tKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2goXG4gICAgICBuZXcgRG91YmxlQ2xpY2tab29tKHtcbiAgICAgICAgZGVsdGE6IG9wdGlvbnMuem9vbURlbHRhLFxuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb24sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgZHJhZ1BhbiA9IG9wdGlvbnMuZHJhZ1BhbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kcmFnUGFuIDogdHJ1ZTtcbiAgaWYgKGRyYWdQYW4pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBEcmFnUGFuKHtcbiAgICAgICAgb25Gb2N1c09ubHk6IG9wdGlvbnMub25Gb2N1c09ubHksXG4gICAgICAgIGtpbmV0aWM6IGtpbmV0aWMsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgcGluY2hSb3RhdGUgPVxuICAgIG9wdGlvbnMucGluY2hSb3RhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGluY2hSb3RhdGUgOiB0cnVlO1xuICBpZiAocGluY2hSb3RhdGUpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgUGluY2hSb3RhdGUoKSk7XG4gIH1cblxuICBjb25zdCBwaW5jaFpvb20gPSBvcHRpb25zLnBpbmNoWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waW5jaFpvb20gOiB0cnVlO1xuICBpZiAocGluY2hab29tKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2goXG4gICAgICBuZXcgUGluY2hab29tKHtcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGtleWJvYXJkID0gb3B0aW9ucy5rZXlib2FyZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlib2FyZCA6IHRydWU7XG4gIGlmIChrZXlib2FyZCkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBLZXlib2FyZFBhbigpKTtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBLZXlib2FyZFpvb20oe1xuICAgICAgICBkZWx0YTogb3B0aW9ucy56b29tRGVsdGEsXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBtb3VzZVdoZWVsWm9vbSA9XG4gICAgb3B0aW9ucy5tb3VzZVdoZWVsWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3VzZVdoZWVsWm9vbSA6IHRydWU7XG4gIGlmIChtb3VzZVdoZWVsWm9vbSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKFxuICAgICAgbmV3IE1vdXNlV2hlZWxab29tKHtcbiAgICAgICAgb25Gb2N1c09ubHk6IG9wdGlvbnMub25Gb2N1c09ubHksXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBzaGlmdERyYWdab29tID1cbiAgICBvcHRpb25zLnNoaWZ0RHJhZ1pvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2hpZnREcmFnWm9vbSA6IHRydWU7XG4gIGlmIChzaGlmdERyYWdab29tKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2goXG4gICAgICBuZXcgRHJhZ1pvb20oe1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb24sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGludGVyYWN0aW9ucztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgTGF5ZXJQcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQSBjc3MgY29sb3IsIG9yIGEgZnVuY3Rpb24gY2FsbGVkIHdpdGggYSB2aWV3IHJlc29sdXRpb24gcmV0dXJuaW5nIGEgY3NzIGNvbG9yLlxuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd8ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmd9IEJhY2tncm91bmRDb2xvclxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmV4dGVudCd8J2NoYW5nZTptYXhSZXNvbHV0aW9uJ3wnY2hhbmdlOm1heFpvb20nfFxuICogICAgJ2NoYW5nZTptaW5SZXNvbHV0aW9uJ3wnY2hhbmdlOm1pblpvb20nfCdjaGFuZ2U6b3BhY2l0eSd8J2NoYW5nZTp2aXNpYmxlJ3wnY2hhbmdlOnpJbmRleCd9IEJhc2VMYXllck9iamVjdEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxCYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfEJhc2VMYXllck9iamVjdEV2ZW50VHlwZXMsIFJldHVybj59IEJhc2VMYXllck9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbGF5ZXInXSBBIENTUyBjbGFzcyBuYW1lIHRvIHNldCB0byB0aGUgbGF5ZXIgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXIgfCB1bmRlZmluZWR9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtCYWNrZ3JvdW5kQ29sb3J9IFtiYWNrZ3JvdW5kXSBCYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgbGF5ZXIuIElmIG5vdCBzcGVjaWZpZWQsIG5vIGJhY2tncm91bmRcbiAqIHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSBbcHJvcGVydGllc10gQXJiaXRyYXJ5IG9ic2VydmFibGUgcHJvcGVydGllcy4gQ2FuIGJlIGFjY2Vzc2VkIHdpdGggYCNnZXQoKWAgYW5kIGAjc2V0KClgLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTm90ZSB0aGF0IHdpdGgge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfkJhc2VMYXllcn0gYW5kIGFsbCBpdHMgc3ViY2xhc3NlcywgYW55IHByb3BlcnR5IHNldCBpblxuICogdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH0gcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdCwgc29cbiAqIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBCYXNlTGF5ZXIgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBMYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZUxheWVyT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYWNrZ3JvdW5kQ29sb3J8ZmFsc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJhY2tncm91bmRfID0gb3B0aW9ucy5iYWNrZ3JvdW5kO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvcGVydGllcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLnByb3BlcnRpZXM7XG4gICAgICBPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIG9wdGlvbnMucHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk9QQUNJVFldID1cbiAgICAgIG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFjaXR5IDogMTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2YgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk9QQUNJVFldID09PSAnbnVtYmVyJyxcbiAgICAgICdMYXllciBvcGFjaXR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICk7XG5cbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuVklTSUJMRV0gPVxuICAgICAgb3B0aW9ucy52aXNpYmxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZpc2libGUgOiB0cnVlO1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5aX0lOREVYXSA9IG9wdGlvbnMuekluZGV4O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTl0gPVxuICAgICAgb3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFJlc29sdXRpb24gOiBJbmZpbml0eTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUlOX1JFU09MVVRJT05dID1cbiAgICAgIG9wdGlvbnMubWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5SZXNvbHV0aW9uIDogMDtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUlOX1pPT01dID1cbiAgICAgIG9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5ab29tIDogLUluZmluaXR5O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfWk9PTV0gPVxuICAgICAgb3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFpvb20gOiBJbmZpbml0eTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNsYXNzTmFtZV8gPVxuICAgICAgcHJvcGVydGllcy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IHByb3BlcnRpZXMuY2xhc3NOYW1lIDogJ29sLWxheWVyJztcbiAgICBkZWxldGUgcHJvcGVydGllcy5jbGFzc05hbWU7XG5cbiAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgZm9yIHRoaXMgbGF5ZXIuXG4gICAqIEByZXR1cm4ge0JhY2tncm91bmRDb2xvcnxmYWxzZX0gTGF5ZXIgYmFja2dyb3VuZC5cbiAgICovXG4gIGdldEJhY2tncm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBDU1MgY2xhc3MgbmFtZS5cbiAgICovXG4gIGdldENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc05hbWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBtZWFudCB0byBiZSBjYWxsZWQgYnkgbGF5ZXJzIG9yIGxheWVyIHJlbmRlcmVycyBiZWNhdXNlIHRoZSBzdGF0ZVxuICAgKiBpcyBpbmNvcnJlY3QgaWYgdGhlIGxheWVyIGlzIGluY2x1ZGVkIGluIGEgbGF5ZXIgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbmFnZWRdIExheWVyIGlzIG1hbmFnZWQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGV9IExheWVyIHN0YXRlLlxuICAgKi9cbiAgZ2V0TGF5ZXJTdGF0ZShtYW5hZ2VkKSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfSAqL1xuICAgIGNvbnN0IHN0YXRlID1cbiAgICAgIHRoaXMuc3RhdGVfIHx8XG4gICAgICAvKiogQHR5cGUgez99ICovICh7XG4gICAgICAgIGxheWVyOiB0aGlzLFxuICAgICAgICBtYW5hZ2VkOiBtYW5hZ2VkID09PSB1bmRlZmluZWQgPyB0cnVlIDogbWFuYWdlZCxcbiAgICAgIH0pO1xuICAgIGNvbnN0IHpJbmRleCA9IHRoaXMuZ2V0WkluZGV4KCk7XG4gICAgc3RhdGUub3BhY2l0eSA9IGNsYW1wKE1hdGgucm91bmQodGhpcy5nZXRPcGFjaXR5KCkgKiAxMDApIC8gMTAwLCAwLCAxKTtcbiAgICBzdGF0ZS52aXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlKCk7XG4gICAgc3RhdGUuZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBzdGF0ZS56SW5kZXggPSB6SW5kZXggPT09IHVuZGVmaW5lZCAmJiAhc3RhdGUubWFuYWdlZCA/IEluZmluaXR5IDogekluZGV4O1xuICAgIHN0YXRlLm1heFJlc29sdXRpb24gPSB0aGlzLmdldE1heFJlc29sdXRpb24oKTtcbiAgICBzdGF0ZS5taW5SZXNvbHV0aW9uID0gTWF0aC5tYXgodGhpcy5nZXRNaW5SZXNvbHV0aW9uKCksIDApO1xuICAgIHN0YXRlLm1pblpvb20gPSB0aGlzLmdldE1pblpvb20oKTtcbiAgICBzdGF0ZS5tYXhab29tID0gdGhpcy5nZXRNYXhab29tKCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBbYXJyYXldIEFycmF5IG9mIGxheWVycyAodG8gYmVcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gQXJyYXkgb2YgbGF5ZXJzLlxuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gW3N0YXRlc10gT3B0aW9uYWwgbGlzdCBvZiBsYXllclxuICAgKiAgICAgc3RhdGVzICh0byBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+fSBMaXN0IG9mIGxheWVyIHN0YXRlcy5cbiAgICovXG4gIGdldExheWVyU3RhdGVzQXJyYXkoc3RhdGVzKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQgZXh0ZW50fSBvZiB0aGUgbGF5ZXIgb3IgYHVuZGVmaW5lZGAgaWYgaXRcbiAgICogd2lsbCBiZSB2aXNpYmxlIHJlZ2FyZGxlc3Mgb2YgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH0gVGhlIGxheWVyIGV4dGVudC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChMYXllclByb3BlcnR5LkVYVEVOVClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci4gUmV0dXJucyBJbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1heGltdW0gcmVzb2x1dGlvbiBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci4gUmV0dXJucyAwIGlmXG4gICAqIHRoZSBsYXllciBoYXMgbm8gbWluaW11bSByZXNvbHV0aW9uIHNldC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluUmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIGxheWVyLiBSZXR1cm5zIC1JbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1pbmltdW0gem9vbSBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fWk9PTSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBsYXllci4gUmV0dXJucyBJbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1heGltdW0gem9vbSBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfWk9PTSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIgKGJldHdlZW4gMCBhbmQgMSkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcGFjaXR5KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuT1BBQ0lUWSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLlN0YXRlfSBTb3VyY2Ugc3RhdGUuXG4gICAqL1xuICBnZXRTb3VyY2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgbGF5ZXIncyBgdmlzaWJsZWAgcHJvcGVydHkuIFRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIGxheWVyXG4gICAqIGlzIHZpc2libGUgb24gYSBtYXAsIHVzZSBgaXNWaXNpYmxlKClgIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2YWx1ZSBvZiB0aGUgYHZpc2libGVgIHByb3BlcnR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VmlzaWJsZSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlXG4gICAqIHJlbmRlcmluZy4gUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGxheWVyIGlzIHVubWFuYWdlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIFotaW5kZXggb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaSW5kZXgoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAqIEBwYXJhbSB7QmFja2dyb3VuZENvbG9yfSBbYmFja2dyb3VuZF0gQmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIHNldEJhY2tncm91bmQoYmFja2dyb3VuZCkge1xuICAgIHRoaXMuYmFja2dyb3VuZF8gPSBiYWNrZ3JvdW5kO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXh0ZW50IGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLiAgSWYgYHVuZGVmaW5lZGAsIHRoZSBsYXllclxuICAgKiB3aWxsIGJlIHZpc2libGUgYXQgYWxsIGV4dGVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IGV4dGVudCBUaGUgZXh0ZW50IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RXh0ZW50KGV4dGVudCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuRVhURU5ULCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBUaGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4UmVzb2x1dGlvbihtYXhSZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTiwgbWF4UmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaW5SZXNvbHV0aW9uKG1pblJlc29sdXRpb24pIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OLCBtaW5SZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSAoZXhjbHVzaXZlKSBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICogTm90ZSB0aGF0IHRoZSB6b29tIGxldmVscyBmb3IgbGF5ZXIgdmlzaWJpbGl0eSBhcmUgYmFzZWQgb24gdGhlXG4gICAqIHZpZXcgem9vbSBsZXZlbCwgd2hpY2ggbWF5IGJlIGRpZmZlcmVudCBmcm9tIGEgdGlsZSBzb3VyY2Ugem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFpvb20gVGhlIG1heGltdW0gem9vbSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1heFpvb20obWF4Wm9vbSkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUFYX1pPT00sIG1heFpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWluaW11bSB6b29tIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBOb3RlIHRoYXQgdGhlIHpvb20gbGV2ZWxzIGZvciBsYXllciB2aXNpYmlsaXR5IGFyZSBiYXNlZCBvbiB0aGVcbiAgICogdmlldyB6b29tIGxldmVsLCB3aGljaCBtYXkgYmUgZGlmZmVyZW50IGZyb20gYSB0aWxlIHNvdXJjZSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWm9vbSBUaGUgbWluaW11bSB6b29tIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWluWm9vbShtaW5ab29tKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fWk9PTSwgbWluWm9vbSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllciwgYWxsb3dlZCB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IFRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJywgJ0xheWVyIG9wYWNpdHkgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuT1BBQ0lUWSwgb3BhY2l0eSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllciAoYHRydWVgIG9yIGBmYWxzZWApLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRWaXNpYmxlKHZpc2libGUpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlZJU0lCTEUsIHZpc2libGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlIHJlbmRlcmluZy5cbiAgICogVGhlIGRlZmF1bHQgWi1pbmRleCBpcyAwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gemluZGV4IFRoZSB6LWluZGV4IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0WkluZGV4KHppbmRleCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCwgemluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVfKSB7XG4gICAgICB0aGlzLnN0YXRlXy5sYXllciA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRlXyA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VMYXllcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlVGlsZVxuICovXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgVGlsZVByb3BlcnR5IGZyb20gJy4vVGlsZVByb3BlcnR5LmpzJztcblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9CYXNlXCIpLkJhc2VMYXllck9iamVjdEV2ZW50VHlwZXN8XG4gKiAgICAgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5MYXllckV2ZW50VHlwZXwnY2hhbmdlOnByZWxvYWQnfCdjaGFuZ2U6dXNlSW50ZXJpbVRpbGVzT25FcnJvcicsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5MYXllclJlbmRlckV2ZW50VHlwZXMsIGltcG9ydChcIi4uL3JlbmRlci9FdmVudFwiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3xcbiAqICAgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5MYXllckV2ZW50VHlwZXwnY2hhbmdlOnByZWxvYWQnfCdjaGFuZ2U6dXNlSW50ZXJpbVRpbGVzT25FcnJvcid8aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5MYXllclJlbmRlckV2ZW50VHlwZXMsIFJldHVybj59IEJhc2VUaWxlTGF5ZXJPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlU291cmNlVHlwZVxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWxheWVyJ10gQSBDU1MgY2xhc3MgbmFtZSB0byBzZXQgdG8gdGhlIGxheWVyIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbV0gVGhlIG1pbmltdW0gdmlldyB6b29tIGxldmVsIChleGNsdXNpdmUpIGFib3ZlIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gVGhlIG1heGltdW0gdmlldyB6b29tIGxldmVsIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcHJlbG9hZD0wXSBQcmVsb2FkLiBMb2FkIGxvdy1yZXNvbHV0aW9uIHRpbGVzIHVwIHRvIGBwcmVsb2FkYCBsZXZlbHMuIGAwYFxuICogbWVhbnMgbm8gcHJlbG9hZGluZy5cbiAqIEBwcm9wZXJ0eSB7VGlsZVNvdXJjZVR5cGV9IFtzb3VyY2VdIFNvdXJjZSBmb3IgdGhpcyBsYXllci5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IFttYXBdIFNldHMgdGhlIGxheWVyIGFzIG92ZXJsYXkgb24gYSBtYXAuIFRoZSBtYXAgd2lsbCBub3QgbWFuYWdlXG4gKiB0aGlzIGxheWVyIGluIGl0cyBsYXllcnMgY29sbGVjdGlvbiwgYW5kIHRoZSBsYXllciB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiB0ZW1wb3JhcnkgbGF5ZXJzLiBUaGUgc3RhbmRhcmQgd2F5IHRvIGFkZCBhIGxheWVyIHRvIGEgbWFwIGFuZCBoYXZlIGl0IG1hbmFnZWQgYnkgdGhlIG1hcCBpcyB0b1xuICogdXNlIHtAbGluayBpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdCNhZGRMYXllciBtYXAuYWRkTGF5ZXIoKX0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5CYWNrZ3JvdW5kQ29sb3J9IFtiYWNrZ3JvdW5kXSBCYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgbGF5ZXIuIElmIG5vdCBzcGVjaWZpZWQsIG5vIGJhY2tncm91bmRcbiAqIHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VJbnRlcmltVGlsZXNPbkVycm9yPXRydWVdIERlcHJlY2F0ZWQuICBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZT01MTJdIFRoZSBpbnRlcm5hbCB0aWxlIGNhY2hlIHNpemUuICBUaGlzIG5lZWRzIHRvIGJlIGxhcmdlIGVub3VnaCB0byByZW5kZXJcbiAqIHR3byB6b29tIGxldmVscyB3b3J0aCBvZiB0aWxlcy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZvciBsYXllciBzb3VyY2VzIHRoYXQgcHJvdmlkZSBwcmUtcmVuZGVyZWQsIHRpbGVkIGltYWdlcyBpbiBncmlkcyB0aGF0IGFyZVxuICogb3JnYW5pemVkIGJ5IHpvb20gbGV2ZWxzIGZvciBzcGVjaWZpYyByZXNvbHV0aW9ucy5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IFRpbGVTb3VyY2VUeXBlXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3JlbmRlcmVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IFJlbmRlcmVyVHlwZVxuICogQGV4dGVuZHMge0xheWVyPFRpbGVTb3VyY2VUeXBlLCBSZW5kZXJlclR5cGU+fVxuICogQGFwaVxuICovXG5jbGFzcyBCYXNlVGlsZUxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zPFRpbGVTb3VyY2VUeXBlPn0gW29wdGlvbnNdIFRpbGUgbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBjYWNoZVNpemUgPSBvcHRpb25zLmNhY2hlU2l6ZTtcbiAgICBkZWxldGUgb3B0aW9ucy5jYWNoZVNpemU7XG5cbiAgICBkZWxldGUgYmFzZU9wdGlvbnMucHJlbG9hZDtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXNlSW50ZXJpbVRpbGVzT25FcnJvcjtcbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VUaWxlTGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtCYXNlVGlsZUxheWVyT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtCYXNlVGlsZUxheWVyT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYWNoZVNpemVfID0gY2FjaGVTaXplO1xuXG4gICAgdGhpcy5zZXRQcmVsb2FkKG9wdGlvbnMucHJlbG9hZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wcmVsb2FkIDogMCk7XG4gICAgdGhpcy5zZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKFxuICAgICAgb3B0aW9ucy51c2VJbnRlcmltVGlsZXNPbkVycm9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3JcbiAgICAgICAgOiB0cnVlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIHN1Z2dlc3RlZCBjYWNoZSBzaXplXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldENhY2hlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGV2ZWwgYXMgbnVtYmVyIHRvIHdoaWNoIHdlIHdpbGwgcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGV2ZWwgdG8gcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJlbG9hZCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChUaWxlUHJvcGVydHkuUFJFTE9BRCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGV2ZWwgYXMgbnVtYmVyIHRvIHdoaWNoIHdlIHdpbGwgcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWxvYWQgVGhlIGxldmVsIHRvIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFByZWxvYWQocHJlbG9hZCkge1xuICAgIHRoaXMuc2V0KFRpbGVQcm9wZXJ0eS5QUkVMT0FELCBwcmVsb2FkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiAgV2hldGhlciB3ZSB1c2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFVzZUludGVyaW1UaWxlc09uRXJyb3IoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKFxuICAgICAgdGhpcy5nZXQoVGlsZVByb3BlcnR5LlVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZC4gIFNldCB3aGV0aGVyIHdlIHVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUludGVyaW1UaWxlc09uRXJyb3IgVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFVzZUludGVyaW1UaWxlc09uRXJyb3IodXNlSW50ZXJpbVRpbGVzT25FcnJvcikge1xuICAgIHRoaXMuc2V0KFRpbGVQcm9wZXJ0eS5VU0VfSU5URVJJTV9USUxFU19PTl9FUlJPUiwgdXNlSW50ZXJpbVRpbGVzT25FcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhdGEgZm9yIGEgcGl4ZWwgbG9jYXRpb24uICBUaGUgcmV0dXJuIHR5cGUgZGVwZW5kcyBvbiB0aGUgc291cmNlIGRhdGEuICBGb3IgaW1hZ2UgdGlsZXMsXG4gICAqIGEgZm91ciBlbGVtZW50IFJHQkEgYXJyYXkgd2lsbCBiZSByZXR1cm5lZC4gIEZvciBkYXRhIHRpbGVzLCB0aGUgYXJyYXkgbGVuZ3RoIHdpbGwgbWF0Y2ggdGhlXG4gICAqIG51bWJlciBvZiBiYW5kcyBpbiB0aGUgZGF0YXNldC4gIEZvciByZXF1ZXN0cyBvdXRzaWRlIHRoZSBsYXllciBleHRlbnQsIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBEYXRhIGZvciBhIGltYWdlIHRpbGVzIGNhbiBvbmx5IGJlIHJldHJpZXZlZCBpZiB0aGUgc291cmNlJ3MgYGNyb3NzT3JpZ2luYCBwcm9wZXJ0eSBpcyBzZXQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGRpc3BsYXkgbGF5ZXIgZGF0YSBvbiBldmVyeSBwb2ludGVyIG1vdmVcbiAgICogbWFwLm9uKCdwb2ludGVybW92ZScsIChldmVudCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGxheWVyLmdldERhdGEoZXZlbnQucGl4ZWwpKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheXxGbG9hdDMyQXJyYXl8RGF0YVZpZXd8bnVsbH0gUGl4ZWwgZGF0YS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RGF0YShwaXhlbCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVRpbGVMYXllcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlVmVjdG9yXG4gKi9cbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBSQnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQgU3R5bGUsIHtcbiAgY3JlYXRlRGVmYXVsdFN0eWxlLFxuICB0b0Z1bmN0aW9uIGFzIHRvU3R5bGVGdW5jdGlvbixcbn0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuaW1wb3J0IHtcbiAgZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbixcbiAgcnVsZXNUb1N0eWxlRnVuY3Rpb24sXG59IGZyb20gJy4uL3JlbmRlci9jYW52YXMvc3R5bGUuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge1QgZXh0ZW5kcyBpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHQ8aW5mZXIgVSBleHRlbmRzIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2U+ID8gVSA6IG5ldmVyfSBFeHRyYWN0ZWRGZWF0dXJlVHlwZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4uL0ZlYXR1cmUnKS5GZWF0dXJlTGlrZX0gRmVhdHVyZVR5cGVcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0PEZlYXR1cmVUeXBlPnxpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0PEZlYXR1cmVUeXBlPn0gVmVjdG9yU291cmNlVHlwZTxGZWF0dXJlVHlwZT5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1sYXllciddIEEgQ1NTIGNsYXNzIG5hbWUgdG8gc2V0IHRvIHRoZSBsYXllciBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIFRoZSBtaW5pbXVtIHZpZXcgem9vbSBsZXZlbCAoZXhjbHVzaXZlKSBhYm92ZSB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIFRoZSBtYXhpbXVtIHZpZXcgem9vbSBsZXZlbCAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufSBbcmVuZGVyT3JkZXJdIFJlbmRlciBvcmRlci4gRnVuY3Rpb24gdG8gYmUgdXNlZCB3aGVuIHNvcnRpbmdcbiAqIGZlYXR1cmVzIGJlZm9yZSByZW5kZXJpbmcuIEJ5IGRlZmF1bHQgZmVhdHVyZXMgYXJlIGRyYXduIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXJlIGNyZWF0ZWQuIFVzZVxuICogYG51bGxgIHRvIGF2b2lkIHRoZSBzb3J0LCBidXQgZ2V0IGFuIHVuZGVmaW5lZCBkcmF3IG9yZGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZW5kZXJCdWZmZXI9MTAwXSBUaGUgYnVmZmVyIGluIHBpeGVscyBhcm91bmQgdGhlIHZpZXdwb3J0IGV4dGVudCB1c2VkIGJ5IHRoZVxuICogcmVuZGVyZXIgd2hlbiBnZXR0aW5nIGZlYXR1cmVzIGZyb20gdGhlIHZlY3RvciBzb3VyY2UgZm9yIHRoZSByZW5kZXJpbmcgb3IgaGl0LWRldGVjdGlvbi5cbiAqIFJlY29tbWVuZGVkIHZhbHVlOiB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBzeW1ib2wsIGxpbmUgd2lkdGggb3IgbGFiZWwuXG4gKiBAcHJvcGVydHkge1ZlY3RvclNvdXJjZVR5cGV9IFtzb3VyY2VdIFNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IFttYXBdIFNldHMgdGhlIGxheWVyIGFzIG92ZXJsYXkgb24gYSBtYXAuIFRoZSBtYXAgd2lsbCBub3QgbWFuYWdlXG4gKiB0aGlzIGxheWVyIGluIGl0cyBsYXllcnMgY29sbGVjdGlvbiwgYW5kIHRoZSBsYXllciB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiB0ZW1wb3JhcnkgbGF5ZXJzLiBUaGUgc3RhbmRhcmQgd2F5IHRvIGFkZCBhIGxheWVyIHRvIGEgbWFwIGFuZCBoYXZlIGl0IG1hbmFnZWQgYnkgdGhlIG1hcCBpcyB0b1xuICogdXNlIFttYXAuYWRkTGF5ZXIoKV17QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHQjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufHN0cmluZ3xudW1iZXJ9IFtkZWNsdXR0ZXI9ZmFsc2VdIERlY2x1dHRlciBpbWFnZXMgYW5kIHRleHQuIEFueSB0cnV0aHkgdmFsdWUgd2lsbCBlbmFibGVcbiAqIGRlY2x1dHRlcmluZy4gV2l0aGluIGEgbGF5ZXIsIGEgZmVhdHVyZSByZW5kZXJlZCBiZWZvcmUgYW5vdGhlciBoYXMgaGlnaGVyIHByaW9yaXR5LiBBbGwgbGF5ZXJzIHdpdGggdGhlXG4gKiBzYW1lIGBkZWNsdXR0ZXJgIHZhbHVlIHdpbGwgYmUgZGVjbHV0dGVyZWQgdG9nZXRoZXIuIFRoZSBwcmlvcml0eSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBkcmF3aW5nIG9yZGVyIG9mIHRoZVxuICogbGF5ZXJzIHdpdGggdGhlIHNhbWUgYGRlY2x1dHRlcmAgdmFsdWUuIEhpZ2hlciBpbiB0aGUgbGF5ZXIgc3RhY2sgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBUbyBkZWNsdXR0ZXIgZGlzdGluY3RcbiAqIGxheWVycyBvciBncm91cHMgb2YgbGF5ZXJzIHNlcGFyYXRlbHksIHVzZSBkaWZmZXJlbnQgdHJ1dGh5IHZhbHVlcyBmb3IgYGRlY2x1dHRlcmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZXxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZUxpa2V8bnVsbH0gW3N0eWxlXSBMYXllciBzdHlsZS4gV2hlbiBzZXQgdG8gYG51bGxgLCBvbmx5XG4gKiBmZWF0dXJlcyB0aGF0IGhhdmUgdGhlaXIgb3duIHN0eWxlIHdpbGwgYmUgcmVuZGVyZWQuIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlfSBmb3IgdGhlIGRlZmF1bHQgc3R5bGVcbiAqIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGlzIG5vdCBzZXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5CYWNrZ3JvdW5kQ29sb3J9IFtiYWNrZ3JvdW5kXSBCYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgbGF5ZXIuIElmIG5vdCBzcGVjaWZpZWQsIG5vIGJhY2tncm91bmRcbiAqIHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUFuaW1hdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLCBmZWF0dXJlIGJhdGNoZXMgd2lsbFxuICogYmUgcmVjcmVhdGVkIGR1cmluZyBhbmltYXRpb25zLiBUaGlzIG1lYW5zIHRoYXQgbm8gdmVjdG9ycyB3aWxsIGJlIHNob3duIGNsaXBwZWQsIGJ1dCB0aGVcbiAqIHNldHRpbmcgd2lsbCBoYXZlIGEgcGVyZm9ybWFuY2UgaW1wYWN0IGZvciBsYXJnZSBhbW91bnRzIG9mIHZlY3RvciBkYXRhLiBXaGVuIHNldCB0byBgZmFsc2VgLFxuICogYmF0Y2hlcyB3aWxsIGJlIHJlY3JlYXRlZCB3aGVuIG5vIGFuaW1hdGlvbiBpcyBhY3RpdmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUludGVyYWN0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAsIGZlYXR1cmUgYmF0Y2hlcyB3aWxsXG4gKiBiZSByZWNyZWF0ZWQgZHVyaW5nIGludGVyYWN0aW9ucy4gU2VlIGFsc28gYHVwZGF0ZVdoaWxlQW5pbWF0aW5nYC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgUHJvcGVydHkgPSB7XG4gIFJFTkRFUl9PUkRFUjogJ3JlbmRlck9yZGVyJyxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVmVjdG9yIGRhdGEgdGhhdCBpcyByZW5kZXJlZCBjbGllbnQtc2lkZS5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi4vRmVhdHVyZScpLkZlYXR1cmVMaWtlfSBGZWF0dXJlVHlwZVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHQ8RmVhdHVyZVR5cGU+fGltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHQ8RmVhdHVyZVR5cGU+fSBWZWN0b3JTb3VyY2VUeXBlPEZlYXR1cmVUeXBlPlxuICogQGV4dGVuZHMge0xheWVyPFZlY3RvclNvdXJjZVR5cGUsIFJlbmRlcmVyVHlwZT59XG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllci5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JUaWxlTGF5ZXIuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXJlci9jYW52YXMvVmVjdG9ySW1hZ2VMYXllci5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlcmVyL3dlYmdsL1BvaW50c0xheWVyLmpzXCIpLmRlZmF1bHR9IFJlbmRlcmVyVHlwZVxuICogQGFwaVxuICovXG5jbGFzcyBCYXNlVmVjdG9yTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM8RmVhdHVyZVR5cGUsIFZlY3RvclNvdXJjZVR5cGU+fSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICBkZWxldGUgYmFzZU9wdGlvbnMuc3R5bGU7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnJlbmRlckJ1ZmZlcjtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXBkYXRlV2hpbGVBbmltYXRpbmc7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc7XG4gICAgc3VwZXIoYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyXyA9IG9wdGlvbnMuZGVjbHV0dGVyID8gU3RyaW5nKG9wdGlvbnMuZGVjbHV0dGVyKSA6IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckJ1ZmZlcl8gPVxuICAgICAgb3B0aW9ucy5yZW5kZXJCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyQnVmZmVyIDogMTAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlciBwcm92aWRlZCBzdHlsZS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfGltcG9ydChcIi4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlTGlrZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFN0eWxlIGZ1bmN0aW9uIGZvciB1c2Ugd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGVGdW5jdGlvbl8gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnNldFN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZVdoaWxlQW5pbWF0aW5nXyA9XG4gICAgICBvcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlV2hpbGVJbnRlcmFjdGluZ18gPVxuICAgICAgb3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdcbiAgICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IERlY2x1dHRlciBncm91cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXREZWNsdXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbHV0dGVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvcG1vc3QgZmVhdHVyZSB0aGF0IGludGVyc2VjdHMgdGhlIGdpdmVuIHBpeGVsIG9uIHRoZSB2aWV3cG9ydC4gUmV0dXJucyBhIHByb21pc2VcbiAgICogdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGZlYXR1cmVzLiBUaGUgYXJyYXkgd2lsbCBlaXRoZXIgY29udGFpbiB0aGUgdG9wbW9zdCBmZWF0dXJlXG4gICAqIHdoZW4gYSBoaXQgd2FzIGRldGVjdGVkLCBvciBpdCB3aWxsIGJlIGVtcHR5LlxuICAgKlxuICAgKiBUaGUgaGl0IGRldGVjdGlvbiBhbGdvcml0aG0gdXNlZCBmb3IgdGhpcyBtZXRob2QgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSwgYnV0IGlzIGxlc3NcbiAgICogYWNjdXJhdGUgdGhhbiB0aGUgb25lIHVzZWQgaW4gW21hcC5nZXRGZWF0dXJlc0F0UGl4ZWwoKV17QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHQjZ2V0RmVhdHVyZXNBdFBpeGVsfS5cbiAgICogVGV4dCBpcyBub3QgY29uc2lkZXJlZCwgYW5kIGljb25zIGFyZSBvbmx5IHJlcHJlc2VudGVkIGJ5IHRoZWlyIGJvdW5kaW5nIGJveCBpbnN0ZWFkIG9mIHRoZSBleGFjdFxuICAgKiBpbWFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZVwiKS5GZWF0dXJlTGlrZT4+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBmZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEZlYXR1cmVzKHBpeGVsKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldEZlYXR1cmVzKHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZW5kZXIgYnVmZmVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlckJ1ZmZlcl87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpOiBudW1iZXJ8bnVsbHx1bmRlZmluZWR9IFJlbmRlclxuICAgKiAgICAgb3JkZXIuXG4gICAqL1xuICBnZXRSZW5kZXJPcmRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoUHJvcGVydHkuUkVOREVSX09SREVSKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBmb3IgZmVhdHVyZXMuICBUaGlzIHJldHVybnMgd2hhdGV2ZXIgd2FzIHBhc3NlZCB0byB0aGUgYHN0eWxlYFxuICAgKiBvcHRpb24gYXQgY29uc3RydWN0aW9uIG9yIHRvIHRoZSBgc2V0U3R5bGVgIG1ldGhvZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfGltcG9ydChcIi4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlTGlrZXxudWxsfHVuZGVmaW5lZH0gTGF5ZXIgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gTGF5ZXIgc3R5bGUgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0eWxlRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVGdW5jdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyZWQgbGF5ZXIgc2hvdWxkIGJlIHVwZGF0ZWQgd2hpbGVcbiAgICogICAgIGFuaW1hdGluZy5cbiAgICovXG4gIGdldFVwZGF0ZVdoaWxlQW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdoaWxlQW5pbWF0aW5nXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBsYXllciBzaG91bGQgYmUgdXBkYXRlZCB3aGlsZVxuICAgKiAgICAgaW50ZXJhY3RpbmcuXG4gICAqL1xuICBnZXRVcGRhdGVXaGlsZUludGVyYWN0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBkZWNsdXR0ZXIgaXRlbXMgZm9yIHRoaXMgbGF5ZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXJEZWNsdXR0ZXIoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIGNvbnN0IGRlY2x1dHRlckdyb3VwID0gdGhpcy5nZXREZWNsdXR0ZXIoKTtcbiAgICBpZiAoZGVjbHV0dGVyR3JvdXAgaW4gZnJhbWVTdGF0ZS5kZWNsdXR0ZXIgPT09IGZhbHNlKSB7XG4gICAgICBmcmFtZVN0YXRlLmRlY2x1dHRlcltkZWNsdXR0ZXJHcm91cF0gPSBuZXcgUkJ1c2goOSk7XG4gICAgfVxuICAgIHRoaXMuZ2V0UmVuZGVyZXIoKS5yZW5kZXJEZWNsdXR0ZXIoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH0gcmVuZGVyT3JkZXJcbiAgICogICAgIFJlbmRlciBvcmRlci5cbiAgICovXG4gIHNldFJlbmRlck9yZGVyKHJlbmRlck9yZGVyKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuUkVOREVSX09SREVSLCByZW5kZXJPcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHlsZSBmb3IgZmVhdHVyZXMuICBUaGlzIGNhbiBiZSBhIHNpbmdsZSBzdHlsZSBvYmplY3QsIGFuIGFycmF5XG4gICAqIG9mIHN0eWxlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZmVhdHVyZSBhbmQgcmVzb2x1dGlvbiBhbmQgcmV0dXJuc1xuICAgKiBhbiBhcnJheSBvZiBzdHlsZXMuIElmIHNldCB0byBgbnVsbGAsIHRoZSBsYXllciBoYXMgbm8gc3R5bGUgKGEgYG51bGxgIHN0eWxlKSxcbiAgICogc28gb25seSBmZWF0dXJlcyB0aGF0IGhhdmUgdGhlaXIgb3duIHN0eWxlcyB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBsYXllci4gQ2FsbFxuICAgKiBgc2V0U3R5bGUoKWAgd2l0aG91dCBhcmd1bWVudHMgdG8gcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3R5bGUuIFNlZVxuICAgKiBbdGhlIG9sL3N0eWxlL1N0eWxlIG1vZHVsZV17QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlfSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIGRlZmF1bHQgc3R5bGUuXG4gICAqXG4gICAqIElmIHlvdXIgbGF5ZXIgaGFzIGEgc3RhdGljIHN0eWxlLCB5b3UgY2FuIHVzZSBbZmxhdCBzdHlsZV17QGxpbmsgbW9kdWxlOm9sL3N0eWxlL2ZsYXR+RmxhdFN0eWxlfSBvYmplY3RcbiAgICogbGl0ZXJhbHMgaW5zdGVhZCBvZiB1c2luZyB0aGUgYFN0eWxlYCBhbmQgc3ltYm9saXplciBjb25zdHJ1Y3RvcnMgKGBGaWxsYCwgYFN0cm9rZWAsIGV0Yy4pOlxuICAgKiBgYGBqc1xuICAgKiB2ZWN0b3JMYXllci5zZXRTdHlsZSh7XG4gICAqICAgXCJmaWxsLWNvbG9yXCI6IFwieWVsbG93XCIsXG4gICAqICAgXCJzdHJva2UtY29sb3JcIjogXCJibGFja1wiLFxuICAgKiAgIFwic3Ryb2tlLXdpZHRoXCI6IDRcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfGltcG9ydChcIi4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlTGlrZXxudWxsfSBbc3R5bGVdIExheWVyIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuc3R5bGVfID0gc3R5bGUgPT09IHVuZGVmaW5lZCA/IGNyZWF0ZURlZmF1bHRTdHlsZSA6IHN0eWxlO1xuICAgIGNvbnN0IHN0eWxlTGlrZSA9IHRvU3R5bGVMaWtlKHN0eWxlKTtcbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID1cbiAgICAgIHN0eWxlID09PSBudWxsID8gdW5kZWZpbmVkIDogdG9TdHlsZUZ1bmN0aW9uKHN0eWxlTGlrZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ3xudW1iZXJ9IGRlY2x1dHRlciBEZWNsdXR0ZXIgaW1hZ2VzIGFuZCB0ZXh0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXREZWNsdXR0ZXIoZGVjbHV0dGVyKSB7XG4gICAgdGhpcy5kZWNsdXR0ZXJfID0gZGVjbHV0dGVyID8gU3RyaW5nKGRlY2x1dHRlcikgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2VyY2UgdGhlIGFsbG93ZWQgc3R5bGUgdHlwZXMgaW50byBhIHNob3J0ZXIgbGlzdCBvZiB0eXBlcy4gIEZsYXQgc3R5bGVzLCBhcnJheXMgb2YgZmxhdFxuICogc3R5bGVzLCBhbmQgYXJyYXlzIG9mIHJ1bGVzIGFyZSBjb252ZXJ0ZWQgaW50byBzdHlsZSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGVMaWtlfG51bGx9IFtzdHlsZV0gTGF5ZXIgc3R5bGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8bnVsbH0gVGhlIHN0eWxlLlxuICovXG5mdW5jdGlvbiB0b1N0eWxlTGlrZShzdHlsZSkge1xuICBpZiAoc3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVEZWZhdWx0U3R5bGU7XG4gIH1cbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgaWYgKHN0eWxlIGluc3RhbmNlb2YgU3R5bGUpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgIHJldHVybiBmbGF0U3R5bGVzVG9TdHlsZUZ1bmN0aW9uKFtzdHlsZV0pO1xuICB9XG4gIGlmIChzdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBzdHlsZS5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gc3R5bGVbMF07XG5cbiAgaWYgKGZpcnN0IGluc3RhbmNlb2YgU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgICAqL1xuICAgIGNvbnN0IHN0eWxlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHN0eWxlW2ldO1xuICAgICAgaWYgKCEoY2FuZGlkYXRlIGluc3RhbmNlb2YgU3R5bGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBsaXN0IG9mIHN0eWxlIGluc3RhbmNlcycpO1xuICAgICAgfVxuICAgICAgc3R5bGVzW2ldID0gY2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG5cbiAgaWYgKCdzdHlsZScgaW4gZmlyc3QpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSBBcnJheTxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLlJ1bGU+XG4gICAgICovXG4gICAgY29uc3QgcnVsZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBzdHlsZVtpXTtcbiAgICAgIGlmICghKCdzdHlsZScgaW4gY2FuZGlkYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgbGlzdCBvZiBydWxlcyB3aXRoIGEgc3R5bGUgcHJvcGVydHknKTtcbiAgICAgIH1cbiAgICAgIHJ1bGVzW2ldID0gY2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZXNUb1N0eWxlRnVuY3Rpb24ocnVsZXMpO1xuICB9XG5cbiAgY29uc3QgZmxhdFN0eWxlcyA9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZT59ICovIChzdHlsZSk7XG4gIHJldHVybiBmbGF0U3R5bGVzVG9TdHlsZUZ1bmN0aW9uKGZsYXRTdHlsZXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlVmVjdG9yTGF5ZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvR3JvdXBcbiAqL1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuL0Jhc2UuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQge2dldEludGVyc2VjdGlvbn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYWRkbGF5ZXInfCdyZW1vdmVsYXllcid9IEdyb3VwRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGxheWVyIGdyb3VwIHRyaWdnZXJzICdhZGRsYXllcicgYW5kICdyZW1vdmVsYXllcicgZXZlbnRzIHdoZW4gbGF5ZXJzIGFyZSBhZGRlZCB0byBvciByZW1vdmVkIGZyb21cbiAqIHRoZSBncm91cCBvciBvbmUgb2YgaXRzIGNoaWxkIGdyb3Vwcy4gIFdoZW4gYSBsYXllciBncm91cCBpcyBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gYW5vdGhlciBsYXllciBncm91cCxcbiAqIGEgc2luZ2xlIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIChpbnN0ZWFkIG9mIG9uZSBwZXIgbGF5ZXIgaW4gdGhlIGdyb3VwIGFkZGVkIG9yIHJlbW92ZWQpLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7R3JvdXBFdmVudFR5cGV9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7QmFzZUxheWVyfSBsYXllciBUaGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBsYXllcikge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFkZGVkIG9yIHJlbW92ZWQgbGF5ZXIuXG4gICAgICogQHR5cGUge0Jhc2VMYXllcn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfFxuICogICAgICdjaGFuZ2U6bGF5ZXJzJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3wnY2hhbmdlOmxheWVycycsIFJldHVybj59IEdyb3VwT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IFtsYXllcnNdIENoaWxkIGxheWVycy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgUHJvcGVydHkgPSB7XG4gIExBWUVSUzogJ2xheWVycycsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IG9mIGxheWVycyB0aGF0IGFyZSBoYW5kbGVkIHRvZ2V0aGVyLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgZ3JvdXAvQ29sbGVjdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTGF5ZXJHcm91cCBleHRlbmRzIEJhc2VMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBMYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gLyoqIEB0eXBlIHtPcHRpb25zfSAqLyAoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5sYXllcnM7XG5cbiAgICBsZXQgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG5cbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0dyb3VwT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7R3JvdXBPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0dyb3VwT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT4+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJLZXlzXyA9IHt9O1xuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihQcm9wZXJ0eS5MQVlFUlMsIHRoaXMuaGFuZGxlTGF5ZXJzQ2hhbmdlZF8pO1xuXG4gICAgaWYgKGxheWVycykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGF5ZXJzKSkge1xuICAgICAgICBsYXllcnMgPSBuZXcgQ29sbGVjdGlvbihsYXllcnMuc2xpY2UoKSwge3VuaXF1ZTogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAobGF5ZXJzKS5nZXRBcnJheSkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICAgJ0V4cGVjdGVkIGBsYXllcnNgIHRvIGJlIGFuIGFycmF5IG9yIGEgYENvbGxlY3Rpb25gJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJzID0gbmV3IENvbGxlY3Rpb24odW5kZWZpbmVkLCB7dW5pcXVlOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRMYXllcnMobGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJDaGFuZ2VfKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllcnNDaGFuZ2VkXygpIHtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcblxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICBsaXN0ZW4obGF5ZXJzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgdGhpcy5oYW5kbGVMYXllcnNBZGRfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgICAgdGhpcy5oYW5kbGVMYXllcnNSZW1vdmVfLFxuICAgICAgICB0aGlzLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmxpc3RlbmVyS2V5c18pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJLZXlzX1tpZF0uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB9XG4gICAgY2xlYXIodGhpcy5saXN0ZW5lcktleXNfKTtcblxuICAgIGNvbnN0IGxheWVyc0FycmF5ID0gbGF5ZXJzLmdldEFycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNBcnJheVtpXTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMYXllckxpc3RlbmVyc18obGF5ZXIpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdhZGRsYXllcicsIGxheWVyKSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZUxheWVyfSBsYXllciBUaGUgbGF5ZXIuXG4gICAqL1xuICByZWdpc3RlckxheWVyTGlzdGVuZXJzXyhsYXllcikge1xuICAgIGNvbnN0IGxpc3RlbmVyS2V5cyA9IFtcbiAgICAgIGxpc3RlbihcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sXG4gICAgICAgIHRoaXMsXG4gICAgICApLFxuICAgICAgbGlzdGVuKGxheWVyLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyQ2hhbmdlXywgdGhpcyksXG4gICAgXTtcblxuICAgIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgIGxpc3RlbmVyS2V5cy5wdXNoKFxuICAgICAgICBsaXN0ZW4obGF5ZXIsICdhZGRsYXllcicsIHRoaXMuaGFuZGxlTGF5ZXJHcm91cEFkZF8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXIsICdyZW1vdmVsYXllcicsIHRoaXMuaGFuZGxlTGF5ZXJHcm91cFJlbW92ZV8sIHRoaXMpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyS2V5c19bZ2V0VWlkKGxheWVyKV0gPSBsaXN0ZW5lcktleXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtHcm91cEV2ZW50fSBldmVudCBUaGUgbGF5ZXIgZ3JvdXAgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVMYXllckdyb3VwQWRkXyhldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBFdmVudCgnYWRkbGF5ZXInLCBldmVudC5sYXllcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R3JvdXBFdmVudH0gZXZlbnQgVGhlIGxheWVyIGdyb3VwIGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlTGF5ZXJHcm91cFJlbW92ZV8oZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ3JlbW92ZWxheWVyJywgZXZlbnQubGF5ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc0FkZF8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSBjb2xsZWN0aW9uRXZlbnQuZWxlbWVudDtcbiAgICB0aGlzLnJlZ2lzdGVyTGF5ZXJMaXN0ZW5lcnNfKGxheWVyKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ2FkZGxheWVyJywgbGF5ZXIpKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc1JlbW92ZV8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSBjb2xsZWN0aW9uRXZlbnQuZWxlbWVudDtcbiAgICBjb25zdCBrZXkgPSBnZXRVaWQobGF5ZXIpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1trZXldLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgZGVsZXRlIHRoaXMubGlzdGVuZXJLZXlzX1trZXldO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBFdmVudCgncmVtb3ZlbGF5ZXInLCBsYXllcikpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcmV0dXJuIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXllcnMoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSAqLyAoXG4gICAgICB0aGlzLmdldChQcm9wZXJ0eS5MQVlFUlMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcGFyYW0geyFDb2xsZWN0aW9uPGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllcnMobGF5ZXJzKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMYXllcnMgPSBjb2xsZWN0aW9uLmdldEFycmF5KCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjdXJyZW50TGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdyZW1vdmVsYXllcicsIGN1cnJlbnRMYXllcnNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldChQcm9wZXJ0eS5MQVlFUlMsIGxheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBbYXJyYXldIEFycmF5IG9mIGxheWVycyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBBcnJheSBvZiBsYXllcnMuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheSA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheSA6IFtdO1xuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmdldExheWVyc0FycmF5KGFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciBzdGF0ZXMgbGlzdCBhbmQgdXNlIHRoaXMgZ3JvdXBzIHotaW5kZXggYXMgdGhlIGRlZmF1bHRcbiAgICogZm9yIGFsbCBsYXllcnMgaW4gdGhpcyBhbmQgbmVzdGVkIGdyb3VwcywgaWYgaXQgaXMgdW5zZXQgYXQgdGhpcyBwb2ludC5cbiAgICogSWYgZGVzdCBpcyBub3QgcHJvdmlkZWQgYW5kIHRoaXMgZ3JvdXAncyB6LWluZGV4IGlzIHVuZGVmaW5lZFxuICAgKiAwIGlzIHVzZWQgYSB0aGUgZGVmYXVsdCB6LWluZGV4LlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+fSBbZGVzdF0gT3B0aW9uYWwgbGlzdFxuICAgKiBvZiBsYXllciBzdGF0ZXMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IExpc3Qgb2YgbGF5ZXIgc3RhdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldExheWVyU3RhdGVzQXJyYXkoZGVzdCkge1xuICAgIGNvbnN0IHN0YXRlcyA9IGRlc3QgIT09IHVuZGVmaW5lZCA/IGRlc3QgOiBbXTtcbiAgICBjb25zdCBwb3MgPSBzdGF0ZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgbGF5ZXIuZ2V0TGF5ZXJTdGF0ZXNBcnJheShzdGF0ZXMpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb3duTGF5ZXJTdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZSgpO1xuICAgIGxldCBkZWZhdWx0WkluZGV4ID0gb3duTGF5ZXJTdGF0ZS56SW5kZXg7XG4gICAgaWYgKCFkZXN0ICYmIG93bkxheWVyU3RhdGUuekluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmF1bHRaSW5kZXggPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcG9zLCBpaSA9IHN0YXRlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllclN0YXRlID0gc3RhdGVzW2ldO1xuICAgICAgbGF5ZXJTdGF0ZS5vcGFjaXR5ICo9IG93bkxheWVyU3RhdGUub3BhY2l0eTtcbiAgICAgIGxheWVyU3RhdGUudmlzaWJsZSA9IGxheWVyU3RhdGUudmlzaWJsZSAmJiBvd25MYXllclN0YXRlLnZpc2libGU7XG4gICAgICBsYXllclN0YXRlLm1heFJlc29sdXRpb24gPSBNYXRoLm1pbihcbiAgICAgICAgbGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uLFxuICAgICAgICBvd25MYXllclN0YXRlLm1heFJlc29sdXRpb24sXG4gICAgICApO1xuICAgICAgbGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgIGxheWVyU3RhdGUubWluUmVzb2x1dGlvbixcbiAgICAgICAgb3duTGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uLFxuICAgICAgKTtcbiAgICAgIGxheWVyU3RhdGUubWluWm9vbSA9IE1hdGgubWF4KGxheWVyU3RhdGUubWluWm9vbSwgb3duTGF5ZXJTdGF0ZS5taW5ab29tKTtcbiAgICAgIGxheWVyU3RhdGUubWF4Wm9vbSA9IE1hdGgubWluKGxheWVyU3RhdGUubWF4Wm9vbSwgb3duTGF5ZXJTdGF0ZS5tYXhab29tKTtcbiAgICAgIGlmIChvd25MYXllclN0YXRlLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChsYXllclN0YXRlLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oXG4gICAgICAgICAgICBsYXllclN0YXRlLmV4dGVudCxcbiAgICAgICAgICAgIG93bkxheWVyU3RhdGUuZXh0ZW50LFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgPSBvd25MYXllclN0YXRlLmV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxheWVyU3RhdGUuekluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGF5ZXJTdGF0ZS56SW5kZXggPSBkZWZhdWx0WkluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5TdGF0ZX0gU291cmNlIHN0YXRlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNvdXJjZVN0YXRlKCkge1xuICAgIHJldHVybiAncmVhZHknO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyR3JvdXA7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvTGF5ZXJcbiAqL1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuL0Jhc2UuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBMYXllclByb3BlcnR5IGZyb20gJy4vUHJvcGVydHkuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBWaWV3IGZyb20gJy4uL1ZpZXcuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlKTpIVE1MRWxlbWVudH0gUmVuZGVyRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnc291cmNlcmVhZHknfCdjaGFuZ2U6c291cmNlJ30gTGF5ZXJFdmVudFR5cGVcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3xcbiAqICAgICBMYXllckV2ZW50VHlwZSwgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlXCIpLkxheWVyUmVuZGVyRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfExheWVyRXZlbnRUeXBlfFxuICogICAgIGltcG9ydChcIi4uL3JlbmRlci9FdmVudFR5cGVcIikuTGF5ZXJSZW5kZXJFdmVudFR5cGVzLCBSZXR1cm4+fSBMYXllck9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdH0gW1NvdXJjZVR5cGU9aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5kZWZhdWx0XVxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWxheWVyJ10gQSBDU1MgY2xhc3MgbmFtZSB0byBzZXQgdG8gdGhlIGxheWVyIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbV0gVGhlIG1pbmltdW0gdmlldyB6b29tIGxldmVsIChleGNsdXNpdmUpIGFib3ZlIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gVGhlIG1heGltdW0gdmlldyB6b29tIGxldmVsIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7U291cmNlVHlwZX0gW3NvdXJjZV0gU291cmNlIGZvciB0aGlzIGxheWVyLiAgSWYgbm90IHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvcixcbiAqIHRoZSBzb3VyY2UgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIjc2V0U291cmNlIGxheWVyLnNldFNvdXJjZShzb3VyY2UpfSBhZnRlclxuICogY29uc3RydWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBbbWFwXSBNYXAuXG4gKiBAcHJvcGVydHkge1JlbmRlckZ1bmN0aW9ufSBbcmVuZGVyXSBSZW5kZXIgZnVuY3Rpb24uIFRha2VzIHRoZSBmcmFtZSBzdGF0ZSBhcyBpbnB1dCBhbmQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuXG4gKiBIVE1MIGVsZW1lbnQuIFdpbGwgb3ZlcndyaXRlIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBmb3IgdGhlIGxheWVyLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCAqPn0gW3Byb3BlcnRpZXNdIEFyYml0cmFyeSBvYnNlcnZhYmxlIHByb3BlcnRpZXMuIENhbiBiZSBhY2Nlc3NlZCB3aXRoIGAjZ2V0KClgIGFuZCBgI3NldCgpYC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LCB0aGUgdmFsdWUgaXMgcm91bmRlZCB0byB0d28gZGlnaXRzIHRvIGFwcGVhciBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlzaWJsZSBWaXNpYmxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBtYW5hZ2VkIE1hbmFnZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6SW5kZXggWkluZGV4LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4aW11bSByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblJlc29sdXRpb24gTWluaW11bSByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblpvb20gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFpvb20gTWF4aW11bSB6b29tLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmcm9tIHdoaWNoIGFsbCBsYXllciB0eXBlcyBhcmUgZGVyaXZlZC4gVGhpcyBzaG91bGQgb25seSBiZSBpbnN0YW50aWF0ZWRcbiAqIGluIHRoZSBjYXNlIHdoZXJlIGEgY3VzdG9tIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAgd2l0aCBhIGN1c3RvbSBgcmVuZGVyYCBmdW5jdGlvbi5cbiAqIFN1Y2ggYSBmdW5jdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhbmQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBBIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiByYXN0ZXIgb3IgdmVjdG9yIG1hcCBkYXRhLlxuICogTGF5ZXJzIGdyb3VwIHRvZ2V0aGVyIHRob3NlIHByb3BlcnRpZXMgdGhhdCBwZXJ0YWluIHRvIGhvdyB0aGUgZGF0YSBpcyB0byBiZVxuICogZGlzcGxheWVkLCBpcnJlc3BlY3RpdmUgb2YgdGhlIHNvdXJjZSBvZiB0aGF0IGRhdGEuXG4gKlxuICogTGF5ZXJzIGFyZSB1c3VhbGx5IGFkZGVkIHRvIGEgbWFwIHdpdGggW21hcC5hZGRMYXllcigpXXtAbGluayBpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdCNhZGRMYXllcn0uXG4gKiBDb21wb25lbnRzIGxpa2Uge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fkRyYXd9IHVzZSB1bm1hbmFnZWQgbGF5ZXJzXG4gKiBpbnRlcm5hbGx5LiBUaGVzZSB1bm1hbmFnZWQgbGF5ZXJzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcCB1c2luZ1xuICogW2xheWVyLnNldE1hcCgpXXtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIjc2V0TWFwfSBpbnN0ZWFkLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlIGNoYW5nZXMuXG4gKiBBIGBzb3VyY2VyZWFkeWAgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgbGF5ZXIncyBzb3VyY2UgaXMgcmVhZHkuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4uL3JlbmRlci9FdmVudC5qc1wiKS5SZW5kZXJFdmVudCNwcmVyZW5kZXJcbiAqIEBmaXJlcyBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnQuanNcIikuUmVuZGVyRXZlbnQjcG9zdHJlbmRlclxuICogQGZpcmVzIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5CYXNlRXZlbnQjc291cmNlcmVhZHlcbiAqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdH0gW1NvdXJjZVR5cGU9aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5kZWZhdWx0XVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9yZW5kZXJlci9MYXllci5qc1wiKS5kZWZhdWx0fSBbUmVuZGVyZXJUeXBlPWltcG9ydChcIi4uL3JlbmRlcmVyL0xheWVyLmpzXCIpLmRlZmF1bHRdXG4gKiBAYXBpXG4gKi9cbmNsYXNzIExheWVyIGV4dGVuZHMgQmFzZUxheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uczxTb3VyY2VUeXBlPn0gb3B0aW9ucyBMYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnNvdXJjZTtcblxuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7TGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7TGF5ZXJPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLm1hcFJlbmRlcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JlbmRlcmVyVHlwZX1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlUmVhZHlfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gICAgLy8gT3ZlcndyaXRlIGRlZmF1bHQgcmVuZGVyIG1ldGhvZCB3aXRoIGEgY3VzdG9tIG9uZVxuICAgIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgICAgdGhpcy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tYXApIHtcbiAgICAgIHRoaXMuc2V0TWFwKG9wdGlvbnMubWFwKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKFxuICAgICAgTGF5ZXJQcm9wZXJ0eS5TT1VSQ0UsXG4gICAgICB0aGlzLmhhbmRsZVNvdXJjZVByb3BlcnR5Q2hhbmdlXyxcbiAgICApO1xuXG4gICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy5zb3VyY2VcbiAgICAgID8gLyoqIEB0eXBlIHtTb3VyY2VUeXBlfSAqLyAob3B0aW9ucy5zb3VyY2UpXG4gICAgICA6IG51bGw7XG4gICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IFthcnJheV0gQXJyYXkgb2YgbGF5ZXJzICh0byBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IEFycmF5IG9mIGxheWVycy5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRMYXllcnNBcnJheShhcnJheSkge1xuICAgIGFycmF5ID0gYXJyYXkgPyBhcnJheSA6IFtdO1xuICAgIGFycmF5LnB1c2godGhpcyk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IFtzdGF0ZXNdIE9wdGlvbmFsIGxpc3Qgb2YgbGF5ZXIgc3RhdGVzICh0byBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+fSBMaXN0IG9mIGxheWVyIHN0YXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRMYXllclN0YXRlc0FycmF5KHN0YXRlcykge1xuICAgIHN0YXRlcyA9IHN0YXRlcyA/IHN0YXRlcyA6IFtdO1xuICAgIHN0YXRlcy5wdXNoKHRoaXMuZ2V0TGF5ZXJTdGF0ZSgpKTtcbiAgICByZXR1cm4gc3RhdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXIgc291cmNlLlxuICAgKiBAcmV0dXJuIHtTb3VyY2VUeXBlfG51bGx9IFRoZSBsYXllciBzb3VyY2UgKG9yIGBudWxsYCBpZiBub3QgeWV0IHNldCkuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtTb3VyY2VUeXBlfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5TT1VSQ0UpKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1NvdXJjZVR5cGV8bnVsbH0gVGhlIHNvdXJjZSBiZWluZyByZW5kZXJlZC5cbiAgICovXG4gIGdldFJlbmRlclNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLlN0YXRlfSBTb3VyY2Ugc3RhdGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0U291cmNlU3RhdGUoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICByZXR1cm4gIXNvdXJjZSA/ICd1bmRlZmluZWQnIDogc291cmNlLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVNvdXJjZUNoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgaWYgKHRoaXMuc291cmNlUmVhZHlfIHx8IHRoaXMuZ2V0U291cmNlKCkuZ2V0U3RhdGUoKSAhPT0gJ3JlYWR5Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZVJlYWR5XyA9IHRydWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdzb3VyY2VyZWFkeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMuc291cmNlQ2hhbmdlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnNvdXJjZUNoYW5nZUtleV8pO1xuICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VSZWFkeV8gPSBmYWxzZTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IGxpc3RlbihcbiAgICAgICAgc291cmNlLFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVNvdXJjZUNoYW5nZV8sXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuICAgICAgaWYgKHNvdXJjZS5nZXRTdGF0ZSgpID09PSAncmVhZHknKSB7XG4gICAgICAgIHRoaXMuc291cmNlUmVhZHlfID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdzb3VyY2VyZWFkeScpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbFwiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZVwiKS5GZWF0dXJlTGlrZT4+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aFxuICAgKiBhbiBhcnJheSBvZiBmZWF0dXJlcy5cbiAgICovXG4gIGdldEZlYXR1cmVzKHBpeGVsKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5nZXRGZWF0dXJlcyhwaXhlbCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbFwiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fFVpbnQ4QXJyYXl8RmxvYXQzMkFycmF5fERhdGFWaWV3fG51bGx9IFBpeGVsIGRhdGEuXG4gICAqL1xuICBnZXREYXRhKHBpeGVsKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyXyB8fCAhdGhpcy5yZW5kZXJlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5nZXREYXRhKHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGF5ZXIgaXMgdmlzaWJsZSBvbiB0aGUgbWFwIHZpZXcsIGkuZS4gd2l0aGluIGl0cyBtaW4vbWF4IHJlc29sdXRpb24gb3Igem9vbSBhbmRcbiAgICogZXh0ZW50LCBub3Qgc2V0IHRvIGB2aXNpYmxlOiBmYWxzZWAsIGFuZCBub3QgaW5zaWRlIGEgbGF5ZXIgZ3JvdXAgdGhhdCBpcyBzZXRcbiAgICogdG8gYHZpc2libGU6IGZhbHNlYC5cbiAgICogQHBhcmFtIHtWaWV3fGltcG9ydChcIi4uL1ZpZXcuanNcIikuVmlld1N0YXRlTGF5ZXJTdGF0ZUV4dGVudH0gW3ZpZXddIFZpZXcgb3Ige0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfS5cbiAgICogT25seSByZXF1aXJlZCB3aGVuIHRoZSBsYXllciBpcyBub3QgYWRkZWQgdG8gYSBtYXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBsYXllciBpcyB2aXNpYmxlIGluIHRoZSBtYXAgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgaXNWaXNpYmxlKHZpZXcpIHtcbiAgICBsZXQgZnJhbWVTdGF0ZTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcEludGVybmFsKCk7XG4gICAgaWYgKCF2aWV3ICYmIG1hcCkge1xuICAgICAgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgfVxuICAgIGlmICh2aWV3IGluc3RhbmNlb2YgVmlldykge1xuICAgICAgZnJhbWVTdGF0ZSA9IHtcbiAgICAgICAgdmlld1N0YXRlOiB2aWV3LmdldFN0YXRlKCksXG4gICAgICAgIGV4dGVudDogdmlldy5jYWxjdWxhdGVFeHRlbnQoKSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lU3RhdGUgPSB2aWV3O1xuICAgIH1cbiAgICBpZiAoIWZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheSAmJiBtYXApIHtcbiAgICAgIGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheSA9IG1hcC5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJTdGF0ZXNBcnJheSgpO1xuICAgIH1cbiAgICBsZXQgbGF5ZXJTdGF0ZTtcbiAgICBpZiAoZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5KSB7XG4gICAgICBsYXllclN0YXRlID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5LmZpbmQoXG4gICAgICAgIChsYXllclN0YXRlKSA9PiBsYXllclN0YXRlLmxheWVyID09PSB0aGlzLFxuICAgICAgKTtcbiAgICAgIGlmICghbGF5ZXJTdGF0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyU3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllckV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgaW5WaWV3KGxheWVyU3RhdGUsIGZyYW1lU3RhdGUudmlld1N0YXRlKSAmJlxuICAgICAgKCFsYXllckV4dGVudCB8fCBpbnRlcnNlY3RzKGxheWVyRXh0ZW50LCBmcmFtZVN0YXRlLmV4dGVudCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF0dHJpYnV0aW9ucyBvZiB0aGUgc291cmNlIG9mIHRoaXMgbGF5ZXIgZm9yIHRoZSBnaXZlbiB2aWV3LlxuICAgKiBAcGFyYW0ge1ZpZXd8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBbdmlld10gVmlldyBvciB7QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LlxuICAgKiBPbmx5IHJlcXVpcmVkIHdoZW4gdGhlIGxheWVyIGlzIG5vdCBhZGRlZCB0byBhIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXR0cmlidXRpb25zIGZvciB0aGlzIGxheWVyIGF0IHRoZSBnaXZlbiB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBdHRyaWJ1dGlvbnModmlldykge1xuICAgIGlmICghdGhpcy5pc1Zpc2libGUodmlldykpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZ2V0QXR0cmlidXRpb25zID0gdGhpcy5nZXRTb3VyY2UoKT8uZ2V0QXR0cmlidXRpb25zKCk7XG4gICAgaWYgKCFnZXRBdHRyaWJ1dGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9XG4gICAgICB2aWV3IGluc3RhbmNlb2YgVmlldyA/IHZpZXcuZ2V0Vmlld1N0YXRlQW5kRXh0ZW50KCkgOiB2aWV3O1xuICAgIGxldCBhdHRyaWJ1dGlvbnMgPSBnZXRBdHRyaWJ1dGlvbnMoZnJhbWVTdGF0ZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9ucykpIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IFthdHRyaWJ1dGlvbnNdO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIGNoYXJnZSB0byBtYW5hZ2UgdGhlIHJlbmRlcmluZyBvZiB0aGUgbGF5ZXIuIE9uZSBsYXllciB0eXBlIGlzXG4gICAqIGJvdW5kZWQgd2l0aCBvbmUgbGF5ZXIgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IHdoaWNoIHRoZSByZW5kZXJlciBtYXkgKGJ1dCBuZWVkIG5vdCkgdXNlXG4gICAqIGZvciByZW5kZXJpbmcgaXRzIGNvbnRlbnQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyKGZyYW1lU3RhdGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGxheWVyUmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCk7XG5cbiAgICBpZiAobGF5ZXJSZW5kZXJlci5wcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSkpIHtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxheWVyUmVuZGVyZXIucmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBsYXllciBpcyBub3QgdmlzaWJsZSBkdXJpbmcgYSBtYXAgcmVuZGVyLlxuICAgKi9cbiAgdW5yZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge3N0cmluZ30gRGVjbHV0dGVyICovXG4gIGdldERlY2x1dHRlcigpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqL1xuICByZW5kZXJEZWNsdXR0ZXIoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge31cblxuICAvKipcbiAgICogV2hlbiB0aGUgcmVuZGVyZXIgZm9sbG93cyBhIGxheW91dCAtPiByZW5kZXIgYXBwcm9hY2gsIGRvIHRoZSBmaW5hbCByZW5kZXJpbmcgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL01hcC5qcycpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGVcbiAgICovXG4gIHJlbmRlckRlZmVycmVkKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBsYXllclJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgIGlmICghbGF5ZXJSZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXllclJlbmRlcmVyLnJlbmRlckRlZmVycmVkKGZyYW1lU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB1c2UgaW5zaWRlIHRoZSBsaWJyYXJ5IG9ubHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcEludGVybmFsKG1hcCkge1xuICAgIGlmICghbWFwKSB7XG4gICAgICB0aGlzLnVucmVuZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUFQLCBtYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB1c2UgaW5zaWRlIHRoZSBsaWJyYXJ5IG9ubHkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IE1hcC5cbiAgICovXG4gIGdldE1hcEludGVybmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdldChMYXllclByb3BlcnR5Lk1BUCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXIgdG8gYmUgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGxheWVycyBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsXG4gICAqIG5vdCBtYW5hZ2UgdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24uIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciB0ZW1wb3JhcnkgbGF5ZXJzLiBUbyByZW1vdmUgYW4gdW5tYW5hZ2VkIGxheWVyIGZyb20gdGhlIG1hcCxcbiAgICogdXNlIGAjc2V0TWFwKG51bGwpYC5cbiAgICpcbiAgICogVG8gYWRkIHRoZSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAsIHVzZVxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjYWRkTGF5ZXJ9IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcFByZWNvbXBvc2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubWFwUHJlY29tcG9zZUtleV8pO1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICghbWFwKSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwUmVuZGVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFJlbmRlcktleV8pO1xuICAgICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IGxpc3RlbihcbiAgICAgICAgbWFwLFxuICAgICAgICBSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSxcbiAgICAgICAgdGhpcy5oYW5kbGVQcmVjb21wb3NlXyxcbiAgICAgICAgdGhpcyxcbiAgICAgICk7XG4gICAgICB0aGlzLm1hcFJlbmRlcktleV8gPSBsaXN0ZW4odGhpcywgRXZlbnRUeXBlLkNIQU5HRSwgbWFwLnJlbmRlciwgbWFwKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSByZW5kZXJFdmVudCBSZW5kZXIgZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVByZWNvbXBvc2VfKHJlbmRlckV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZXNBcnJheSA9XG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9FdmVudC5qc1wiKS5kZWZhdWx0fSAqLyAocmVuZGVyRXZlbnQpXG4gICAgICAgIC5mcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZShmYWxzZSk7XG4gICAgYXNzZXJ0KFxuICAgICAgIWxheWVyU3RhdGVzQXJyYXkuc29tZShcbiAgICAgICAgKGFycmF5TGF5ZXJTdGF0ZSkgPT4gYXJyYXlMYXllclN0YXRlLmxheWVyID09PSBsYXllclN0YXRlLmxheWVyLFxuICAgICAgKSxcbiAgICAgICdBIGxheWVyIGNhbiBvbmx5IGJlIGFkZGVkIHRvIHRoZSBtYXAgb25jZS4gVXNlIGVpdGhlciBgbGF5ZXIuc2V0TWFwKClgIG9yIGBtYXAuYWRkTGF5ZXIoKWAsIG5vdCBib3RoLicsXG4gICAgKTtcbiAgICBsYXllclN0YXRlc0FycmF5LnB1c2gobGF5ZXJTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsYXllciBzb3VyY2UuXG4gICAqIEBwYXJhbSB7U291cmNlVHlwZXxudWxsfSBzb3VyY2UgVGhlIGxheWVyIHNvdXJjZS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U291cmNlKHNvdXJjZSkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuU09VUkNFLCBzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVuZGVyZXIgZm9yIHRoaXMgbGF5ZXIuXG4gICAqIEByZXR1cm4ge1JlbmRlcmVyVHlwZXxudWxsfSBUaGUgbGF5ZXIgcmVuZGVyZXIuXG4gICAqL1xuICBnZXRSZW5kZXJlcigpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXJfKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyXyA9IHRoaXMuY3JlYXRlUmVuZGVyZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBsYXllciBoYXMgYSByZW5kZXJlci5cbiAgICovXG4gIGhhc1JlbmRlcmVyKCkge1xuICAgIHJldHVybiAhIXRoaXMucmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlbmRlcmVyIGZvciB0aGlzIGxheWVyLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlclR5cGV9IEEgbGF5ZXIgcmVuZGVyZXIuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNyZWF0ZVJlbmRlcmVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBjbGVhciB0aGUgcmVuZGVyZXIgc28gdGhhdCBhIG5ldyBvbmUgY2FuIGJlIGNyZWF0ZWQgbmV4dCB0aW1lIGl0IGlzIG5lZWRlZFxuICAgKi9cbiAgY2xlYXJSZW5kZXJlcigpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcl8pIHtcbiAgICAgIHRoaXMucmVuZGVyZXJfLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyXztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMuY2xlYXJSZW5kZXJlcigpO1xuICAgIHRoaXMuc2V0U291cmNlKG51bGwpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgbGF5ZXIgaXMgdmlzaWJsZSBhbmQgaWYgdGhlIHByb3ZpZGVkIHZpZXcgc3RhdGVcbiAqIGhhcyByZXNvbHV0aW9uIGFuZCB6b29tIGxldmVscyB0aGF0IGFyZSBpbiByYW5nZSBvZiB0aGUgbGF5ZXIncyBtaW4vbWF4LlxuICogQHBhcmFtIHtTdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5TdGF0ZX0gdmlld1N0YXRlIFZpZXcgc3RhdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbGF5ZXIgaXMgdmlzaWJsZSBhdCB0aGUgZ2l2ZW4gdmlldyBzdGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluVmlldyhsYXllclN0YXRlLCB2aWV3U3RhdGUpIHtcbiAgaWYgKCFsYXllclN0YXRlLnZpc2libGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICBpZiAoXG4gICAgcmVzb2x1dGlvbiA8IGxheWVyU3RhdGUubWluUmVzb2x1dGlvbiB8fFxuICAgIHJlc29sdXRpb24gPj0gbGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB6b29tID0gdmlld1N0YXRlLnpvb207XG4gIHJldHVybiB6b29tID4gbGF5ZXJTdGF0ZS5taW5ab29tICYmIHpvb20gPD0gbGF5ZXJTdGF0ZS5tYXhab29tO1xufVxuXG5leHBvcnQgZGVmYXVsdCBMYXllcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9Qcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBPUEFDSVRZOiAnb3BhY2l0eScsXG4gIFZJU0lCTEU6ICd2aXNpYmxlJyxcbiAgRVhURU5UOiAnZXh0ZW50JyxcbiAgWl9JTkRFWDogJ3pJbmRleCcsXG4gIE1BWF9SRVNPTFVUSU9OOiAnbWF4UmVzb2x1dGlvbicsXG4gIE1JTl9SRVNPTFVUSU9OOiAnbWluUmVzb2x1dGlvbicsXG4gIE1BWF9aT09NOiAnbWF4Wm9vbScsXG4gIE1JTl9aT09NOiAnbWluWm9vbScsXG4gIFNPVVJDRTogJ3NvdXJjZScsXG4gIE1BUDogJ21hcCcsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1RpbGVcbiAqL1xuaW1wb3J0IEJhc2VUaWxlTGF5ZXIgZnJvbSAnLi9CYXNlVGlsZS5qcyc7XG5pbXBvcnQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgZnJvbSAnLi4vcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRm9yIGxheWVyIHNvdXJjZXMgdGhhdCBwcm92aWRlIHByZS1yZW5kZXJlZCwgdGlsZWQgaW1hZ2VzIGluIGdyaWRzIHRoYXQgYXJlXG4gKiBvcmdhbml6ZWQgYnkgem9vbSBsZXZlbHMgZm9yIHNwZWNpZmljIHJlc29sdXRpb25zLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gW1RpbGVTb3VyY2VUeXBlPWltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHRdXG4gKiBAZXh0ZW5kcyBCYXNlVGlsZUxheWVyPFRpbGVTb3VyY2VUeXBlLCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcj5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVGlsZUxheWVyIGV4dGVuZHMgQmFzZVRpbGVMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQmFzZVRpbGUuanNcIikuT3B0aW9uczxUaWxlU291cmNlVHlwZT59IFtvcHRpb25zXSBUaWxlIGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gbmV3IENhbnZhc1RpbGVMYXllclJlbmRlcmVyKHRoaXMsIHtcbiAgICAgIGNhY2hlU2l6ZTogdGhpcy5nZXRDYWNoZVNpemUoKSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlTGF5ZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVGlsZVByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSRUxPQUQ6ICdwcmVsb2FkJyxcbiAgVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1I6ICd1c2VJbnRlcmltVGlsZXNPbkVycm9yJyxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbWF0aFxuICovXG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgYW5kIGNsYW1wcyBpdCB0byB3aXRoaW4gdGhlIHByb3ZpZGVkIGJvdW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIHRvIHJldHVybi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGlucHV0IG51bWJlciBpZiBpdCBpcyB3aXRoaW4gYm91bmRzLCBvciB0aGUgbmVhcmVzdFxuICogICAgIG51bWJlciB3aXRoaW4gdGhlIGJvdW5kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50ICh4LCB5KSBhbmQgdGhlXG4gKiBsaW5lIHNlZ21lbnQgKHgxLCB5MSkgdG8gKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRTZWdtZW50RGlzdGFuY2UoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuICAgIGNvbnN0IHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgIHgxICs9IGR4ICogdDtcbiAgICAgIHkxICs9IGR5ICogdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZSh4LCB5LCB4MSwgeTEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vKipcbiAqIFNvbHZlcyBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyB1c2luZyBHYXVzc2lhbiBlbGltaW5hdGlvbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0IEF1Z21lbnRlZCBtYXRyaXggKG4geCBuICsgMSBjb2x1bW4pXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiByb3ctbWFqb3Igb3JkZXIuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFRoZSByZXN1bHRpbmcgdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29sdmVMaW5lYXJTeXN0ZW0obWF0KSB7XG4gIGNvbnN0IG4gPSBtYXQubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgLy8gRmluZCBtYXggaW4gdGhlIGktdGggY29sdW1uIChpZ25vcmluZyBpIC0gMSBmaXJzdCByb3dzKVxuICAgIGxldCBtYXhSb3cgPSBpO1xuICAgIGxldCBtYXhFbCA9IE1hdGguYWJzKG1hdFtpXVtpXSk7XG4gICAgZm9yIChsZXQgciA9IGkgKyAxOyByIDwgbjsgcisrKSB7XG4gICAgICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKG1hdFtyXVtpXSk7XG4gICAgICBpZiAoYWJzVmFsdWUgPiBtYXhFbCkge1xuICAgICAgICBtYXhFbCA9IGFic1ZhbHVlO1xuICAgICAgICBtYXhSb3cgPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhFbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG1hdHJpeCBpcyBzaW5ndWxhclxuICAgIH1cblxuICAgIC8vIFN3YXAgbWF4IHJvdyB3aXRoIGktdGggKGN1cnJlbnQpIHJvd1xuICAgIGNvbnN0IHRtcCA9IG1hdFttYXhSb3ddO1xuICAgIG1hdFttYXhSb3ddID0gbWF0W2ldO1xuICAgIG1hdFtpXSA9IHRtcDtcblxuICAgIC8vIFN1YnRyYWN0IHRoZSBpLXRoIHJvdyB0byBtYWtlIGFsbCB0aGUgcmVtYWluaW5nIHJvd3MgMCBpbiB0aGUgaS10aCBjb2x1bW5cbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgIGNvbnN0IGNvZWYgPSAtbWF0W2pdW2ldIC8gbWF0W2ldW2ldO1xuICAgICAgZm9yIChsZXQgayA9IGk7IGsgPCBuICsgMTsgaysrKSB7XG4gICAgICAgIGlmIChpID09IGspIHtcbiAgICAgICAgICBtYXRbal1ba10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdFtqXVtrXSArPSBjb2VmICogbWF0W2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU29sdmUgQXg9YiBmb3IgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggQSAobWF0KVxuICBjb25zdCB4ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKGxldCBsID0gbiAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgeFtsXSA9IG1hdFtsXVtuXSAvIG1hdFtsXVtsXTtcbiAgICBmb3IgKGxldCBtID0gbCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICBtYXRbbV1bbl0gLT0gbWF0W21dW2xdICogeFtsXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbi8qKlxuICogQ29udmVydHMgcmFkaWFucyB0byB0byBkZWdyZWVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiBkZWdyZWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKGFuZ2xlSW5SYWRpYW5zKSB7XG4gIHJldHVybiAoYW5nbGVJblJhZGlhbnMgKiAxODApIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5EZWdyZWVzIEFuZ2xlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIHJhZGlhbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoYW5nbGVJbkRlZ3JlZXMpIHtcbiAgcmV0dXJuIChhbmdsZUluRGVncmVlcyAqIE1hdGguUEkpIC8gMTgwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZHVsbyBvZiBhIC8gYiwgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIGIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgRGl2aWRlbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gYiBEaXZpc29yLlxuICogQHJldHVybiB7bnVtYmVyfSBNb2R1bG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2R1bG8oYSwgYikge1xuICBjb25zdCByID0gYSAlIGI7XG4gIHJldHVybiByICogYiA8IDAgPyByICsgYiA6IHI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGluZWFybHkgaW50ZXJwb2xhdGVkIHZhbHVlIG9mIHggYmV0d2VlbiBhIGFuZCBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0geCBWYWx1ZSB0byBiZSBpbnRlcnBvbGF0ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVycG9sYXRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoYSwgYiwgeCkge1xuICByZXR1cm4gYSArIHggKiAoYiAtIGEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2l0aCBhIGxpbWl0ZWQgbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgd2l0aCBhIGxpbWl0ZWQgbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GaXhlZChuLCBkZWNpbWFscykge1xuICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChuICogZmFjdG9yKSAvIGZhY3Rvcjtcbn1cblxuLyoqXG4gKiBSb3VuZHMgYSBudW1iZXIgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZSBjb25zaWRlcmluZyBvbmx5IHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGRlY2ltYWwgZGlnaXRzICh3aXRoIHJvdW5kaW5nIG9uIHRoZSBmaW5hbCBkaWdpdCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5lYXJlc3QgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG4sIGRlY2ltYWxzKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHRvRml4ZWQobiwgZGVjaW1hbHMpKTtcbn1cblxuLyoqXG4gKiBSb3VuZHMgYSBudW1iZXIgdG8gdGhlIG5leHQgc21hbGxlciBpbnRlZ2VyIGNvbnNpZGVyaW5nIG9ubHkgdGhlIGdpdmVuIG51bWJlclxuICogb2YgZGVjaW1hbCBkaWdpdHMgKHdpdGggcm91bmRpbmcgb24gdGhlIGZpbmFsIGRpZ2l0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBzbWFsbGVyIGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihuLCBkZWNpbWFscykge1xuICByZXR1cm4gTWF0aC5mbG9vcih0b0ZpeGVkKG4sIGRlY2ltYWxzKSk7XG59XG5cbi8qKlxuICogUm91bmRzIGEgbnVtYmVyIHRvIHRoZSBuZXh0IGJpZ2dlciBpbnRlZ2VyIGNvbnNpZGVyaW5nIG9ubHkgdGhlIGdpdmVuIG51bWJlclxuICogb2YgZGVjaW1hbCBkaWdpdHMgKHdpdGggcm91bmRpbmcgb24gdGhlIGZpbmFsIGRpZ2l0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBiaWdnZXIgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwobiwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0b0ZpeGVkKG4sIGRlY2ltYWxzKSk7XG59XG5cbi8qKlxuICogV3JhcHMgYSBudW1iZXIgYmV0d2VlbiBzb21lIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBvZiB0aGUgcmFuZ2UgKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIG9mIHRoZSByYW5nZSAoZXhjbHVzaXZlKS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdyYXBwZWQgbnVtYmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcChuLCBtaW4sIG1heCkge1xuICBpZiAobiA+PSBtaW4gJiYgbiA8IG1heCkge1xuICAgIHJldHVybiBuO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICByZXR1cm4gKCgoKG4gLSBtaW4pICUgcmFuZ2UpICsgcmFuZ2UpICUgcmFuZ2UpICsgbWluO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL29ialxuICovXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgdW5rbm93bj59IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIob2JqZWN0KSB7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhbnkgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBvYmplY3QgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuICBsZXQgcHJvcGVydHk7XG4gIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhcHJvcGVydHk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9FdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgZXZlbnQgbmFtZXMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBPSU5URVJNT1ZFOiAncG9pbnRlcm1vdmUnLFxuICBQT0lOVEVSRE9XTjogJ3BvaW50ZXJkb3duJyxcbiAgUE9JTlRFUlVQOiAncG9pbnRlcnVwJyxcbiAgUE9JTlRFUk9WRVI6ICdwb2ludGVyb3ZlcicsXG4gIFBPSU5URVJPVVQ6ICdwb2ludGVyb3V0JyxcbiAgUE9JTlRFUkVOVEVSOiAncG9pbnRlcmVudGVyJyxcbiAgUE9JTlRFUkxFQVZFOiAncG9pbnRlcmxlYXZlJyxcbiAgUE9JTlRFUkNBTkNFTDogJ3BvaW50ZXJjYW5jZWwnLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qXG4gKi9cblxuLyoqXG4gKiBUaGUgb2wvcHJvaiBtb2R1bGUgc3RvcmVzOlxuICogKiBhIGxpc3Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn1cbiAqIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBwcm9qZWN0aW9uIHN1cHBvcnRlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqICogYSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgbmVlZGVkIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gb25lIHByb2plY3Rpb25cbiAqIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgc3RhdGljIGZ1bmN0aW9ucyBhcmUgdGhlIG1ldGhvZHMgdXNlZCB0byBtYWludGFpbiB0aGVzZS5cbiAqIEVhY2ggdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiBoYW5kbGUgbm90IG9ubHkgc2ltcGxlIGNvb3JkaW5hdGUgcGFpcnMsIGJ1dCBhbHNvXG4gKiBsYXJnZSBhcnJheXMgb2YgY29vcmRpbmF0ZXMgc3VjaCBhcyB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBXaGVuIGxvYWRlZCwgdGhlIGxpYnJhcnkgYWRkcyBwcm9qZWN0aW9uIG9iamVjdHMgZm9yIEVQU0c6NDMyNiAoV0dTODRcbiAqIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMpIGFuZCBFUFNHOjM4NTcgKFdlYiBvciBTcGhlcmljYWwgTWVyY2F0b3IsIGFzIHVzZWRcbiAqIGZvciBleGFtcGxlIGJ5IEJpbmcgTWFwcyBvciBPcGVuU3RyZWV0TWFwKSwgdG9nZXRoZXIgd2l0aCB0aGUgcmVsZXZhbnRcbiAqIHRyYW5zZm9ybSBmdW5jdGlvbnMuXG4gKlxuICogQWRkaXRpb25hbCB0cmFuc2Zvcm1zIG1heSBiZSBhZGRlZCBieSB1c2luZyB0aGUgaHR0cDovL3Byb2o0anMub3JnL1xuICogbGlicmFyeSAodmVyc2lvbiAyLjIgb3IgbGF0ZXIpLiBZb3UgY2FuIHVzZSB0aGUgZnVsbCBidWlsZCBzdXBwbGllZCBieVxuICogUHJvajRqcywgb3IgY3JlYXRlIGEgY3VzdG9tIGJ1aWxkIHRvIHN1cHBvcnQgdGhvc2UgcHJvamVjdGlvbnMgeW91IG5lZWQ7IHNlZVxuICogdGhlIFByb2o0anMgd2Vic2l0ZSBmb3IgaG93IHRvIGRvIHRoaXMuIFlvdSBhbHNvIG5lZWQgdGhlIFByb2o0anMgZGVmaW5pdGlvbnNcbiAqIGZvciB0aGUgcmVxdWlyZWQgcHJvamVjdGlvbnMuIFRoZXNlIGRlZmluaXRpb25zIGNhbiBiZSBvYnRhaW5lZCBmcm9tXG4gKiBodHRwczovL2Vwc2cuaW8vLCBhbmQgYXJlIGEgSlMgZnVuY3Rpb24sIHNvIGNhbiBiZSBsb2FkZWQgaW4gYSBzY3JpcHRcbiAqIHRhZyAoYXMgaW4gdGhlIGV4YW1wbGVzKSBvciBwYXN0ZWQgaW50byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZSBhZGRlZCB0byBwcm9qNCdzIHJlZ2lzdHJ5IChieVxuICogdXNpbmcgYHByb2o0LmRlZnMoKWApLCBzaW1wbHkgY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBmcm9tIHRoZSBgb2wvcHJvai9wcm9qNGBcbiAqIHBhY2thZ2UuIEV4aXN0aW5nIHRyYW5zZm9ybXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IHRoaXMgZnVuY3Rpb24uIFNlZVxuICogZXhhbXBsZXMvd21zLWltYWdlLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogQWRkaXRpb25hbCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGNhbiBiZSByZWdpc3RlcmVkIHdpdGggYHByb2o0LmRlZnMoKWAgYW55XG4gKiB0aW1lLiBKdXN0IG1ha2Ugc3VyZSB0byBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGFnYWluOyBmb3IgZXhhbXBsZSwgd2l0aCB1c2VyLXN1cHBsaWVkIGRhdGEgd2hlcmUgeW91IGRvbid0XG4gKiBrbm93IGluIGFkdmFuY2Ugd2hhdCBwcm9qZWN0aW9ucyBhcmUgbmVlZGVkLCB5b3UgY2FuIGluaXRpYWxseSBsb2FkIG1pbmltYWxcbiAqIHN1cHBvcnQgYW5kIHRoZW4gbG9hZCB3aGljaGV2ZXIgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBOb3RlIHRoYXQgUHJvajRqcyBkb2VzIG5vdCBzdXBwb3J0IHByb2plY3Rpb24gZXh0ZW50cy4gSWYgeW91IHdhbnQgdG8gYWRkXG4gKiBvbmUgZm9yIGNyZWF0aW5nIGRlZmF1bHQgdGlsZSBncmlkcywgeW91IGNhbiBhZGQgaXQgYWZ0ZXIgdGhlIFByb2plY3Rpb25cbiAqIG9iamVjdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYHNldEV4dGVudGAsIGZvciBleGFtcGxlLFxuICogYGdldCgnRVBTRzoxMjM0Jykuc2V0RXh0ZW50KGV4dGVudClgLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIFByb2o0anMgc3VwcG9ydCwgYW55IHRyYW5zZm9ybSBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFRvIHVzZSB0aGlzLCB5b3UgbXVzdCBmaXJzdCBjcmVhdGVcbiAqIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0IGZvciB0aGUgbmV3IHByb2plY3Rpb24gYW5kIGFkZCBpdCB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouYWRkUHJvamVjdGlvbn0uIFlvdSBjYW4gdGhlbiBhZGQgdGhlIGZvcndhcmQgYW5kIGludmVyc2VcbiAqIGZ1bmN0aW9ucyB3aXRoIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFNlZVxuICogZXhhbXBsZXMvd21zLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogTm90ZSB0aGF0IGlmIG5vIHRyYW5zZm9ybXMgYXJlIG5lZWRlZCBhbmQgeW91IG9ubHkgbmVlZCB0byBkZWZpbmUgdGhlXG4gKiBwcm9qZWN0aW9uLCBqdXN0IGFkZCBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRQcm9qZWN0aW9ufS4gU2VlIGV4YW1wbGVzL3dtcy1uby1wcm9qIGZvciBhbiBleGFtcGxlIG9mXG4gKiB0aGlzLlxuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL3Byb2ovUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQge1xuICBQUk9KRUNUSU9OUyBhcyBFUFNHMzg1N19QUk9KRUNUSU9OUyxcbiAgZnJvbUVQU0c0MzI2LFxuICB0b0VQU0c0MzI2LFxufSBmcm9tICcuL3Byb2ovZXBzZzM4NTcuanMnO1xuaW1wb3J0IHtQUk9KRUNUSU9OUyBhcyBFUFNHNDMyNl9QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2c0MzI2LmpzJztcbmltcG9ydCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IHtcbiAgYWRkIGFzIGFkZFByb2osXG4gIGNsZWFyIGFzIGNsZWFyUHJvaixcbiAgZ2V0IGFzIGdldFByb2osXG59IGZyb20gJy4vcHJvai9wcm9qZWN0aW9ucy5qcyc7XG5pbXBvcnQge1xuICBhZGQgYXMgYWRkVHJhbnNmb3JtRnVuYyxcbiAgY2xlYXIgYXMgY2xlYXJUcmFuc2Zvcm1GdW5jcyxcbiAgZ2V0IGFzIGdldFRyYW5zZm9ybUZ1bmMsXG59IGZyb20gJy4vcHJvai90cmFuc2Zvcm1zLmpzJztcbmltcG9ydCB7YXBwbHlUcmFuc2Zvcm0sIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wLCBtb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2VxdWFscywgZ2V0V29ybGRzQXdheX0gZnJvbSAnLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCB7Z2V0RGlzdGFuY2V9IGZyb20gJy4vc3BoZXJlLmpzJztcbmltcG9ydCB7XG4gIG1ha2VQcm9qZWN0aW9uIGFzIG1ha2VVVE1Qcm9qZWN0aW9uLFxuICBtYWtlVHJhbnNmb3JtcyBhcyBtYWtlVVRNVHJhbnNmb3Jtcyxcbn0gZnJvbSAnLi9wcm9qL3V0bS5qcyc7XG5pbXBvcnQge3dhcm59IGZyb20gJy4vY29uc29sZS5qcyc7XG5cbi8qKlxuICogQSBwcm9qZWN0aW9uIGFzIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259LCBTUlMgaWRlbnRpZmllclxuICogc3RyaW5nIG9yIHVuZGVmaW5lZC5cbiAqIEB0eXBlZGVmIHtQcm9qZWN0aW9ufHN0cmluZ3x1bmRlZmluZWR9IFByb2plY3Rpb25MaWtlXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmFuc2Zvcm1zXG4gKiBAcHJvcGVydHkge1RyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkIFRoZSBmb3J3YXJkIHRyYW5zZm9ybSAoZnJvbSBnZW9ncmFwaGljKS5cbiAqIEBwcm9wZXJ0eSB7VHJhbnNmb3JtRnVuY3Rpb259IGludmVyc2UgVGhlIGludmVyc2UgdHJhbnNmb3JtICh0byBnZW9ncmFwaGljKS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihQcm9qZWN0aW9uKTogVHJhbnNmb3Jtc3xudWxsPn1cbiAqL1xuY29uc3QgdHJhbnNmb3JtRmFjdG9yaWVzID0gW21ha2VVVE1UcmFuc2Zvcm1zXTtcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oc3RyaW5nKTogUHJvamVjdGlvbnxudWxsPn1cbiAqL1xuY29uc3QgcHJvamVjdGlvbkZhY3RvcmllcyA9IFttYWtlVVRNUHJvamVjdGlvbl07XG5cbi8qKlxuICogQSB0cmFuc2Zvcm0gZnVuY3Rpb24gYWNjZXB0cyBhbiBhcnJheSBvZiBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgYW4gb3B0aW9uYWxcbiAqIG91dHB1dCBhcnJheSwgYW5kIGFuIG9wdGlvbmFsIGRpbWVuc2lvbiAoZGVmYXVsdCBzaG91bGQgYmUgMikuICBUaGUgZnVuY3Rpb25cbiAqIHRyYW5zZm9ybXMgdGhlIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBwb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSwgYW5kXG4gKiByZXR1cm5zIHRoZSBvdXRwdXQgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIFRyYW5zZm9ybUZ1bmN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdXG4gKiBAcGFyYW0ge251bWJlcn0gW2RpbWVuc2lvbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaWRlXVxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn1cbiAqXG4gKiBAYXBpXG4gKi9cblxuZXhwb3J0IHtNRVRFUlNfUEVSX1VOSVR9O1xuXG5leHBvcnQge1Byb2plY3Rpb259O1xuXG5sZXQgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nID0gdHJ1ZTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkaXNhYmxlID0gdHJ1ZV0gRGlzYWJsZSBjb25zb2xlIGluZm8gYWJvdXQgYHVzZUdlb2dyYXBoaWMoKWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDb29yZGluYXRlV2FybmluZyhkaXNhYmxlKSB7XG4gIGNvbnN0IGhpZGUgPSBkaXNhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogZGlzYWJsZTtcbiAgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nID0gIWhpZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBjb29yZGluYXRlIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgY29vcmRpbmF0ZSBhcnJheSAobmV3IGFycmF5LCBzYW1lIGNvb3JkaW5hdGVcbiAqICAgICB2YWx1ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVUcmFuc2Zvcm0oaW5wdXQsIG91dHB1dCkge1xuICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvdXRwdXRbaV0gPSBpbnB1dFtpXTtcbiAgICB9XG4gICAgb3V0cHV0ID0gb3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IElucHV0IGNvb3JkaW5hdGUgYXJyYXkgKHNhbWUgYXJyYXkgYXMgaW5wdXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHlUcmFuc2Zvcm0oaW5wdXQsIG91dHB1dCkge1xuICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQgJiYgaW5wdXQgIT09IG91dHB1dCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBpbnB1dCA9IG91dHB1dDtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogQWRkIGEgUHJvamVjdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHByb2plY3Rpb25zIHRoYXQgY2FuIGJlXG4gKiBsb29rZWQgdXAgYnkgdGhlaXIgY29kZS5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbiBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBhZGRQcm9qKHByb2plY3Rpb24uZ2V0Q29kZSgpLCBwcm9qZWN0aW9uKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uLCBwcm9qZWN0aW9uLCBjbG9uZVRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGFkZFByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIEZldGNoZXMgYSBQcm9qZWN0aW9uIG9iamVjdCBmb3IgdGhlIGNvZGUgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb25MaWtlIEVpdGhlciBhIGNvZGUgc3RyaW5nIHdoaWNoIGlzXG4gKiAgICAgYSBjb21iaW5hdGlvbiBvZiBhdXRob3JpdHkgYW5kIGlkZW50aWZpZXIgc3VjaCBhcyBcIkVQU0c6NDMyNlwiLCBvciBhblxuICogICAgIGV4aXN0aW5nIHByb2plY3Rpb24gb2JqZWN0LCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJuIHtQcm9qZWN0aW9ufG51bGx9IFByb2plY3Rpb24gb2JqZWN0LCBvciBudWxsIGlmIG5vdCBpbiBsaXN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHByb2plY3Rpb25MaWtlKSB7XG4gIGlmICghKHR5cGVvZiBwcm9qZWN0aW9uTGlrZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgcmV0dXJuIHByb2plY3Rpb25MaWtlO1xuICB9XG4gIGNvbnN0IHByb2plY3Rpb24gPSBnZXRQcm9qKHByb2plY3Rpb25MaWtlKTtcbiAgaWYgKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuICBmb3IgKGNvbnN0IG1ha2VQcm9qZWN0aW9uIG9mIHByb2plY3Rpb25GYWN0b3JpZXMpIHtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gbWFrZVByb2plY3Rpb24ocHJvamVjdGlvbkxpa2UpO1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2V0IHRoZSByZXNvbHV0aW9uIG9mIHRoZSBwb2ludCBpbiBkZWdyZWVzIG9yIGRpc3RhbmNlIHVuaXRzLlxuICogRm9yIHByb2plY3Rpb25zIHdpdGggZGVncmVlcyBhcyB0aGUgdW5pdCB0aGlzIHdpbGwgc2ltcGx5IHJldHVybiB0aGVcbiAqIHByb3ZpZGVkIHJlc29sdXRpb24uIEZvciBvdGhlciBwcm9qZWN0aW9ucyB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpc1xuICogYnkgZGVmYXVsdCBlc3RpbWF0ZWQgYnkgdHJhbnNmb3JtaW5nIHRoZSBgcG9pbnRgIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAqIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSxcbiAqIGFuZCB0YWtpbmcgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gKiBBIGN1c3RvbSBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQgZm9yIGEgc3BlY2lmaWMgcHJvamVjdGlvbiwgZWl0aGVyXG4gKiBieSBzZXR0aW5nIHRoZSBgZ2V0UG9pbnRSZXNvbHV0aW9uYCBvcHRpb24gaW4gdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBjb25zdHJ1Y3RvciBvciBieSB1c2luZ1xuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbiNzZXRHZXRQb2ludFJlc29sdXRpb259IHRvIGNoYW5nZSBhbiBleGlzdGluZ1xuICogcHJvamVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gTm9taW5hbCByZXNvbHV0aW9uIGluIHByb2plY3Rpb24gdW5pdHMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludCB0byBmaW5kIGFkanVzdGVkIHJlc29sdXRpb24gYXQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Vbml0cy5qc1wiKS5Vbml0c30gW3VuaXRzXSBVbml0cyB0byBnZXQgdGhlIHBvaW50IHJlc29sdXRpb24gaW4uXG4gKiBEZWZhdWx0IGlzIHRoZSBwcm9qZWN0aW9uJ3MgdW5pdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBvaW50IHJlc29sdXRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludFJlc29sdXRpb24ocHJvamVjdGlvbiwgcmVzb2x1dGlvbiwgcG9pbnQsIHVuaXRzKSB7XG4gIHByb2plY3Rpb24gPSBnZXQocHJvamVjdGlvbik7XG4gIGxldCBwb2ludFJlc29sdXRpb247XG4gIGNvbnN0IGdldHRlciA9IHByb2plY3Rpb24uZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYygpO1xuICBpZiAoZ2V0dGVyKSB7XG4gICAgcG9pbnRSZXNvbHV0aW9uID0gZ2V0dGVyKHJlc29sdXRpb24sIHBvaW50KTtcbiAgICBpZiAodW5pdHMgJiYgdW5pdHMgIT09IHByb2plY3Rpb24uZ2V0VW5pdHMoKSkge1xuICAgICAgY29uc3QgbWV0ZXJzUGVyVW5pdCA9IHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgICAgaWYgKG1ldGVyc1BlclVuaXQpIHtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uID1cbiAgICAgICAgICAocG9pbnRSZXNvbHV0aW9uICogbWV0ZXJzUGVyVW5pdCkgLyBNRVRFUlNfUEVSX1VOSVRbdW5pdHNdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcm9qVW5pdHMgPSBwcm9qZWN0aW9uLmdldFVuaXRzKCk7XG4gICAgaWYgKChwcm9qVW5pdHMgPT0gJ2RlZ3JlZXMnICYmICF1bml0cykgfHwgdW5pdHMgPT0gJ2RlZ3JlZXMnKSB7XG4gICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFc3RpbWF0ZSBwb2ludCByZXNvbHV0aW9uIGJ5IHRyYW5zZm9ybWluZyB0aGUgY2VudGVyIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAgICAgIC8vIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSwgYW5kIHRha2luZyB0aGVcbiAgICAgIC8vIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICBjb25zdCB0b0VQU0c0MzI2ID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKFxuICAgICAgICBwcm9qZWN0aW9uLFxuICAgICAgICBnZXQoJ0VQU0c6NDMyNicpLFxuICAgICAgKTtcbiAgICAgIGlmICghdG9FUFNHNDMyNiAmJiBwcm9qVW5pdHMgIT09ICdkZWdyZWVzJykge1xuICAgICAgICAvLyBubyB0cmFuc2Zvcm0gaXMgYXZhaWxhYmxlXG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiA9IHJlc29sdXRpb24gKiBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgICBwb2ludFswXSAtIHJlc29sdXRpb24gLyAyLFxuICAgICAgICAgIHBvaW50WzFdLFxuICAgICAgICAgIHBvaW50WzBdICsgcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgICAgcG9pbnRbMV0sXG4gICAgICAgICAgcG9pbnRbMF0sXG4gICAgICAgICAgcG9pbnRbMV0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgICBwb2ludFswXSxcbiAgICAgICAgICBwb2ludFsxXSArIHJlc29sdXRpb24gLyAyLFxuICAgICAgICBdO1xuICAgICAgICB2ZXJ0aWNlcyA9IHRvRVBTRzQzMjYodmVydGljZXMsIHZlcnRpY2VzLCAyKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXN0YW5jZSh2ZXJ0aWNlcy5zbGljZSgwLCAyKSwgdmVydGljZXMuc2xpY2UoMiwgNCkpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBnZXREaXN0YW5jZSh2ZXJ0aWNlcy5zbGljZSg0LCA2KSwgdmVydGljZXMuc2xpY2UoNiwgOCkpO1xuICAgICAgICBwb2ludFJlc29sdXRpb24gPSAod2lkdGggKyBoZWlnaHQpIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGVyc1BlclVuaXQgPSB1bml0c1xuICAgICAgICA/IE1FVEVSU19QRVJfVU5JVFt1bml0c11cbiAgICAgICAgOiBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICAgIGlmIChtZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uIC89IG1ldGVyc1BlclVuaXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2ludFJlc29sdXRpb247XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzLiBUaG9zZSBhbGxvd1xuICogdG8gdHJhbnNmb3JtIGJldHdlZW4gcHJvamVjdGlvbnMgd2l0aCBlcXVhbCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zIFByb2plY3Rpb25zLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKTtcbiAgcHJvamVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcHJvamVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgIGlmIChzb3VyY2UgIT09IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGFkZFRyYW5zZm9ybUZ1bmMoc291cmNlLCBkZXN0aW5hdGlvbiwgY2xvbmVUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gYW55IHByb2plY3Rpb25cbiAqIGluIHByb2plY3Rpb24xIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24yLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zMSBQcm9qZWN0aW9ucyB3aXRoIGVxdWFsXG4gKiAgICAgbWVhbmluZy5cbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zMiBQcm9qZWN0aW9ucyB3aXRoIGVxdWFsXG4gKiAgICAgbWVhbmluZy5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtRnVuY3Rpb259IGZvcndhcmRUcmFuc2Zvcm0gVHJhbnNmb3JtYXRpb24gZnJvbSBhbnlcbiAqICAgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtRnVuY3Rpb259IGludmVyc2VUcmFuc2Zvcm0gVHJhbnNmb3JtIGZyb20gYW55IHByb2plY3Rpb25cbiAqICAgaW4gcHJvamVjdGlvbjIgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMoXG4gIHByb2plY3Rpb25zMSxcbiAgcHJvamVjdGlvbnMyLFxuICBmb3J3YXJkVHJhbnNmb3JtLFxuICBpbnZlcnNlVHJhbnNmb3JtLFxuKSB7XG4gIHByb2plY3Rpb25zMS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMSkge1xuICAgIHByb2plY3Rpb25zMi5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMikge1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIsIGZvcndhcmRUcmFuc2Zvcm0pO1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMiwgcHJvamVjdGlvbjEsIGludmVyc2VUcmFuc2Zvcm0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIHByb2plY3Rpb25zIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxQcm9qZWN0aW9ucygpIHtcbiAgY2xlYXJQcm9qKCk7XG4gIGNsZWFyVHJhbnNmb3JtRnVuY3MoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRDb2RlIERlZmF1bHQgY29kZS5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb259IFByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uKHByb2plY3Rpb24sIGRlZmF1bHRDb2RlKSB7XG4gIGlmICghcHJvamVjdGlvbikge1xuICAgIHJldHVybiBnZXQoZGVmYXVsdENvZGUpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0KHByb2plY3Rpb24pO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBmcm9tIGEgc2ltcGxlIDJEIGNvb3JkaW5hdGUgdHJhbnNmb3JtXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRUcmFuc2Zvcm0gQ29vcmRpbmF0ZVxuICogICAgIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShjb29yZFRyYW5zZm9ybSkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb25dIERpbWVuc2lvbnMgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHJpZGVdIFN0cmlkZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbiwgc3RyaWRlKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICBkaW1lbnNpb24gPSBkaW1lbnNpb24gIT09IHVuZGVmaW5lZCA/IGRpbWVuc2lvbiA6IDI7XG4gICAgICBzdHJpZGUgPSBzdHJpZGUgPz8gZGltZW5zaW9uO1xuICAgICAgb3V0cHV0ID0gb3V0cHV0ICE9PSB1bmRlZmluZWQgPyBvdXRwdXQgOiBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IHN0cmlkZSkge1xuICAgICAgICBjb25zdCBwb2ludCA9IGNvb3JkVHJhbnNmb3JtKGlucHV0LnNsaWNlKGksIGkgKyBkaW1lbnNpb24pKTtcbiAgICAgICAgY29uc3QgcG9pbnRMZW5ndGggPSBwb2ludC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHN0cmlkZTsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBvdXRwdXRbaSArIGpdID0gaiA+PSBwb2ludExlbmd0aCA/IGlucHV0W2kgKyBqXSA6IHBvaW50W2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb25zIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgYmV0d2VlbiB0aGVcbiAqIHNvdXJjZSBwcm9qZWN0aW9uIGFuZCB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoZSBmb3J3YXJkIGFuZCBpbnZlcnNlIGZ1bmN0aW9ucyBjb252ZXJ0IGNvb3JkaW5hdGUgcGFpcnM7IHRoaXMgZnVuY3Rpb25cbiAqIGNvbnZlcnRzIHRoZXNlIGludG8gdGhlIGZ1bmN0aW9ucyB1c2VkIGludGVybmFsbHkgd2hpY2ggYWxzbyBoYW5kbGVcbiAqIGV4dGVudHMgYW5kIGNvb3JkaW5hdGUgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZvcndhcmQgVGhlIGZvcndhcmQgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvblxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBpbnZlcnNlIFRoZSBpbnZlcnNlIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHRvIHRoZSBzb3VyY2VcbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS4gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiBjYW4gb25seVxuICogICAgIHRyYW5zZm9ybSBsZXNzIGRpbWVuc2lvbnMgdGhhbiB0aGUgaW5wdXQgY29vcmRpbmF0ZSwgaXQgaXMgc3VwcG9zZWVkIHRvIHJldHVybiBhIGNvb3JkaW5hdGVcbiAqICAgICB3aXRoIG9ubHkgdGhlIGxlbmd0aCBpdCBjYW4gdHJhbnNmb3JtLiBUaGUgb3RoZXIgZGltZW5zaW9ucyB3aWxsIGJlIHRha2VuIHVuY2hhbmdlZCBmcm9tIHRoZVxuICogICAgIHNvdXJjZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zKHNvdXJjZSwgZGVzdGluYXRpb24sIGZvcndhcmQsIGludmVyc2UpIHtcbiAgY29uc3Qgc291cmNlUHJvaiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0UHJvaiA9IGdldChkZXN0aW5hdGlvbik7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoXG4gICAgc291cmNlUHJvaixcbiAgICBkZXN0UHJvaixcbiAgICBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShmb3J3YXJkKSxcbiAgKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhcbiAgICBkZXN0UHJvaixcbiAgICBzb3VyY2VQcm9qLFxuICAgIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGludmVyc2UpLFxuICApO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIGEgZGlmZmVyZW50IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgYXMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSwgaS5lLlxuICogICAgIGFuIGFycmF5IHdpdGggbG9uZ2l0dWRlIGFzIDFzdCBhbmQgbGF0aXR1ZGUgYXMgMm5kIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gVGFyZ2V0IHByb2plY3Rpb24uIFRoZVxuICogICAgIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgcHJvamVjdGVkIHRvIHRoZSB0YXJnZXQgcHJvamVjdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Mb25MYXQoY29vcmRpbmF0ZSwgcHJvamVjdGlvbikge1xuICBkaXNhYmxlQ29vcmRpbmF0ZVdhcm5pbmcoKTtcbiAgcmV0dXJuIHRyYW5zZm9ybShcbiAgICBjb29yZGluYXRlLFxuICAgICdFUFNHOjQzMjYnLFxuICAgIHByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IHByb2plY3Rpb24gOiAnRVBTRzozODU3JyxcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSB0byBsb25naXR1ZGUvbGF0aXR1ZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFByb2plY3RlZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24gb2YgdGhlIGNvb3JkaW5hdGUuXG4gKiAgICAgVGhlIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgYXMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSwgaS5lLiBhbiBhcnJheVxuICogICAgIHdpdGggbG9uZ2l0dWRlIGFzIDFzdCBhbmQgbGF0aXR1ZGUgYXMgMm5kIGVsZW1lbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xvbkxhdChjb29yZGluYXRlLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IGxvbkxhdCA9IHRyYW5zZm9ybShcbiAgICBjb29yZGluYXRlLFxuICAgIHByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IHByb2plY3Rpb24gOiAnRVBTRzozODU3JyxcbiAgICAnRVBTRzo0MzI2JyxcbiAgKTtcbiAgY29uc3QgbG9uID0gbG9uTGF0WzBdO1xuICBpZiAobG9uIDwgLTE4MCB8fCBsb24gPiAxODApIHtcbiAgICBsb25MYXRbMF0gPSBtb2R1bG8obG9uICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIHJldHVybiBsb25MYXQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBwcm9qZWN0aW9ucyBhcmUgdGhlIHNhbWUsIHRoYXQgaXMgZXZlcnkgY29vcmRpbmF0ZSBpbiBvbmVcbiAqIHByb2plY3Rpb24gZG9lcyByZXByZXNlbnQgdGhlIHNhbWUgZ2VvZ3JhcGhpYyBwb2ludCBhcyB0aGUgc2FtZSBjb29yZGluYXRlIGluXG4gKiB0aGUgb3RoZXIgcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24xIFByb2plY3Rpb24gMS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbjIgUHJvamVjdGlvbiAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRXF1aXZhbGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWl2YWxlbnQocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKSB7XG4gIGlmIChwcm9qZWN0aW9uMSA9PT0gcHJvamVjdGlvbjIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBlcXVhbFVuaXRzID0gcHJvamVjdGlvbjEuZ2V0VW5pdHMoKSA9PT0gcHJvamVjdGlvbjIuZ2V0VW5pdHMoKTtcbiAgaWYgKHByb2plY3Rpb24xLmdldENvZGUoKSA9PT0gcHJvamVjdGlvbjIuZ2V0Q29kZSgpKSB7XG4gICAgcmV0dXJuIGVxdWFsVW5pdHM7XG4gIH1cbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpO1xuICByZXR1cm4gdHJhbnNmb3JtRnVuYyA9PT0gY2xvbmVUcmFuc2Zvcm0gJiYgZXF1YWxVbml0cztcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBpbiB0aGUgbGlzdCBvZiB0cmFuc2Zvcm0gZnVuY3Rpb25zIGZvciB0aGUgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlIFNvdXJjZSBQcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gUHJvamVjdGlvblxuICogICAgIG9iamVjdC5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufG51bGx9IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGxldCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnVuYyhzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpO1xuICBpZiAodHJhbnNmb3JtRnVuYykge1xuICAgIHJldHVybiB0cmFuc2Zvcm1GdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUcmFuc2Zvcm1zfG51bGx9XG4gICAqL1xuICBsZXQgc291cmNlVHJhbnNmb3JtcyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUcmFuc2Zvcm1zfG51bGx9XG4gICAqL1xuICBsZXQgZGVzdGluYXRpb25UcmFuc2Zvcm1zID0gbnVsbDtcblxuICAvLyBsYXppbHkgYWRkIHByb2plY3Rpb25zIGlmIHdlIGhhdmUgc3VwcG9ydGVkIHRyYW5zZm9ybXNcbiAgZm9yIChjb25zdCBtYWtlVHJhbnNmb3JtcyBvZiB0cmFuc2Zvcm1GYWN0b3JpZXMpIHtcbiAgICBpZiAoIXNvdXJjZVRyYW5zZm9ybXMpIHtcbiAgICAgIHNvdXJjZVRyYW5zZm9ybXMgPSBtYWtlVHJhbnNmb3Jtcyhzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIWRlc3RpbmF0aW9uVHJhbnNmb3Jtcykge1xuICAgICAgZGVzdGluYXRpb25UcmFuc2Zvcm1zID0gbWFrZVRyYW5zZm9ybXMoZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc291cmNlVHJhbnNmb3JtcyAmJiAhZGVzdGluYXRpb25UcmFuc2Zvcm1zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpbnRlcm1lZGlhdGVDb2RlID0gJ0VQU0c6NDMyNic7XG4gIGlmICghZGVzdGluYXRpb25UcmFuc2Zvcm1zKSB7XG4gICAgY29uc3QgdG9EZXN0aW5hdGlvbiA9IGdldFRyYW5zZm9ybUZ1bmMoaW50ZXJtZWRpYXRlQ29kZSwgZGVzdGluYXRpb25Db2RlKTtcbiAgICBpZiAodG9EZXN0aW5hdGlvbikge1xuICAgICAgdHJhbnNmb3JtRnVuYyA9IGNvbXBvc2VUcmFuc2Zvcm1GdW5jcyhcbiAgICAgICAgc291cmNlVHJhbnNmb3Jtcy5pbnZlcnNlLFxuICAgICAgICB0b0Rlc3RpbmF0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXNvdXJjZVRyYW5zZm9ybXMpIHtcbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VHJhbnNmb3JtRnVuYyhzb3VyY2VDb2RlLCBpbnRlcm1lZGlhdGVDb2RlKTtcbiAgICBpZiAoZnJvbVNvdXJjZSkge1xuICAgICAgdHJhbnNmb3JtRnVuYyA9IGNvbXBvc2VUcmFuc2Zvcm1GdW5jcyhcbiAgICAgICAgZnJvbVNvdXJjZSxcbiAgICAgICAgZGVzdGluYXRpb25UcmFuc2Zvcm1zLmZvcndhcmQsXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cmFuc2Zvcm1GdW5jID0gY29tcG9zZVRyYW5zZm9ybUZ1bmNzKFxuICAgICAgc291cmNlVHJhbnNmb3Jtcy5pbnZlcnNlLFxuICAgICAgZGVzdGluYXRpb25UcmFuc2Zvcm1zLmZvcndhcmQsXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm1GdW5jKSB7XG4gICAgYWRkUHJvamVjdGlvbihzb3VyY2UpO1xuICAgIGFkZFByb2plY3Rpb24oZGVzdGluYXRpb24pO1xuICAgIGFkZFRyYW5zZm9ybUZ1bmMoc291cmNlLCBkZXN0aW5hdGlvbiwgdHJhbnNmb3JtRnVuYyk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtRnVuYztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSB0MSBUaGUgZmlyc3QgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtUcmFuc2Zvcm1GdW5jdGlvbn0gdDIgVGhlIHNlY29uZCB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVGhlIGNvbXBvc2VkIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZVRyYW5zZm9ybUZ1bmNzKHQxLCB0Mikge1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbnMsIHN0cmlkZSkge1xuICAgIG91dHB1dCA9IHQxKGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbnMsIHN0cmlkZSk7XG4gICAgcmV0dXJuIHQyKG91dHB1dCwgb3V0cHV0LCBkaW1lbnNpb25zLCBzdHJpZGUpO1xuICB9O1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBwcm9qZWN0aW9uLWxpa2Ugb2JqZWN0cywgc2VhcmNoZXMgZm9yIGEgdHJhbnNmb3JtYXRpb25cbiAqIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBjb29yZGluYXRlcyBhcnJheSBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGVcbiAqIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHNvdXJjZVByb2plY3Rpb24gPSBnZXQoc291cmNlKTtcbiAgY29uc3QgZGVzdGluYXRpb25Qcm9qZWN0aW9uID0gZ2V0KGRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhzb3VyY2VQcm9qZWN0aW9uLCBkZXN0aW5hdGlvblByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoaXMgcmV0dXJucyBhIG5ldyBjb29yZGluYXRlIChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuIElmIHRoZXJlXG4gKiBpcyBubyBhdmFpbGFibGUgdHJhbnNmb3JtIGJldHdlZW4gdGhlIHR3byBwcm9qZWN0aW9uLCB0aGUgZnVuY3Rpb24gd2lsbCB0aHJvd1xuICogYW4gZXJyb3IuXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvcHJvai50cmFuc2Zvcm1FeHRlbnR9IGZvciBleHRlbnQgdHJhbnNmb3JtYXRpb24uXG4gKiBTZWUgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBhbmQgaXRzXG4gKiBzdWJjbGFzc2VzIGZvciBnZW9tZXRyeSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICBpZiAoIXRyYW5zZm9ybUZ1bmMpIHtcbiAgICBjb25zdCBzb3VyY2VDb2RlID0gZ2V0KHNvdXJjZSkuZ2V0Q29kZSgpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGdldChkZXN0aW5hdGlvbikuZ2V0Q29kZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBObyB0cmFuc2Zvcm0gYXZhaWxhYmxlIGJldHdlZW4gJHtzb3VyY2VDb2RlfSBhbmQgJHtkZXN0aW5hdGlvbkNvZGV9YCxcbiAgICApO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKGNvb3JkaW5hdGUsIHVuZGVmaW5lZCwgY29vcmRpbmF0ZS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZXh0ZW50IGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXNcbiAqIHJldHVybnMgYSBuZXcgZXh0ZW50IChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wc10gTnVtYmVyIG9mIHN0b3BzIHBlciBzaWRlIHVzZWQgZm9yIHRoZSB0cmFuc2Zvcm0uXG4gKiBCeSBkZWZhdWx0IG9ubHkgdGhlIGNvcm5lcnMgYXJlIHVzZWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSB0cmFuc2Zvcm1lZCBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBzb3VyY2UsIGRlc3RpbmF0aW9uLCBzdG9wcykge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1GdW5jLCB1bmRlZmluZWQsIHN0b3BzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvamVjdGlvbiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gUG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1XaXRoUHJvamVjdGlvbnMoXG4gIHBvaW50LFxuICBzb3VyY2VQcm9qZWN0aW9uLFxuICBkZXN0aW5hdGlvblByb2plY3Rpb24sXG4pIHtcbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgICBzb3VyY2VQcm9qZWN0aW9uLFxuICAgIGRlc3RpbmF0aW9uUHJvamVjdGlvbixcbiAgKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMocG9pbnQpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtQcm9qZWN0aW9ufG51bGx9XG4gKi9cbmxldCB1c2VyUHJvamVjdGlvbiA9IG51bGw7XG5cbi8qKlxuICogU2V0IHRoZSBwcm9qZWN0aW9uIGZvciBjb29yZGluYXRlcyBzdXBwbGllZCBmcm9tIGFuZCByZXR1cm5lZCBieSBBUEkgbWV0aG9kcy5cbiAqIFRoaXMgaW5jbHVkZXMgYWxsIEFQSSBtZXRob2RzIGV4Y2VwdCBmb3IgdGhvc2UgaW50ZXJhY3Rpbmcgd2l0aCB0aWxlIGdyaWRzLFxuICogcGx1cyB7QGxpbmsgaW1wb3J0KFwiLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gYW5kIHtAbGluayBpbXBvcnQoXCIuL1ZpZXcuanNcIikuU3RhdGV9LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgdXNlciBwcm9qZWN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VXNlclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICB1c2VyUHJvamVjdGlvbiA9IGdldChwcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlciBwcm9qZWN0aW9uIGlmIHNldC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyVXNlclByb2plY3Rpb24oKSB7XG4gIHVzZXJQcm9qZWN0aW9uID0gbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb2plY3Rpb24gZm9yIGNvb3JkaW5hdGVzIHN1cHBsaWVkIGZyb20gYW5kIHJldHVybmVkIGJ5IEFQSSBtZXRob2RzLlxuICogQHJldHVybiB7UHJvamVjdGlvbnxudWxsfSBUaGUgdXNlciBwcm9qZWN0aW9uIChvciBudWxsIGlmIG5vdCBzZXQpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlclByb2plY3Rpb24oKSB7XG4gIHJldHVybiB1c2VyUHJvamVjdGlvbjtcbn1cblxuLyoqXG4gKiBVc2UgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyAoV0dTLTg0IGRhdHVtKSBpbiBBUEkgbWV0aG9kcy5cbiAqIFRoaXMgaW5jbHVkZXMgYWxsIEFQSSBtZXRob2RzIGV4Y2VwdCBmb3IgdGhvc2UgaW50ZXJhY3Rpbmcgd2l0aCB0aWxlIGdyaWRzLFxuICogcGx1cyB7QGxpbmsgaW1wb3J0KFwiLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gYW5kIHtAbGluayBpbXBvcnQoXCIuL1ZpZXcuanNcIikuU3RhdGV9LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlR2VvZ3JhcGhpYygpIHtcbiAgc2V0VXNlclByb2plY3Rpb24oJ0VQU0c6NDMyNicpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGNvb3JkaW5hdGUgdHJhbnNmb3JtZWQgaW50byB0aGUgdXNlciBwcm9qZWN0aW9uLiAgSWYgbm8gdXNlciBwcm9qZWN0aW9uXG4gKiBpcyBzZXQsIHRoZSBvcmlnaW5hbCBjb29yZGluYXRlIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlIElucHV0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2VQcm9qZWN0aW9uIFRoZSBpbnB1dCBjb29yZGluYXRlIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgaW5wdXQgY29vcmRpbmF0ZSBpbiB0aGUgdXNlciBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Vc2VyQ29vcmRpbmF0ZShjb29yZGluYXRlLCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHNvdXJjZVByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb29yZGluYXRlIHRyYW5zZm9ybWVkIGZyb20gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgY29vcmRpbmF0ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZSBJbnB1dCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdFByb2plY3Rpb24gVGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgaW5wdXQgY29vcmRpbmF0ZSB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyQ29vcmRpbmF0ZShjb29yZGluYXRlLCBkZXN0UHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgaWYgKFxuICAgICAgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nICYmXG4gICAgICAhZXF1YWxzKGNvb3JkaW5hdGUsIFswLCAwXSkgJiZcbiAgICAgIGNvb3JkaW5hdGVbMF0gPj0gLTE4MCAmJlxuICAgICAgY29vcmRpbmF0ZVswXSA8PSAxODAgJiZcbiAgICAgIGNvb3JkaW5hdGVbMV0gPj0gLTkwICYmXG4gICAgICBjb29yZGluYXRlWzFdIDw9IDkwXG4gICAgKSB7XG4gICAgICBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSBmYWxzZTtcbiAgICAgIHdhcm4oXG4gICAgICAgICdDYWxsIHVzZUdlb2dyYXBoaWMoKSBmcm9tIG9sL3Byb2ogb25jZSB0byB3b3JrIHdpdGggW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIGNvb3JkaW5hdGVzLicsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGV4dGVudCB0cmFuc2Zvcm1lZCBpbnRvIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGV4dGVudCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgSW5wdXQgZXh0ZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgZXh0ZW50IHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBpbnB1dCBleHRlbnQgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gZXh0ZW50IHRyYW5zZm9ybWVkIGZyb20gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgZXh0ZW50IGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBJbnB1dCBleHRlbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIGlucHV0IGV4dGVudCB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyRXh0ZW50KGV4dGVudCwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIGlucHV0IHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfVxuICBjb25zdCBzb3VyY2VNZXRlcnNQZXJVbml0ID0gZ2V0KHNvdXJjZVByb2plY3Rpb24pLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgY29uc3QgdXNlck1ldGVyc1BlclVuaXQgPSB1c2VyUHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIHJldHVybiBzb3VyY2VNZXRlcnNQZXJVbml0ICYmIHVzZXJNZXRlcnNQZXJVbml0XG4gICAgPyAocmVzb2x1dGlvbiAqIHNvdXJjZU1ldGVyc1BlclVuaXQpIC8gdXNlck1ldGVyc1BlclVuaXRcbiAgICA6IHJlc29sdXRpb247XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZXN0UHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc29sdXRpb247XG4gIH1cbiAgY29uc3QgZGVzdE1ldGVyc1BlclVuaXQgPSBnZXQoZGVzdFByb2plY3Rpb24pLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgY29uc3QgdXNlck1ldGVyc1BlclVuaXQgPSB1c2VyUHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIHJldHVybiBkZXN0TWV0ZXJzUGVyVW5pdCAmJiB1c2VyTWV0ZXJzUGVyVW5pdFxuICAgID8gKHJlc29sdXRpb24gKiB1c2VyTWV0ZXJzUGVyVW5pdCkgLyBkZXN0TWV0ZXJzUGVyVW5pdFxuICAgIDogcmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2FmZSBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbiBmcm9tIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBcIlNhZmVcIiBtZWFucyB0aGF0IGl0IGNhbiBoYW5kbGUgd3JhcHBpbmcgb2YgeC1jb29yZGluYXRlcyBmb3IgZ2xvYmFsIHByb2plY3Rpb25zLFxuICogYW5kIHRoYXQgY29vcmRpbmF0ZXMgZXhjZWVkaW5nIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB2YWxpZGl0eSBleHRlbnQncyByYW5nZSB3aWxsIGJlXG4gKiBjbGFtcGVkIHRvIHRoZSB2YWxpZGl0eSByYW5nZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdFByb2ogRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdHJhbnNmb3JtIFRyYW5zZm9ybSBmdW5jdGlvbiAoc291cmNlIHRvIGRlc3RpbmF0aW9uKS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFNhZmUgdHJhbnNmb3JtIGZ1bmN0aW9uIChzb3VyY2UgdG8gZGVzdGluYXRpb24pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2FmZUNvb3JkaW5hdGVUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdFByb2osIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgbGV0IHRyYW5zZm9ybWVkLCB3b3JsZHNBd2F5O1xuICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICBjb25zdCBzb3VyY2VFeHRlbnRXaWR0aCA9IGdldFdpZHRoKHNvdXJjZUV4dGVudCk7XG4gICAgICBjb29yZCA9IGNvb3JkLnNsaWNlKDApO1xuICAgICAgd29ybGRzQXdheSA9IGdldFdvcmxkc0F3YXkoY29vcmQsIHNvdXJjZVByb2osIHNvdXJjZUV4dGVudFdpZHRoKTtcbiAgICAgIGlmICh3b3JsZHNBd2F5KSB7XG4gICAgICAgIC8vIE1vdmUgeCB0byB0aGUgcmVhbCB3b3JsZFxuICAgICAgICBjb29yZFswXSA9IGNvb3JkWzBdIC0gd29ybGRzQXdheSAqIHNvdXJjZUV4dGVudFdpZHRoO1xuICAgICAgfVxuICAgICAgY29vcmRbMF0gPSBjbGFtcChjb29yZFswXSwgc291cmNlRXh0ZW50WzBdLCBzb3VyY2VFeHRlbnRbMl0pO1xuICAgICAgY29vcmRbMV0gPSBjbGFtcChjb29yZFsxXSwgc291cmNlRXh0ZW50WzFdLCBzb3VyY2VFeHRlbnRbM10pO1xuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0oY29vcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShjb29yZCk7XG4gICAgfVxuICAgIGlmICh3b3JsZHNBd2F5ICYmIGRlc3RQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIC8vIE1vdmUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZSBiYWNrIHRvIHRoZSBvZmZzZXQgd29ybGRcbiAgICAgIHRyYW5zZm9ybWVkWzBdICs9IHdvcmxkc0F3YXkgKiBnZXRXaWR0aChkZXN0UHJvai5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBZGQgdHJhbnNmb3JtcyB0byBhbmQgZnJvbSBFUFNHOjQzMjYgYW5kIEVQU0c6Mzg1Ny4gIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBieSB3aGVuIHRoaXMgbW9kdWxlIGlzIGV4ZWN1dGVkIGFuZCBzaG91bGQgb25seSBuZWVkIHRvIGJlIGNhbGxlZCBhZ2FpbiBhZnRlclxuICogYGNsZWFyQWxsUHJvamVjdGlvbnMoKWAgaXMgY2FsbGVkIChlLmcuIGluIHRlc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbW1vbigpIHtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzIHRvIGNvbnZlcnQgd2l0aGluIHNldCBvZlxuICAvLyBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHMzg1N19QUk9KRUNUSU9OUyk7XG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHNDMyNl9QUk9KRUNUSU9OUyk7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdG8gY29udmVydCBFUFNHOjQzMjYgbGlrZSBjb29yZGluYXRlcyB0byBFUFNHOjM4NTcgbGlrZVxuICAvLyBjb29yZGluYXRlcyBhbmQgYmFjay5cbiAgYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMoXG4gICAgRVBTRzQzMjZfUFJPSkVDVElPTlMsXG4gICAgRVBTRzM4NTdfUFJPSkVDVElPTlMsXG4gICAgZnJvbUVQU0c0MzI2LFxuICAgIHRvRVBTRzQzMjYsXG4gICk7XG59XG5cbmFkZENvbW1vbigpO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovUHJvamVjdGlvblxuICovXG5pbXBvcnQge01FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9Vbml0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgVGhlIFNSUyBpZGVudGlmaWVyIGNvZGUsIGUuZy4gYEVQU0c6NDMyNmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVW5pdHMuanNcIikuVW5pdHN9IFt1bml0c10gVW5pdHMuIFJlcXVpcmVkIHVubGVzcyBhXG4gKiBwcm9qNCBwcm9qZWN0aW9uIGlzIGRlZmluZWQgZm9yIGBjb2RlYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uPSdlbnUnXSBUaGUgYXhpcyBvcmllbnRhdGlvbiBhcyBzcGVjaWZpZWQgaW4gUHJvajQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnbG9iYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgdmFsaWQgZm9yIHRoZSB3aG9sZSBnbG9iZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWV0ZXJzUGVyVW5pdF0gVGhlIG1ldGVycyBwZXIgdW5pdCBmb3IgdGhlIFNSUy5cbiAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGB1bml0c2AgYXJlIHVzZWQgdG8gZ2V0IHRoZSBtZXRlcnMgcGVyIHVuaXQgZnJvbSB0aGUge0BsaW5rIE1FVEVSU19QRVJfVU5JVH1cbiAqIGxvb2t1cCB0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3dvcmxkRXh0ZW50XSBUaGUgd29ybGQgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfSBbZ2V0UG9pbnRSZXNvbHV0aW9uXVxuICogRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHJlc29sdXRpb24gYXQgYSBwb2ludC4gVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAqIGBudW1iZXJgIHZpZXcgcmVzb2x1dGlvbiBhbmQgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnRzLCBhbmQgcmV0dXJuc1xuICogdGhlIGBudW1iZXJgIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cyBhdCB0aGUgcGFzc2VkIGNvb3JkaW5hdGUuIElmIHRoaXMgaXMgYHVuZGVmaW5lZGAsXG4gKiB0aGUgZGVmYXVsdCB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouZ2V0UG9pbnRSZXNvbHV0aW9ufSBmdW5jdGlvbiB3aWxsIGJlIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbiBtb3N0IGNhc2VzLCB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy5cbiAqIEluc3RlYWQsIHdoZXJlIHByb2plY3Rpb24gaW5mb3JtYXRpb24gaXMgcmVxdWlyZWQsIHlvdSBjYW4gdXNlIGEgc3RyaW5nXG4gKiBwcm9qZWN0aW9uIGNvZGUgb3IgaWRlbnRpZmllciAoZS5nLiBgRVBTRzo0MzI2YCkgaW5zdGVhZCBvZiBhIHByb2plY3Rpb25cbiAqIGluc3RhbmNlLlxuICpcbiAqIFRoZSBsaWJyYXJ5IGluY2x1ZGVzIHN1cHBvcnQgZm9yIHRyYW5zZm9ybWluZyBjb29yZGluYXRlcyBiZXR3ZWVuIHRoZSBmb2xsb3dpbmdcbiAqIHByb2plY3Rpb25zOlxuICpcbiAqICAqIFdHUyA4NCAvIEdlb2dyYXBoaWMgLSBVc2luZyBjb2RlcyBgRVBTRzo0MzI2YCwgYENSUzo4NGAsIGB1cm46b2djOmRlZjpjcnM6RVBTRzo2LjY6NDMyNmAsXG4gKiAgICBgdXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODRgLCBgdXJuOm9nYzpkZWY6Y3JzOk9HQzoyOjg0YCwgYGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCM0MzI2YCxcbiAqICAgIG9yIGB1cm46eC1vZ2M6ZGVmOmNyczpFUFNHOjQzMjZgXG4gKiAgKiBXR1MgODQgLyBTcGhlcmljYWwgTWVyY2F0b3IgLSBVc2luZyBjb2RlcyBgRVBTRzozODU3YCwgYEVQU0c6MTAyMTAwYCwgYEVQU0c6MTAyMTEzYCwgYEVQU0c6OTAwOTEzYCxcbiAqICAgIGB1cm46b2djOmRlZjpjcnM6RVBTRzo2LjE4OjM6Mzg1N2AsIG9yIGBodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjMzg1N2BcbiAqICAqIFdHUyA4NCAvIFVUTSB6b25lcyAtIFVzaW5nIGNvZGVzIGBFUFNHOjMyNjAxYCB0aHJvdWdoIGBFUFNHOjMyNjYwYCBmb3Igbm9ydGhlcm4gem9uZXNcbiAqICAgIGFuZCBgRVBTRzozMjcwMWAgdGhyb3VnaCBgRVBTRzozMjc2MGAgZm9yIHNvdXRoZXJuIHpvbmVzLiBOb3RlIHRoYXQgdGhlIGJ1aWx0LWluIFVUTSB0cmFuc2Zvcm1zXG4gKiAgICBhcmUgbG93ZXIgYWNjdXJhY3kgKHdpdGggZXJyb3JzIG9uIHRoZSBvcmRlciBvZiAwLjEgbSkgdGhhbiB0aG9zZSB0aGF0IHlvdSBtaWdodCBnZXQgaW4gYVxuICogICAgbGlicmFyeSBsaWtlIFtwcm9qNGpzXShodHRwczovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzKS5cbiAqXG4gKiBGb3IgYWRkaXRpb25hbCBwcm9qZWN0aW9uIHN1cHBvcnQsIG9yIHRvIHVzZSBoaWdoZXIgYWNjdXJhY3kgdHJhbnNmb3JtcyB0aGFuIHRoZSBidWlsdC1pbiBvbmVzLCB5b3UgY2FuIHVzZVxuICogdGhlIFtwcm9qNGpzXShodHRwczovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzKSBsaWJyYXJ5LiBXaXRoIGBwcm9qNGpzYCwgYWZ0ZXIgYWRkaW5nIGFueSBuZXcgcHJvamVjdGlvblxuICogZGVmaW5pdGlvbnMsIGNhbGwgdGhlIHtAbGluayBtb2R1bGU6b2wvcHJvai9wcm9qNC5yZWdpc3Rlcn0gZnVuY3Rpb24uXG4gKlxuICogWW91IGNhbiB1c2UgdGhlIHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXR9IGZ1bmN0aW9uIHRvIHJldHJpZXZlIGEgcHJvamVjdGlvbiBpbnN0YW5jZVxuICogZm9yIG9uZSBvZiB0aGUgcmVnaXN0ZXJlZCBwcm9qZWN0aW9ucy5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFByb2plY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFByb2plY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb2RlXyA9IG9wdGlvbnMuY29kZTtcblxuICAgIC8qKlxuICAgICAqIFVuaXRzIG9mIHByb2plY3RlZCBjb29yZGluYXRlcy4gV2hlbiBzZXQgdG8gYFRJTEVfUElYRUxTYCwgYVxuICAgICAqIGB0aGlzLmV4dGVudF9gIGFuZCBgdGhpcy53b3JsZEV4dGVudF9gIG11c3QgYmUgY29uZmlndXJlZCBwcm9wZXJseSBmb3IgZWFjaFxuICAgICAqIHRpbGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c31cbiAgICAgKi9cbiAgICB0aGlzLnVuaXRzXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c30gKi8gKG9wdGlvbnMudW5pdHMpO1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRpdHkgZXh0ZW50IG9mIHRoZSBwcm9qZWN0aW9uIGluIHByb2plY3RlZCBjb29yZGluYXRlcy4gRm9yIHByb2plY3Rpb25zXG4gICAgICogd2l0aCBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICAgKiB0aWxlIHBpeGVsIHNwYWNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gb3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0ZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEV4dGVudCBvZiB0aGUgd29ybGQgaW4gRVBTRzo0MzI2LiBGb3IgcHJvamVjdGlvbnMgd2l0aFxuICAgICAqIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgICAqIHByb2plY3RlZCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZEV4dGVudF8gPVxuICAgICAgb3B0aW9ucy53b3JsZEV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53b3JsZEV4dGVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5heGlzT3JpZW50YXRpb25fID1cbiAgICAgIG9wdGlvbnMuYXhpc09yaWVudGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF4aXNPcmllbnRhdGlvbiA6ICdlbnUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbF8gPSBvcHRpb25zLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nbG9iYWwgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgdGhpcy5leHRlbnRfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBvcHRpb25zLmdldFBvaW50UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0VGlsZUdyaWRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5tZXRlcnNQZXJVbml0XyA9IG9wdGlvbnMubWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcHJvamVjdGlvbiBpcyBzdWl0YWJsZSBmb3Igd3JhcHBpbmcgdGhlIHgtYXhpc1xuICAgKi9cbiAgY2FuV3JhcFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuV3JhcFhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29kZSBmb3IgdGhpcyBwcm9qZWN0aW9uLCBlLmcuICdFUFNHOjQzMjYnLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuaXRzIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c30gVW5pdHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFVuaXRzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaXRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFtb3VudCBvZiBtZXRlcnMgcGVyIHVuaXQgb2YgdGhpcyBwcm9qZWN0aW9uLiAgSWYgdGhlIHByb2plY3Rpb24gaXNcbiAgICogbm90IGNvbmZpZ3VyZWQgd2l0aCBgbWV0ZXJzUGVyVW5pdGAgb3IgYSB1bml0cyBpZGVudGlmaWVyLCB0aGUgcmV0dXJuIGlzXG4gICAqIGB1bmRlZmluZWRgLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNZXRlcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1ldGVyc1BlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0ZXJzUGVyVW5pdF8gfHwgTUVURVJTX1BFUl9VTklUW3RoaXMudW5pdHNfXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdvcmxkRXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLndvcmxkRXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF4aXMgb3JpZW50YXRpb24gb2YgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBFeGFtcGxlIHZhbHVlcyBhcmU6XG4gICAqIGVudSAtIHRoZSBkZWZhdWx0IGVhc3RpbmcsIG5vcnRoaW5nLCBlbGV2YXRpb24uXG4gICAqIG5ldSAtIG5vcnRoaW5nLCBlYXN0aW5nLCB1cCAtIHVzZWZ1bCBmb3IgXCJsYXQvbG9uZ1wiIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMsXG4gICAqICAgICBvciBzb3V0aCBvcmllbnRhdGVkIHRyYW5zdmVyc2UgbWVyY2F0b3IuXG4gICAqIHdudSAtIHdlc3RpbmcsIG5vcnRoaW5nLCB1cCAtIHNvbWUgcGxhbmV0YXJ5IGNvb3JkaW5hdGUgc3lzdGVtcyBoYXZlXG4gICAqICAgICBcIndlc3QgcG9zaXRpdmVcIiBjb29yZGluYXRlIHN5c3RlbXNcbiAgICogQHJldHVybiB7c3RyaW5nfSBBeGlzIG9yaWVudGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBeGlzT3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc09yaWVudGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGlzIHByb2plY3Rpb24gYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGQ/XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICAgKiBAYXBpXG4gICAqL1xuICBpc0dsb2JhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpZiB0aGUgcHJvamVjdGlvbiBpcyBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdsb2JhbCBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIGdsb2JhbC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0R2xvYmFsKGdsb2JhbCkge1xuICAgIHRoaXMuZ2xvYmFsXyA9IGdsb2JhbDtcbiAgICB0aGlzLmNhbldyYXBYXyA9ICEhKGdsb2JhbCAmJiB0aGlzLmV4dGVudF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRoZSBkZWZhdWx0IHRpbGUgZ3JpZC5cbiAgICovXG4gIGdldERlZmF1bHRUaWxlR3JpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0VGlsZUdyaWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICAgKi9cbiAgc2V0RGVmYXVsdFRpbGVHcmlkKHRpbGVHcmlkKSB7XG4gICAgdGhpcy5kZWZhdWx0VGlsZUdyaWRfID0gdGlsZUdyaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRFeHRlbnQoZXh0ZW50KSB7XG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50O1xuICAgIHRoaXMuY2FuV3JhcFhfID0gISEodGhpcy5nbG9iYWxfICYmIGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB3b3JsZCBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSB3b3JsZEV4dGVudCBXb3JsZCBleHRlbnRcbiAgICogICAgIFttaW5sb24sIG1pbmxhdCwgbWF4bG9uLCBtYXhsYXRdLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRXb3JsZEV4dGVudCh3b3JsZEV4dGVudCkge1xuICAgIHRoaXMud29ybGRFeHRlbnRfID0gd29ybGRFeHRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBnZXRQb2ludFJlc29sdXRpb24gZnVuY3Rpb24gKHNlZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouZ2V0UG9pbnRSZXNvbHV0aW9ufVxuICAgKiBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ9IGZ1bmMgRnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0R2V0UG9pbnRSZXNvbHV0aW9uKGZ1bmMpIHtcbiAgICB0aGlzLmdldFBvaW50UmVzb2x1dGlvbkZ1bmNfID0gZnVuYztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1c3RvbSBwb2ludCByZXNvbHV0aW9uIGZ1bmN0aW9uIGZvciB0aGlzIHByb2plY3Rpb24gKGlmIHNldCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfSBUaGUgY3VzdG9tIHBvaW50XG4gICAqIHJlc29sdXRpb24gZnVuY3Rpb24gKGlmIHNldCkuXG4gICAqL1xuICBnZXRQb2ludFJlc29sdXRpb25GdW5jKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UmVzb2x1dGlvbkZ1bmNfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3Rpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9Vbml0c1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydyYWRpYW5zJyB8ICdkZWdyZWVzJyB8ICdmdCcgfCAnbScgfCAncGl4ZWxzJyB8ICd0aWxlLXBpeGVscycgfCAndXMtZnQnfSBVbml0c1xuICogUHJvamVjdGlvbiB1bml0cy5cbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwOi8vZHVmZi5lc3Mud2FzaGluZ3Rvbi5lZHUvZGF0YS9yYXN0ZXIvZHJnL2RvY3MvZ2VvdGlmZi50eHRcbiAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBVbml0cz59XG4gKi9cbmNvbnN0IHVuaXRCeUNvZGUgPSB7XG4gICc5MDAxJzogJ20nLFxuICAnOTAwMic6ICdmdCcsXG4gICc5MDAzJzogJ3VzLWZ0JyxcbiAgJzkxMDEnOiAncmFkaWFucycsXG4gICc5MTAyJzogJ2RlZ3JlZXMnLFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZSBVbml0IGNvZGUuXG4gKiBAcmV0dXJuIHtVbml0c30gVW5pdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ29kZShjb2RlKSB7XG4gIHJldHVybiB1bml0QnlDb2RlW2NvZGVdO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGVyc1BlclVuaXRMb29rdXBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYWRpYW5zIFJhZGlhbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWdyZWVzIERlZ3JlZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmdCAgRmVldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG0gTWV0ZXJzXG4gKiBAcHJvcGVydHkge251bWJlcn0gdXMtZnQgVVMgZmVldFxuICovXG5cbi8qKlxuICogTWV0ZXJzIHBlciB1bml0IGxvb2t1cCB0YWJsZS5cbiAqIEBjb25zdFxuICogQHR5cGUge01ldGVyc1BlclVuaXRMb29rdXB9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBNRVRFUlNfUEVSX1VOSVQgPSB7XG4gIC8vIHVzZSB0aGUgcmFkaXVzIG9mIHRoZSBOb3JtYWwgc3BoZXJlXG4gICdyYWRpYW5zJzogNjM3MDk5NyAvICgyICogTWF0aC5QSSksXG4gICdkZWdyZWVzJzogKDIgKiBNYXRoLlBJICogNjM3MDk5NykgLyAzNjAsXG4gICdmdCc6IDAuMzA0OCxcbiAgJ20nOiAxLFxuICAndXMtZnQnOiAxMjAwIC8gMzkzNyxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnMzg1N1xuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL1Byb2plY3Rpb24uanMnO1xuXG4vKipcbiAqIFJhZGl1cyBvZiBXR1M4NCBzcGhlcmVcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEhBTEZfU0laRSA9IE1hdGguUEkgKiBSQURJVVM7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVYVEVOVCA9IFstSEFMRl9TSVpFLCAtSEFMRl9TSVpFLCBIQUxGX1NJWkUsIEhBTEZfU0laRV07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IFdPUkxEX0VYVEVOVCA9IFstMTgwLCAtODUsIDE4MCwgODVdO1xuXG4vKipcbiAqIE1heGltdW0gc2FmZSB2YWx1ZSBpbiB5IGRpcmVjdGlvblxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfWSA9IFJBRElVUyAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyAyKSk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIHdlYi9zcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKi9cbmNsYXNzIEVQU0czODU3UHJvamVjdGlvbiBleHRlbmRzIFByb2plY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgQ29kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICBzdXBlcih7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgdW5pdHM6ICdtJyxcbiAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgd29ybGRFeHRlbnQ6IFdPUkxEX0VYVEVOVCxcbiAgICAgIGdldFBvaW50UmVzb2x1dGlvbjogZnVuY3Rpb24gKHJlc29sdXRpb24sIHBvaW50KSB7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uIC8gTWF0aC5jb3NoKHBvaW50WzFdIC8gUkFESVVTKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjM4NTcuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgY29uc3QgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjEwMCcpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjExMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjkwMDkxMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvRVBTRy8wLzM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTcnKSxcbl07XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjQzMjYgdG8gRVBTRzozODU3LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaWRlXSBTdHJpZGUgKGRlZmF1bHQgaXMgYGRpbWVuc2lvbmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUVQU0c0MzI2KGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbiwgc3RyaWRlKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgZGltZW5zaW9uID0gZGltZW5zaW9uID4gMSA/IGRpbWVuc2lvbiA6IDI7XG4gIHN0cmlkZSA9IHN0cmlkZSA/PyBkaW1lbnNpb247XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkaW1lbnNpb24gPiAyKSB7XG4gICAgICAvLyBwcmVzZXJ2ZSB2YWx1ZXMgYmV5b25kIHNlY29uZCBkaW1lbnNpb25cbiAgICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBzdHJpZGUpIHtcbiAgICBvdXRwdXRbaV0gPSAoSEFMRl9TSVpFICogaW5wdXRbaV0pIC8gMTgwO1xuICAgIGxldCB5ID0gUkFESVVTICogTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgKiAoK2lucHV0W2kgKyAxXSArIDkwKSkgLyAzNjApKTtcbiAgICBpZiAoeSA+IE1BWF9TQUZFX1kpIHtcbiAgICAgIHkgPSBNQVhfU0FGRV9ZO1xuICAgIH0gZWxzZSBpZiAoeSA8IC1NQVhfU0FGRV9ZKSB7XG4gICAgICB5ID0gLU1BWF9TQUZFX1k7XG4gICAgfVxuICAgIG91dHB1dFtpICsgMV0gPSB5O1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjM4NTcgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaWRlXSBTdHJpZGUgKGRlZmF1bHQgaXMgYGRpbWVuc2lvbmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9FUFNHNDMyNihpbnB1dCwgb3V0cHV0LCBkaW1lbnNpb24sIHN0cmlkZSkge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiA+IDEgPyBkaW1lbnNpb24gOiAyO1xuICBzdHJpZGUgPSBzdHJpZGUgPz8gZGltZW5zaW9uO1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgb3V0cHV0W2ldID0gKDE4MCAqIGlucHV0W2ldKSAvIEhBTEZfU0laRTtcbiAgICBvdXRwdXRbaSArIDFdID1cbiAgICAgICgzNjAgKiBNYXRoLmF0YW4oTWF0aC5leHAoaW5wdXRbaSArIDFdIC8gUkFESVVTKSkpIC8gTWF0aC5QSSAtIDkwO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnNDMyNlxuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL1Byb2plY3Rpb24uanMnO1xuXG4vKipcbiAqIFNlbWktbWFqb3IgcmFkaXVzIG9mIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgUkFESVVTID0gNjM3ODEzNztcblxuLyoqXG4gKiBFeHRlbnQgb2YgdGhlIEVQU0c6NDMyNiBwcm9qZWN0aW9uIHdoaWNoIGlzIHRoZSB3aG9sZSB3b3JsZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgY29uc3QgRVhURU5UID0gWy0xODAsIC05MCwgMTgwLCA5MF07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgTUVURVJTX1BFUl9VTklUID0gKE1hdGguUEkgKiBSQURJVVMpIC8gMTgwO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gb2JqZWN0IGZvciBXR1M4NCBnZW9ncmFwaGljIGNvb3JkaW5hdGVzIChFUFNHOjQzMjYpLlxuICpcbiAqIE5vdGUgdGhhdCBPcGVuTGF5ZXJzIGRvZXMgbm90IHN0cmljdGx5IGNvbXBseSB3aXRoIHRoZSBFUFNHIGRlZmluaXRpb24uXG4gKiBUaGUgRVBTRyByZWdpc3RyeSBkZWZpbmVzIDQzMjYgYXMgYSBDUlMgZm9yIExhdGl0dWRlLExvbmdpdHVkZSAoeSx4KS5cbiAqIE9wZW5MYXllcnMgdHJlYXRzIEVQU0c6NDMyNiBhcyBhIHBzZXVkby1wcm9qZWN0aW9uLCB3aXRoIHgseSBjb29yZGluYXRlcy5cbiAqL1xuY2xhc3MgRVBTRzQzMjZQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNPcmllbnRhdGlvbl0gQXhpcyBvcmllbnRhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIGF4aXNPcmllbnRhdGlvbikge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICB1bml0czogJ2RlZ3JlZXMnLFxuICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICBheGlzT3JpZW50YXRpb246IGF4aXNPcmllbnRhdGlvbixcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIG1ldGVyc1BlclVuaXQ6IE1FVEVSU19QRVJfVU5JVCxcbiAgICAgIHdvcmxkRXh0ZW50OiBFWFRFTlQsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjQzMjYuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgY29uc3QgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0NSUzo4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdFUFNHOjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvT0dDLzEuMy9DUlM4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvY3JzL0VQU0cvMC80MzI2JywgJ25ldScpLFxuXTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3Byb2plY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5sZXQgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcHJvamVjdGlvbnMgY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgY2FjaGUgPSB7fTtcbn1cblxuLyoqXG4gKiBHZXQgYSBjYWNoZWQgcHJvamVjdGlvbiBieSBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8bnVsbH0gVGhlIHByb2plY3Rpb24gKGlmIGNhY2hlZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoY29kZSkge1xuICByZXR1cm4gKFxuICAgIGNhY2hlW2NvZGVdIHx8XG4gICAgY2FjaGVbY29kZS5yZXBsYWNlKC91cm46KHgtKT9vZ2M6ZGVmOmNyczpFUFNHOiguKjopPyhcXHcrKSQvLCAnRVBTRzokMycpXSB8fFxuICAgIG51bGxcbiAgKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBwcm9qZWN0aW9uIHRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBwcm9qZWN0aW9uIGNvZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uIHRvIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvZGUsIHByb2plY3Rpb24pIHtcbiAgY2FjaGVbY29kZV0gPSBwcm9qZWN0aW9uO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovdHJhbnNmb3Jtc1xuICovXG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uL29iai5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbj4+fVxuICovXG5sZXQgdHJhbnNmb3JtcyA9IHt9O1xuXG4vKipcbiAqIENsZWFyIHRoZSB0cmFuc2Zvcm0gY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgdHJhbnNmb3JtcyA9IHt9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gdG8gY29udmVydCBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlIFNvdXJjZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoc291cmNlLCBkZXN0aW5hdGlvbiwgdHJhbnNmb3JtRm4pIHtcbiAgY29uc3Qgc291cmNlQ29kZSA9IHNvdXJjZS5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uLmdldENvZGUoKTtcbiAgaWYgKCEoc291cmNlQ29kZSBpbiB0cmFuc2Zvcm1zKSkge1xuICAgIHRyYW5zZm9ybXNbc291cmNlQ29kZV0gPSB7fTtcbiAgfVxuICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV0gPSB0cmFuc2Zvcm1Gbjtcbn1cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyB0aGUgY29udmVyc2lvbiBmdW5jdGlvbiB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZVxuICogcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY2xlYW4gdXBcbiAqIGNhY2hlZCB0cmFuc2Zvcm1zIGR1cmluZyB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUaGUgdW5yZWdpc3RlcmVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgaWYgKGlzRW1wdHkodHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkpIHtcbiAgICBkZWxldGUgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIEdldCBhIHRyYW5zZm9ybSBnaXZlbiBhIHNvdXJjZSBjb2RlIGFuZCBhIGRlc3RpbmF0aW9uIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlQ29kZSBUaGUgY29kZSBmb3IgdGhlIHNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uQ29kZSBUaGUgY29kZSBmb3IgdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufG51bGx9IFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKGlmIGZvdW5kKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpIHtcbiAgaWYgKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcyAmJiBkZXN0aW5hdGlvbkNvZGUgaW4gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai91dG1cbiAqL1xuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vVHVyYm84Ny91dG1cbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRvYmlhcyBCaWVuaWVrXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBoZXJlIHByb3ZpZGUgYXBwcm94aW1hdGUgdHJhbnNmb3JtcyB0byBhbmQgZnJvbSBVVE0uXG4gKiBUaGV5IGFyZSBub3QgYXBwcm9wcmlhdGUgZm9yIHVzZSBiZXlvbmQgdGhlIHZhbGlkaXR5IGV4dGVuZCBvZiBhIFVUTVxuICogem9uZSwgYW5kIHRoZSBhY2N1cmFjeSBvZiB0aGUgdHJhbnNmb3JtIGRlY3JlYXNlcyB0b3dhcmQgdGhlIHpvbmVcbiAqIGVkZ2VzLlxuICovXG5cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQge3RvRGVncmVlcywgdG9SYWRpYW5zLCB3cmFwfSBmcm9tICcuLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVVE1ab25lXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtYmVyIFRoZSB6b25lIG51bWJlciAoMSAtIDYwKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbm9ydGggVGhlIG5vcnRoZXJuIGhlbWlzcGhlcmUuXG4gKi9cblxuY29uc3QgSzAgPSAwLjk5OTY7XG5cbmNvbnN0IEUgPSAwLjAwNjY5NDM4O1xuY29uc3QgRTIgPSBFICogRTtcbmNvbnN0IEUzID0gRTIgKiBFO1xuY29uc3QgRV9QMiA9IEUgLyAoMSAtIEUpO1xuXG5jb25zdCBTUVJUX0UgPSBNYXRoLnNxcnQoMSAtIEUpO1xuY29uc3QgX0UgPSAoMSAtIFNRUlRfRSkgLyAoMSArIFNRUlRfRSk7XG5jb25zdCBfRTIgPSBfRSAqIF9FO1xuY29uc3QgX0UzID0gX0UyICogX0U7XG5jb25zdCBfRTQgPSBfRTMgKiBfRTtcbmNvbnN0IF9FNSA9IF9FNCAqIF9FO1xuXG5jb25zdCBNMSA9IDEgLSBFIC8gNCAtICgzICogRTIpIC8gNjQgLSAoNSAqIEUzKSAvIDI1NjtcbmNvbnN0IE0yID0gKDMgKiBFKSAvIDggKyAoMyAqIEUyKSAvIDMyICsgKDQ1ICogRTMpIC8gMTAyNDtcbmNvbnN0IE0zID0gKDE1ICogRTIpIC8gMjU2ICsgKDQ1ICogRTMpIC8gMTAyNDtcbmNvbnN0IE00ID0gKDM1ICogRTMpIC8gMzA3MjtcblxuY29uc3QgUDIgPSAoMyAvIDIpICogX0UgLSAoMjcgLyAzMikgKiBfRTMgKyAoMjY5IC8gNTEyKSAqIF9FNTtcbmNvbnN0IFAzID0gKDIxIC8gMTYpICogX0UyIC0gKDU1IC8gMzIpICogX0U0O1xuY29uc3QgUDQgPSAoMTUxIC8gOTYpICogX0UzIC0gKDQxNyAvIDEyOCkgKiBfRTU7XG5jb25zdCBQNSA9ICgxMDk3IC8gNTEyKSAqIF9FNDtcblxuY29uc3QgUiA9IDYzNzgxMzc7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGVhc3RpbmcgRWFzdGluZyB2YWx1ZSBvZiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG5vcnRoaW5nIE5vcnRoaW5nIHZhbHVlIG9mIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1VUTVpvbmV9IHpvbmUgVGhlIFVUTSB6b25lLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaGUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gdG9Mb25MYXQoZWFzdGluZywgbm9ydGhpbmcsIHpvbmUpIHtcbiAgY29uc3QgeCA9IGVhc3RpbmcgLSA1MDAwMDA7XG4gIGNvbnN0IHkgPSB6b25lLm5vcnRoID8gbm9ydGhpbmcgOiBub3J0aGluZyAtIDEwMDAwMDAwO1xuXG4gIGNvbnN0IG0gPSB5IC8gSzA7XG4gIGNvbnN0IG11ID0gbSAvIChSICogTTEpO1xuXG4gIGNvbnN0IHBSYWQgPVxuICAgIG11ICtcbiAgICBQMiAqIE1hdGguc2luKDIgKiBtdSkgK1xuICAgIFAzICogTWF0aC5zaW4oNCAqIG11KSArXG4gICAgUDQgKiBNYXRoLnNpbig2ICogbXUpICtcbiAgICBQNSAqIE1hdGguc2luKDggKiBtdSk7XG5cbiAgY29uc3QgcFNpbiA9IE1hdGguc2luKHBSYWQpO1xuICBjb25zdCBwU2luMiA9IHBTaW4gKiBwU2luO1xuXG4gIGNvbnN0IHBDb3MgPSBNYXRoLmNvcyhwUmFkKTtcblxuICBjb25zdCBwVGFuID0gcFNpbiAvIHBDb3M7XG4gIGNvbnN0IHBUYW4yID0gcFRhbiAqIHBUYW47XG4gIGNvbnN0IHBUYW40ID0gcFRhbjIgKiBwVGFuMjtcblxuICBjb25zdCBlcFNpbiA9IDEgLSBFICogcFNpbjI7XG4gIGNvbnN0IGVwU2luU3FydCA9IE1hdGguc3FydCgxIC0gRSAqIHBTaW4yKTtcblxuICBjb25zdCBuID0gUiAvIGVwU2luU3FydDtcbiAgY29uc3QgciA9ICgxIC0gRSkgLyBlcFNpbjtcblxuICBjb25zdCBjID0gRV9QMiAqIHBDb3MgKiogMjtcbiAgY29uc3QgYzIgPSBjICogYztcblxuICBjb25zdCBkID0geCAvIChuICogSzApO1xuICBjb25zdCBkMiA9IGQgKiBkO1xuICBjb25zdCBkMyA9IGQyICogZDtcbiAgY29uc3QgZDQgPSBkMyAqIGQ7XG4gIGNvbnN0IGQ1ID0gZDQgKiBkO1xuICBjb25zdCBkNiA9IGQ1ICogZDtcblxuICBjb25zdCBsYXRpdHVkZSA9XG4gICAgcFJhZCAtXG4gICAgKHBUYW4gLyByKSAqXG4gICAgICAoZDIgLyAyIC0gKGQ0IC8gMjQpICogKDUgKyAzICogcFRhbjIgKyAxMCAqIGMgLSA0ICogYzIgLSA5ICogRV9QMikpICtcbiAgICAoZDYgLyA3MjApICogKDYxICsgOTAgKiBwVGFuMiArIDI5OCAqIGMgKyA0NSAqIHBUYW40IC0gMjUyICogRV9QMiAtIDMgKiBjMik7XG5cbiAgbGV0IGxvbmdpdHVkZSA9XG4gICAgKGQgLVxuICAgICAgKGQzIC8gNikgKiAoMSArIDIgKiBwVGFuMiArIGMpICtcbiAgICAgIChkNSAvIDEyMCkgKiAoNSAtIDIgKiBjICsgMjggKiBwVGFuMiAtIDMgKiBjMiArIDggKiBFX1AyICsgMjQgKiBwVGFuNCkpIC9cbiAgICBwQ29zO1xuXG4gIGxvbmdpdHVkZSA9IHdyYXAoXG4gICAgbG9uZ2l0dWRlICsgdG9SYWRpYW5zKHpvbmVUb0NlbnRyYWxMb25naXR1ZGUoem9uZS5udW1iZXIpKSxcbiAgICAtTWF0aC5QSSxcbiAgICBNYXRoLlBJLFxuICApO1xuXG4gIHJldHVybiBbdG9EZWdyZWVzKGxvbmdpdHVkZSksIHRvRGVncmVlcyhsYXRpdHVkZSldO1xufVxuXG5jb25zdCBNSU5fTEFUSVRVREUgPSAtODA7XG5jb25zdCBNQVhfTEFUSVRVREUgPSA4NDtcbmNvbnN0IE1JTl9MT05HSVRVREUgPSAtMTgwO1xuY29uc3QgTUFYX0xPTkdJVFVERSA9IDE4MDtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGUgVGhlIGxhdGl0dWRlLlxuICogQHBhcmFtIHtVVE1ab25lfSB6b25lIFRoZSBVVE0gem9uZS5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGV9IFRoZSBVVE0gY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gZnJvbUxvbkxhdChsb25naXR1ZGUsIGxhdGl0dWRlLCB6b25lKSB7XG4gIGxvbmdpdHVkZSA9IHdyYXAobG9uZ2l0dWRlLCBNSU5fTE9OR0lUVURFLCBNQVhfTE9OR0lUVURFKTtcblxuICBpZiAobGF0aXR1ZGUgPCBNSU5fTEFUSVRVREUpIHtcbiAgICBsYXRpdHVkZSA9IE1JTl9MQVRJVFVERTtcbiAgfSBlbHNlIGlmIChsYXRpdHVkZSA+IE1BWF9MQVRJVFVERSkge1xuICAgIGxhdGl0dWRlID0gTUFYX0xBVElUVURFO1xuICB9XG5cbiAgY29uc3QgbGF0UmFkID0gdG9SYWRpYW5zKGxhdGl0dWRlKTtcbiAgY29uc3QgbGF0U2luID0gTWF0aC5zaW4obGF0UmFkKTtcbiAgY29uc3QgbGF0Q29zID0gTWF0aC5jb3MobGF0UmFkKTtcblxuICBjb25zdCBsYXRUYW4gPSBsYXRTaW4gLyBsYXRDb3M7XG4gIGNvbnN0IGxhdFRhbjIgPSBsYXRUYW4gKiBsYXRUYW47XG4gIGNvbnN0IGxhdFRhbjQgPSBsYXRUYW4yICogbGF0VGFuMjtcblxuICBjb25zdCBsb25SYWQgPSB0b1JhZGlhbnMobG9uZ2l0dWRlKTtcbiAgY29uc3QgY2VudHJhbExvbiA9IHpvbmVUb0NlbnRyYWxMb25naXR1ZGUoem9uZS5udW1iZXIpO1xuICBjb25zdCBjZW50cmFsTG9uUmFkID0gdG9SYWRpYW5zKGNlbnRyYWxMb24pO1xuXG4gIGNvbnN0IG4gPSBSIC8gTWF0aC5zcXJ0KDEgLSBFICogbGF0U2luICoqIDIpO1xuICBjb25zdCBjID0gRV9QMiAqIGxhdENvcyAqKiAyO1xuXG4gIGNvbnN0IGEgPSBsYXRDb3MgKiB3cmFwKGxvblJhZCAtIGNlbnRyYWxMb25SYWQsIC1NYXRoLlBJLCBNYXRoLlBJKTtcbiAgY29uc3QgYTIgPSBhICogYTtcbiAgY29uc3QgYTMgPSBhMiAqIGE7XG4gIGNvbnN0IGE0ID0gYTMgKiBhO1xuICBjb25zdCBhNSA9IGE0ICogYTtcbiAgY29uc3QgYTYgPSBhNSAqIGE7XG5cbiAgY29uc3QgbSA9XG4gICAgUiAqXG4gICAgKE0xICogbGF0UmFkIC1cbiAgICAgIE0yICogTWF0aC5zaW4oMiAqIGxhdFJhZCkgK1xuICAgICAgTTMgKiBNYXRoLnNpbig0ICogbGF0UmFkKSAtXG4gICAgICBNNCAqIE1hdGguc2luKDYgKiBsYXRSYWQpKTtcblxuICBjb25zdCBlYXN0aW5nID1cbiAgICBLMCAqXG4gICAgICBuICpcbiAgICAgIChhICtcbiAgICAgICAgKGEzIC8gNikgKiAoMSAtIGxhdFRhbjIgKyBjKSArXG4gICAgICAgIChhNSAvIDEyMCkgKiAoNSAtIDE4ICogbGF0VGFuMiArIGxhdFRhbjQgKyA3MiAqIGMgLSA1OCAqIEVfUDIpKSArXG4gICAgNTAwMDAwO1xuXG4gIGxldCBub3J0aGluZyA9XG4gICAgSzAgKlxuICAgIChtICtcbiAgICAgIG4gKlxuICAgICAgICBsYXRUYW4gKlxuICAgICAgICAoYTIgLyAyICtcbiAgICAgICAgICAoYTQgLyAyNCkgKiAoNSAtIGxhdFRhbjIgKyA5ICogYyArIDQgKiBjICoqIDIpICtcbiAgICAgICAgICAoYTYgLyA3MjApICogKDYxIC0gNTggKiBsYXRUYW4yICsgbGF0VGFuNCArIDYwMCAqIGMgLSAzMzAgKiBFX1AyKSkpO1xuXG4gIGlmICghem9uZS5ub3J0aCkge1xuICAgIG5vcnRoaW5nICs9IDEwMDAwMDAwO1xuICB9XG5cbiAgcmV0dXJuIFtlYXN0aW5nLCBub3J0aGluZ107XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHpvbmUgVGhlIHpvbmUgbnVtYmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY2VudHJhbCBsb25naXR1ZGUgaW4gZGVncmVlcy5cbiAqL1xuZnVuY3Rpb24gem9uZVRvQ2VudHJhbExvbmdpdHVkZSh6b25lKSB7XG4gIHJldHVybiAoem9uZSAtIDEpICogNiAtIDE4MCArIDM7XG59XG5cbi8qKlxuICogQHR5cGUge0FycmF5PFJlZ0V4cD59XG4gKi9cbmNvbnN0IGVwc2dSZWdFeGVzID0gW1xuICAvXkVQU0c6KFxcZCspJC8sXG4gIC9edXJuOm9nYzpkZWY6Y3JzOkVQU0c6OihcXGQrKSQvLFxuICAvXmh0dHA6XFwvXFwvd3d3XFwub3Blbmdpc1xcLm5ldFxcL2RlZlxcL2Nyc1xcL0VQU0dcXC8wXFwvKFxcZCspJC8sXG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBwcm9qZWN0aW9uIGNvZGUuXG4gKiBAcmV0dXJuIHtVVE1ab25lfG51bGx9IFRoZSBVVE0gem9uZSBpbmZvIChvciBudWxsIGlmIG5vdCBVVE0pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gem9uZUZyb21Db2RlKGNvZGUpIHtcbiAgbGV0IGVwc2dJZCA9IDA7XG4gIGZvciAoY29uc3QgcmUgb2YgZXBzZ1JlZ0V4ZXMpIHtcbiAgICBjb25zdCBtYXRjaCA9IGNvZGUubWF0Y2gocmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZXBzZ0lkID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghZXBzZ0lkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgbnVtYmVyID0gMDtcbiAgbGV0IG5vcnRoID0gZmFsc2U7XG4gIGlmIChlcHNnSWQgPiAzMjcwMCAmJiBlcHNnSWQgPCAzMjc2MSkge1xuICAgIG51bWJlciA9IGVwc2dJZCAtIDMyNzAwO1xuICB9IGVsc2UgaWYgKGVwc2dJZCA+IDMyNjAwICYmIGVwc2dJZCA8IDMyNjYxKSB7XG4gICAgbm9ydGggPSB0cnVlO1xuICAgIG51bWJlciA9IGVwc2dJZCAtIDMyNjAwO1xuICB9XG4gIGlmICghbnVtYmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge251bWJlciwgbm9ydGh9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIFVUTVpvbmUpOiBpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlfSB0cmFuc2Zvcm1lciBUaGUgdHJhbnNmb3JtZXIuXG4gKiBAcGFyYW0ge1VUTVpvbmV9IHpvbmUgVGhlIFVUTSB6b25lLlxuICogQHJldHVybiB7aW1wb3J0KCcuLi9wcm9qLmpzJykuVHJhbnNmb3JtRnVuY3Rpb259IFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1ha2VUcmFuc2Zvcm1GdW5jdGlvbih0cmFuc2Zvcm1lciwgem9uZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbiwgc3RyaWRlKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiA+IDEgPyBkaW1lbnNpb24gOiAyO1xuICAgIHN0cmlkZSA9IHN0cmlkZSA/PyBkaW1lbnNpb247XG4gICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgIGlmIChkaW1lbnNpb24gPiAyKSB7XG4gICAgICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCB4ID0gaW5wdXRbaV07XG4gICAgICBjb25zdCB5ID0gaW5wdXRbaSArIDFdO1xuICAgICAgY29uc3QgY29vcmQgPSB0cmFuc2Zvcm1lcih4LCB5LCB6b25lKTtcbiAgICAgIG91dHB1dFtpXSA9IGNvb3JkWzBdO1xuICAgICAgb3V0cHV0W2kgKyAxXSA9IGNvb3JkWzFdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBwcm9qZWN0aW9uIGNvZGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4vUHJvamVjdGlvbi5qcycpLmRlZmF1bHR8bnVsbH0gQSBwcm9qZWN0aW9uIG9yIG51bGwgaWYgdW5hYmxlIHRvIGNyZWF0ZSBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHJvamVjdGlvbihjb2RlKSB7XG4gIGNvbnN0IHpvbmUgPSB6b25lRnJvbUNvZGUoY29kZSk7XG4gIGlmICghem9uZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgUHJvamVjdGlvbih7Y29kZSwgdW5pdHM6ICdtJ30pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL1Byb2plY3Rpb24uanMnKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KCcuLi9wcm9qLmpzJykuVHJhbnNmb3Jtc3xudWxsfSBUaGUgdHJhbnNmb3JtcyBsb29rdXAgb3IgbnVsbCBpZiB1bmFibGUgdG8gaGFuZGxlIHByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlVHJhbnNmb3Jtcyhwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHpvbmUgPSB6b25lRnJvbUNvZGUocHJvamVjdGlvbi5nZXRDb2RlKCkpO1xuICBpZiAoIXpvbmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9yd2FyZDogbWFrZVRyYW5zZm9ybUZ1bmN0aW9uKGZyb21Mb25MYXQsIHpvbmUpLFxuICAgIGludmVyc2U6IG1ha2VUcmFuc2Zvcm1GdW5jdGlvbih0b0xvbkxhdCwgem9uZSksXG4gIH07XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0JveFxuICovXG5cbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcblxuY2xhc3MgUmVuZGVyQm94IGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIENTUyBjbGFzcyBuYW1lLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xhc3NOYW1lKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmVsZW1lbnRfLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLmVsZW1lbnRfLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG4gICAgdGhpcy5lbGVtZW50Xy5jbGFzc05hbWUgPSAnb2wtYm94ICcgKyBjbGFzc05hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqL1xuICAgIHRoaXMuZW5kUGl4ZWxfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy5zZXRNYXAobnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbmRlcl8oKSB7XG4gICAgY29uc3Qgc3RhcnRQaXhlbCA9IHRoaXMuc3RhcnRQaXhlbF87XG4gICAgY29uc3QgZW5kUGl4ZWwgPSB0aGlzLmVuZFBpeGVsXztcbiAgICBjb25zdCBweCA9ICdweCc7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsZW1lbnRfLnN0eWxlO1xuICAgIHN0eWxlLmxlZnQgPSBNYXRoLm1pbihzdGFydFBpeGVsWzBdLCBlbmRQaXhlbFswXSkgKyBweDtcbiAgICBzdHlsZS50b3AgPSBNYXRoLm1pbihzdGFydFBpeGVsWzFdLCBlbmRQaXhlbFsxXSkgKyBweDtcbiAgICBzdHlsZS53aWR0aCA9IE1hdGguYWJzKGVuZFBpeGVsWzBdIC0gc3RhcnRQaXhlbFswXSkgKyBweDtcbiAgICBzdHlsZS5oZWlnaHQgPSBNYXRoLmFicyhlbmRQaXhlbFsxXSAtIHN0YXJ0UGl4ZWxbMV0pICsgcHg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBtYXAgTWFwLlxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHRoaXMubWFwXy5nZXRPdmVybGF5Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuZWxlbWVudF8uc3R5bGU7XG4gICAgICBzdHlsZS5sZWZ0ID0gJ2luaGVyaXQnO1xuICAgICAgc3R5bGUudG9wID0gJ2luaGVyaXQnO1xuICAgICAgc3R5bGUud2lkdGggPSAnaW5oZXJpdCc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnaW5oZXJpdCc7XG4gICAgfVxuICAgIHRoaXMubWFwXyA9IG1hcDtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICB0aGlzLm1hcF8uZ2V0T3ZlcmxheUNvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudF8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFN0YXJ0IHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBFbmQgcGl4ZWwuXG4gICAqL1xuICBzZXRQaXhlbHMoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpIHtcbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLmVuZFBpeGVsXyA9IGVuZFBpeGVsO1xuICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSgpO1xuICAgIHRoaXMucmVuZGVyXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgdXBkYXRlcyB0aGUgY2FjaGVkIGdlb21ldHJ5LlxuICAgKi9cbiAgY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSgpIHtcbiAgICBpZiAoIXRoaXMubWFwXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB0aGlzLnN0YXJ0UGl4ZWxfO1xuICAgIGNvbnN0IGVuZFBpeGVsID0gdGhpcy5lbmRQaXhlbF87XG4gICAgY29uc3QgcGl4ZWxzID0gW1xuICAgICAgc3RhcnRQaXhlbCxcbiAgICAgIFtzdGFydFBpeGVsWzBdLCBlbmRQaXhlbFsxXV0sXG4gICAgICBlbmRQaXhlbCxcbiAgICAgIFtlbmRQaXhlbFswXSwgc3RhcnRQaXhlbFsxXV0sXG4gICAgXTtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHBpeGVscy5tYXAoXG4gICAgICB0aGlzLm1hcF8uZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsLFxuICAgICAgdGhpcy5tYXBfLFxuICAgICk7XG4gICAgLy8gY2xvc2UgdGhlIHBvbHlnb25cbiAgICBjb29yZGluYXRlc1s0XSA9IGNvb3JkaW5hdGVzWzBdLnNsaWNlKCk7XG4gICAgaWYgKCF0aGlzLmdlb21ldHJ5Xykge1xuICAgICAgdGhpcy5nZW9tZXRyeV8gPSBuZXcgUG9seWdvbihbY29vcmRpbmF0ZXNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZW9tZXRyeV8uc2V0Q29vcmRpbmF0ZXMoW2Nvb3JkaW5hdGVzXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5XztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJCb3g7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50XG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5cbmNsYXNzIFJlbmRlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gW2ludmVyc2VQaXhlbFRyYW5zZm9ybV0gVHJhbnNmb3JtIGZvclxuICAgKiAgICAgQ1NTIHBpeGVscyB0byByZW5kZXJlZCBwaXhlbHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHs/KENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxXZWJHTFJlbmRlcmluZ0NvbnRleHQpfSBbY29udGV4dF0gQ29udGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGludmVyc2VQaXhlbFRyYW5zZm9ybSwgZnJhbWVTdGF0ZSwgY29udGV4dCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGZyb20gQ1NTIHBpeGVscyAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgbWFwIHZpZXdwb3J0KVxuICAgICAqIHRvIHJlbmRlcmVkIHBpeGVscyBvbiB0aGlzIGV2ZW50J3MgYGNvbnRleHRgLiBPbmx5IGF2YWlsYWJsZSB3aGVuIGEgQ2FudmFzIHJlbmRlcmVyIGlzIHVzZWQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0gPSBpbnZlcnNlUGl4ZWxUcmFuc2Zvcm07XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJlbmRlciBmcmFtZSBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIGNvbnRleHQuIE5vdCBhdmFpbGFibGUgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBieSB0aGUgbWFwLiBGb3IgQ2FudmFzIDJEIGxheWVycyxcbiAgICAgKiB0aGUgY29udGV4dCB3aWxsIGJlIHRoZSAyRCByZW5kZXJpbmcgY29udGV4dC4gIEZvciBXZWJHTCBsYXllcnMsIHRoZSBjb250ZXh0IHdpbGwgYmUgdGhlIFdlYkdMXG4gICAgICogY29udGV4dC5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFdlYkdMUmVuZGVyaW5nQ29udGV4dHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyRXZlbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGJlZm9yZSBhIGxheWVyIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwcmVyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUFJFUkVOREVSOiAncHJlcmVuZGVyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbGF5ZXIgaXMgcmVuZGVyZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYmVmb3JlIGxheWVycyBhcmUgY29tcG9zZWQuICBXaGVuIGRpc3BhdGNoZWQgYnkgdGhlIG1hcCwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIG5vdCBoYXZlXG4gICAqIGEgYGNvbnRleHRgIHNldC4gIFdoZW4gZGlzcGF0Y2hlZCBieSBhIGxheWVyLCB0aGUgZXZlbnQgb2JqZWN0IHdpbGwgaGF2ZSBhIGBjb250ZXh0YCBzZXQuICBPbmx5XG4gICAqIFdlYkdMIGxheWVycyBjdXJyZW50bHkgZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUkVDT01QT1NFOiAncHJlY29tcG9zZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciBsYXllcnMgYXJlIGNvbXBvc2VkLiAgV2hlbiBkaXNwYXRjaGVkIGJ5IHRoZSBtYXAsIHRoZSBldmVudCBvYmplY3Qgd2lsbCBub3QgaGF2ZVxuICAgKiBhIGBjb250ZXh0YCBzZXQuICBXaGVuIGRpc3BhdGNoZWQgYnkgYSBsYXllciwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIGhhdmUgYSBgY29udGV4dGAgc2V0LiAgT25seVxuICAgKiBXZWJHTCBsYXllcnMgY3VycmVudGx5IGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3Rjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RDT01QT1NFOiAncG9zdGNvbXBvc2UnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiByZW5kZXJpbmcgaXMgY29tcGxldGUsIGkuZS4gYWxsIHNvdXJjZXMgYW5kIHRpbGVzIGhhdmVcbiAgICogZmluaXNoZWQgbG9hZGluZyBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQsIGFuZCBhbGwgdGlsZXMgYXJlIGZhZGVkIGluLlxuICAgKiBUaGUgZXZlbnQgb2JqZWN0IHdpbGwgbm90IGhhdmUgYSBgY29udGV4dGAgc2V0LlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNyZW5kZXJjb21wbGV0ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU5ERVJDT01QTEVURTogJ3JlbmRlcmNvbXBsZXRlJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeydwb3N0cmVuZGVyJ3wncHJlY29tcG9zZSd8J3Bvc3Rjb21wb3NlJ3wncmVuZGVyY29tcGxldGUnfSBNYXBSZW5kZXJFdmVudFR5cGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3Bvc3RyZW5kZXInfCdwcmVyZW5kZXInfSBMYXllclJlbmRlckV2ZW50VHlwZXNcbiAqL1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXNcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7V09SS0VSX09GRlNDUkVFTl9DQU5WQVN9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2dldEZvbnRQYXJhbWV0ZXJzfSBmcm9tICcuLi9jc3MuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnQ2lyY2xlJyB8ICdJbWFnZScgfCAnTGluZVN0cmluZycgfCAnUG9seWdvbicgfCAnVGV4dCcgfCAnRGVmYXVsdCd9IEJ1aWxkZXJUeXBlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gZmlsbFN0eWxlIEZpbGxTdHlsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIExhYmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nfG51bWJlcj59IGNvbnRleHRJbnN0cnVjdGlvbnMgQ29udGV4dEluc3RydWN0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGxTdHJva2VTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY3VycmVudEZpbGxTdHlsZV0gQ3VycmVudCBGaWxsU3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjdXJyZW50U3Ryb2tlU3R5bGVdIEN1cnJlbnQgU3Ryb2tlU3R5bGUuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFtjdXJyZW50TGluZUNhcF0gQ3VycmVudCBMaW5lQ2FwLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBjdXJyZW50TGluZURhc2ggQ3VycmVudCBMaW5lRGFzaC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVEYXNoT2Zmc2V0XSBDdXJyZW50IExpbmVEYXNoT2Zmc2V0LlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gW2N1cnJlbnRMaW5lSm9pbl0gQ3VycmVudCBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVXaWR0aF0gQ3VycmVudCBMaW5lV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRNaXRlckxpbWl0XSBDdXJyZW50IE1pdGVyTGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xhc3RTdHJva2VdIExhc3Qgc3Ryb2tlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbZmlsbFN0eWxlXSBGaWxsU3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtzdHJva2VTdHlsZV0gU3Ryb2tlU3R5bGUuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFtsaW5lQ2FwXSBMaW5lQ2FwLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBsaW5lRGFzaCBMaW5lRGFzaC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZURhc2hPZmZzZXRdIExpbmVEYXNoT2Zmc2V0LlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gW2xpbmVKb2luXSBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZVdpZHRoXSBMaW5lV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pdGVyTGltaXRdIE1pdGVyTGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZpbGxQYXR0ZXJuU2NhbGVdIEZpbGwgcGF0dGVybiBzY2FsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0cm9rZVN0YXRlXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IGxpbmVDYXAgTGluZUNhcC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gbGluZURhc2ggTGluZURhc2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXQgTGluZURhc2hPZmZzZXQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBsaW5lSm9pbiBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lV2lkdGggTGluZVdpZHRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pdGVyTGltaXQgTWl0ZXJMaW1pdC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gc3Ryb2tlU3R5bGUgU3Ryb2tlU3R5bGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0U3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb250IEZvbnQuXG4gKiBAcHJvcGVydHkge0NhbnZhc1RleHRBbGlnbn0gW3RleHRBbGlnbl0gVGV4dEFsaWduLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXBlYXRdIFJlcGVhdC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvVGV4dC5qc1wiKS5UZXh0SnVzdGlmeX0gW2p1c3RpZnldIEp1c3RpZnkuXG4gKiBAcHJvcGVydHkge0NhbnZhc1RleHRCYXNlbGluZX0gdGV4dEJhc2VsaW5lIFRleHRCYXNlbGluZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvVGV4dC5qc1wiKS5UZXh0UGxhY2VtZW50fSBbcGxhY2VtZW50XSBQbGFjZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heEFuZ2xlXSBNYXhBbmdsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW292ZXJmbG93XSBPdmVyZmxvdy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvRmlsbC5qc1wiKS5kZWZhdWx0fSBbYmFja2dyb3VuZEZpbGxdIEJhY2tncm91bmRGaWxsLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHJva2UuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRTdHJva2VdIEJhY2tncm91bmRTdHJva2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3BhZGRpbmddIFBhZGRpbmcuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemFibGVJbnN0cnVjdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8Kj59IGluc3RydWN0aW9ucyBUaGUgcmVuZGVyaW5nIGluc3RydWN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8Kj59IGhpdERldGVjdGlvbkluc3RydWN0aW9ucyBUaGUgcmVuZGVyaW5nIGhpdCBkZXRlY3Rpb24gaW5zdHJ1Y3Rpb25zLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBUaGUgYXJyYXkgb2YgYWxsIGNvb3JkaW5hdGVzLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgVGV4dFN0YXRlPn0gW3RleHRTdGF0ZXNdIFRoZSB0ZXh0IHN0YXRlcyAoZGVjbHV0dGVyaW5nKS5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIEZpbGxTdGF0ZT59IFtmaWxsU3RhdGVzXSBUaGUgZmlsbCBzdGF0ZXMgKGRlY2x1dHRlcmluZykuXG4gKiBAcHJvcGVydHkgeyFPYmplY3Q8c3RyaW5nLCBTdHJva2VTdGF0ZT59IFtzdHJva2VTdGF0ZXNdIFRoZSBzdHJva2Ugc3RhdGVzIChkZWNsdXR0ZXJpbmcpLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdDxudW1iZXIsIGltcG9ydChcIi4vY2FudmFzL0V4ZWN1dG9yLmpzXCIpLlJlcGxheUltYWdlT3JMYWJlbEFyZ3M+fSBEZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0Rm9udCA9ICcxMHB4IHNhbnMtc2VyaWYnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGaWxsU3R5bGUgPSAnIzAwMCc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Q2FudmFzTGluZUNhcH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMaW5lQ2FwID0gJ3JvdW5kJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVEYXNoID0gW107XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVEYXNoT2Zmc2V0ID0gMDtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtDYW52YXNMaW5lSm9pbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMaW5lSm9pbiA9ICdyb3VuZCc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdE1pdGVyTGltaXQgPSAxMDtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFN0cm9rZVN0eWxlID0gJyMwMDAnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0NhbnZhc1RleHRBbGlnbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRUZXh0QWxpZ24gPSAnY2VudGVyJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtDYW52YXNUZXh0QmFzZWxpbmV9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0VGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMaW5lV2lkdGggPSAxO1xuXG4vKipcbiAqIEB0eXBlIHtCYXNlT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgY2hlY2tlZEZvbnRzID0gbmV3IEJhc2VPYmplY3QoKTtcblxuLyoqXG4gKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICovXG5sZXQgbWVhc3VyZUNvbnRleHQgPSBudWxsO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmxldCBtZWFzdXJlRm9udDtcblxuLyoqXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCB0ZXh0SGVpZ2h0cyA9IHt9O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbGFiZWwgY2FjaGUgd2hlbiBhIGZvbnQgYmVjb21lcyBhdmFpbGFibGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFNwZWMgQ1NTIGZvbnQgc3BlYy5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyRm9udCA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHJldHJpZXMgPSAxMDA7XG4gIGNvbnN0IHNpemUgPSAnMzJweCAnO1xuICBjb25zdCByZWZlcmVuY2VGb250cyA9IFsnbW9ub3NwYWNlJywgJ3NlcmlmJ107XG4gIGNvbnN0IGxlbiA9IHJlZmVyZW5jZUZvbnRzLmxlbmd0aDtcbiAgY29uc3QgdGV4dCA9ICd3bXl0emlsV01ZVFpJTEAjLyY/JCUxMFxcdUYwMTMnO1xuICBsZXQgaW50ZXJ2YWwsIHJlZmVyZW5jZVdpZHRoO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFN0eWxlIENzcyBmb250LXN0eWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250V2VpZ2h0IENzcyBmb250LXdlaWdodFxuICAgKiBAcGFyYW0geyp9IGZvbnRGYW1pbHkgQ3NzIGZvbnQtZmFtaWx5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEZvbnQgd2l0aCBzdHlsZSBhbmQgd2VpZ2h0IGlzIGF2YWlsYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNBdmFpbGFibGUoZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5KSB7XG4gICAgbGV0IGF2YWlsYWJsZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgcmVmZXJlbmNlRm9udCA9IHJlZmVyZW5jZUZvbnRzW2ldO1xuICAgICAgcmVmZXJlbmNlV2lkdGggPSBtZWFzdXJlVGV4dFdpZHRoKFxuICAgICAgICBmb250U3R5bGUgKyAnICcgKyBmb250V2VpZ2h0ICsgJyAnICsgc2l6ZSArIHJlZmVyZW5jZUZvbnQsXG4gICAgICAgIHRleHQsXG4gICAgICApO1xuICAgICAgaWYgKGZvbnRGYW1pbHkgIT0gcmVmZXJlbmNlRm9udCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoXG4gICAgICAgICAgZm9udFN0eWxlICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBmb250V2VpZ2h0ICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBzaXplICtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgK1xuICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgIHJlZmVyZW5jZUZvbnQsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgKTtcbiAgICAgICAgLy8gSWYgd2lkdGggYW5kIHJlZmVyZW5jZVdpZHRoIGFyZSB0aGUgc2FtZSwgdGhlbiB0aGUgZmFsbGJhY2sgd2FzIHVzZWRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZm9udCB3ZSB3YW50ZWQsIHNvIHRoZSBmb250IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgIGF2YWlsYWJsZSA9IGF2YWlsYWJsZSAmJiB3aWR0aCAhPSByZWZlcmVuY2VXaWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICBjb25zdCBmb250cyA9IGNoZWNrZWRGb250cy5nZXRLZXlzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm9udHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZm9udCA9IGZvbnRzW2ldO1xuICAgICAgaWYgKGNoZWNrZWRGb250cy5nZXQoZm9udCkgPCByZXRyaWVzKSB7XG4gICAgICAgIGNvbnN0IFtzdHlsZSwgd2VpZ2h0LCBmYW1pbHldID0gZm9udC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGlmIChpc0F2YWlsYWJsZShzdHlsZSwgd2VpZ2h0LCBmYW1pbHkpKSB7XG4gICAgICAgICAgY2xlYXIodGV4dEhlaWdodHMpO1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxvYWRlZCBmb250cyBhcmUgcGlja2VkIHVwIGJ5IFNhZmFyaVxuICAgICAgICAgIG1lYXN1cmVDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICBtZWFzdXJlRm9udCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjaGVja2VkRm9udHMuc2V0KGZvbnQsIHJldHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrZWRGb250cy5zZXQoZm9udCwgY2hlY2tlZEZvbnRzLmdldChmb250KSArIDEsIHRydWUpO1xuICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG9uZSkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBpbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZvbnRTcGVjKSB7XG4gICAgY29uc3QgZm9udCA9IGdldEZvbnRQYXJhbWV0ZXJzKGZvbnRTcGVjKTtcbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmFtaWxpZXMgPSBmb250LmZhbWlsaWVzO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZhbWlsaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGZhbWlseSA9IGZhbWlsaWVzW2ldO1xuICAgICAgY29uc3Qga2V5ID0gZm9udC5zdHlsZSArICdcXG4nICsgZm9udC53ZWlnaHQgKyAnXFxuJyArIGZhbWlseTtcbiAgICAgIGlmIChjaGVja2VkRm9udHMuZ2V0KGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGVja2VkRm9udHMuc2V0KGtleSwgcmV0cmllcywgdHJ1ZSk7XG4gICAgICAgIGlmICghaXNBdmFpbGFibGUoZm9udC5zdHlsZSwgZm9udC53ZWlnaHQsIGZhbWlseSkpIHtcbiAgICAgICAgICBjaGVja2VkRm9udHMuc2V0KGtleSwgMCwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKGludGVydmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2ssIDMyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IE1lYXN1cmVtZW50LlxuICovXG5leHBvcnQgY29uc3QgbWVhc3VyZVRleHRIZWlnaHQgPSAoZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgbGV0IG1lYXN1cmVFbGVtZW50O1xuICByZXR1cm4gZnVuY3Rpb24gKGZvbnRTcGVjKSB7XG4gICAgbGV0IGhlaWdodCA9IHRleHRIZWlnaHRzW2ZvbnRTcGVjXTtcbiAgICBpZiAoaGVpZ2h0ID09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKFdPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTKSB7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBnZXRGb250UGFyYW1ldGVycyhmb250U3BlYyk7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dChmb250U3BlYywgJ8W9ZycpO1xuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXNOYU4oTnVtYmVyKGZvbnQubGluZUhlaWdodCkpXG4gICAgICAgICAgPyAxLjJcbiAgICAgICAgICA6IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICAgICAgICBoZWlnaHQgPVxuICAgICAgICAgIGxpbmVIZWlnaHQgKlxuICAgICAgICAgIChtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFtZWFzdXJlRWxlbWVudCkge1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuaW5uZXJIVE1MID0gJ00nO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLm1pbkhlaWdodCA9ICcwJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSAnbm9uZSc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5sZWZ0ID0gJy05OTk5OXB4JztcbiAgICAgICAgfVxuICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5mb250ID0gZm9udFNwZWM7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWVhc3VyZUVsZW1lbnQpO1xuICAgICAgICBoZWlnaHQgPSBtZWFzdXJlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobWVhc3VyZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGV4dEhlaWdodHNbZm9udFNwZWNdID0gaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBGb250LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAqIEByZXR1cm4ge1RleHRNZXRyaWNzfSBUZXh0IG1ldHJpY3MuXG4gKi9cbmZ1bmN0aW9uIG1lYXN1cmVUZXh0KGZvbnQsIHRleHQpIHtcbiAgaWYgKCFtZWFzdXJlQ29udGV4dCkge1xuICAgIG1lYXN1cmVDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICB9XG4gIGlmIChmb250ICE9IG1lYXN1cmVGb250KSB7XG4gICAgbWVhc3VyZUNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgbWVhc3VyZUZvbnQgPSBtZWFzdXJlQ29udGV4dC5mb250O1xuICB9XG4gIHJldHVybiBtZWFzdXJlQ29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBGb250LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIHRleHQpIHtcbiAgcmV0dXJuIG1lYXN1cmVUZXh0KGZvbnQsIHRleHQpLndpZHRoO1xufVxuXG4vKipcbiAqIE1lYXN1cmUgdGV4dCB3aWR0aCB1c2luZyBhIGNhY2hlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgVGhlIGZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBtZWFzdXJlLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fSBjYWNoZSBBIGxvb2t1cCBvZiBjYWNoZWQgd2lkdGhzIGJ5IHRleHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0ZXh0IHdpZHRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoKGZvbnQsIHRleHQsIGNhY2hlKSB7XG4gIGlmICh0ZXh0IGluIGNhY2hlKSB7XG4gICAgcmV0dXJuIGNhY2hlW3RleHRdO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gdGV4dFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBNYXRoLm1heChwcmV2LCBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIGN1cnIpKSwgMCk7XG4gIGNhY2hlW3RleHRdID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHRTdGF0ZX0gYmFzZVN0eWxlIEJhc2Ugc3R5bGUuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGNodW5rcyBUZXh0IGNodW5rcyB0byBtZWFzdXJlLlxuICogQHJldHVybiB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB3aWR0aHM6IEFycmF5PG51bWJlcj4sIGhlaWdodHM6IEFycmF5PG51bWJlcj4sIGxpbmVXaWR0aHM6IEFycmF5PG51bWJlcj59fX0gVGV4dCBtZXRyaWNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dERpbWVuc2lvbnMoYmFzZVN0eWxlLCBjaHVua3MpIHtcbiAgY29uc3Qgd2lkdGhzID0gW107XG4gIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgY29uc3QgbGluZVdpZHRocyA9IFtdO1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgbGluZVdpZHRoID0gMDtcbiAgbGV0IGhlaWdodCA9IDA7XG4gIGxldCBsaW5lSGVpZ2h0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2h1bmtzLmxlbmd0aDsgaSA8PSBpaTsgaSArPSAyKSB7XG4gICAgY29uc3QgdGV4dCA9IGNodW5rc1tpXTtcbiAgICBpZiAodGV4dCA9PT0gJ1xcbicgfHwgaSA9PT0gaWkpIHtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcbiAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgIGxpbmVIZWlnaHQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSBjaHVua3NbaSArIDFdIHx8IGJhc2VTdHlsZS5mb250O1xuICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCk7XG4gICAgd2lkdGhzLnB1c2goY3VycmVudFdpZHRoKTtcbiAgICBsaW5lV2lkdGggKz0gY3VycmVudFdpZHRoO1xuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBtZWFzdXJlVGV4dEhlaWdodChmb250KTtcbiAgICBoZWlnaHRzLnB1c2goY3VycmVudEhlaWdodCk7XG4gICAgbGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGN1cnJlbnRIZWlnaHQpO1xuICB9XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodCwgd2lkdGhzLCBoZWlnaHRzLCBsaW5lV2lkdGhzfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggWCBvZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBZIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9aSW5kZXhDb250ZXh0LmpzXCIpLlpJbmRleENvbnRleHRQcm94eX0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfG51bGx9IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQHBhcmFtIHtMYWJlbHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IGxhYmVsT3JJbWFnZSBMYWJlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpbiBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblkgT3JpZ2luIFkuXG4gKiBAcGFyYW0ge251bWJlcn0gdyBXaWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoIEhlaWdodC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd0ltYWdlT3JMYWJlbChcbiAgY29udGV4dCxcbiAgdHJhbnNmb3JtLFxuICBvcGFjaXR5LFxuICBsYWJlbE9ySW1hZ2UsXG4gIG9yaWdpblgsXG4gIG9yaWdpblksXG4gIHcsXG4gIGgsXG4gIHgsXG4gIHksXG4gIHNjYWxlLFxuKSB7XG4gIGNvbnRleHQuc2F2ZSgpO1xuXG4gIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgaWYgKGNvbnRleHQuZ2xvYmFsQWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IChjb250ZXh0KSA9PiAoY29udGV4dC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5O1xuICAgIH1cbiAgfVxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgY29udGV4dC50cmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlmICgvKiogQHR5cGUgeyp9ICovIChsYWJlbE9ySW1hZ2UpLmNvbnRleHRJbnN0cnVjdGlvbnMpIHtcbiAgICAvLyBsYWJlbFxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQuc2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKTtcbiAgICBleGVjdXRlTGFiZWxJbnN0cnVjdGlvbnMoLyoqIEB0eXBlIHtMYWJlbH0gKi8gKGxhYmVsT3JJbWFnZSksIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHNjYWxlWzBdIDwgMCB8fCBzY2FsZVsxXSA8IDApIHtcbiAgICAvLyBmbGlwcGVkIGltYWdlXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5zY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChcbiAgICAgICAgbGFiZWxPckltYWdlXG4gICAgICApLFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICB3LFxuICAgICAgaCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpbWFnZSBub3QgZmxpcHBlZCB0cmFuc2xhdGUgYW5kIHNjYWxlIGNhbiBiZSBhdm9pZGVkXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gKi8gKFxuICAgICAgICBsYWJlbE9ySW1hZ2VcbiAgICAgICksXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3ICogc2NhbGVbMF0sXG4gICAgICBoICogc2NhbGVbMV0sXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRleHQucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsIExhYmVsLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZUxhYmVsSW5zdHJ1Y3Rpb25zKGxhYmVsLCBjb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRleHRJbnN0cnVjdGlvbnMgPSBsYWJlbC5jb250ZXh0SW5zdHJ1Y3Rpb25zO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb250ZXh0SW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0SW5zdHJ1Y3Rpb25zW2kgKyAxXSkpIHtcbiAgICAgIGNvbnRleHRbY29udGV4dEluc3RydWN0aW9uc1tpXV0uYXBwbHkoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnNbaSArIDFdLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dFtjb250ZXh0SW5zdHJ1Y3Rpb25zW2ldXSA9IGNvbnRleHRJbnN0cnVjdGlvbnNbaSArIDFdO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvWkluZGV4Q29udGV4dFxuICovXG5cbmltcG9ydCB7Z2V0U2hhcmVkQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuXG4vKiogQHR5cGVkZWYge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmIHtnbG9iYWxBbHBoYTogYW55fX0gWkluZGV4Q29udGV4dFByb3h5ICovXG5cbi8qKlxuICogQGV4dGVuZHMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xuY2xhc3MgWkluZGV4Q29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5PCo+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9uc18gPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1pJbmRleENvbnRleHRQcm94eX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRfID0gLyoqIEB0eXBlIHtaSW5kZXhDb250ZXh0UHJveHl9ICovIChcbiAgICAgIG5ldyBQcm94eShnZXRTaGFyZWRDYW52YXNDb250ZXh0MkQoKSwge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgeyp9ICovIChnZXRTaGFyZWRDYW52YXNDb250ZXh0MkQoKSlbcHJvcGVydHldKSAhPT1cbiAgICAgICAgICAgICdmdW5jdGlvbidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgYWNjZXB0IGNhbGxpbmcgZnVuY3Rpb25zIG9uIHRoZSBwcm94eSwgbm90IGFjY2Vzc2luZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10pIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnNfW3RoaXMuekluZGV4ICsgdGhpcy5vZmZzZXRfXS5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoTWV0aG9kQXJnc187XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLmluc3RydWN0aW9uc19bdGhpcy56SW5kZXggKyB0aGlzLm9mZnNldF9dKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RydWN0aW9uc19bdGhpcy56SW5kZXggKyB0aGlzLm9mZnNldF9dID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10ucHVzaChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmdzLlxuICAgKiBAcmV0dXJuIHtaSW5kZXhDb250ZXh0fSBUaGlzLlxuICAgKi9cbiAgcHVzaE1ldGhvZEFyZ3NfID0gKC4uLmFyZ3MpID0+IHtcbiAgICB0aGlzLmluc3RydWN0aW9uc19bdGhpcy56SW5kZXggKyB0aGlzLm9mZnNldF9dLnB1c2goYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdG8gdGhlIGNvbnRleHQgZGlyZWN0bHkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZH0gcmVuZGVyIEZ1bmN0aW9uLlxuICAgKi9cbiAgcHVzaEZ1bmN0aW9uKHJlbmRlcikge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10ucHVzaChyZW5kZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHByb3h5IGZvciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBnZXR0aW5nIHN0YXRlXG4gICAqIChlLmcuIGBjb250ZXh0Lmdsb2JhbEFscGhhYCwgd2hpY2ggd2lsbCByZXR1cm4gYHVuZGVmaW5lZGApLiBUbyBzZXQgc3RhdGUsIGlmIGl0IHJlbGllcyBvbiBhXG4gICAqIHByZXZpb3VzIHN0YXRlIChlLmcuIGBjb250ZXh0Lmdsb2JhbEFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYSAvIDJgKSwgc2V0IGEgZnVuY3Rpb24sXG4gICAqIGUuZy4gYGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAoY29udGV4dCkgPT4gY29udGV4dC5nbG9iYWxBbHBoYSAvIDJgLlxuICAgKiBAcmV0dXJuIHtaSW5kZXhDb250ZXh0UHJveHl9IENvbnRleHQuXG4gICAqL1xuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqL1xuICBkcmF3KGNvbnRleHQpIHtcbiAgICB0aGlzLmluc3RydWN0aW9uc18uZm9yRWFjaCgoaW5zdHJ1Y3Rpb25zQXRJbmRleCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5zdHJ1Y3Rpb25zQXRJbmRleC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gaW5zdHJ1Y3Rpb25zQXRJbmRleFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3BlcnR5KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uQXRJbmRleCA9IGluc3RydWN0aW9uc0F0SW5kZXhbKytpXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoLyoqIEB0eXBlIHsqfSAqLyAoY29udGV4dClbcHJvcGVydHldKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8qKiBAdHlwZSB7Kn0gKi8gKGNvbnRleHQpW3Byb3BlcnR5XSguLi5pbnN0cnVjdGlvbkF0SW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb25BdEluZGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyp9ICovIChjb250ZXh0KVtwcm9wZXJ0eV0gPSBpbnN0cnVjdGlvbkF0SW5kZXgoY29udGV4dCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEB0eXBlIHsqfSAqLyAoY29udGV4dClbcHJvcGVydHldID0gaW5zdHJ1Y3Rpb25BdEluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmluc3RydWN0aW9uc18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5vZmZzZXRfID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPZmZzZXRzIHRoZSB6SW5kZXggYnkgdGhlIGhpZ2hlc3QgY3VycmVudCB6SW5kZXguIFVzZWZ1bCBmb3IgcmVuZGVyaW5nIG11bHRpcGxlIHdvcmxkcyBvciB0aWxlcywgdG9cbiAgICogYXZvaWQgY29uZmxpY3RpbmcgY29udGV4dC5jbGlwKCkgb3IgY29udGV4dC5zYXZlKCkvcmVzdG9yZSgpIGNhbGxzLlxuICAgKi9cbiAgb2Zmc2V0KCkge1xuICAgIHRoaXMub2Zmc2V0XyA9IHRoaXMuaW5zdHJ1Y3Rpb25zXy5sZW5ndGg7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpJbmRleENvbnRleHQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9zdHlsZVxuICovXG5cbmltcG9ydCBDaXJjbGUgZnJvbSAnLi4vLi4vc3R5bGUvQ2lyY2xlLmpzJztcbmltcG9ydCBGaWxsIGZyb20gJy4uLy4uL3N0eWxlL0ZpbGwuanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vLi4vc3R5bGUvSWNvbi5qcyc7XG5pbXBvcnQgUmVndWxhclNoYXBlIGZyb20gJy4uLy4uL3N0eWxlL1JlZ3VsYXJTaGFwZS5qcyc7XG5pbXBvcnQgU3Ryb2tlIGZyb20gJy4uLy4uL3N0eWxlL1N0cm9rZS5qcyc7XG5pbXBvcnQgU3R5bGUgZnJvbSAnLi4vLi4vc3R5bGUvU3R5bGUuanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi4vLi4vc3R5bGUvVGV4dC5qcyc7XG5pbXBvcnQge1xuICBCb29sZWFuVHlwZSxcbiAgQ29sb3JUeXBlLFxuICBOdW1iZXJBcnJheVR5cGUsXG4gIE51bWJlclR5cGUsXG4gIFN0cmluZ1R5cGUsXG4gIGNvbXB1dGVHZW9tZXRyeVR5cGUsXG4gIG5ld1BhcnNpbmdDb250ZXh0LFxufSBmcm9tICcuLi8uLi9leHByL2V4cHJlc3Npb24uanMnO1xuaW1wb3J0IHtOT19DT0xPUn0gZnJvbSAnLi4vLi4vY29sb3IuanMnO1xuaW1wb3J0IHtidWlsZEV4cHJlc3Npb24sIG5ld0V2YWx1YXRpb25Db250ZXh0fSBmcm9tICcuLi8uLi9leHByL2NwdS5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uLy4uL29iai5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBpbmNsdWRlcyBmdW5jdGlvbnMgdG8gYnVpbGQgc3R5bGVzIGZvciB0aGUgY2FudmFzIHJlbmRlcmVyLiAgQnVpbGRpbmdcbiAqIGlzIGNvbXBvc2VkIG9mIHR3byBzdGVwczogcGFyc2luZyBhbmQgY29tcGlsaW5nLiAgVGhlIHBhcnNpbmcgc3RlcCB0YWtlcyBhbiBlbmNvZGVkIGV4cHJlc3Npb25cbiAqIGFuZCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIG9uZSBvZiB0aGUgZXhwcmVzc2lvbiBjbGFzc2VzLiAgVGhlIGNvbXBpbGluZyBzdGVwIHRha2VzIHRoZVxuICogZXhwcmVzc2lvbiBpbnN0YW5jZSBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGV2YWx1YXRlZCB0byByZXR1cm4gYSBsaXRlcmFsIHZhbHVlLiAgVGhlXG4gKiBldmFsdWF0b3IgZnVuY3Rpb24gc2hvdWxkIGRvIGFzIGxpdHRsZSBhbGxvY2F0aW9uIGFuZCB3b3JrIGFzIHBvc3NpYmxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlfSBGbGF0U3R5bGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9leHByL2V4cHJlc3Npb24uanNcIikuRW5jb2RlZEV4cHJlc3Npb259IEVuY29kZWRFeHByZXNzaW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9leHByZXNzaW9uLmpzXCIpLlBhcnNpbmdDb250ZXh0fSBQYXJzaW5nQ29udGV4dFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2V4cHIvZXhwcmVzc2lvbi5qc1wiKS5DYWxsRXhwcmVzc2lvbn0gQ2FsbEV4cHJlc3Npb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9leHByL2NwdS5qc1wiKS5FdmFsdWF0aW9uQ29udGV4dH0gRXZhbHVhdGlvbkNvbnRleHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9leHByL2NwdS5qc1wiKS5FeHByZXNzaW9uRXZhbHVhdG9yfSBFeHByZXNzaW9uRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0V2YWx1YXRpb25Db250ZXh0fSBjb250ZXh0IFRoZSBldmFsdWF0aW9uIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBBbHdheXMgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gYWx3YXlzKGNvbnRleHQpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGFwdHMgYSBydWxlIGV2YWx1YXRvciB0byB0aGUgZXhpc3Rpbmcgc3R5bGUgZnVuY3Rpb24gaW50ZXJmYWNlLlxuICogQWZ0ZXIgd2UgaGF2ZSBkZXByZWNhdGVkIHRoZSBzdHlsZSBmdW5jdGlvbiwgd2UgY2FuIHVzZSB0aGUgY29tcGlsZWQgcnVsZXMgZGlyZWN0bHlcbiAqIGFuZCBwYXNzIGEgbW9yZSBjb21wbGV0ZSBldmFsdWF0aW9uIGNvbnRleHQgKHZhcmlhYmxlcywgem9vbSwgdGltZSwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uLy4uL3N0eWxlL2ZsYXQuanMnKS5SdWxlPn0gcnVsZXMgVGhlIHJ1bGVzLlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9zdHlsZS9TdHlsZS5qcycpLlN0eWxlRnVuY3Rpb259IEEgc3R5bGUgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydWxlc1RvU3R5bGVGdW5jdGlvbihydWxlcykge1xuICBjb25zdCBwYXJzaW5nQ29udGV4dCA9IG5ld1BhcnNpbmdDb250ZXh0KCk7XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkUnVsZVNldChydWxlcywgcGFyc2luZ0NvbnRleHQpO1xuICBjb25zdCBldmFsdWF0aW9uQ29udGV4dCA9IG5ld0V2YWx1YXRpb25Db250ZXh0KCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIGV2YWx1YXRpb25Db250ZXh0LnByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXNJbnRlcm5hbCgpO1xuICAgIGV2YWx1YXRpb25Db250ZXh0LnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIGlmIChwYXJzaW5nQ29udGV4dC5mZWF0dXJlSWQpIHtcbiAgICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXZhbHVhdGlvbkNvbnRleHQuZmVhdHVyZUlkID0gaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmFsdWF0aW9uQ29udGV4dC5mZWF0dXJlSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2luZ0NvbnRleHQuZ2VvbWV0cnlUeXBlKSB7XG4gICAgICBldmFsdWF0aW9uQ29udGV4dC5nZW9tZXRyeVR5cGUgPSBjb21wdXRlR2VvbWV0cnlUeXBlKFxuICAgICAgICBmZWF0dXJlLmdldEdlb21ldHJ5KCksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZXZhbHVhdG9yKGV2YWx1YXRpb25Db250ZXh0KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkYXB0cyBhIHN0eWxlIGV2YWx1YXRvciB0byB0aGUgZXhpc3Rpbmcgc3R5bGUgZnVuY3Rpb24gaW50ZXJmYWNlLlxuICogQWZ0ZXIgd2UgaGF2ZSBkZXByZWNhdGVkIHRoZSBzdHlsZSBmdW5jdGlvbiwgd2UgY2FuIHVzZSB0aGUgY29tcGlsZWQgcnVsZXMgZGlyZWN0bHlcbiAqIGFuZCBwYXNzIGEgbW9yZSBjb21wbGV0ZSBldmFsdWF0aW9uIGNvbnRleHQgKHZhcmlhYmxlcywgem9vbSwgdGltZSwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uLy4uL3N0eWxlL2ZsYXQuanMnKS5GbGF0U3R5bGU+fSBmbGF0U3R5bGVzIFRoZSBmbGF0IHN0eWxlcy5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vc3R5bGUvU3R5bGUuanMnKS5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbihmbGF0U3R5bGVzKSB7XG4gIGNvbnN0IHBhcnNpbmdDb250ZXh0ID0gbmV3UGFyc2luZ0NvbnRleHQoKTtcbiAgY29uc3QgbGVuZ3RoID0gZmxhdFN0eWxlcy5sZW5ndGg7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxTdHlsZUV2YWx1YXRvcj59XG4gICAqL1xuICBjb25zdCBldmFsdWF0b3JzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBldmFsdWF0b3JzW2ldID0gYnVpbGRTdHlsZShmbGF0U3R5bGVzW2ldLCBwYXJzaW5nQ29udGV4dCk7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGlvbkNvbnRleHQgPSBuZXdFdmFsdWF0aW9uQ29udGV4dCgpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgKi9cbiAgY29uc3Qgc3R5bGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgZXZhbHVhdGlvbkNvbnRleHQucHJvcGVydGllcyA9IGZlYXR1cmUuZ2V0UHJvcGVydGllc0ludGVybmFsKCk7XG4gICAgZXZhbHVhdGlvbkNvbnRleHQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgaWYgKHBhcnNpbmdDb250ZXh0LmZlYXR1cmVJZCkge1xuICAgICAgY29uc3QgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBldmFsdWF0aW9uQ29udGV4dC5mZWF0dXJlSWQgPSBpZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2YWx1YXRpb25Db250ZXh0LmZlYXR1cmVJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBub25OdWxsQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gZXZhbHVhdG9yc1tpXShldmFsdWF0aW9uQ29udGV4dCk7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgc3R5bGVzW25vbk51bGxDb3VudF0gPSBzdHlsZTtcbiAgICAgICAgbm9uTnVsbENvdW50ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHN0eWxlcy5sZW5ndGggPSBub25OdWxsQ291bnQ7XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOkFycmF5PFN0eWxlPn0gUnVsZVNldEV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29tcGlsZWRSdWxlXG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb25FdmFsdWF0b3J9IGZpbHRlciBUaGUgY29tcGlsZWQgZmlsdGVyIGV2YWx1YXRvci5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8U3R5bGVFdmFsdWF0b3I+fSBzdHlsZXMgVGhlIGxpc3Qgb2YgY29tcGlsZWQgc3R5bGUgZXZhbHVhdG9ycy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi8uLi9zdHlsZS9mbGF0LmpzJykuUnVsZT59IHJ1bGVzIFRoZSBydWxlcy5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge1J1bGVTZXRFdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFJ1bGVTZXQocnVsZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgbGVuZ3RoID0gcnVsZXMubGVuZ3RoO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8Q29tcGlsZWRSdWxlPn1cbiAgICovXG4gIGNvbnN0IGNvbXBpbGVkUnVsZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVzW2ldO1xuICAgIGNvbnN0IGZpbHRlciA9XG4gICAgICAnZmlsdGVyJyBpbiBydWxlXG4gICAgICAgID8gYnVpbGRFeHByZXNzaW9uKHJ1bGUuZmlsdGVyLCBCb29sZWFuVHlwZSwgY29udGV4dClcbiAgICAgICAgOiBhbHdheXM7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3R5bGVFdmFsdWF0b3I+fVxuICAgICAqL1xuICAgIGxldCBzdHlsZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZS5zdHlsZSkpIHtcbiAgICAgIGNvbnN0IHN0eWxlTGVuZ3RoID0gcnVsZS5zdHlsZS5sZW5ndGg7XG4gICAgICBzdHlsZXMgPSBuZXcgQXJyYXkoc3R5bGVMZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHlsZUxlbmd0aDsgKytqKSB7XG4gICAgICAgIHN0eWxlc1tqXSA9IGJ1aWxkU3R5bGUocnVsZS5zdHlsZVtqXSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtidWlsZFN0eWxlKHJ1bGUuc3R5bGUsIGNvbnRleHQpXTtcbiAgICB9XG5cbiAgICBjb21waWxlZFJ1bGVzW2ldID0ge2ZpbHRlciwgc3R5bGVzfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdHlsZT59XG4gICAgICovXG4gICAgY29uc3Qgc3R5bGVzID0gW107XG5cbiAgICBsZXQgc29tZU1hdGNoZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBmaWx0ZXJFdmFsdWF0b3IgPSBjb21waWxlZFJ1bGVzW2ldLmZpbHRlcjtcbiAgICAgIGlmICghZmlsdGVyRXZhbHVhdG9yKGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJ1bGVzW2ldLmVsc2UgJiYgc29tZU1hdGNoZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb21lTWF0Y2hlZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IHN0eWxlRXZhbHVhdG9yIG9mIGNvbXBpbGVkUnVsZXNbaV0uc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVFdmFsdWF0b3IoY29udGV4dCk7XG4gICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZXMucHVzaChzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOlN0eWxlfG51bGx9IFN0eWxlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIEEgZmxhdCBzdHlsZSBsaXRlcmFsLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7U3R5bGVFdmFsdWF0b3J9IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYSBzdHlsZS4gIFRoZSBzdHlsZSByZXR1cm5lZCBieVxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJldXNlZCBiZXR3ZWVuIGludm9jYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTdHlsZShmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgJycsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVN0cm9rZSA9IGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgJycsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVRleHQgPSBidWlsZFRleHQoZmxhdFN0eWxlLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVJbWFnZSA9IGJ1aWxkSW1hZ2UoZmxhdFN0eWxlLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVaSW5kZXggPSBudW1iZXJFdmFsdWF0b3IoZmxhdFN0eWxlLCAnei1pbmRleCcsIGNvbnRleHQpO1xuXG4gIGlmIChcbiAgICAhZXZhbHVhdGVGaWxsICYmXG4gICAgIWV2YWx1YXRlU3Ryb2tlICYmXG4gICAgIWV2YWx1YXRlVGV4dCAmJlxuICAgICFldmFsdWF0ZUltYWdlICYmXG4gICAgIWlzRW1wdHkoZmxhdFN0eWxlKVxuICApIHtcbiAgICAvLyBhc3N1bWUgdGhpcyBpcyBhIHVzZXIgZXJyb3JcbiAgICAvLyB3b3VsZCBiZSBuaWNlIHRvIGNoZWNrIHRoZSBwcm9wZXJ0aWVzIGFuZCBzdWdnZXN0IFwiZGlkIHlvdSBtZWFuLi4uXCJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnTm8gZmlsbCwgc3Ryb2tlLCBwb2ludCwgb3IgdGV4dCBzeW1ib2xpemVyIHByb3BlcnRpZXMgaW4gc3R5bGU6ICcgK1xuICAgICAgICBKU09OLnN0cmluZ2lmeShmbGF0U3R5bGUpLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IG5ldyBTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGlmIChldmFsdWF0ZUZpbGwpIHtcbiAgICAgIGNvbnN0IGZpbGwgPSBldmFsdWF0ZUZpbGwoY29udGV4dCk7XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3R5bGUuc2V0RmlsbChmaWxsKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICBjb25zdCBzdHJva2UgPSBldmFsdWF0ZVN0cm9rZShjb250ZXh0KTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldFN0cm9rZShzdHJva2UpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVUZXh0KSB7XG4gICAgICBjb25zdCB0ZXh0ID0gZXZhbHVhdGVUZXh0KGNvbnRleHQpO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldFRleHQodGV4dCk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZUltYWdlKSB7XG4gICAgICBjb25zdCBpbWFnZSA9IGV2YWx1YXRlSW1hZ2UoY29udGV4dCk7XG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldEltYWdlKGltYWdlKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlWkluZGV4KSB7XG4gICAgICBzdHlsZS5zZXRaSW5kZXgoZXZhbHVhdGVaSW5kZXgoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpGaWxsfG51bGx9IEZpbGxFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtGaWxsRXZhbHVhdG9yP30gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhIGZpbGwuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRmlsbChmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCkge1xuICBsZXQgZXZhbHVhdGVDb2xvcjtcbiAgaWYgKHByZWZpeCArICdmaWxsLXBhdHRlcm4tc3JjJyBpbiBmbGF0U3R5bGUpIHtcbiAgICBldmFsdWF0ZUNvbG9yID0gcGF0dGVybkV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdmaWxsLScsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChmbGF0U3R5bGVbcHJlZml4ICsgJ2ZpbGwtY29sb3InXSA9PT0gJ25vbmUnKSB7XG4gICAgICAvLyBhdm9pZHMgaGl0IGRldGVjdGlvblxuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBudWxsO1xuICAgIH1cblxuICAgIGV2YWx1YXRlQ29sb3IgPSBjb2xvckxpa2VFdmFsdWF0b3IoXG4gICAgICBmbGF0U3R5bGUsXG4gICAgICBwcmVmaXggKyAnZmlsbC1jb2xvcicsXG4gICAgICBjb250ZXh0LFxuICAgICk7XG4gIH1cbiAgaWYgKCFldmFsdWF0ZUNvbG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBmaWxsID0gbmV3IEZpbGwoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgY29uc3QgY29sb3IgPSBldmFsdWF0ZUNvbG9yKGNvbnRleHQpO1xuICAgIGlmIChjb2xvciA9PT0gTk9fQ09MT1IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmaWxsLnNldENvbG9yKGNvbG9yKTtcbiAgICByZXR1cm4gZmlsbDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOlN0cm9rZXxudWxsfSBTdHJva2VFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtTdHJva2VFdmFsdWF0b3I/fSBBIGZ1bmN0aW9uIHRoZSBldmFsdWF0ZXMgdG8gYSBzdHJva2UuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KSB7XG4gIGNvbnN0IGV2YWx1YXRlV2lkdGggPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2Utd2lkdGgnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVDb2xvciA9IGNvbG9yTGlrZUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS1jb2xvcicsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBpZiAoIWV2YWx1YXRlV2lkdGggJiYgIWV2YWx1YXRlQ29sb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRlTGluZUNhcCA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS1saW5lLWNhcCcsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUxpbmVKb2luID0gc3RyaW5nRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWxpbmUtam9pbicsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUxpbmVEYXNoID0gbnVtYmVyQXJyYXlFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbGluZS1kYXNoJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlTGluZURhc2hPZmZzZXQgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbGluZS1kYXNoLW9mZnNldCcsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU1pdGVyTGltaXQgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbWl0ZXItbGltaXQnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3Qgc3Ryb2tlID0gbmV3IFN0cm9rZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoZXZhbHVhdGVDb2xvcikge1xuICAgICAgY29uc3QgY29sb3IgPSBldmFsdWF0ZUNvbG9yKGNvbnRleHQpO1xuICAgICAgaWYgKGNvbG9yID09PSBOT19DT0xPUikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0cm9rZS5zZXRDb2xvcihjb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlV2lkdGgpIHtcbiAgICAgIHN0cm9rZS5zZXRXaWR0aChldmFsdWF0ZVdpZHRoKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVMaW5lQ2FwKSB7XG4gICAgICBjb25zdCBsaW5lQ2FwID0gZXZhbHVhdGVMaW5lQ2FwKGNvbnRleHQpO1xuICAgICAgaWYgKGxpbmVDYXAgIT09ICdidXR0JyAmJiBsaW5lQ2FwICE9PSAncm91bmQnICYmIGxpbmVDYXAgIT09ICdzcXVhcmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYnV0dCwgcm91bmQsIG9yIHNxdWFyZSBsaW5lIGNhcCcpO1xuICAgICAgfVxuICAgICAgc3Ryb2tlLnNldExpbmVDYXAobGluZUNhcCk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTGluZUpvaW4pIHtcbiAgICAgIGNvbnN0IGxpbmVKb2luID0gZXZhbHVhdGVMaW5lSm9pbihjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgbGluZUpvaW4gIT09ICdiZXZlbCcgJiZcbiAgICAgICAgbGluZUpvaW4gIT09ICdyb3VuZCcgJiZcbiAgICAgICAgbGluZUpvaW4gIT09ICdtaXRlcidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIgbGluZSBqb2luJyk7XG4gICAgICB9XG4gICAgICBzdHJva2Uuc2V0TGluZUpvaW4obGluZUpvaW4pO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUxpbmVEYXNoKSB7XG4gICAgICBzdHJva2Uuc2V0TGluZURhc2goZXZhbHVhdGVMaW5lRGFzaChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTGluZURhc2hPZmZzZXQpIHtcbiAgICAgIHN0cm9rZS5zZXRMaW5lRGFzaE9mZnNldChldmFsdWF0ZUxpbmVEYXNoT2Zmc2V0KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVNaXRlckxpbWl0KSB7XG4gICAgICBzdHJva2Uuc2V0TWl0ZXJMaW1pdChldmFsdWF0ZU1pdGVyTGltaXQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJva2U7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpUZXh0fSBUZXh0RXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7VGV4dEV2YWx1YXRvcj99IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYSB0ZXh0IHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVGV4dChmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZml4ID0gJ3RleHQtJztcblxuICAvLyBDdXJyZW50bHksIGFuIEFycmF5PHN0cmluZz4gbWF5IGJlIHVzZWQgZm9yIHJpY2ggdGV4dCBzdXBwb3J0LiAgVGhpcyBkb2Vzbid0XG4gIC8vIHdvcmsgd2l0aCBvdXIgZXhwcmVzc2lvbiBzeW50YXggd2hlcmUgYXJyYXlzIG9mIHN0cmluZ3MgYXJlIGludGVycHJldGVkIGFzXG4gIC8vIGNhbGwgZXhwcmVzc2lvbnMuICBUbyBzdXBwb3J0IHJpY2ggdGV4dCwgd2UgY291bGQgYWRkIGEgJ3N0cmluZ3MnIG9wZXJhdG9yXG4gIC8vIHdoZXJlIGFsbCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50cyB3b3VsZCBiZSBzdHJpbmcgdmFsdWVzLlxuICBjb25zdCBldmFsdWF0ZVZhbHVlID0gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3ZhbHVlJywgY29udGV4dCk7XG4gIGlmICghZXZhbHVhdGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUJhY2tncm91bmRGaWxsID0gYnVpbGRGaWxsKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnYmFja2dyb3VuZC0nLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVTdHJva2UgPSBidWlsZFN0cm9rZShmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG5cbiAgY29uc3QgZXZhbHVhdGVCYWNrZ3JvdW5kU3Ryb2tlID0gYnVpbGRTdHJva2UoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdiYWNrZ3JvdW5kLScsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUZvbnQgPSBzdHJpbmdFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAnZm9udCcsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlTWF4QW5nbGUgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdtYXgtYW5nbGUnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVPZmZzZXRYID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnb2Zmc2V0LXgnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVPZmZzZXRZID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnb2Zmc2V0LXknLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVPdmVyZmxvdyA9IGJvb2xlYW5FdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdvdmVyZmxvdycsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVBsYWNlbWVudCA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3BsYWNlbWVudCcsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVJlcGVhdCA9IG51bWJlckV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdyZXBlYXQnLCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZVNjYWxlID0gc2l6ZUxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAnc2NhbGUnLCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3ID0gYm9vbGVhbkV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0ZS13aXRoLXZpZXcnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVSb3RhdGlvbiA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0aW9uJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlQWxpZ24gPSBzdHJpbmdFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAnYWxpZ24nLCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUp1c3RpZnkgPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdqdXN0aWZ5JyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlQmFzZWxpbmUgPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdiYXNlbGluZScsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUtlZXBVcHJpZ2h0ID0gYm9vbGVhbkV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2tlZXAtdXByaWdodCcsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVBhZGRpbmcgPSBudW1iZXJBcnJheUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3BhZGRpbmcnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3QgY3VycmVudGx5IHNldHRhYmxlXG4gIGNvbnN0IGRlY2x1dHRlck1vZGUgPSBvcHRpb25hbERlY2x1dHRlck1vZGUoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkZWNsdXR0ZXItbW9kZScsXG4gICk7XG5cbiAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KHtkZWNsdXR0ZXJNb2RlfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGV4dC5zZXRUZXh0KGV2YWx1YXRlVmFsdWUoY29udGV4dCkpO1xuXG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgdGV4dC5zZXRGaWxsKGV2YWx1YXRlRmlsbChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQmFja2dyb3VuZEZpbGwpIHtcbiAgICAgIHRleHQuc2V0QmFja2dyb3VuZEZpbGwoZXZhbHVhdGVCYWNrZ3JvdW5kRmlsbChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICB0ZXh0LnNldFN0cm9rZShldmFsdWF0ZVN0cm9rZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQmFja2dyb3VuZFN0cm9rZSkge1xuICAgICAgdGV4dC5zZXRCYWNrZ3JvdW5kU3Ryb2tlKGV2YWx1YXRlQmFja2dyb3VuZFN0cm9rZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlRm9udCkge1xuICAgICAgdGV4dC5zZXRGb250KGV2YWx1YXRlRm9udChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTWF4QW5nbGUpIHtcbiAgICAgIHRleHQuc2V0TWF4QW5nbGUoZXZhbHVhdGVNYXhBbmdsZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT2Zmc2V0WCkge1xuICAgICAgdGV4dC5zZXRPZmZzZXRYKGV2YWx1YXRlT2Zmc2V0WChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT2Zmc2V0WSkge1xuICAgICAgdGV4dC5zZXRPZmZzZXRZKGV2YWx1YXRlT2Zmc2V0WShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT3ZlcmZsb3cpIHtcbiAgICAgIHRleHQuc2V0T3ZlcmZsb3coZXZhbHVhdGVPdmVyZmxvdyhjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUGxhY2VtZW50KSB7XG4gICAgICBjb25zdCBwbGFjZW1lbnQgPSBldmFsdWF0ZVBsYWNlbWVudChjb250ZXh0KTtcbiAgICAgIGlmIChwbGFjZW1lbnQgIT09ICdwb2ludCcgJiYgcGxhY2VtZW50ICE9PSAnbGluZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb2ludCBvciBsaW5lIGZvciB0ZXh0LXBsYWNlbWVudCcpO1xuICAgICAgfVxuICAgICAgdGV4dC5zZXRQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSZXBlYXQpIHtcbiAgICAgIHRleHQuc2V0UmVwZWF0KGV2YWx1YXRlUmVwZWF0KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVTY2FsZSkge1xuICAgICAgdGV4dC5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGVXaXRoVmlldykge1xuICAgICAgdGV4dC5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGlvbikge1xuICAgICAgdGV4dC5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVBbGlnbikge1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gZXZhbHVhdGVBbGlnbihjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgdGV4dEFsaWduICE9PSAnbGVmdCcgJiZcbiAgICAgICAgdGV4dEFsaWduICE9PSAnY2VudGVyJyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdyaWdodCcgJiZcbiAgICAgICAgdGV4dEFsaWduICE9PSAnZW5kJyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdzdGFydCdcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGxlZnQsIHJpZ2h0LCBjZW50ZXIsIHN0YXJ0LCBvciBlbmQgZm9yIHRleHQtYWxpZ24nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGV4dC5zZXRUZXh0QWxpZ24odGV4dEFsaWduKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVKdXN0aWZ5KSB7XG4gICAgICBjb25zdCBqdXN0aWZ5ID0gZXZhbHVhdGVKdXN0aWZ5KGNvbnRleHQpO1xuICAgICAgaWYgKGp1c3RpZnkgIT09ICdsZWZ0JyAmJiBqdXN0aWZ5ICE9PSAncmlnaHQnICYmIGp1c3RpZnkgIT09ICdjZW50ZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGVmdCwgcmlnaHQsIG9yIGNlbnRlciBmb3IgdGV4dC1qdXN0aWZ5Jyk7XG4gICAgICB9XG4gICAgICB0ZXh0LnNldEp1c3RpZnkoanVzdGlmeSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQmFzZWxpbmUpIHtcbiAgICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IGV2YWx1YXRlQmFzZWxpbmUoY29udGV4dCk7XG4gICAgICBpZiAoXG4gICAgICAgIHRleHRCYXNlbGluZSAhPT0gJ2JvdHRvbScgJiZcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAndG9wJyAmJlxuICAgICAgICB0ZXh0QmFzZWxpbmUgIT09ICdtaWRkbGUnICYmXG4gICAgICAgIHRleHRCYXNlbGluZSAhPT0gJ2FscGhhYmV0aWMnICYmXG4gICAgICAgIHRleHRCYXNlbGluZSAhPT0gJ2hhbmdpbmcnXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCBib3R0b20sIHRvcCwgbWlkZGxlLCBhbHBoYWJldGljLCBvciBoYW5naW5nIGZvciB0ZXh0LWJhc2VsaW5lJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRleHQuc2V0VGV4dEJhc2VsaW5lKHRleHRCYXNlbGluZSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUGFkZGluZykge1xuICAgICAgdGV4dC5zZXRQYWRkaW5nKGV2YWx1YXRlUGFkZGluZyhjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlS2VlcFVwcmlnaHQpIHtcbiAgICAgIHRleHQuc2V0S2VlcFVwcmlnaHQoZXZhbHVhdGVLZWVwVXByaWdodChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTppbXBvcnQoXCIuLi8uLi9zdHlsZS9JbWFnZS5qc1wiKS5kZWZhdWx0fSBJbWFnZUV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0ltYWdlRXZhbHVhdG9yP30gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBpbWFnZSBzeW1ib2xpemVyLlxuICovXG5mdW5jdGlvbiBidWlsZEltYWdlKGZsYXRTdHlsZSwgY29udGV4dCkge1xuICBpZiAoJ2ljb24tc3JjJyBpbiBmbGF0U3R5bGUpIHtcbiAgICByZXR1cm4gYnVpbGRJY29uKGZsYXRTdHlsZSwgY29udGV4dCk7XG4gIH1cblxuICBpZiAoJ3NoYXBlLXBvaW50cycgaW4gZmxhdFN0eWxlKSB7XG4gICAgcmV0dXJuIGJ1aWxkU2hhcGUoZmxhdFN0eWxlLCBjb250ZXh0KTtcbiAgfVxuXG4gIGlmICgnY2lyY2xlLXJhZGl1cycgaW4gZmxhdFN0eWxlKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ2lyY2xlKGZsYXRTdHlsZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7SW1hZ2VFdmFsdWF0b3J9IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYW4gaW1hZ2Ugc3ltYm9saXplci5cbiAqL1xuZnVuY3Rpb24gYnVpbGRJY29uKGZsYXRTdHlsZSwgY29udGV4dCkge1xuICBjb25zdCBwcmVmaXggPSAnaWNvbi0nO1xuXG4gIC8vIHJlcXVpcmVkIHByb3BlcnR5XG4gIGNvbnN0IHNyY05hbWUgPSBwcmVmaXggKyAnc3JjJztcbiAgY29uc3Qgc3JjID0gcmVxdWlyZVN0cmluZyhmbGF0U3R5bGVbc3JjTmFtZV0sIHNyY05hbWUpO1xuXG4gIC8vIHNldHRhYmxlIHByb3BlcnRpZXNcbiAgY29uc3QgZXZhbHVhdGVBbmNob3IgPSBjb29yZGluYXRlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnYW5jaG9yJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlT3BhY2l0eSA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ29wYWNpdHknLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVEaXNwbGFjZW1lbnQgPSBjb29yZGluYXRlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGlzcGxhY2VtZW50JyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUm90YXRpb24gPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGlvbicsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3ID0gYm9vbGVhbkV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0ZS13aXRoLXZpZXcnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgLy8gdGhlIHJlbWFpbmluZyBzeW1ib2xpemVyIHByb3BlcnRpZXMgYXJlIG5vdCBjdXJyZW50bHkgc2V0dGFibGVcbiAgY29uc3QgYW5jaG9yT3JpZ2luID0gb3B0aW9uYWxJY29uT3JpZ2luKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2FuY2hvci1vcmlnaW4nKTtcbiAgY29uc3QgYW5jaG9yWFVuaXRzID0gb3B0aW9uYWxJY29uQW5jaG9yVW5pdHMoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdhbmNob3IteC11bml0cycsXG4gICk7XG4gIGNvbnN0IGFuY2hvcllVbml0cyA9IG9wdGlvbmFsSWNvbkFuY2hvclVuaXRzKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnYW5jaG9yLXktdW5pdHMnLFxuICApO1xuICBjb25zdCBjb2xvciA9IG9wdGlvbmFsQ29sb3JMaWtlKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2NvbG9yJyk7XG4gIGNvbnN0IGNyb3NzT3JpZ2luID0gb3B0aW9uYWxTdHJpbmcoZmxhdFN0eWxlLCBwcmVmaXggKyAnY3Jvc3Mtb3JpZ2luJyk7XG4gIGNvbnN0IG9mZnNldCA9IG9wdGlvbmFsTnVtYmVyQXJyYXkoZmxhdFN0eWxlLCBwcmVmaXggKyAnb2Zmc2V0Jyk7XG4gIGNvbnN0IG9mZnNldE9yaWdpbiA9IG9wdGlvbmFsSWNvbk9yaWdpbihmbGF0U3R5bGUsIHByZWZpeCArICdvZmZzZXQtb3JpZ2luJyk7XG4gIGNvbnN0IHdpZHRoID0gb3B0aW9uYWxOdW1iZXIoZmxhdFN0eWxlLCBwcmVmaXggKyAnd2lkdGgnKTtcbiAgY29uc3QgaGVpZ2h0ID0gb3B0aW9uYWxOdW1iZXIoZmxhdFN0eWxlLCBwcmVmaXggKyAnaGVpZ2h0Jyk7XG4gIGNvbnN0IHNpemUgPSBvcHRpb25hbFNpemUoZmxhdFN0eWxlLCBwcmVmaXggKyAnc2l6ZScpO1xuICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gb3B0aW9uYWxEZWNsdXR0ZXJNb2RlKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGVjbHV0dGVyLW1vZGUnLFxuICApO1xuXG4gIGNvbnN0IGljb24gPSBuZXcgSWNvbih7XG4gICAgc3JjLFxuICAgIGFuY2hvck9yaWdpbixcbiAgICBhbmNob3JYVW5pdHMsXG4gICAgYW5jaG9yWVVuaXRzLFxuICAgIGNvbG9yLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIG9mZnNldCxcbiAgICBvZmZzZXRPcmlnaW4sXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIHNpemUsXG4gICAgZGVjbHV0dGVyTW9kZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGV2YWx1YXRlT3BhY2l0eSkge1xuICAgICAgaWNvbi5zZXRPcGFjaXR5KGV2YWx1YXRlT3BhY2l0eShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBpY29uLnNldERpc3BsYWNlbWVudChldmFsdWF0ZURpc3BsYWNlbWVudChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUm90YXRpb24pIHtcbiAgICAgIGljb24uc2V0Um90YXRpb24oZXZhbHVhdGVSb3RhdGlvbihjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUm90YXRlV2l0aFZpZXcpIHtcbiAgICAgIGljb24uc2V0Um90YXRlV2l0aFZpZXcoZXZhbHVhdGVSb3RhdGVXaXRoVmlldyhjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIGljb24uc2V0U2NhbGUoZXZhbHVhdGVTY2FsZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQW5jaG9yKSB7XG4gICAgICBpY29uLnNldEFuY2hvcihldmFsdWF0ZUFuY2hvcihjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBpY29uO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtJbWFnZUV2YWx1YXRvcn0gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBpY29uIHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU2hhcGUoZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHByZWZpeCA9ICdzaGFwZS0nO1xuXG4gIC8vIHJlcXVpcmVkIHByb3BlcnR5XG4gIGNvbnN0IHBvaW50c05hbWUgPSBwcmVmaXggKyAncG9pbnRzJztcbiAgY29uc3QgcmFkaXVzTmFtZSA9IHByZWZpeCArICdyYWRpdXMnO1xuICBjb25zdCBwb2ludHMgPSByZXF1aXJlTnVtYmVyKGZsYXRTdHlsZVtwb2ludHNOYW1lXSwgcG9pbnRzTmFtZSk7XG4gIGNvbnN0IHJhZGl1cyA9IHJlcXVpcmVOdW1iZXIoZmxhdFN0eWxlW3JhZGl1c05hbWVdLCByYWRpdXNOYW1lKTtcblxuICAvLyBzZXR0YWJsZSBwcm9wZXJ0aWVzXG4gIGNvbnN0IGV2YWx1YXRlRmlsbCA9IGJ1aWxkRmlsbChmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU3Ryb2tlID0gYnVpbGRTdHJva2UoZmxhdFN0eWxlLCBwcmVmaXgsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVNjYWxlID0gc2l6ZUxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAnc2NhbGUnLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVEaXNwbGFjZW1lbnQgPSBjb29yZGluYXRlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGlzcGxhY2VtZW50JyxcbiAgICBjb250ZXh0LFxuICApO1xuICBjb25zdCBldmFsdWF0ZVJvdGF0aW9uID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRpb24nLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICAvLyB0aGUgcmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIG5vdCBjdXJyZW50bHkgc2V0dGFibGVcbiAgY29uc3QgcmFkaXVzMiA9IG9wdGlvbmFsTnVtYmVyKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JhZGl1czInKTtcbiAgY29uc3QgYW5nbGUgPSBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByZWZpeCArICdhbmdsZScpO1xuICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gb3B0aW9uYWxEZWNsdXR0ZXJNb2RlKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGVjbHV0dGVyLW1vZGUnLFxuICApO1xuXG4gIGNvbnN0IHNoYXBlID0gbmV3IFJlZ3VsYXJTaGFwZSh7XG4gICAgcG9pbnRzLFxuICAgIHJhZGl1cyxcbiAgICByYWRpdXMyLFxuICAgIGFuZ2xlLFxuICAgIGRlY2x1dHRlck1vZGUsXG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmIChldmFsdWF0ZUZpbGwpIHtcbiAgICAgIHNoYXBlLnNldEZpbGwoZXZhbHVhdGVGaWxsKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICBzaGFwZS5zZXRTdHJva2UoZXZhbHVhdGVTdHJva2UoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVEaXNwbGFjZW1lbnQpIHtcbiAgICAgIHNoYXBlLnNldERpc3BsYWNlbWVudChldmFsdWF0ZURpc3BsYWNlbWVudChjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVJvdGF0aW9uKSB7XG4gICAgICBzaGFwZS5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRlV2l0aFZpZXcpIHtcbiAgICAgIHNoYXBlLnNldFJvdGF0ZVdpdGhWaWV3KGV2YWx1YXRlUm90YXRlV2l0aFZpZXcoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVTY2FsZSkge1xuICAgICAgc2hhcGUuc2V0U2NhbGUoZXZhbHVhdGVTY2FsZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtJbWFnZUV2YWx1YXRvcn0gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhIGNpcmNsZSBzeW1ib2xpemVyLlxuICovXG5mdW5jdGlvbiBidWlsZENpcmNsZShmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZml4ID0gJ2NpcmNsZS0nO1xuXG4gIC8vIHNldHRhYmxlIHByb3BlcnRpZXNcbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVTdHJva2UgPSBidWlsZFN0cm9rZShmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlUmFkaXVzID0gbnVtYmVyRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JhZGl1cycsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVNjYWxlID0gc2l6ZUxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAnc2NhbGUnLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVEaXNwbGFjZW1lbnQgPSBjb29yZGluYXRlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGlzcGxhY2VtZW50JyxcbiAgICBjb250ZXh0LFxuICApO1xuICBjb25zdCBldmFsdWF0ZVJvdGF0aW9uID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRpb24nLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICAvLyB0aGUgcmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIG5vdCBjdXJyZW50bHkgc2V0dGFibGVcbiAgY29uc3QgZGVjbHV0dGVyTW9kZSA9IG9wdGlvbmFsRGVjbHV0dGVyTW9kZShcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2RlY2x1dHRlci1tb2RlJyxcbiAgKTtcblxuICBjb25zdCBjaXJjbGUgPSBuZXcgQ2lyY2xlKHtcbiAgICByYWRpdXM6IDUsIC8vIHRoaXMgaXMgYXJiaXRyYXJ5LCBidXQgcmVxdWlyZWQgLSB0aGUgZXZhbHVhdGVkIHJhZGl1cyBpcyB1c2VkIGJlbG93XG4gICAgZGVjbHV0dGVyTW9kZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGV2YWx1YXRlUmFkaXVzKSB7XG4gICAgICBjaXJjbGUuc2V0UmFkaXVzKGV2YWx1YXRlUmFkaXVzKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgY2lyY2xlLnNldEZpbGwoZXZhbHVhdGVGaWxsKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICBjaXJjbGUuc2V0U3Ryb2tlKGV2YWx1YXRlU3Ryb2tlKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBjaXJjbGUuc2V0RGlzcGxhY2VtZW50KGV2YWx1YXRlRGlzcGxhY2VtZW50KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRpb24pIHtcbiAgICAgIGNpcmNsZS5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRlV2l0aFZpZXcpIHtcbiAgICAgIGNpcmNsZS5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIGNpcmNsZS5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY2xlO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5OdW1iZXJFdmFsdWF0b3J8dW5kZWZpbmVkfSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3Igb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBudW1iZXJFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyVHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlTnVtYmVyKGV2YWx1YXRvcihjb250ZXh0KSwgbmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLlN0cmluZ0V2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBTdHJpbmdUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVTdHJpbmcoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGF0dGVybkV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCkge1xuICBjb25zdCBzcmNFdmFsdWF0b3IgPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdwYXR0ZXJuLXNyYycsXG4gICAgY29udGV4dCxcbiAgKTtcbiAgY29uc3Qgb2Zmc2V0RXZhbHVhdG9yID0gc2l6ZUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3BhdHRlcm4tb2Zmc2V0JyxcbiAgICBjb250ZXh0LFxuICApO1xuICBjb25zdCBwYXR0ZXJuU2l6ZUV2YWx1YXRvciA9IHNpemVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdwYXR0ZXJuLXNpemUnLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIGNvbnN0IGNvbG9yRXZhbHVhdG9yID0gY29sb3JMaWtlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnY29sb3InLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICBzcmM6IHNyY0V2YWx1YXRvcihjb250ZXh0KSxcbiAgICAgIG9mZnNldDogb2Zmc2V0RXZhbHVhdG9yICYmIG9mZnNldEV2YWx1YXRvcihjb250ZXh0KSxcbiAgICAgIHNpemU6IHBhdHRlcm5TaXplRXZhbHVhdG9yICYmIHBhdHRlcm5TaXplRXZhbHVhdG9yKGNvbnRleHQpLFxuICAgICAgY29sb3I6IGNvbG9yRXZhbHVhdG9yICYmIGNvbG9yRXZhbHVhdG9yKGNvbnRleHQpLFxuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLkJvb2xlYW5FdmFsdWF0b3I/fSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3IuXG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW5FdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihmbGF0U3R5bGVbbmFtZV0sIEJvb2xlYW5UeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBldmFsdWF0b3IoY29udGV4dCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgYm9vbGVhbiBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLkNvbG9yTGlrZUV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gY29sb3JMaWtlRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBDb2xvclR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUNvbG9yTGlrZShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5OdW1iZXJBcnJheUV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyQXJyYXlFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihmbGF0U3R5bGVbbmFtZV0sIE51bWJlckFycmF5VHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlTnVtYmVyQXJyYXkoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuQ29vcmRpbmF0ZUV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gY29vcmRpbmF0ZUV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyQXJyYXlUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgY29uc3QgYXJyYXkgPSByZXF1aXJlTnVtYmVyQXJyYXkoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHR3byBudW1iZXJzIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuU2l6ZUV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gc2l6ZUV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyQXJyYXlUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVTaXplKGV2YWx1YXRvcihjb250ZXh0KSwgbmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLlNpemVMaWtlRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKFxuICAgIGZsYXRTdHlsZVtuYW1lXSxcbiAgICBOdW1iZXJBcnJheVR5cGUgfCBOdW1iZXJUeXBlLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlU2l6ZUxpa2UoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gQSBudW1iZXIgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHZhbHVlID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IEEgc2l6ZSBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsU2l6ZShmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvU2l6ZShlbmNvZGVkKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoZW5jb2RlZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyIG9yIHNpemUgYXJyYXkgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgaWYgKFxuICAgIGVuY29kZWQubGVuZ3RoICE9PSAyIHx8XG4gICAgdHlwZW9mIGVuY29kZWRbMF0gIT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIGVuY29kZWRbMV0gIT09ICdudW1iZXInXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXIgb3Igc2l6ZSBhcnJheSBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gQSBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbFN0cmluZyhmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kZWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0cmluZyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uT3JpZ2lufHVuZGVmaW5lZH0gQW4gaWNvbiBvcmlnaW4gb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbEljb25PcmlnaW4oZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKFxuICAgIGVuY29kZWQgIT09ICdib3R0b20tbGVmdCcgJiZcbiAgICBlbmNvZGVkICE9PSAnYm90dG9tLXJpZ2h0JyAmJlxuICAgIGVuY29kZWQgIT09ICd0b3AtbGVmdCcgJiZcbiAgICBlbmNvZGVkICE9PSAndG9wLXJpZ2h0J1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodCwgdG9wLWxlZnQsIG9yIHRvcC1yaWdodCBmb3IgJHtwcm9wZXJ0eX1gLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL3N0eWxlL0ljb24uanNcIikuSWNvbkFuY2hvclVuaXRzfHVuZGVmaW5lZH0gSWNvbiBhbmNob3IgdW5pdHMgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbEljb25BbmNob3JVbml0cyhmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZW5jb2RlZCAhPT0gJ3BpeGVscycgJiYgZW5jb2RlZCAhPT0gJ2ZyYWN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcGl4ZWxzIG9yIGZyYWN0aW9uIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHN5bWJvbGl6ZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gQW4gYXJyYXkgb2YgbnVtYmVycyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsTnVtYmVyQXJyYXkoZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHJlcXVpcmVOdW1iZXJBcnJheShlbmNvZGVkLCBwcm9wZXJ0eSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vc3R5bGUvU3R5bGUuanMnKS5EZWNsdXR0ZXJNb2RlfSBJY29uIGRlY2x1dHRlciBtb2RlLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbERlY2x1dHRlck1vZGUoZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGVkICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgaWYgKGVuY29kZWQgIT09ICdkZWNsdXR0ZXInICYmIGVuY29kZWQgIT09ICdvYnN0YWNsZScgJiYgZW5jb2RlZCAhPT0gJ25vbmUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBkZWNsdXR0ZXIsIG9ic3RhY2xlLCBvciBub25lIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHN5bWJvbGl6ZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIGNvbG9yIHZhbHVlcyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsQ29sb3JMaWtlKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiByZXF1aXJlQ29sb3JMaWtlKGVuY29kZWQsIHByb3BlcnR5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXJBcnJheSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgb2YgbnVtYmVycyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVN0cmluZyh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXIodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHN0cmluZ30gQSBjb2xvci5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUNvbG9yTGlrZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3QgYXJyYXkgPSByZXF1aXJlTnVtYmVyQXJyYXkodmFsdWUsIHByb3BlcnR5KTtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDwgMyB8fCBsZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGNvbG9yIHdpdGggMyBvciA0IHZhbHVlcyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBIG51bWJlciBvciBhbiBhcnJheSBvZiB0d28gbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVNpemUodmFsdWUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNpemUgPSByZXF1aXJlTnVtYmVyQXJyYXkodmFsdWUsIHByb3BlcnR5KTtcbiAgaWYgKHNpemUubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSBvZiB0d28gbnVtYmVycyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge251bWJlcnxBcnJheTxudW1iZXI+fSBBIG51bWJlciBvciBhbiBhcnJheSBvZiB0d28gbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVNpemVMaWtlKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVxdWlyZVNpemUodmFsdWUsIHByb3BlcnR5KTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9Db21wb3NpdGVcbiAqL1xuaW1wb3J0IEJhc2VWZWN0b3JMYXllciBmcm9tICcuLi9sYXllci9CYXNlVmVjdG9yLmpzJztcbmltcG9ydCBNYXBSZW5kZXJlciBmcm9tICcuL01hcC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4uL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnQgZnJvbSAnLi4vcmVuZGVyL0V2ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0NMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7Y2hlY2tlZEZvbnRzfSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCB7aW5WaWV3fSBmcm9tICcuLi9sYXllci9MYXllci5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7cmVwbGFjZUNoaWxkcmVufSBmcm9tICcuLi9kb20uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyBtYXAgcmVuZGVyZXIuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENvbXBvc2l0ZU1hcFJlbmRlcmVyIGV4dGVuZHMgTWFwUmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgIHN1cGVyKG1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMuZm9udENoYW5nZUxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgIGNoZWNrZWRGb250cyxcbiAgICAgIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgIG1hcC5yZWRyYXdUZXh0LFxuICAgICAgbWFwLFxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsZW1lbnRfLnN0eWxlO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBzdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgc3R5bGUuekluZGV4ID0gJzAnO1xuXG4gICAgdGhpcy5lbGVtZW50Xy5jbGFzc05hbWUgPSBDTEFTU19VTlNFTEVDVEFCTEUgKyAnIG9sLWxheWVycyc7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBtYXAuZ2V0Vmlld3BvcnQoKTtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudF8sIGNvbnRhaW5lci5maXJzdENoaWxkIHx8IG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRyZW5fID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50KHR5cGUsIGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXAuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFJlbmRlckV2ZW50KHR5cGUsIHVuZGVmaW5lZCwgZnJhbWVTdGF0ZSk7XG4gICAgICBtYXAuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHVubGlzdGVuQnlLZXkodGhpcy5mb250Q2hhbmdlTGlzdGVuZXJLZXlfKTtcbiAgICB0aGlzLmVsZW1lbnRfLnJlbW92ZSgpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlci5cbiAgICogQHBhcmFtIHs/aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmVsZW1lbnRfLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FsY3VsYXRlTWF0cmljZXMyRChmcmFtZVN0YXRlKTtcbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnQoUmVuZGVyRXZlbnRUeXBlLlBSRUNPTVBPU0UsIGZyYW1lU3RhdGUpO1xuXG4gICAgY29uc3QgbGF5ZXJTdGF0ZXNBcnJheSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGEuekluZGV4IC0gYi56SW5kZXgsXG4gICAgKTtcbiAgICBjb25zdCBkZWNsdXR0ZXIgPSBsYXllclN0YXRlc0FycmF5LnNvbWUoXG4gICAgICAobGF5ZXJTdGF0ZSkgPT5cbiAgICAgICAgbGF5ZXJTdGF0ZS5sYXllciBpbnN0YW5jZW9mIEJhc2VWZWN0b3JMYXllciAmJlxuICAgICAgICBsYXllclN0YXRlLmxheWVyLmdldERlY2x1dHRlcigpLFxuICAgICk7XG4gICAgaWYgKGRlY2x1dHRlcikge1xuICAgICAgLy8gU29tZSBsYXllcnMgbmVlZCBkZWNsdXR0ZXJpbmcsIHR1cm4gb24gZGVmZXJyZWQgcmVuZGVyaW5nIGhpbnRcbiAgICAgIGZyYW1lU3RhdGUuZGVjbHV0dGVyID0ge307XG4gICAgfVxuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuXG4gICAgdGhpcy5jaGlsZHJlbl8ubGVuZ3RoID0gMDtcblxuICAgIGNvbnN0IHJlbmRlcmVkTGF5ZXJTdGF0ZXMgPSBbXTtcbiAgICBsZXQgcHJldmlvdXNFbGVtZW50ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBsYXllclN0YXRlc0FycmF5W2ldO1xuICAgICAgZnJhbWVTdGF0ZS5sYXllckluZGV4ID0gaTtcblxuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgY29uc3Qgc291cmNlU3RhdGUgPSBsYXllci5nZXRTb3VyY2VTdGF0ZSgpO1xuICAgICAgaWYgKFxuICAgICAgICAhaW5WaWV3KGxheWVyU3RhdGUsIHZpZXdTdGF0ZSkgfHxcbiAgICAgICAgKHNvdXJjZVN0YXRlICE9ICdyZWFkeScgJiYgc291cmNlU3RhdGUgIT0gJ3VuZGVmaW5lZCcpXG4gICAgICApIHtcbiAgICAgICAgbGF5ZXIudW5yZW5kZXIoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllci5yZW5kZXIoZnJhbWVTdGF0ZSwgcHJldmlvdXNFbGVtZW50KTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50ICE9PSBwcmV2aW91c0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbl8ucHVzaChlbGVtZW50KTtcbiAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZWRMYXllclN0YXRlcy5wdXNoKGxheWVyU3RhdGUpO1xuICAgIH1cblxuICAgIHRoaXMuZGVjbHV0dGVyKGZyYW1lU3RhdGUsIHJlbmRlcmVkTGF5ZXJTdGF0ZXMpO1xuXG4gICAgcmVwbGFjZUNoaWxkcmVuKHRoaXMuZWxlbWVudF8sIHRoaXMuY2hpbGRyZW5fKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUE9TVENPTVBPU0UsIGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKCF0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgIHRoaXMuZWxlbWVudF8uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlSWNvbkNhY2hlKGZyYW1lU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9sYXllci9MYXllci5qcycpLlN0YXRlPn0gbGF5ZXJTdGF0ZXMgTGF5ZXJzLlxuICAgKi9cbiAgZGVjbHV0dGVyKGZyYW1lU3RhdGUsIGxheWVyU3RhdGVzKSB7XG4gICAgaWYgKCFmcmFtZVN0YXRlLmRlY2x1dHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gbGF5ZXJTdGF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBsYXllclN0YXRlc1tpXTtcbiAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJTdGF0ZS5sYXllcjtcbiAgICAgIGlmIChsYXllci5nZXREZWNsdXR0ZXIoKSkge1xuICAgICAgICBsYXllci5yZW5kZXJEZWNsdXR0ZXIoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxheWVyU3RhdGVzLmZvckVhY2goKGxheWVyU3RhdGUpID0+XG4gICAgICBsYXllclN0YXRlLmxheWVyLnJlbmRlckRlZmVycmVkKGZyYW1lU3RhdGUpLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9zaXRlTWFwUmVuZGVyZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvTGF5ZXJcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcblxuY29uc3QgbWF4U3RhbGVLZXlzID0gNTtcblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IExheWVyVHlwZVxuICovXG5jbGFzcyBMYXllclJlbmRlcmVyIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xheWVyVHlwZX0gbGF5ZXIgTGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsYXllcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgaXMgaW5pdGlhbGl6ZWQgYW5kIHJlYWR5IHRvIHJlbmRlci5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuYm91bmRIYW5kbGVJbWFnZUNoYW5nZV8gPSB0aGlzLmhhbmRsZUltYWdlQ2hhbmdlXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TGF5ZXJUeXBlfVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJfID0gbGF5ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhbGVLZXlzXyA9IG5ldyBBcnJheSgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5tYXhTdGFsZUtleXMgPSBtYXhTdGFsZUtleXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gR2V0IHRoZSBsaXN0IG9mIHN0YWxlIGtleXMuXG4gICAqL1xuICBnZXRTdGFsZUtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhbGVLZXlzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuZXcgc3RhbGUga2V5LlxuICAgKi9cbiAgcHJlcGVuZFN0YWxlS2V5KGtleSkge1xuICAgIHRoaXMuc3RhbGVLZXlzXy51bnNoaWZ0KGtleSk7XG4gICAgaWYgKHRoaXMuc3RhbGVLZXlzXy5sZW5ndGggPiB0aGlzLm1heFN0YWxlS2V5cykge1xuICAgICAgdGhpcy5zdGFsZUtleXNfLmxlbmd0aCA9IHRoaXMubWF4U3RhbGVLZXlzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgbGF5ZXIgbGV2ZWwgaGl0IGRldGVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZVwiKS5GZWF0dXJlTGlrZT4+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aFxuICAgKiBhbiBhcnJheSBvZiBmZWF0dXJlcy5cbiAgICovXG4gIGdldEZlYXR1cmVzKHBpeGVsKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fFVpbnQ4QXJyYXl8RmxvYXQzMkFycmF5fERhdGFWaWV3fG51bGx9IFBpeGVsIGRhdGEuXG4gICAqL1xuICBnZXREYXRhKHBpeGVsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgcmVuZGVyIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBMYXllciBpcyByZWFkeSB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIHByZXBhcmVGcmFtZShmcmFtZVN0YXRlKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBsYXllci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8bnVsbH0gdGFyZ2V0IFRhcmdldCB0aGF0IG1heSBiZSB1c2VkIHRvIHJlbmRlciBjb250ZW50IHRvLlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSBUaGUgcmVuZGVyZWQgZWxlbWVudC5cbiAgICovXG4gIHJlbmRlckZyYW1lKGZyYW1lU3RhdGUsIHRhcmdldCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdmVjdG9yLmpzXCIpLkZlYXR1cmVDYWxsYmFjazxUPn0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL01hcC5qc1wiKS5IaXRNYXRjaDxUPj59IG1hdGNoZXMgVGhlIGhpdCBkZXRlY3RlZCBtYXRjaGVzIHdpdGggdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgY29vcmRpbmF0ZSxcbiAgICBmcmFtZVN0YXRlLFxuICAgIGhpdFRvbGVyYW5jZSxcbiAgICBjYWxsYmFjayxcbiAgICBtYXRjaGVzLFxuICApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0xheWVyVHlwZX0gTGF5ZXIuXG4gICAqL1xuICBnZXRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcl87XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhY3Rpb24gbmVjZXNzYXJ5IHRvIGdldCB0aGUgbGF5ZXIgcmVuZGVyZWQgYWZ0ZXIgbmV3IGZvbnRzIGhhdmUgbG9hZGVkXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgaGFuZGxlRm9udHNDaGFuZ2VkKCkge31cblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZXMgaW4gaW1hZ2Ugc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEltYWdlIGNoYW5nZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlQ2hhbmdlXyhldmVudCkge1xuICAgIGNvbnN0IGltYWdlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAoXG4gICAgICBpbWFnZS5nZXRTdGF0ZSgpID09PSBJbWFnZVN0YXRlLkxPQURFRCB8fFxuICAgICAgaW1hZ2UuZ2V0U3RhdGUoKSA9PT0gSW1hZ2VTdGF0ZS5FUlJPUlxuICAgICkge1xuICAgICAgdGhpcy5yZW5kZXJJZlJlYWR5QW5kVmlzaWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBpZiBub3QgYWxyZWFkeSBsb2FkZWQsIGFuZCByZWdpc3RlciB0aGUgaW1hZ2UgY2hhbmdlXG4gICAqIGxpc3RlbmVyIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBpbWFnZSBJbWFnZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbWFnZSBpcyBhbHJlYWR5IGxvYWRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGxvYWRJbWFnZShpbWFnZSkge1xuICAgIGxldCBpbWFnZVN0YXRlID0gaW1hZ2UuZ2V0U3RhdGUoKTtcbiAgICBpZiAoaW1hZ2VTdGF0ZSAhPSBJbWFnZVN0YXRlLkxPQURFRCAmJiBpbWFnZVN0YXRlICE9IEltYWdlU3RhdGUuRVJST1IpIHtcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5ib3VuZEhhbmRsZUltYWdlQ2hhbmdlXyk7XG4gICAgfVxuICAgIGlmIChpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgaW1hZ2UubG9hZCgpO1xuICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlLmdldFN0YXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuTE9BREVEO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGlmIChsYXllciAmJiBsYXllci5nZXRWaXNpYmxlKCkgJiYgbGF5ZXIuZ2V0U291cmNlU3RhdGUoKSA9PT0gJ3JlYWR5Jykge1xuICAgICAgbGF5ZXIuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRGVmZXJyZWQoZnJhbWVTdGF0ZSkge31cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIGRlbGV0ZSB0aGlzLmxheWVyXztcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMYXllclJlbmRlcmVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL01hcFxuICovXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sIG1ha2VJbnZlcnNlfSBmcm9tICcuLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtnZXRXaWR0aH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7c2hhcmVkIGFzIGljb25JbWFnZUNhY2hlfSBmcm9tICcuLi9zdHlsZS9JY29uSW1hZ2VDYWNoZS5qcyc7XG5pbXBvcnQge2luVmlld30gZnJvbSAnLi4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IHt3cmFwWH0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIEhpdE1hdGNoXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlzdGFuY2VTcSBTcXVhcmVkIGRpc3RhbmNlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3ZlY3Rvci5qc1wiKS5GZWF0dXJlQ2FsbGJhY2s8VD59IGNhbGxiYWNrIENhbGxiYWNrLlxuICovXG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIE1hcFJlbmRlcmVyIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFwKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGRpc3BhdGNoUmVuZGVyRXZlbnQodHlwZSwgZnJhbWVTdGF0ZSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjYWxjdWxhdGVNYXRyaWNlczJEKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSA9IGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm07XG4gICAgY29uc3QgcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0gPSBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtO1xuXG4gICAgY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLFxuICAgICAgZnJhbWVTdGF0ZS5zaXplWzBdIC8gMixcbiAgICAgIGZyYW1lU3RhdGUuc2l6ZVsxXSAvIDIsXG4gICAgICAxIC8gdmlld1N0YXRlLnJlc29sdXRpb24sXG4gICAgICAtMSAvIHZpZXdTdGF0ZS5yZXNvbHV0aW9uLFxuICAgICAgLXZpZXdTdGF0ZS5yb3RhdGlvbixcbiAgICAgIC12aWV3U3RhdGUuY2VudGVyWzBdLFxuICAgICAgLXZpZXdTdGF0ZS5jZW50ZXJbMV0sXG4gICAgKTtcblxuICAgIG1ha2VJbnZlcnNlKHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLCBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrV3JhcHBlZCBDaGVjayBmb3Igd3JhcHBlZCBnZW9tZXRyaWVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdmVjdG9yLmpzXCIpLkZlYXR1cmVDYWxsYmFjazxUPn0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtTfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcyIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFMsVCxVXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNoZWNrV3JhcHBlZCxcbiAgICBjYWxsYmFjayxcbiAgICB0aGlzQXJnLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIHRoaXNBcmcyLFxuICApIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtYW5hZ2VkIE1hbmFnZWQgbGF5ZXIuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShtYW5hZ2VkLCBmZWF0dXJlLCBsYXllciwgZ2VvbWV0cnkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGZlYXR1cmUsIG1hbmFnZWQgPyBsYXllciA6IG51bGwsIGdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG5cbiAgICBjb25zdCB0cmFuc2xhdGVkQ29vcmRpbmF0ZSA9IHdyYXBYKGNvb3JkaW5hdGUuc2xpY2UoKSwgcHJvamVjdGlvbik7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFtbMCwgMF1dO1xuICAgIGlmIChwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiYgY2hlY2tXcmFwcGVkKSB7XG4gICAgICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgIG9mZnNldHMucHVzaChbLXdvcmxkV2lkdGgsIDBdLCBbd29ybGRXaWR0aCwgMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxheWVyU3RhdGVzID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIGNvbnN0IG51bUxheWVycyA9IGxheWVyU3RhdGVzLmxlbmd0aDtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSAvKiogQHR5cGUge0FycmF5PEhpdE1hdGNoPFQ+Pn0gKi8gKFtdKTtcbiAgICBjb25zdCB0bXBDb29yZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IG51bUxheWVycyAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBsYXllclN0YXRlc1tqXTtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbGF5ZXIuaGFzUmVuZGVyZXIoKSAmJlxuICAgICAgICAgIGluVmlldyhsYXllclN0YXRlLCB2aWV3U3RhdGUpICYmXG4gICAgICAgICAgbGF5ZXJGaWx0ZXIuY2FsbCh0aGlzQXJnMiwgbGF5ZXIpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGxheWVyUmVuZGVyZXIgPSBsYXllci5nZXRSZW5kZXJlcigpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGxheWVyLmdldFNvdXJjZSgpO1xuICAgICAgICAgIGlmIChsYXllclJlbmRlcmVyICYmIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBzb3VyY2UuZ2V0V3JhcFgoKVxuICAgICAgICAgICAgICA/IHRyYW5zbGF0ZWRDb29yZGluYXRlXG4gICAgICAgICAgICAgIDogY29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUuYmluZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbGF5ZXJTdGF0ZS5tYW5hZ2VkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRtcENvb3JkWzBdID0gY29vcmRpbmF0ZXNbMF0gKyBvZmZzZXRzW2ldWzBdO1xuICAgICAgICAgICAgdG1wQ29vcmRbMV0gPSBjb29yZGluYXRlc1sxXSArIG9mZnNldHNbaV1bMV07XG4gICAgICAgICAgICByZXN1bHQgPSBsYXllclJlbmRlcmVyLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgICAgICAgICB0bXBDb29yZCxcbiAgICAgICAgICAgICAgZnJhbWVTdGF0ZSxcbiAgICAgICAgICAgICAgaGl0VG9sZXJhbmNlLFxuICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXIgPSAxIC8gbWF0Y2hlcy5sZW5ndGg7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtLCBpKSA9PiAobS5kaXN0YW5jZVNxICs9IGkgKiBvcmRlcikpO1xuICAgIG1hdGNoZXMuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZVNxIC0gYi5kaXN0YW5jZVNxKTtcbiAgICBtYXRjaGVzLnNvbWUoKG0pID0+IHtcbiAgICAgIHJldHVybiAocmVzdWx0ID0gbS5jYWxsYmFjayhtLmZlYXR1cmUsIG0ubGF5ZXIsIG0uZ2VvbWV0cnkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja1dyYXBwZWQgQ2hlY2sgZm9yIHdyYXBwZWQgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGF5ZXJGaWx0ZXJgLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyB0aGVyZSBhIGZlYXR1cmUgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGU/XG4gICAqIEB0ZW1wbGF0ZSBVXG4gICAqL1xuICBoYXNGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgZnJhbWVTdGF0ZSxcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgY2hlY2tXcmFwcGVkLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIHRoaXNBcmcsXG4gICkge1xuICAgIGNvbnN0IGhhc0ZlYXR1cmUgPSB0aGlzLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIGZyYW1lU3RhdGUsXG4gICAgICBoaXRUb2xlcmFuY2UsXG4gICAgICBjaGVja1dyYXBwZWQsXG4gICAgICBUUlVFLFxuICAgICAgdGhpcyxcbiAgICAgIGxheWVyRmlsdGVyLFxuICAgICAgdGhpc0FyZyxcbiAgICApO1xuXG4gICAgcmV0dXJuIGhhc0ZlYXR1cmUgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gTWFwLlxuICAgKi9cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHs/aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICByZW5kZXJGcmFtZShmcmFtZVN0YXRlKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzY2hlZHVsZUV4cGlyZUljb25DYWNoZShmcmFtZVN0YXRlKSB7XG4gICAgaWYgKGljb25JbWFnZUNhY2hlLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucy5wdXNoKGV4cGlyZUljb25DYWNoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIGV4cGlyZUljb25DYWNoZShtYXAsIGZyYW1lU3RhdGUpIHtcbiAgaWNvbkltYWdlQ2FjaGUuZXhwaXJlKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcFJlbmRlcmVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9MYXllclxuICovXG5pbXBvcnQgTGF5ZXJSZW5kZXJlciBmcm9tICcuLi9MYXllci5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnQgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgWkluZGV4Q29udGV4dCBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzL1pJbmRleENvbnRleHQuanMnO1xuaW1wb3J0IHtcbiAgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sXG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbiAgbWFrZUludmVyc2UsXG4gIHRvU3RyaW5nIGFzIHRvVHJhbnNmb3JtU3RyaW5nLFxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi8uLi9jb2xvci5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge1xuICBnZXRCb3R0b21MZWZ0LFxuICBnZXRCb3R0b21SaWdodCxcbiAgZ2V0SGVpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRUb3BSaWdodCxcbiAgZ2V0V2lkdGgsXG59IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5cbi8qKlxuICogQHR5cGUge0FycmF5PEhUTUxDYW52YXNFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbnZhc1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICovXG5sZXQgcGl4ZWxDb250ZXh0ID0gbnVsbDtcblxuZnVuY3Rpb24gY3JlYXRlUGl4ZWxDb250ZXh0KCkge1xuICBwaXhlbENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSwgdW5kZWZpbmVkLCB7XG4gICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlLFxuICB9KTtcbn1cblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXJUeXBlXG4gKiBAZXh0ZW5kcyB7TGF5ZXJSZW5kZXJlcjxMYXllclR5cGU+fVxuICovXG5jbGFzcyBDYW52YXNMYXllclJlbmRlcmVyIGV4dGVuZHMgTGF5ZXJSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xheWVyVHlwZX0gbGF5ZXIgTGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsYXllcikge1xuICAgIHN1cGVyKGxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyeSB0cmFuc2Zvcm0uICBUaGUgdmFsdWVzIGluIHRoaXMgdHJhbnNmb3JtIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gYVxuICAgICAqIGZ1bmN0aW9uIHRoYXQgc2V0cyB0aGUgdmFsdWVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRlbXBUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm0gZm9yIHJlbmRlcmVkIHBpeGVscyB0byB2aWV3cG9ydCBDU1MgcGl4ZWxzLiAgVGhpcyB0cmFuc2Zvcm0gbXVzdFxuICAgICAqIGJlIHNldCB3aGVuIHJlbmRlcmluZyBhIGZyYW1lIGFuZCBtYXkgYmUgdXNlZCBieSBvdGhlciBmdW5jdGlvbnMgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtIGZvciB2aWV3cG9ydCBDU1MgcGl4ZWxzIHRvIHJlbmRlcmVkIHBpeGVscy4gIFRoaXMgdHJhbnNmb3JtIG11c3RcbiAgICAgKiBiZSBzZXQgd2hlbiByZW5kZXJpbmcgYSBmcmFtZSBhbmQgbWF5IGJlIHVzZWQgYnkgb3RoZXIgZnVuY3Rpb25zIGFmdGVyIHJlbmRlcmluZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1pJbmRleENvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5kZWZlcnJlZENvbnRleHRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyUmV1c2VkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIEltYWdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8bnVsbH0gVGhlIGltYWdlIGRhdGEuXG4gICAqL1xuICBnZXRJbWFnZURhdGEoaW1hZ2UsIGNvbCwgcm93KSB7XG4gICAgaWYgKCFwaXhlbENvbnRleHQpIHtcbiAgICAgIGNyZWF0ZVBpeGVsQ29udGV4dCgpO1xuICAgIH1cbiAgICBwaXhlbENvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDEsIDEpO1xuXG4gICAgbGV0IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIHBpeGVsQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIGNvbCwgcm93LCAxLCAxLCAwLCAwLCAxLCAxKTtcbiAgICAgIGRhdGEgPSBwaXhlbENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwaXhlbENvbnRleHQgPSBudWxsO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9NYXAuanMnKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBnZXRCYWNrZ3JvdW5kKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBsZXQgYmFja2dyb3VuZCA9IGxheWVyLmdldEJhY2tncm91bmQoKTtcbiAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJhY2tncm91bmQgPSBiYWNrZ3JvdW5kKGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVuZGVyaW5nIGNvbnRhaW5lciBmcm9tIGFuIGV4aXN0aW5nIHRhcmdldCwgaWYgY29tcGF0aWJsZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IFBvdGVudGlhbCByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmb3JtIENTUyBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yXSBCYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgdXNlQ29udGFpbmVyKHRhcmdldCwgdHJhbnNmb3JtLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBjb25zdCBsYXllckNsYXNzTmFtZSA9IHRoaXMuZ2V0TGF5ZXIoKS5nZXRDbGFzc05hbWUoKTtcbiAgICBsZXQgY29udGFpbmVyLCBjb250ZXh0O1xuICAgIGlmIChcbiAgICAgIHRhcmdldCAmJlxuICAgICAgdGFyZ2V0LmNsYXNzTmFtZSA9PT0gbGF5ZXJDbGFzc05hbWUgJiZcbiAgICAgICghYmFja2dyb3VuZENvbG9yIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yICYmXG4gICAgICAgICAgZXF1YWxzKFxuICAgICAgICAgICAgYXNBcnJheSh0YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICAgIGFzQXJyYXkoYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICApKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRhcmdldC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGlmIChjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9PT0gdHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb250YWluZXIgb2YgdGhlIHByZXZpb3VzIGxheWVyIHJlbmRlcmVyIGNhbiBiZSB1c2VkLlxuICAgICAgdGhpcy5jb250YWluZXIgPSB0YXJnZXQ7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5jb250YWluZXJSZXVzZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIC8vIFByZXZpb3VzbHkgcmV1c2VkIGNvbnRhaW5lciBjYW5ub3QgYmUgdXNlZCBhbnkgbW9yZS5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRhaW5lclJldXNlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGxheWVyQ2xhc3NOYW1lO1xuICAgICAgbGV0IHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ3RvcCBsZWZ0JztcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIXRoaXMuY29udGFpbmVyUmV1c2VkICYmXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgJiZcbiAgICAgICF0aGlzLmNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICApIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgQ2xpcCBleHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNsaXBVbnJvdGF0ZWQoY29udGV4dCwgZnJhbWVTdGF0ZSwgZXh0ZW50KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG5cbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BMZWZ0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BSaWdodCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbUxlZnQpO1xuXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgdG9wTGVmdCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oaW52ZXJ0ZWQsIHRvcFJpZ2h0KTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGludmVydGVkLCBib3R0b21MZWZ0KTtcblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oTWF0aC5yb3VuZCh0b3BMZWZ0WzBdKSwgTWF0aC5yb3VuZCh0b3BMZWZ0WzFdKSk7XG4gICAgY29udGV4dC5saW5lVG8oTWF0aC5yb3VuZCh0b3BSaWdodFswXSksIE1hdGgucm91bmQodG9wUmlnaHRbMV0pKTtcbiAgICBjb250ZXh0LmxpbmVUbyhNYXRoLnJvdW5kKGJvdHRvbVJpZ2h0WzBdKSwgTWF0aC5yb3VuZChib3R0b21SaWdodFsxXSkpO1xuICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQoYm90dG9tTGVmdFswXSksIE1hdGgucm91bmQoYm90dG9tTGVmdFsxXSkpO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgdGhhdCBtYXkgYmUgdXNlZCB0byByZW5kZXIgY29udGVudCB0by5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJlcGFyZUNvbnRhaW5lcihmcmFtZVN0YXRlLCB0YXJnZXQpIHtcbiAgICBjb25zdCBleHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKChnZXRXaWR0aChleHRlbnQpIC8gcmVzb2x1dGlvbikgKiBwaXhlbFJhdGlvKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKChnZXRIZWlnaHQoZXh0ZW50KSAvIHJlc29sdXRpb24pICogcGl4ZWxSYXRpbyk7XG4gICAgLy8gc2V0IGZvcndhcmQgYW5kIGludmVyc2UgcGl4ZWwgdHJhbnNmb3Jtc1xuICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICB0aGlzLnBpeGVsVHJhbnNmb3JtLFxuICAgICAgZnJhbWVTdGF0ZS5zaXplWzBdIC8gMixcbiAgICAgIGZyYW1lU3RhdGUuc2l6ZVsxXSAvIDIsXG4gICAgICAxIC8gcGl4ZWxSYXRpbyxcbiAgICAgIDEgLyBwaXhlbFJhdGlvLFxuICAgICAgcm90YXRpb24sXG4gICAgICAtd2lkdGggLyAyLFxuICAgICAgLWhlaWdodCAvIDIsXG4gICAgKTtcbiAgICBtYWtlSW52ZXJzZSh0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSwgdGhpcy5waXhlbFRyYW5zZm9ybSk7XG5cbiAgICBjb25zdCBjYW52YXNUcmFuc2Zvcm0gPSB0b1RyYW5zZm9ybVN0cmluZyh0aGlzLnBpeGVsVHJhbnNmb3JtKTtcbiAgICB0aGlzLnVzZUNvbnRhaW5lcih0YXJnZXQsIGNhbnZhc1RyYW5zZm9ybSwgdGhpcy5nZXRCYWNrZ3JvdW5kKGZyYW1lU3RhdGUpKTtcblxuICAgIGlmICghdGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY29udGV4dC5jYW52YXM7XG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW52YXNUcmFuc2Zvcm0gIT09IGNhbnZhcy5zdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9IGNhbnZhc1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoUmVuZGVyRXZlbnRfKHR5cGUsIGNvbnRleHQsIGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFJlbmRlckV2ZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSxcbiAgICAgICAgZnJhbWVTdGF0ZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICk7XG4gICAgICBsYXllci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJlUmVuZGVyKGNvbnRleHQsIGZyYW1lU3RhdGUpIHtcbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlO1xuICAgIGlmIChmcmFtZVN0YXRlLmRlY2x1dHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QUkVSRU5ERVIsIGNvbnRleHQsIGZyYW1lU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHBvc3RSZW5kZXIoY29udGV4dCwgZnJhbWVTdGF0ZSkge1xuICAgIGlmIChmcmFtZVN0YXRlLmRlY2x1dHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QT1NUUkVOREVSLCBjb250ZXh0LCBmcmFtZVN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRGVmZXJyZWRJbnRlcm5hbChmcmFtZVN0YXRlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3JlbmRlci9jYW52YXMvWkluZGV4Q29udGV4dC5qcycpLlpJbmRleENvbnRleHRQcm94eX0gQ29udGV4dC5cbiAgICovXG4gIGdldFJlbmRlckNvbnRleHQoZnJhbWVTdGF0ZSkge1xuICAgIGlmIChmcmFtZVN0YXRlLmRlY2x1dHRlciAmJiAhdGhpcy5kZWZlcnJlZENvbnRleHRfKSB7XG4gICAgICB0aGlzLmRlZmVycmVkQ29udGV4dF8gPSBuZXcgWkluZGV4Q29udGV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhbWVTdGF0ZS5kZWNsdXR0ZXJcbiAgICAgID8gdGhpcy5kZWZlcnJlZENvbnRleHRfLmdldENvbnRleHQoKVxuICAgICAgOiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXJEZWZlcnJlZChmcmFtZVN0YXRlKSB7XG4gICAgaWYgKCFmcmFtZVN0YXRlLmRlY2x1dHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFxuICAgICAgUmVuZGVyRXZlbnRUeXBlLlBSRVJFTkRFUixcbiAgICAgIHRoaXMuY29udGV4dCxcbiAgICAgIGZyYW1lU3RhdGUsXG4gICAgKTtcbiAgICBpZiAoZnJhbWVTdGF0ZS5kZWNsdXR0ZXIgJiYgdGhpcy5kZWZlcnJlZENvbnRleHRfKSB7XG4gICAgICB0aGlzLmRlZmVycmVkQ29udGV4dF8uZHJhdyh0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5kZWZlcnJlZENvbnRleHRfLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyRGVmZXJyZWRJbnRlcm5hbChmcmFtZVN0YXRlKTtcbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFxuICAgICAgUmVuZGVyRXZlbnRUeXBlLlBPU1RSRU5ERVIsXG4gICAgICB0aGlzLmNvbnRleHQsXG4gICAgICBmcmFtZVN0YXRlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nIHRvIGFuIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHJvdGF0ZWQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZW5kZXJlZCBlbGVtZW50IChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVuZGVyZWQgZWxlbWVudCAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggT2Zmc2V0IG9uIHRoZSB4LWF4aXMgaW4gdmlldyBjb29yZGluYXRlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gVHJhbnNmb3JtLlxuICAgKi9cbiAgZ2V0UmVuZGVyVHJhbnNmb3JtKFxuICAgIGNlbnRlcixcbiAgICByZXNvbHV0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG9mZnNldFgsXG4gICkge1xuICAgIGNvbnN0IGR4MSA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBkeTEgPSBoZWlnaHQgLyAyO1xuICAgIGNvbnN0IHN4ID0gcGl4ZWxSYXRpbyAvIHJlc29sdXRpb247XG4gICAgY29uc3Qgc3kgPSAtc3g7XG4gICAgY29uc3QgZHgyID0gLWNlbnRlclswXSArIG9mZnNldFg7XG4gICAgY29uc3QgZHkyID0gLWNlbnRlclsxXTtcbiAgICByZXR1cm4gY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIHRoaXMudGVtcFRyYW5zZm9ybSxcbiAgICAgIGR4MSxcbiAgICAgIGR5MSxcbiAgICAgIHN4LFxuICAgICAgc3ksXG4gICAgICAtcm90YXRpb24sXG4gICAgICBkeDIsXG4gICAgICBkeTIsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgZGVsZXRlIHRoaXMuZnJhbWVTdGF0ZTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNMYXllclJlbmRlcmVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgRGF0YVRpbGUsIHthc0ltYWdlTGlrZX0gZnJvbSAnLi4vLi4vRGF0YVRpbGUuanMnO1xuaW1wb3J0IEltYWdlVGlsZSBmcm9tICcuLi8uLi9JbWFnZVRpbGUuanMnO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4uLy4uL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IFJlcHJvakRhdGFUaWxlIGZyb20gJy4uLy4uL3JlcHJvai9EYXRhVGlsZS5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi8uLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlIGZyb20gJy4uLy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uLy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge1xuICBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSxcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHthc2NlbmRpbmd9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlRW1wdHksXG4gIGVxdWFscyxcbiAgZ2V0SW50ZXJzZWN0aW9uLFxuICBnZXRUb3BMZWZ0LFxuICBpbnRlcnNlY3RzLFxufSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVUaWxlQ29vcmQsIGdldEtleVpYWX0gZnJvbSAnLi4vLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7ZnJvbVVzZXJFeHRlbnR9IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uLy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VLZXkgVGhlIHNvdXJjZSBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaGUgdGlsZSB6IGxldmVsLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHRpbGUgeCBsZXZlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB0aWxlIHkgbGV2ZWwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjYWNoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldENhY2hlS2V5KHNvdXJjZUtleSwgeiwgeCwgeSkge1xuICByZXR1cm4gYCR7c291cmNlS2V5fSwke2dldEtleVpYWSh6LCB4LCB5KX1gO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3Q8bnVtYmVyLCBTZXQ8aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pj59IFRpbGVMb29rdXBcbiAqL1xuXG4vKipcbiAqIEFkZCBhIHRpbGUgdG8gdGhlIGxvb2t1cC5cbiAqIEBwYXJhbSB7VGlsZUxvb2t1cH0gdGlsZXNCeVogTG9va3VwIG9mIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBBIHRpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaGUgem9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHdhcyBhZGRlZCB0byB0aGUgbG9va3VwLlxuICovXG5mdW5jdGlvbiBhZGRUaWxlVG9Mb29rdXAodGlsZXNCeVosIHRpbGUsIHopIHtcbiAgaWYgKCEoeiBpbiB0aWxlc0J5WikpIHtcbiAgICB0aWxlc0J5Wlt6XSA9IG5ldyBTZXQoW3RpbGVdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZXQgPSB0aWxlc0J5Wlt6XTtcbiAgY29uc3QgZXhpc3RpbmcgPSBzZXQuaGFzKHRpbGUpO1xuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgc2V0LmFkZCh0aWxlKTtcbiAgfVxuICByZXR1cm4gIWV4aXN0aW5nO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHRpbGUgZnJvbSB0aGUgbG9va3VwLlxuICogQHBhcmFtIHtUaWxlTG9va3VwfSB0aWxlc0J5WiBMb29rdXAgb2YgdGlsZXMgYnkgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIEEgdGlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFRoZSB6b29tIGxldmVsLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgd2FzIHJlbW92ZWQgZnJvbSB0aGUgbG9va3VwLlxuICovXG5mdW5jdGlvbiByZW1vdmVUaWxlRnJvbUxvb2t1cCh0aWxlc0J5WiwgdGlsZSwgeikge1xuICBjb25zdCBzZXQgPSB0aWxlc0J5Wlt6XTtcbiAgaWYgKHNldCkge1xuICAgIHJldHVybiBzZXQuZGVsZXRlKHRpbGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGZyYW1lIGV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEZyYW1lIGV4dGVudCBpbnRlcnNlY3RlZCB3aXRoIGxheWVyIGV4dGVudHMuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlckV4dGVudChmcmFtZVN0YXRlLCBleHRlbnQpIHtcbiAgY29uc3QgbGF5ZXJTdGF0ZSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheVtmcmFtZVN0YXRlLmxheWVySW5kZXhdO1xuICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQpIHtcbiAgICBleHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oXG4gICAgICBleHRlbnQsXG4gICAgICBmcm9tVXNlckV4dGVudChsYXllclN0YXRlLmV4dGVudCwgZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbiksXG4gICAgKTtcbiAgfVxuICBjb25zdCBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICBsYXllclN0YXRlLmxheWVyLmdldFJlbmRlclNvdXJjZSgpXG4gICk7XG4gIGlmICghc291cmNlLmdldFdyYXBYKCkpIHtcbiAgICBjb25zdCBncmlkRXh0ZW50ID0gc291cmNlXG4gICAgICAuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24pXG4gICAgICAuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKGdyaWRFeHRlbnQpIHtcbiAgICAgIGV4dGVudCA9IGdldEludGVyc2VjdGlvbihleHRlbnQsIGdyaWRFeHRlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTUxMl0gVGhlIGNhY2hlIHNpemUuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgcmVuZGVyZXIgZm9yIHRpbGUgbGF5ZXJzLlxuICogQGFwaVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSBbTGF5ZXJUeXBlPWltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0PnxpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHRdXG4gKiBAZXh0ZW5kcyB7Q2FudmFzTGF5ZXJSZW5kZXJlcjxMYXllclR5cGU+fVxuICovXG5jbGFzcyBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciBleHRlbmRzIENhbnZhc0xheWVyUmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtMYXllclR5cGV9IHRpbGVMYXllciBUaWxlIGxheWVyLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZUxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIodGlsZUxheWVyKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyZWQgZXh0ZW50IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBwcmV2aW91cyBgcmVuZGVyRnJhbWUoKWAgY2FsbFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50Q2hhbmdlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBjYWxsIHRvIGByZW5kZXJGcmFtZWAgd2FzIGNvbXBsZXRlZCB3aXRoIGFsbCB0aWxlcyBsb2FkZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckNvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUHJvamVjdGlvbiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRUaWxlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRTb3VyY2VLZXlfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRTb3VyY2VSZXZpc2lvbl87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy50ZW1wRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGVtcFRpbGVSYW5nZV8gPSBuZXcgVGlsZVJhbmdlKDAsIDAsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRlbXBUaWxlQ29vcmRfID0gY3JlYXRlVGlsZUNvb3JkKDAsIDAsIDApO1xuXG4gICAgY29uc3QgY2FjaGVTaXplID0gb3B0aW9ucy5jYWNoZVNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2FjaGVTaXplIDogNTEyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3N0cnVjdHMvTFJVQ2FjaGUuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGVfID0gbmV3IExSVUNhY2hlKGNhY2hlU2l6ZSk7XG5cbiAgICB0aGlzLm1heFN0YWxlS2V5cyA9IGNhY2hlU2l6ZSAqIDAuNTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtMUlVDYWNoZX0gVGlsZSBjYWNoZS5cbiAgICovXG4gIGdldFRpbGVDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRpbGUgZnJvbSB0aGUgY2FjaGUgb3IgY3JlYXRlIG9uZSBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIChvciBudWxsIGlmIG91dHNpZGUgc291cmNlIGV4dGVudCkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldE9yQ3JlYXRlVGlsZSh6LCB4LCB5LCBmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgdGlsZUNhY2hlID0gdGhpcy50aWxlQ2FjaGVfO1xuICAgIGNvbnN0IHRpbGVMYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBjb25zdCB0aWxlU291cmNlID0gdGlsZUxheWVyLmdldFNvdXJjZSgpO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkodGlsZVNvdXJjZS5nZXRLZXkoKSwgeiwgeCwgeSk7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gKi9cbiAgICBsZXQgdGlsZTtcblxuICAgIGlmICh0aWxlQ2FjaGUuY29udGFpbnNLZXkoY2FjaGVLZXkpKSB7XG4gICAgICB0aWxlID0gdGlsZUNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGUgPSB0aWxlU291cmNlLmdldFRpbGUoXG4gICAgICAgIHosXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZyYW1lU3RhdGUucGl4ZWxSYXRpbyxcbiAgICAgICAgZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbixcbiAgICAgICk7XG4gICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aWxlQ2FjaGUuc2V0KGNhY2hlS2V5LCB0aWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fG51bGx9IFRpbGUgKG9yIG51bGwgaWYgb3V0c2lkZSBzb3VyY2UgZXh0ZW50KS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0VGlsZSh6LCB4LCB5LCBmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgdGlsZSA9IHRoaXMuZ2V0T3JDcmVhdGVUaWxlKHosIHgsIHksIGZyYW1lU3RhdGUpO1xuICAgIGlmICghdGlsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheX0gRGF0YSBhdCB0aGUgcGl4ZWwgbG9jYXRpb24uXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0RGF0YShwaXhlbCkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGU7XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBjb25zdCBjb29yZGluYXRlID0gYXBwbHlUcmFuc2Zvcm0oXG4gICAgICBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLFxuICAgICAgcGl4ZWwuc2xpY2UoKSxcbiAgICApO1xuXG4gICAgY29uc3QgbGF5ZXJFeHRlbnQgPSBsYXllci5nZXRFeHRlbnQoKTtcbiAgICBpZiAobGF5ZXJFeHRlbnQpIHtcbiAgICAgIGlmICghY29udGFpbnNDb29yZGluYXRlKGxheWVyRXh0ZW50LCBjb29yZGluYXRlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBzb3VyY2UgPSBsYXllci5nZXRSZW5kZXJTb3VyY2UoKTtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHNvdXJjZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24odmlld1N0YXRlLnByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gc291cmNlLmdldFRpbGVQaXhlbFJhdGlvKGZyYW1lU3RhdGUucGl4ZWxSYXRpbyk7XG5cbiAgICBmb3IgKFxuICAgICAgbGV0IHogPSB0aWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbih2aWV3U3RhdGUucmVzb2x1dGlvbik7XG4gICAgICB6ID49IHRpbGVHcmlkLmdldE1pblpvb20oKTtcbiAgICAgIC0telxuICAgICkge1xuICAgICAgY29uc3QgdGlsZUNvb3JkID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNvb3JkaW5hdGUsIHopO1xuICAgICAgY29uc3QgdGlsZSA9IHRoaXMuZ2V0VGlsZSh6LCB0aWxlQ29vcmRbMV0sIHRpbGVDb29yZFsyXSwgZnJhbWVTdGF0ZSk7XG4gICAgICBpZiAoIXRpbGUgfHwgdGlsZS5nZXRTdGF0ZSgpICE9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aWxlT3JpZ2luID0gdGlsZUdyaWQuZ2V0T3JpZ2luKHopO1xuICAgICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGlsZUdyaWQuZ2V0VGlsZVNpemUoeikpO1xuICAgICAgY29uc3QgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfVxuICAgICAgICovXG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodGlsZSBpbnN0YW5jZW9mIEltYWdlVGlsZSB8fCB0aWxlIGluc3RhbmNlb2YgUmVwcm9qVGlsZSkge1xuICAgICAgICBpbWFnZSA9IHRpbGUuZ2V0SW1hZ2UoKTtcbiAgICAgIH0gZWxzZSBpZiAodGlsZSBpbnN0YW5jZW9mIERhdGFUaWxlKSB7XG4gICAgICAgIGltYWdlID0gYXNJbWFnZUxpa2UodGlsZS5nZXREYXRhKCkpO1xuICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb2wgPSBNYXRoLmZsb29yKFxuICAgICAgICB0aWxlUGl4ZWxSYXRpbyAqXG4gICAgICAgICAgKChjb29yZGluYXRlWzBdIC0gdGlsZU9yaWdpblswXSkgLyB0aWxlUmVzb2x1dGlvbiAtXG4gICAgICAgICAgICB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKFxuICAgICAgICB0aWxlUGl4ZWxSYXRpbyAqXG4gICAgICAgICAgKCh0aWxlT3JpZ2luWzFdIC0gY29vcmRpbmF0ZVsxXSkgLyB0aWxlUmVzb2x1dGlvbiAtXG4gICAgICAgICAgICB0aWxlQ29vcmRbMl0gKiB0aWxlU2l6ZVsxXSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBndXR0ZXIgPSBNYXRoLnJvdW5kKFxuICAgICAgICB0aWxlUGl4ZWxSYXRpbyAqIHNvdXJjZS5nZXRHdXR0ZXJGb3JQcm9qZWN0aW9uKHZpZXdTdGF0ZS5wcm9qZWN0aW9uKSxcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmdldEltYWdlRGF0YShpbWFnZSwgY29sICsgZ3V0dGVyLCByb3cgKyBndXR0ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIHJlbmRlciBzaG91bGQgYmUgY2FsbGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBMYXllciBpcyByZWFkeSB0byBiZSByZW5kZXJlZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBwcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIGlmICghdGhpcy5yZW5kZXJlZFByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMucmVuZGVyZWRQcm9qZWN0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICB9IGVsc2UgaWYgKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24gIT09IHRoaXMucmVuZGVyZWRQcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZV8uY2xlYXIoKTtcbiAgICAgIHRoaXMucmVuZGVyZWRQcm9qZWN0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldExheWVyKCkuZ2V0U291cmNlKCk7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlUmV2aXNpb24gPSBzb3VyY2UuZ2V0UmV2aXNpb24oKTtcbiAgICBpZiAoIXRoaXMucmVuZGVyZWRSZXZpc2lvbl8pIHtcbiAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPSBzb3VyY2VSZXZpc2lvbjtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gIT09IHNvdXJjZVJldmlzaW9uKSB7XG4gICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb25fID0gc291cmNlUmV2aXNpb247XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZFNvdXJjZUtleV8gPT09IHNvdXJjZS5nZXRLZXkoKSkge1xuICAgICAgICB0aGlzLnRpbGVDYWNoZV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudCB0byBiZSByZW5kZXJlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluaXRpYWxaIFRoZSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge1RpbGVMb29rdXB9IHRpbGVzQnlaIExvb2t1cCBvZiB0aWxlcyBieSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJlbG9hZCBOdW1iZXIgb2YgYWRkaXRpb25hbCBsZXZlbHMgdG8gbG9hZC5cbiAgICovXG4gIGVucXVldWVUaWxlcyhmcmFtZVN0YXRlLCBleHRlbnQsIGluaXRpYWxaLCB0aWxlc0J5WiwgcHJlbG9hZCkge1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHRpbGVMYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBjb25zdCB0aWxlU291cmNlID0gdGlsZUxheWVyLmdldFJlbmRlclNvdXJjZSgpO1xuICAgIGNvbnN0IHRpbGVHcmlkID0gdGlsZVNvdXJjZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24odmlld1N0YXRlLnByb2plY3Rpb24pO1xuXG4gICAgY29uc3QgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICBpZiAoISh0aWxlU291cmNlS2V5IGluIGZyYW1lU3RhdGUud2FudGVkVGlsZXMpKSB7XG4gICAgICBmcmFtZVN0YXRlLndhbnRlZFRpbGVzW3RpbGVTb3VyY2VLZXldID0ge307XG4gICAgfVxuXG4gICAgY29uc3Qgd2FudGVkVGlsZXMgPSBmcmFtZVN0YXRlLndhbnRlZFRpbGVzW3RpbGVTb3VyY2VLZXldO1xuXG4gICAgY29uc3QgbWFwID0gdGlsZUxheWVyLmdldE1hcEludGVybmFsKCk7XG4gICAgY29uc3QgbWluWiA9IE1hdGgubWF4KFxuICAgICAgaW5pdGlhbFogLSBwcmVsb2FkLFxuICAgICAgdGlsZUdyaWQuZ2V0TWluWm9vbSgpLFxuICAgICAgdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24oXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIHRpbGVMYXllci5nZXRNYXhSZXNvbHV0aW9uKCksXG4gICAgICAgICAgbWFwXG4gICAgICAgICAgICA/IG1hcFxuICAgICAgICAgICAgICAgIC5nZXRWaWV3KClcbiAgICAgICAgICAgICAgICAuZ2V0UmVzb2x1dGlvbkZvclpvb20oTWF0aC5tYXgodGlsZUxheWVyLmdldE1pblpvb20oKSwgMCkpXG4gICAgICAgICAgICA6IHRpbGVHcmlkLmdldFJlc29sdXRpb24oMCksXG4gICAgICAgICksXG4gICAgICAgIHRpbGVTb3VyY2UuekRpcmVjdGlvbixcbiAgICAgICksXG4gICAgKTtcbiAgICBmb3IgKGxldCB6ID0gaW5pdGlhbFo7IHogPj0gbWluWjsgLS16KSB7XG4gICAgICBjb25zdCB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICBleHRlbnQsXG4gICAgICAgIHosXG4gICAgICAgIHRoaXMudGVtcFRpbGVSYW5nZV8sXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0aWxlUmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG5cbiAgICAgIGZvciAobGV0IHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgICAgIGZvciAobGV0IHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMuZ2V0VGlsZSh6LCB4LCB5LCBmcmFtZVN0YXRlKTtcbiAgICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhZGRlZCA9IGFkZFRpbGVUb0xvb2t1cCh0aWxlc0J5WiwgdGlsZSwgeik7XG4gICAgICAgICAgaWYgKCFhZGRlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdGlsZVF1ZXVlS2V5ID0gdGlsZS5nZXRLZXkoKTtcbiAgICAgICAgICB3YW50ZWRUaWxlc1t0aWxlUXVldWVLZXldID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICBpZiAoIWZyYW1lU3RhdGUudGlsZVF1ZXVlLmlzS2V5UXVldWVkKHRpbGVRdWV1ZUtleSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGlsZUNvb3JkID0gY3JlYXRlVGlsZUNvb3JkKHosIHgsIHksIHRoaXMudGVtcFRpbGVDb29yZF8pO1xuICAgICAgICAgICAgICBmcmFtZVN0YXRlLnRpbGVRdWV1ZS5lbnF1ZXVlKFtcbiAgICAgICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgICAgIHRpbGVTb3VyY2VLZXksXG4gICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGVDb29yZCksXG4gICAgICAgICAgICAgICAgdGlsZVJlc29sdXRpb24sXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIGZvciB0aWxlcyBjb3ZlcmluZyB0aGUgcHJvdmlkZWQgdGlsZSBjb29yZGluYXRlIGF0IGFuIGFsdGVybmF0ZVxuICAgKiB6b29tIGxldmVsLiAgTG9hZGVkIHRpbGVzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHByb3ZpZGVkIHRpbGUgdGV4dHVyZSBsb29rdXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRoZSB0YXJnZXQgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge1RpbGVMb29rdXB9IHRpbGVzQnlaIExvb2t1cCBvZiB0aWxlcyBieSB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSBjb29yZGluYXRlIGlzIGNvdmVyZWQgYnkgbG9hZGVkIHRpbGVzIGF0IHRoZSBhbHRlcm5hdGUgem9vbSBsZXZlbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZpbmRTdGFsZVRpbGVfKHRpbGVDb29yZCwgdGlsZXNCeVopIHtcbiAgICBjb25zdCB0aWxlQ2FjaGUgPSB0aGlzLnRpbGVDYWNoZV87XG4gICAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgICBjb25zdCB4ID0gdGlsZUNvb3JkWzFdO1xuICAgIGNvbnN0IHkgPSB0aWxlQ29vcmRbMl07XG4gICAgY29uc3Qgc3RhbGVLZXlzID0gdGhpcy5nZXRTdGFsZUtleXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWxlS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShzdGFsZUtleXNbaV0sIHosIHgsIHkpO1xuICAgICAgaWYgKHRpbGVDYWNoZS5jb250YWluc0tleShjYWNoZUtleSkpIHtcbiAgICAgICAgY29uc3QgdGlsZSA9IHRpbGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgdGlsZS5lbmRUcmFuc2l0aW9uKGdldFVpZCh0aGlzKSk7XG4gICAgICAgICAgYWRkVGlsZVRvTG9va3VwKHRpbGVzQnlaLCB0aWxlLCB6KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTG9vayBmb3IgdGlsZXMgY292ZXJpbmcgdGhlIHByb3ZpZGVkIHRpbGUgY29vcmRpbmF0ZSBhdCBhbiBhbHRlcm5hdGVcbiAgICogem9vbSBsZXZlbC4gIExvYWRlZCB0aWxlcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBwcm92aWRlZCB0aWxlIHRleHR1cmUgbG9va3VwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRoZSB0aWxlIGdyaWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRoZSB0YXJnZXQgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWx0WiBUaGUgYWx0ZXJuYXRlIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7VGlsZUxvb2t1cH0gdGlsZXNCeVogTG9va3VwIG9mIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIGNvb3JkaW5hdGUgaXMgY292ZXJlZCBieSBsb2FkZWQgdGlsZXMgYXQgdGhlIGFsdGVybmF0ZSB6b29tIGxldmVsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmluZEFsdFRpbGVzXyh0aWxlR3JpZCwgdGlsZUNvb3JkLCBhbHRaLCB0aWxlc0J5Wikge1xuICAgIGNvbnN0IHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvclRpbGVDb29yZEFuZFooXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICBhbHRaLFxuICAgICAgdGhpcy50ZW1wVGlsZVJhbmdlXyxcbiAgICApO1xuXG4gICAgaWYgKCF0aWxlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY292ZXJlZCA9IHRydWU7XG4gICAgY29uc3QgdGlsZUNhY2hlID0gdGhpcy50aWxlQ2FjaGVfO1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoKS5nZXRSZW5kZXJTb3VyY2UoKTtcbiAgICBjb25zdCBzb3VyY2VLZXkgPSBzb3VyY2UuZ2V0S2V5KCk7XG4gICAgZm9yIChsZXQgeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgIGZvciAobGV0IHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoc291cmNlS2V5LCBhbHRaLCB4LCB5KTtcbiAgICAgICAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGlsZUNhY2hlLmNvbnRhaW5zS2V5KGNhY2hlS2V5KSkge1xuICAgICAgICAgIGNvbnN0IHRpbGUgPSB0aWxlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgICBhZGRUaWxlVG9Mb29rdXAodGlsZXNCeVosIHRpbGUsIGFsdFopO1xuICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBsYXllci5cbiAgICpcbiAgICogVGhlIGZyYW1lIHJlbmRlcmluZyBsb2dpYyBoYXMgdGhyZWUgcGFydHM6XG4gICAqXG4gICAqICAxLiBFbnF1ZXVlIHRpbGVzXG4gICAqICAyLiBGaW5kIGFsdCB0aWxlcyBmb3IgdGhvc2UgdGhhdCBhcmUgbm90IHlldCBsb2FkZWRcbiAgICogIDMuIFJlbmRlciBsb2FkZWQgdGlsZXNcbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IFRhcmdldCB0aGF0IG1heSBiZSB1c2VkIHRvIHJlbmRlciBjb250ZW50IHRvLlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIHJlbmRlcmVkIGVsZW1lbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KSB7XG4gICAgbGV0IGFsbFRpbGVzSWRsZSA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJDb21wbGV0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUT0RPOlxuICAgICAqICAqIG1heWJlIHNraXAgdHJhbnNpdGlvbiB3aGVuIG5vdCBmdWxseSBvcGFxdWVcbiAgICAgKiAgKiBkZWNpZGUgaWYgdGhpcy5yZW5kZXJDb21wbGV0ZSBpcyB1c2VmdWxcbiAgICAgKi9cblxuICAgIGNvbnN0IGxheWVyU3RhdGUgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXlbZnJhbWVTdGF0ZS5sYXllckluZGV4XTtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3Qgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCB2aWV3Q2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuXG4gICAgY29uc3QgdGlsZUxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGNvbnN0IHRpbGVTb3VyY2UgPSB0aWxlTGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgY29uc3Qgc291cmNlUmV2aXNpb24gPSB0aWxlU291cmNlLmdldFJldmlzaW9uKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSB0aWxlU291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBjb25zdCB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24odmlld1Jlc29sdXRpb24sIHRpbGVTb3VyY2UuekRpcmVjdGlvbik7XG4gICAgY29uc3QgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuXG4gICAgY29uc3Qgc291cmNlS2V5ID0gdGlsZVNvdXJjZS5nZXRLZXkoKTtcbiAgICBpZiAoIXRoaXMucmVuZGVyZWRTb3VyY2VLZXlfKSB7XG4gICAgICB0aGlzLnJlbmRlcmVkU291cmNlS2V5XyA9IHNvdXJjZUtleTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVuZGVyZWRTb3VyY2VLZXlfICE9PSBzb3VyY2VLZXkpIHtcbiAgICAgIHRoaXMucHJlcGVuZFN0YWxlS2V5KHRoaXMucmVuZGVyZWRTb3VyY2VLZXlfKTtcbiAgICAgIHRoaXMucmVuZGVyZWRTb3VyY2VLZXlfID0gc291cmNlS2V5O1xuICAgIH1cblxuICAgIGxldCBmcmFtZUV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcblxuICAgIHRoaXMucHJlcGFyZUNvbnRhaW5lcihmcmFtZVN0YXRlLCB0YXJnZXQpO1xuXG4gICAgLy8gZGVzaXJlZCBkaW1lbnNpb25zIG9mIHRoZSBjYW52YXMgaW4gcGl4ZWxzXG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmNvbnRleHQuY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0O1xuXG4gICAgY29uc3QgbGF5ZXJFeHRlbnQgPVxuICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgJiYgZnJvbVVzZXJFeHRlbnQobGF5ZXJTdGF0ZS5leHRlbnQsIHByb2plY3Rpb24pO1xuICAgIGlmIChsYXllckV4dGVudCkge1xuICAgICAgZnJhbWVFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oXG4gICAgICAgIGZyYW1lRXh0ZW50LFxuICAgICAgICBmcm9tVXNlckV4dGVudChsYXllclN0YXRlLmV4dGVudCwgcHJvamVjdGlvbiksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGR4ID0gKHRpbGVSZXNvbHV0aW9uICogd2lkdGgpIC8gMiAvIHRpbGVQaXhlbFJhdGlvO1xuICAgIGNvbnN0IGR5ID0gKHRpbGVSZXNvbHV0aW9uICogaGVpZ2h0KSAvIDIgLyB0aWxlUGl4ZWxSYXRpbztcbiAgICBjb25zdCBjYW52YXNFeHRlbnQgPSBbXG4gICAgICB2aWV3Q2VudGVyWzBdIC0gZHgsXG4gICAgICB2aWV3Q2VudGVyWzFdIC0gZHksXG4gICAgICB2aWV3Q2VudGVyWzBdICsgZHgsXG4gICAgICB2aWV3Q2VudGVyWzFdICsgZHksXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUaWxlTG9va3VwfVxuICAgICAqL1xuICAgIGNvbnN0IHRpbGVzQnlaID0ge307XG5cbiAgICB0aGlzLnJlbmRlcmVkVGlsZXMubGVuZ3RoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFBhcnQgMTogRW5xdWV1ZSB0aWxlc1xuICAgICAqL1xuXG4gICAgY29uc3QgcHJlbG9hZCA9IHRpbGVMYXllci5nZXRQcmVsb2FkKCk7XG4gICAgaWYgKGZyYW1lU3RhdGUubmV4dEV4dGVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0WiA9IHRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKFxuICAgICAgICB2aWV3U3RhdGUubmV4dFJlc29sdXRpb24sXG4gICAgICAgIHRpbGVTb3VyY2UuekRpcmVjdGlvbixcbiAgICAgICk7XG4gICAgICBjb25zdCBuZXh0RXh0ZW50ID0gZ2V0UmVuZGVyRXh0ZW50KGZyYW1lU3RhdGUsIGZyYW1lU3RhdGUubmV4dEV4dGVudCk7XG4gICAgICB0aGlzLmVucXVldWVUaWxlcyhmcmFtZVN0YXRlLCBuZXh0RXh0ZW50LCB0YXJnZXRaLCB0aWxlc0J5WiwgcHJlbG9hZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyRXh0ZW50ID0gZ2V0UmVuZGVyRXh0ZW50KGZyYW1lU3RhdGUsIGZyYW1lRXh0ZW50KTtcbiAgICB0aGlzLmVucXVldWVUaWxlcyhmcmFtZVN0YXRlLCByZW5kZXJFeHRlbnQsIHosIHRpbGVzQnlaLCAwKTtcbiAgICBpZiAocHJlbG9hZCA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmVucXVldWVUaWxlcyhcbiAgICAgICAgICBmcmFtZVN0YXRlLFxuICAgICAgICAgIHJlbmRlckV4dGVudCxcbiAgICAgICAgICB6IC0gMSxcbiAgICAgICAgICB0aWxlc0J5WixcbiAgICAgICAgICBwcmVsb2FkIC0gMSxcbiAgICAgICAgKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGlmICghKHogaW4gdGlsZXNCeVopKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFydCAyOiBGaW5kIGFsdCB0aWxlcyBmb3IgdGhvc2UgdGhhdCBhcmUgbm90IHlldCBsb2FkZWRcbiAgICAgKi9cblxuICAgIGNvbnN0IHVpZCA9IGdldFVpZCh0aGlzKTtcbiAgICBjb25zdCB0aW1lID0gZnJhbWVTdGF0ZS50aW1lO1xuXG4gICAgLy8gbG9vayBmb3IgY2FjaGVkIHRpbGVzIHRvIHVzZSBpZiBhIHRhcmdldCB0aWxlIGlzIG5vdCByZWFkeVxuICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aWxlc0J5Wlt6XSkge1xuICAgICAgY29uc3QgdGlsZVN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKFxuICAgICAgICAodGlsZSBpbnN0YW5jZW9mIFJlcHJvalRpbGUgfHwgdGlsZSBpbnN0YW5jZW9mIFJlcHJvakRhdGFUaWxlKSAmJlxuICAgICAgICB0aWxlU3RhdGUgPT09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGlsZUNvb3JkID0gdGlsZS50aWxlQ29vcmQ7XG5cbiAgICAgIGlmICh0aWxlU3RhdGUgPT09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgY29uc3QgYWxwaGEgPSB0aWxlLmdldEFscGhhKHVpZCwgdGltZSk7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgICAgIC8vIG5vIG5lZWQgdG8gbG9vayBmb3IgYWx0IHRpbGVzXG4gICAgICAgICAgdGlsZS5lbmRUcmFuc2l0aW9uKHVpZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aWxlU3RhdGUgIT09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgIGFsbFRpbGVzSWRsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRpbGVTdGF0ZSAhPT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFzU3RhbGVUaWxlID0gdGhpcy5maW5kU3RhbGVUaWxlXyh0aWxlQ29vcmQsIHRpbGVzQnlaKTtcbiAgICAgIGlmIChoYXNTdGFsZVRpbGUpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBzdGFsZSB0aWxlIGJlZm9yZSB0aGUgbmV3IHRpbGUncyB0cmFuc2l0aW9uIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgcmVtb3ZlVGlsZUZyb21Mb29rdXAodGlsZXNCeVosIHRpbGUsIHopO1xuICAgICAgICBmcmFtZVN0YXRlLmFuaW1hdGUgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlyc3QgbG9vayBmb3IgY2hpbGQgdGlsZXMgKGF0IHogKyAxKVxuICAgICAgY29uc3QgY292ZXJlZEJ5Q2hpbGRyZW4gPSB0aGlzLmZpbmRBbHRUaWxlc18oXG4gICAgICAgIHRpbGVHcmlkLFxuICAgICAgICB0aWxlQ29vcmQsXG4gICAgICAgIHogKyAxLFxuICAgICAgICB0aWxlc0J5WixcbiAgICAgICk7XG5cbiAgICAgIGlmIChjb3ZlcmVkQnlDaGlsZHJlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbmV4dCBsb29rIGZvciBwYXJlbnQgdGlsZXNcbiAgICAgIGNvbnN0IG1pblpvb20gPSB0aWxlR3JpZC5nZXRNaW5ab29tKCk7XG4gICAgICBmb3IgKGxldCBwYXJlbnRaID0geiAtIDE7IHBhcmVudFogPj0gbWluWm9vbTsgLS1wYXJlbnRaKSB7XG4gICAgICAgIGNvbnN0IGNvdmVyZWRCeVBhcmVudCA9IHRoaXMuZmluZEFsdFRpbGVzXyhcbiAgICAgICAgICB0aWxlR3JpZCxcbiAgICAgICAgICB0aWxlQ29vcmQsXG4gICAgICAgICAgcGFyZW50WixcbiAgICAgICAgICB0aWxlc0J5WixcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoY292ZXJlZEJ5UGFyZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0IDM6IFJlbmRlciBsb2FkZWQgdGlsZXNcbiAgICAgKi9cblxuICAgIGNvbnN0IGNhbnZhc1NjYWxlID1cbiAgICAgICgodGlsZVJlc29sdXRpb24gLyB2aWV3UmVzb2x1dGlvbikgKiBwaXhlbFJhdGlvKSAvIHRpbGVQaXhlbFJhdGlvO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0UmVuZGVyQ29udGV4dChmcmFtZVN0YXRlKTtcblxuICAgIC8vIHNldCBzY2FsZSB0cmFuc2Zvcm0gZm9yIGNhbGN1bGF0aW5nIHRpbGUgcG9zaXRpb25zIG9uIHRoZSBjYW52YXNcbiAgICBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgdGhpcy50ZW1wVHJhbnNmb3JtLFxuICAgICAgd2lkdGggLyAyLFxuICAgICAgaGVpZ2h0IC8gMixcbiAgICAgIGNhbnZhc1NjYWxlLFxuICAgICAgY2FudmFzU2NhbGUsXG4gICAgICAwLFxuICAgICAgLXdpZHRoIC8gMixcbiAgICAgIC1oZWlnaHQgLyAyLFxuICAgICk7XG5cbiAgICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQpIHtcbiAgICAgIHRoaXMuY2xpcFVucm90YXRlZChjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllckV4dGVudCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aWxlU291cmNlLmdldEludGVycG9sYXRlKCkpIHtcbiAgICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5wcmVSZW5kZXIoY29udGV4dCwgZnJhbWVTdGF0ZSk7XG5cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgenMgPSBPYmplY3Qua2V5cyh0aWxlc0J5WikubWFwKE51bWJlcik7XG4gICAgenMuc29ydChhc2NlbmRpbmcpO1xuXG4gICAgbGV0IGN1cnJlbnRDbGlwO1xuICAgIGNvbnN0IGNsaXBzID0gW107XG4gICAgY29uc3QgY2xpcFpzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBjdXJyZW50WiA9IHpzW2ldO1xuICAgICAgY29uc3QgY3VycmVudFRpbGVQaXhlbFNpemUgPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFNpemUoXG4gICAgICAgIGN1cnJlbnRaLFxuICAgICAgICBwaXhlbFJhdGlvLFxuICAgICAgICBwcm9qZWN0aW9uLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbihjdXJyZW50Wik7XG4gICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSBjdXJyZW50UmVzb2x1dGlvbiAvIHRpbGVSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgZHggPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVswXSAqIGN1cnJlbnRTY2FsZSAqIGNhbnZhc1NjYWxlO1xuICAgICAgY29uc3QgZHkgPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVsxXSAqIGN1cnJlbnRTY2FsZSAqIGNhbnZhc1NjYWxlO1xuICAgICAgY29uc3Qgb3JpZ2luVGlsZUNvb3JkID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKFxuICAgICAgICBnZXRUb3BMZWZ0KGNhbnZhc0V4dGVudCksXG4gICAgICAgIGN1cnJlbnRaLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG9yaWdpblRpbGVFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQob3JpZ2luVGlsZUNvb3JkKTtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IGFwcGx5VHJhbnNmb3JtKHRoaXMudGVtcFRyYW5zZm9ybSwgW1xuICAgICAgICAodGlsZVBpeGVsUmF0aW8gKiAob3JpZ2luVGlsZUV4dGVudFswXSAtIGNhbnZhc0V4dGVudFswXSkpIC9cbiAgICAgICAgICB0aWxlUmVzb2x1dGlvbixcbiAgICAgICAgKHRpbGVQaXhlbFJhdGlvICogKGNhbnZhc0V4dGVudFszXSAtIG9yaWdpblRpbGVFeHRlbnRbM10pKSAvXG4gICAgICAgICAgdGlsZVJlc29sdXRpb24sXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IHRpbGVHdXR0ZXIgPVxuICAgICAgICB0aWxlUGl4ZWxSYXRpbyAqIHRpbGVTb3VyY2UuZ2V0R3V0dGVyRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aWxlc0J5WltjdXJyZW50Wl0pIHtcbiAgICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSAhPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbGVDb29yZCA9IHRpbGUudGlsZUNvb3JkO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBpbnRlZ2VyIHBvc2l0aW9ucyBhbmQgc2l6ZXMgc28gdGhhdCB0aWxlcyBhbGlnblxuICAgICAgICBjb25zdCB4SW5kZXggPSBvcmlnaW5UaWxlQ29vcmRbMV0gLSB0aWxlQ29vcmRbMV07XG4gICAgICAgIGNvbnN0IG5leHRYID0gTWF0aC5yb3VuZChvcmlnaW5bMF0gLSAoeEluZGV4IC0gMSkgKiBkeCk7XG4gICAgICAgIGNvbnN0IHlJbmRleCA9IG9yaWdpblRpbGVDb29yZFsyXSAtIHRpbGVDb29yZFsyXTtcbiAgICAgICAgY29uc3QgbmV4dFkgPSBNYXRoLnJvdW5kKG9yaWdpblsxXSAtICh5SW5kZXggLSAxKSAqIGR5KTtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQob3JpZ2luWzBdIC0geEluZGV4ICogZHgpO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZChvcmlnaW5bMV0gLSB5SW5kZXggKiBkeSk7XG4gICAgICAgIGNvbnN0IHcgPSBuZXh0WCAtIHg7XG4gICAgICAgIGNvbnN0IGggPSBuZXh0WSAtIHk7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB6cy5sZW5ndGggPT09IDE7XG5cbiAgICAgICAgbGV0IGNvbnRleHRTYXZlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENsaXAgbWFzayBmb3IgcmVnaW9ucyBpbiB0aGlzIHRpbGUgdGhhdCBhbHJlYWR5IGZpbGxlZCBieSBhIGhpZ2hlciB6IHRpbGVcbiAgICAgICAgY3VycmVudENsaXAgPSBbeCwgeSwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgeCwgeSArIGhdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjbGlwcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgaWYgKCF0cmFuc2l0aW9uICYmIGN1cnJlbnRaIDwgY2xpcFpzW2ldKSB7XG4gICAgICAgICAgICBjb25zdCBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGludGVyc2VjdHMoXG4gICAgICAgICAgICAgICAgW3gsIHksIHggKyB3LCB5ICsgaF0sXG4gICAgICAgICAgICAgICAgW2NsaXBbMF0sIGNsaXBbM10sIGNsaXBbNF0sIGNsaXBbN11dLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKCFjb250ZXh0U2F2ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0U2F2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIC8vIGNvdW50ZXItY2xvY2t3aXNlIChvdXRlciByaW5nKSBmb3IgY3VycmVudCB0aWxlXG4gICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGN1cnJlbnRDbGlwWzBdLCBjdXJyZW50Q2xpcFsxXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzJdLCBjdXJyZW50Q2xpcFszXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzRdLCBjdXJyZW50Q2xpcFs1XSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzZdLCBjdXJyZW50Q2xpcFs3XSk7XG4gICAgICAgICAgICAgIC8vIGNsb2Nrd2lzZSAoaW5uZXIgcmluZykgZm9yIGhpZ2hlciB6IHRpbGVcbiAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY2xpcFs2XSwgY2xpcFs3XSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbNF0sIGNsaXBbNV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzJdLCBjbGlwWzNdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFswXSwgY2xpcFsxXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGlwcy5wdXNoKGN1cnJlbnRDbGlwKTtcbiAgICAgICAgY2xpcFpzLnB1c2goY3VycmVudFopO1xuXG4gICAgICAgIHRoaXMuZHJhd1RpbGUodGlsZSwgZnJhbWVTdGF0ZSwgeCwgeSwgdywgaCwgdGlsZUd1dHRlciwgdHJhbnNpdGlvbik7XG4gICAgICAgIGlmIChjb250ZXh0U2F2ZWQpIHtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVkVGlsZXMudW5zaGlmdCh0aWxlKTtcblxuICAgICAgICAvLyBUT0RPOiBkZWNpZGUgaWYgdGhpcyBpcyBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy51cGRhdGVVc2VkVGlsZXMoZnJhbWVTdGF0ZS51c2VkVGlsZXMsIHRpbGVTb3VyY2UsIHRpbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbiA9IHNvdXJjZVJldmlzaW9uO1xuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uID0gdGlsZVJlc29sdXRpb247XG4gICAgdGhpcy5leHRlbnRDaGFuZ2VkID1cbiAgICAgICF0aGlzLnJlbmRlcmVkRXh0ZW50XyB8fCAhZXF1YWxzKHRoaXMucmVuZGVyZWRFeHRlbnRfLCBjYW52YXNFeHRlbnQpO1xuICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gY2FudmFzRXh0ZW50O1xuICAgIHRoaXMucmVuZGVyZWRQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAgIHRoaXMucG9zdFJlbmRlcih0aGlzLmNvbnRleHQsIGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKGxheWVyU3RhdGUuZXh0ZW50KSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29tcGxldGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHBvc3RSZW5kZXJGdW5jdGlvbiA9IChtYXAsIGZyYW1lU3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICAgICAgY29uc3Qgd2FudGVkVGlsZXMgPSBmcmFtZVN0YXRlLndhbnRlZFRpbGVzW3RpbGVTb3VyY2VLZXldO1xuICAgICAgICBjb25zdCB0aWxlc0NvdW50ID0gd2FudGVkVGlsZXMgPyBPYmplY3Qua2V5cyh3YW50ZWRUaWxlcykubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZVNpemUodGlsZXNDb3VudCk7XG4gICAgICAgIHRoaXMudGlsZUNhY2hlXy5leHBpcmVDYWNoZSgpO1xuICAgICAgfTtcblxuICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLnB1c2gocG9zdFJlbmRlckZ1bmN0aW9uKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbXBsZXRlICYmICFhbGxUaWxlc0lkbGUpIHtcbiAgICAgIGZyYW1lU3RhdGUuYW5pbWF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlcyB0aGUgY2FjaGUgc2l6ZSBpZiBuZWVkZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGVDb3VudCBNaW5pbXVtIG51bWJlciBvZiB0aWxlcyBuZWVkZWQuXG4gICAqL1xuICB1cGRhdGVDYWNoZVNpemUodGlsZUNvdW50KSB7XG4gICAgdGhpcy50aWxlQ2FjaGVfLmhpZ2hXYXRlck1hcmsgPSBNYXRoLm1heChcbiAgICAgIHRoaXMudGlsZUNhY2hlXy5oaWdoV2F0ZXJNYXJrLFxuICAgICAgdGlsZUNvdW50ICogMixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IExlZnQgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRvcCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGggb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBUaWxlIGd1dHRlci5cbiAgICogQHBhcmFtIHtib29sZWFufSB0cmFuc2l0aW9uIEFwcGx5IGFuIGFscGhhIHRyYW5zaXRpb24uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRyYXdUaWxlKHRpbGUsIGZyYW1lU3RhdGUsIHgsIHksIHcsIGgsIGd1dHRlciwgdHJhbnNpdGlvbikge1xuICAgIGxldCBpbWFnZTtcbiAgICBpZiAodGlsZSBpbnN0YW5jZW9mIERhdGFUaWxlKSB7XG4gICAgICBpbWFnZSA9IGFzSW1hZ2VMaWtlKHRpbGUuZ2V0RGF0YSgpKTtcbiAgICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJpbmcgYXJyYXkgZGF0YSBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZSA9IHRoaXMuZ2V0VGlsZUltYWdlKFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZSksXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldFJlbmRlckNvbnRleHQoZnJhbWVTdGF0ZSk7XG4gICAgY29uc3QgdWlkID0gZ2V0VWlkKHRoaXMpO1xuICAgIGNvbnN0IGxheWVyU3RhdGUgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXlbZnJhbWVTdGF0ZS5sYXllckluZGV4XTtcbiAgICBjb25zdCBhbHBoYSA9XG4gICAgICBsYXllclN0YXRlLm9wYWNpdHkgKlxuICAgICAgKHRyYW5zaXRpb24gPyB0aWxlLmdldEFscGhhKHVpZCwgZnJhbWVTdGF0ZS50aW1lKSA6IDEpO1xuICAgIGNvbnN0IGFscGhhQ2hhbmdlZCA9IGFscGhhICE9PSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgIGlmIChhbHBoYUNoYW5nZWQpIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgIGltYWdlLFxuICAgICAgZ3V0dGVyLFxuICAgICAgZ3V0dGVyLFxuICAgICAgaW1hZ2Uud2lkdGggLSAyICogZ3V0dGVyLFxuICAgICAgaW1hZ2UuaGVpZ2h0IC0gMiAqIGd1dHRlcixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgKTtcblxuICAgIGlmIChhbHBoYUNoYW5nZWQpIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoYWxwaGEgIT09IGxheWVyU3RhdGUub3BhY2l0eSkge1xuICAgICAgZnJhbWVTdGF0ZS5hbmltYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIHRpbGUuZW5kVHJhbnNpdGlvbih1aWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gSW1hZ2VcbiAgICovXG4gIGdldEltYWdlKCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0LmNhbnZhcyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBmcm9tIGEgdGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IEltYWdlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRUaWxlSW1hZ2UodGlsZSkge1xuICAgIHJldHVybiB0aWxlLmdldEltYWdlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgIU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+Pn0gdXNlZFRpbGVzIFVzZWQgdGlsZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZVNvdXJjZSBUaWxlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL1RpbGUuanMnKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHVwZGF0ZVVzZWRUaWxlcyh1c2VkVGlsZXMsIHRpbGVTb3VyY2UsIHRpbGUpIHtcbiAgICAvLyBGSVhNRSBzaG91bGQgd2UgdXNlIHRpbGVzVG9EcmF3QnlaIGluc3RlYWQ/XG4gICAgY29uc3QgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICBpZiAoISh0aWxlU291cmNlS2V5IGluIHVzZWRUaWxlcykpIHtcbiAgICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XSA9IHt9O1xuICAgIH1cbiAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV1bdGlsZS5nZXRLZXkoKV0gPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1RpbGVMYXllclJlbmRlcmVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvalxuICovXG5pbXBvcnQge1xuICBjb250YWluc0Nvb3JkaW5hdGUsXG4gIGNyZWF0ZUVtcHR5LFxuICBleHRlbmQsXG4gIGZvckVhY2hDb3JuZXIsXG4gIGdldENlbnRlcixcbiAgZ2V0SGVpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRXaWR0aCxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkQsIHJlbGVhc2VDYW52YXN9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7Z2V0UG9pbnRSZXNvbHV0aW9uLCB0cmFuc2Zvcm19IGZyb20gJy4vcHJvai5qcyc7XG5pbXBvcnQge3NvbHZlTGluZWFyU3lzdGVtfSBmcm9tICcuL21hdGguanMnO1xuXG5sZXQgYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxIVE1MQ2FudmFzRWxlbWVudD59XG4gKi9cbmV4cG9ydCBjb25zdCBjYW52YXNQb29sID0gW107XG5cbi8qKlxuICogVGhpcyBkcmF3cyBhIHNtYWxsIHRyaWFuZ2xlIGludG8gYSBjYW52YXMgYnkgc2V0dGluZyB0aGUgdHJpYW5nbGUgYXMgdGhlIGNsaXAgcmVnaW9uXG4gKiBhbmQgdGhlbiBkcmF3aW5nIGEgKHRvbyBsYXJnZSkgcmVjdGFuZ2xlXG4gKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY29udGV4dCBpbiB3aGljaCB0byBkcmF3IHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHUxIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC4gVGhlIGZpcnN0IHBvaW50IGlzIDAsMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2MSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdTIgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdGhpcmQgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdjIgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdGhpcmQgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIGRyYXdUZXN0VHJpYW5nbGUoY3R4LCB1MSwgdjEsIHUyLCB2Mikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oMCwgMCk7XG4gIGN0eC5saW5lVG8odTEsIHYxKTtcbiAgY3R4LmxpbmVUbyh1MiwgdjIpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5jbGlwKCk7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCBNYXRoLm1heCh1MSwgdTIpICsgMSwgTWF0aC5tYXgodjEsIHYyKSk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGRhdGEgZnJvbSBnZXRJbWFnZURhdGEsIHNlZSBpZiB0aGUgcmlnaHQgdmFsdWVzIGFwcGVhciBhdCB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICogUmV0dXJucyB0cnVlIGlmIGVpdGhlciB0aGUgY29sb3Igb3IgdHJhbnNwYXJlbmN5IGlzIG9mZlxuICpcbiAqIEBwYXJhbSB7VWludDhDbGFtcGVkQXJyYXl9IGRhdGEgVGhlIGRhdGEgcmV0dXJuZWQgZnJvbSBnZXRJbWFnZURhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIHBpeGVsIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBkYXRhLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZGlhZ29uYWwgcmVuZGVyaW5nIGlzIGJyb2tlblxuICovXG5mdW5jdGlvbiB2ZXJpZnlCcm9rZW5EaWFnb25hbFJlbmRlcmluZyhkYXRhLCBvZmZzZXQpIHtcbiAgLy8gdGhlIHZhbHVlcyBvdWdodCB0byBiZSBjbG9zZSB0byB0aGUgcmdiYSgyMTAsIDAsIDAsIDAuNzUpXG4gIHJldHVybiAoXG4gICAgTWF0aC5hYnMoZGF0YVtvZmZzZXQgKiA0XSAtIDIxMCkgPiAyIHx8XG4gICAgTWF0aC5hYnMoZGF0YVtvZmZzZXQgKiA0ICsgM10gLSAwLjc1ICogMjU1KSA+IDJcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgY29uZmlndXJhdGlvbiBjYW4gcmVuZGVyIHRyaWFuZ3VsYXIgY2xpcCByZWdpb25zIGNvcnJlY3RseS5cbiAqIFRoaXMgdmFsdWUgaXMgY2FjaGVkIHNvIHRoZSBmdW5jdGlvbiBpcyBvbmx5IGV4cGVuc2l2ZSB0aGUgZmlyc3QgdGltZSBjYWxsZWQuXG4gKiBGaXJlZm94IG9uIFdpbmRvd3MgKGFzIG9mIG5vdykgZG9lcyBub3QgaWYgSFdBIGlzIGVuYWJsZWQuIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjA2OTc2XG4gKiBDaHJvbWUgd29ya3MsIGFuZCBldmVyeXRoaW5nIHNlZW1zIHRvIHdvcmsgb24gT1NYIGFuZCBBbmRyb2lkLiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyB0aGVcbiAqIHJlc3VsdC4gSSBzdXBwb3NlIHRoYXQgaXQgaXMgY29uY2VpdmFibHkgcG9zc2libGUgdGhhdCBhIGJyb3dzZXIgbWlnaHQgZmxpcCBtb2RlcyB3aGlsZSB0aGUgYXBwIGlzXG4gKiBydW5uaW5nLCBidXQgbGV0cyBob3BlIG5vdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBEaWFnb25hbCBSZW5kZXJpbmcgaXMgYnJva2VuLlxuICovXG5mdW5jdGlvbiBpc0Jyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKCkge1xuICBpZiAoYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoNiwgNiwgY2FudmFzUG9vbCk7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdsaWdodGVyJztcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjEwLCAwLCAwLCAwLjc1KSc7XG4gICAgZHJhd1Rlc3RUcmlhbmdsZShjdHgsIDQsIDUsIDQsIDApO1xuICAgIGRyYXdUZXN0VHJpYW5nbGUoY3R4LCA0LCA1LCAwLCA1KTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAzLCAzKS5kYXRhO1xuICAgIGJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nXyA9XG4gICAgICB2ZXJpZnlCcm9rZW5EaWFnb25hbFJlbmRlcmluZyhkYXRhLCAwKSB8fFxuICAgICAgdmVyaWZ5QnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoZGF0YSwgNCkgfHxcbiAgICAgIHZlcmlmeUJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKGRhdGEsIDgpO1xuICAgIHJlbGVhc2VDYW52YXMoY3R4KTtcbiAgICBjYW52YXNQb29sLnB1c2goY3R4LmNhbnZhcyk7XG4gIH1cblxuICByZXR1cm4gYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgaWRlYWwgcmVzb2x1dGlvbiB0byB1c2UgZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGFjaGlldmVcbiAqIHBpeGVsIG1hcHBpbmcgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gMToxIGR1cmluZyByZXByb2plY3Rpb24uXG4gKiBUaGUgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkIHJlZ2FyZGxlc3Mgb2Ygd2hhdCByZXNvbHV0aW9uc1xuICogYXJlIGFjdHVhbGx5IGF2YWlsYWJsZSBpbiB0aGUgZGF0YXNldCAoVGlsZUdyaWQsIEltYWdlLCAuLi4pLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRhcmdldENlbnRlciBUYXJnZXQgY2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiZXN0IHJlc29sdXRpb24gdG8gdXNlLiBDYW4gYmUgKy1JbmZpbml0eSwgTmFOIG9yIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICBzb3VyY2VQcm9qLFxuICB0YXJnZXRQcm9qLFxuICB0YXJnZXRDZW50ZXIsXG4gIHRhcmdldFJlc29sdXRpb24sXG4pIHtcbiAgY29uc3Qgc291cmNlQ2VudGVyID0gdHJhbnNmb3JtKHRhcmdldENlbnRlciwgdGFyZ2V0UHJvaiwgc291cmNlUHJvaik7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBpZGVhbCByZXNvbHV0aW9uIG9mIHRoZSBzb3VyY2UgZGF0YVxuICBsZXQgc291cmNlUmVzb2x1dGlvbiA9IGdldFBvaW50UmVzb2x1dGlvbihcbiAgICB0YXJnZXRQcm9qLFxuICAgIHRhcmdldFJlc29sdXRpb24sXG4gICAgdGFyZ2V0Q2VudGVyLFxuICApO1xuXG4gIGNvbnN0IHRhcmdldE1ldGVyc1BlclVuaXQgPSB0YXJnZXRQcm9qLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgaWYgKHRhcmdldE1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVJlc29sdXRpb24gKj0gdGFyZ2V0TWV0ZXJzUGVyVW5pdDtcbiAgfVxuICBjb25zdCBzb3VyY2VNZXRlcnNQZXJVbml0ID0gc291cmNlUHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmIChzb3VyY2VNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uIC89IHNvdXJjZU1ldGVyc1BlclVuaXQ7XG4gIH1cblxuICAvLyBCYXNlZCBvbiB0aGUgcHJvamVjdGlvbiBwcm9wZXJ0aWVzLCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBhdCB0aGUgc3BlY2lmaWVkXG4gIC8vIGNvb3JkaW5hdGVzIG1heSBiZSBzbGlnaHRseSBkaWZmZXJlbnQuIFdlIG5lZWQgdG8gcmV2ZXJzZS1jb21wZW5zYXRlIHRoaXNcbiAgLy8gaW4gb3JkZXIgdG8gYWNoaWV2ZSBvcHRpbWFsIHJlc3VsdHMuXG5cbiAgY29uc3Qgc291cmNlRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgaWYgKCFzb3VyY2VFeHRlbnQgfHwgY29udGFpbnNDb29yZGluYXRlKHNvdXJjZUV4dGVudCwgc291cmNlQ2VudGVyKSkge1xuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkZhY3RvciA9XG4gICAgICBnZXRQb2ludFJlc29sdXRpb24oc291cmNlUHJvaiwgc291cmNlUmVzb2x1dGlvbiwgc291cmNlQ2VudGVyKSAvXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uO1xuICAgIGlmIChpc0Zpbml0ZShjb21wZW5zYXRpb25GYWN0b3IpICYmIGNvbXBlbnNhdGlvbkZhY3RvciA+IDApIHtcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gLz0gY29tcGVuc2F0aW9uRmFjdG9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2VSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgaWRlYWwgcmVzb2x1dGlvbiB0byB1c2UgZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGFjaGlldmVcbiAqIHBpeGVsIG1hcHBpbmcgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gMToxIGR1cmluZyByZXByb2plY3Rpb24uXG4gKiBUaGUgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkIHJlZ2FyZGxlc3Mgb2Ygd2hhdCByZXNvbHV0aW9uc1xuICogYXJlIGFjdHVhbGx5IGF2YWlsYWJsZSBpbiB0aGUgZGF0YXNldCAoVGlsZUdyaWQsIEltYWdlLCAuLi4pLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudFxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiZXN0IHJlc29sdXRpb24gdG8gdXNlLiBDYW4gYmUgKy1JbmZpbml0eSwgTmFOIG9yIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTb3VyY2VFeHRlbnRSZXNvbHV0aW9uKFxuICBzb3VyY2VQcm9qLFxuICB0YXJnZXRQcm9qLFxuICB0YXJnZXRFeHRlbnQsXG4gIHRhcmdldFJlc29sdXRpb24sXG4pIHtcbiAgY29uc3QgdGFyZ2V0Q2VudGVyID0gZ2V0Q2VudGVyKHRhcmdldEV4dGVudCk7XG4gIGxldCBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihcbiAgICBzb3VyY2VQcm9qLFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0Q2VudGVyLFxuICAgIHRhcmdldFJlc29sdXRpb24sXG4gICk7XG5cbiAgaWYgKCFpc0Zpbml0ZShzb3VyY2VSZXNvbHV0aW9uKSB8fCBzb3VyY2VSZXNvbHV0aW9uIDw9IDApIHtcbiAgICBmb3JFYWNoQ29ybmVyKHRhcmdldEV4dGVudCwgZnVuY3Rpb24gKGNvcm5lcikge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiA9IGNhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24oXG4gICAgICAgIHNvdXJjZVByb2osXG4gICAgICAgIHRhcmdldFByb2osXG4gICAgICAgIGNvcm5lcixcbiAgICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICAgICk7XG4gICAgICByZXR1cm4gaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgJiYgc291cmNlUmVzb2x1dGlvbiA+IDA7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlUmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbWFnZUV4dGVudFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2NsaXBFeHRlbnRdIENsaXAgZXh0ZW50LlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIEltYWdlLlxuICovXG5cbi8qKlxuICogUmVuZGVycyB0aGUgc291cmNlIGRhdGEgaW50byBuZXcgY2FudmFzIGJhc2VkIG9uIHRoZSB0cmlhbmd1bGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtudW1iZXJ9IHNvdXJjZVJlc29sdXRpb24gU291cmNlIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gc291cmNlRXh0ZW50IEV4dGVudCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9yZXByb2ovVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fSB0cmlhbmd1bGF0aW9uIENhbGN1bGF0ZWQgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8SW1hZ2VFeHRlbnQ+fSBzb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIEd1dHRlciBvZiB0aGUgc291cmNlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbmRlckVkZ2VzXSBSZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzLlxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJwb2xhdGVdIFVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aGVuIHJlc2FtcGxpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkcmF3U2luZ2xlXSBEcmF3IHNpbmdsZSBzb3VyY2UgaW1hZ2VzIGRpcmVjdGx5IHdpdGhvdXQgc3RpdGNoQ29udGV4dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsaXBFeHRlbnRdIENsaXAgc3RpdGNoQ29udGV4dCB0byBzb3VyY2VFeHRlbnQuXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzIHdpdGggcmVwcm9qZWN0ZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgcGl4ZWxSYXRpbyxcbiAgc291cmNlUmVzb2x1dGlvbixcbiAgc291cmNlRXh0ZW50LFxuICB0YXJnZXRSZXNvbHV0aW9uLFxuICB0YXJnZXRFeHRlbnQsXG4gIHRyaWFuZ3VsYXRpb24sXG4gIHNvdXJjZXMsXG4gIGd1dHRlcixcbiAgcmVuZGVyRWRnZXMsXG4gIGludGVycG9sYXRlLFxuICBkcmF3U2luZ2xlLFxuICBjbGlwRXh0ZW50LFxuKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogd2lkdGgpLFxuICAgIE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIGhlaWdodCksXG4gICAgY2FudmFzUG9vbCxcbiAgKTtcblxuICBpZiAoIWludGVycG9sYXRlKSB7XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb250ZXh0LmNhbnZhcztcbiAgfVxuXG4gIGNvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cbiAgZnVuY3Rpb24gcGl4ZWxSb3VuZCh2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICB9XG5cbiAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbGlnaHRlcic7XG5cbiAgY29uc3Qgc291cmNlRGF0YUV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc3JjLCBpLCBhcnIpIHtcbiAgICBleHRlbmQoc291cmNlRGF0YUV4dGVudCwgc3JjLmV4dGVudCk7XG4gIH0pO1xuXG4gIGxldCBzdGl0Y2hDb250ZXh0O1xuICBjb25zdCBzdGl0Y2hTY2FsZSA9IHBpeGVsUmF0aW8gLyBzb3VyY2VSZXNvbHV0aW9uO1xuICAvLyBSb3VuZCB1cCBGbG9hdDMyIHNjYWxlIHZhbHVlcyB0byBwcmV2ZW50IGludGVycG9sYXRpb24gaW4gRmlyZWZveC5cbiAgY29uc3QgaW52ZXJzZVNjYWxlID0gKGludGVycG9sYXRlID8gMSA6IDEgKyBNYXRoLnBvdygyLCAtMjQpKSAvIHN0aXRjaFNjYWxlO1xuXG4gIGlmICghZHJhd1NpbmdsZSB8fCBzb3VyY2VzLmxlbmd0aCAhPT0gMSB8fCBndXR0ZXIgIT09IDApIHtcbiAgICBzdGl0Y2hDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgTWF0aC5yb3VuZChnZXRXaWR0aChzb3VyY2VEYXRhRXh0ZW50KSAqIHN0aXRjaFNjYWxlKSxcbiAgICAgIE1hdGgucm91bmQoZ2V0SGVpZ2h0KHNvdXJjZURhdGFFeHRlbnQpICogc3RpdGNoU2NhbGUpLFxuICAgICAgY2FudmFzUG9vbCxcbiAgICApO1xuXG4gICAgaWYgKCFpbnRlcnBvbGF0ZSkge1xuICAgICAgc3RpdGNoQ29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUV4dGVudCAmJiBjbGlwRXh0ZW50KSB7XG4gICAgICBjb25zdCB4UG9zID0gKHNvdXJjZUV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF0pICogc3RpdGNoU2NhbGU7XG4gICAgICBjb25zdCB5UG9zID0gLShzb3VyY2VFeHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKSAqIHN0aXRjaFNjYWxlO1xuICAgICAgY29uc3Qgd2lkdGggPSBnZXRXaWR0aChzb3VyY2VFeHRlbnQpICogc3RpdGNoU2NhbGU7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQoc291cmNlRXh0ZW50KSAqIHN0aXRjaFNjYWxlO1xuICAgICAgc3RpdGNoQ29udGV4dC5yZWN0KHhQb3MsIHlQb3MsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgc3RpdGNoQ29udGV4dC5jbGlwKCk7XG4gICAgfVxuXG4gICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMsIGksIGFycikge1xuICAgICAgLy8gVGhpcyB0ZXN0IHNob3VsZCBuZXZlciBmYWlsIC0tIGJ1dCBpdCBkb2VzLiBOZWVkIHRvIGZpbmQgYSBmaXggdGhlIHVwc3RyZWFtIGNvbmRpdGlvblxuICAgICAgaWYgKHNyYy5pbWFnZS53aWR0aCA+IDAgJiYgc3JjLmltYWdlLmhlaWdodCA+IDApIHtcbiAgICAgICAgaWYgKHNyYy5jbGlwRXh0ZW50KSB7XG4gICAgICAgICAgc3RpdGNoQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgY29uc3QgeFBvcyA9IChzcmMuY2xpcEV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF0pICogc3RpdGNoU2NhbGU7XG4gICAgICAgICAgY29uc3QgeVBvcyA9IC0oc3JjLmNsaXBFeHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKSAqIHN0aXRjaFNjYWxlO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0V2lkdGgoc3JjLmNsaXBFeHRlbnQpICogc3RpdGNoU2NhbGU7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KHNyYy5jbGlwRXh0ZW50KSAqIHN0aXRjaFNjYWxlO1xuICAgICAgICAgIHN0aXRjaENvbnRleHQucmVjdChcbiAgICAgICAgICAgIGludGVycG9sYXRlID8geFBvcyA6IE1hdGgucm91bmQoeFBvcyksXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSA/IHlQb3MgOiBNYXRoLnJvdW5kKHlQb3MpLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGUgPyB3aWR0aCA6IE1hdGgucm91bmQoeFBvcyArIHdpZHRoKSAtIE1hdGgucm91bmQoeFBvcyksXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSA/IGhlaWdodCA6IE1hdGgucm91bmQoeVBvcyArIGhlaWdodCkgLSBNYXRoLnJvdW5kKHlQb3MpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RpdGNoQ29udGV4dC5jbGlwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4UG9zID0gKHNyYy5leHRlbnRbMF0gLSBzb3VyY2VEYXRhRXh0ZW50WzBdKSAqIHN0aXRjaFNjYWxlO1xuICAgICAgICBjb25zdCB5UG9zID0gLShzcmMuZXh0ZW50WzNdIC0gc291cmNlRGF0YUV4dGVudFszXSkgKiBzdGl0Y2hTY2FsZTtcbiAgICAgICAgY29uc3Qgc3JjV2lkdGggPSBnZXRXaWR0aChzcmMuZXh0ZW50KSAqIHN0aXRjaFNjYWxlO1xuICAgICAgICBjb25zdCBzcmNIZWlnaHQgPSBnZXRIZWlnaHQoc3JjLmV4dGVudCkgKiBzdGl0Y2hTY2FsZTtcbiAgICAgICAgc3RpdGNoQ29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgc3JjLmltYWdlLFxuICAgICAgICAgIGd1dHRlcixcbiAgICAgICAgICBndXR0ZXIsXG4gICAgICAgICAgc3JjLmltYWdlLndpZHRoIC0gMiAqIGd1dHRlcixcbiAgICAgICAgICBzcmMuaW1hZ2UuaGVpZ2h0IC0gMiAqIGd1dHRlcixcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA/IHhQb3MgOiBNYXRoLnJvdW5kKHhQb3MpLFxuICAgICAgICAgIGludGVycG9sYXRlID8geVBvcyA6IE1hdGgucm91bmQoeVBvcyksXG4gICAgICAgICAgaW50ZXJwb2xhdGVcbiAgICAgICAgICAgID8gc3JjV2lkdGhcbiAgICAgICAgICAgIDogTWF0aC5yb3VuZCh4UG9zICsgc3JjV2lkdGgpIC0gTWF0aC5yb3VuZCh4UG9zKSxcbiAgICAgICAgICBpbnRlcnBvbGF0ZVxuICAgICAgICAgICAgPyBzcmNIZWlnaHRcbiAgICAgICAgICAgIDogTWF0aC5yb3VuZCh5UG9zICsgc3JjSGVpZ2h0KSAtIE1hdGgucm91bmQoeVBvcyksXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHNyYy5jbGlwRXh0ZW50KSB7XG4gICAgICAgICAgc3RpdGNoQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCB0YXJnZXRUb3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuXG4gIHRyaWFuZ3VsYXRpb24uZ2V0VHJpYW5nbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJpYW5nbGUsIGksIGFycikge1xuICAgIC8qIENhbGN1bGF0ZSBhZmZpbmUgdHJhbnNmb3JtIChzcmMgLT4gZHN0KVxuICAgICAqIFJlc3VsdGluZyBtYXRyaXggY2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkaW5hdGVcbiAgICAgKiBmcm9tIGBzb3VyY2VQcm9qZWN0aW9uYCB0byBkZXN0aW5hdGlvbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBUbyBvcHRpbWl6ZSBudW1iZXIgb2YgY29udGV4dCBjYWxscyBhbmQgaW5jcmVhc2UgbnVtZXJpY2FsIHN0YWJpbGl0eSxcbiAgICAgKiB3ZSBhbHNvIGRvIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcbiAgICAgKiB0cmFucygtdG9wTGVmdEV4dGVudENvcm5lciksIHNjYWxlKDEgLyB0YXJnZXRSZXNvbHV0aW9uKSwgc2NhbGUoMSwgLTEpXG4gICAgICogaGVyZSBiZWZvcmUgc29sdmluZyB0aGUgbGluZWFyIHN5c3RlbSBzbyBbdWksIHZpXSBhcmUgcGl4ZWwgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBTcmMgcG9pbnRzOiB4aSwgeWlcbiAgICAgKiBEc3QgcG9pbnRzOiB1aSwgdmlcbiAgICAgKiBBZmZpbmUgY29lZmZpY2llbnRzOiBhaWpcbiAgICAgKlxuICAgICAqIHwgeDAgeTAgMSAgMCAgMCAwIHwgICB8YTAwfCAgIHx1MHxcbiAgICAgKiB8IHgxIHkxIDEgIDAgIDAgMCB8ICAgfGEwMXwgICB8dTF8XG4gICAgICogfCB4MiB5MiAxICAwICAwIDAgfCB4IHxhMDJ8ID0gfHUyfFxuICAgICAqIHwgIDAgIDAgMCB4MCB5MCAxIHwgICB8YTEwfCAgIHx2MHxcbiAgICAgKiB8ICAwICAwIDAgeDEgeTEgMSB8ICAgfGExMXwgICB8djF8XG4gICAgICogfCAgMCAgMCAwIHgyIHkyIDEgfCAgIHxhMTJ8ICAgfHYyfFxuICAgICAqL1xuICAgIGNvbnN0IHNvdXJjZSA9IHRyaWFuZ2xlLnNvdXJjZTtcbiAgICBjb25zdCB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgbGV0IHgwID0gc291cmNlWzBdWzBdLFxuICAgICAgeTAgPSBzb3VyY2VbMF1bMV07XG4gICAgbGV0IHgxID0gc291cmNlWzFdWzBdLFxuICAgICAgeTEgPSBzb3VyY2VbMV1bMV07XG4gICAgbGV0IHgyID0gc291cmNlWzJdWzBdLFxuICAgICAgeTIgPSBzb3VyY2VbMl1bMV07XG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgZXZlcnl0aGluZyBpcyBvbiBwaXhlbCBib3VuZGFyaWVzXG4gICAgY29uc3QgdTAgPSBwaXhlbFJvdW5kKCh0YXJnZXRbMF1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb24pO1xuICAgIGNvbnN0IHYwID0gcGl4ZWxSb3VuZChcbiAgICAgIC0odGFyZ2V0WzBdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uLFxuICAgICk7XG4gICAgY29uc3QgdTEgPSBwaXhlbFJvdW5kKCh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb24pO1xuICAgIGNvbnN0IHYxID0gcGl4ZWxSb3VuZChcbiAgICAgIC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uLFxuICAgICk7XG4gICAgY29uc3QgdTIgPSBwaXhlbFJvdW5kKCh0YXJnZXRbMl1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb24pO1xuICAgIGNvbnN0IHYyID0gcGl4ZWxSb3VuZChcbiAgICAgIC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uLFxuICAgICk7XG5cbiAgICAvLyBTaGlmdCBhbGwgdGhlIHNvdXJjZSBwb2ludHMgdG8gaW1wcm92ZSBudW1lcmljYWwgc3RhYmlsaXR5XG4gICAgLy8gb2YgYWxsIHRoZSBzdWJzZXF1ZW50IGNhbGN1bGF0aW9ucy4gVGhlIFt4MCwgeTBdIGlzIHVzZWQgaGVyZS5cbiAgICAvLyBUaGlzIGlzIGFsc28gdXNlZCB0byBzaW1wbGlmeSB0aGUgbGluZWFyIHN5c3RlbS5cbiAgICBjb25zdCBzb3VyY2VOdW1lcmljYWxTaGlmdFggPSB4MDtcbiAgICBjb25zdCBzb3VyY2VOdW1lcmljYWxTaGlmdFkgPSB5MDtcbiAgICB4MCA9IDA7XG4gICAgeTAgPSAwO1xuICAgIHgxIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG4gICAgeDIgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRYO1xuICAgIHkyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WTtcblxuICAgIGNvbnN0IGF1Z21lbnRlZE1hdHJpeCA9IFtcbiAgICAgIFt4MSwgeTEsIDAsIDAsIHUxIC0gdTBdLFxuICAgICAgW3gyLCB5MiwgMCwgMCwgdTIgLSB1MF0sXG4gICAgICBbMCwgMCwgeDEsIHkxLCB2MSAtIHYwXSxcbiAgICAgIFswLCAwLCB4MiwgeTIsIHYyIC0gdjBdLFxuICAgIF07XG4gICAgY29uc3QgYWZmaW5lQ29lZnMgPSBzb2x2ZUxpbmVhclN5c3RlbShhdWdtZW50ZWRNYXRyaXgpO1xuICAgIGlmICghYWZmaW5lQ29lZnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKGlzQnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoKSB8fCAhaW50ZXJwb2xhdGUpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGFsbCBsaW5lcyBhcmUgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuICAgICAgY29udGV4dC5tb3ZlVG8odTEsIHYxKTtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGRpYWdvbmFsIGxpbmUuIERvIGl0IGluIDQgc3RlcHNcbiAgICAgIGNvbnN0IHN0ZXBzID0gNDtcbiAgICAgIGNvbnN0IHVkID0gdTAgLSB1MTtcbiAgICAgIGNvbnN0IHZkID0gdjAgLSB2MTtcbiAgICAgIGZvciAobGV0IHN0ZXAgPSAwOyBzdGVwIDwgc3RlcHM7IHN0ZXArKykge1xuICAgICAgICAvLyBHbyBob3Jpem9udGFsbHlcbiAgICAgICAgY29udGV4dC5saW5lVG8oXG4gICAgICAgICAgdTEgKyBwaXhlbFJvdW5kKCgoc3RlcCArIDEpICogdWQpIC8gc3RlcHMpLFxuICAgICAgICAgIHYxICsgcGl4ZWxSb3VuZCgoc3RlcCAqIHZkKSAvIChzdGVwcyAtIDEpKSxcbiAgICAgICAgKTtcbiAgICAgICAgLy8gR28gdmVydGljYWxseVxuICAgICAgICBpZiAoc3RlcCAhPSBzdGVwcyAtIDEpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICAgIHUxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHVkKSAvIHN0ZXBzKSxcbiAgICAgICAgICAgIHYxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHZkKSAvIChzdGVwcyAtIDEpKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhcmUgYWxtb3N0IGF0IHUwciwgdjByXG4gICAgICBjb250ZXh0LmxpbmVUbyh1MiwgdjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgY29udGV4dC5saW5lVG8odTAsIHYwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICBjb250ZXh0LnRyYW5zZm9ybShcbiAgICAgIGFmZmluZUNvZWZzWzBdLFxuICAgICAgYWZmaW5lQ29lZnNbMl0sXG4gICAgICBhZmZpbmVDb2Vmc1sxXSxcbiAgICAgIGFmZmluZUNvZWZzWzNdLFxuICAgICAgdTAsXG4gICAgICB2MCxcbiAgICApO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoXG4gICAgICBzb3VyY2VEYXRhRXh0ZW50WzBdIC0gc291cmNlTnVtZXJpY2FsU2hpZnRYLFxuICAgICAgc291cmNlRGF0YUV4dGVudFszXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WSxcbiAgICApO1xuXG4gICAgbGV0IGltYWdlO1xuICAgIGlmIChzdGl0Y2hDb250ZXh0KSB7XG4gICAgICBpbWFnZSA9IHN0aXRjaENvbnRleHQuY2FudmFzO1xuICAgICAgY29udGV4dC5zY2FsZShpbnZlcnNlU2NhbGUsIC1pbnZlcnNlU2NhbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzWzBdO1xuICAgICAgY29uc3QgZXh0ZW50ID0gc291cmNlLmV4dGVudDtcbiAgICAgIGltYWdlID0gc291cmNlLmltYWdlO1xuICAgICAgY29udGV4dC5zY2FsZShcbiAgICAgICAgZ2V0V2lkdGgoZXh0ZW50KSAvIGltYWdlLndpZHRoLFxuICAgICAgICAtZ2V0SGVpZ2h0KGV4dGVudCkgLyBpbWFnZS5oZWlnaHQsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgaWYgKHN0aXRjaENvbnRleHQpIHtcbiAgICByZWxlYXNlQ2FudmFzKHN0aXRjaENvbnRleHQpO1xuICAgIGNhbnZhc1Bvb2wucHVzaChzdGl0Y2hDb250ZXh0LmNhbnZhcyk7XG4gIH1cblxuICBpZiAocmVuZGVyRWRnZXMpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG5cbiAgICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24gKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICAgIGNvbnN0IHUwID0gKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB1MSA9ICh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MSA9IC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjIgPSAtKHRhcmdldFsyXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MCwgdjApO1xuICAgICAgY29udGV4dC5saW5lVG8odTIsIHYyKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9EYXRhVGlsZVxuICovXG5pbXBvcnQge0VSUk9SX1RIUkVTSE9MRH0gZnJvbSAnLi9jb21tb24uanMnO1xuXG5pbXBvcnQgRGF0YVRpbGUsIHthc0FycmF5TGlrZSwgYXNJbWFnZUxpa2UsIHRvQXJyYXl9IGZyb20gJy4uL0RhdGFUaWxlLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVHJpYW5ndWxhdGlvbiBmcm9tICcuL1RyaWFuZ3VsYXRpb24uanMnO1xuaW1wb3J0IHtjYWxjdWxhdGVTb3VyY2VFeHRlbnRSZXNvbHV0aW9ufSBmcm9tICcuLi9yZXByb2ouanMnO1xuaW1wb3J0IHtcbiAgY2FudmFzR0xQb29sLFxuICBjcmVhdGVDYW52YXNDb250ZXh0V2ViR0wsXG4gIHJlbGVhc2VHTENhbnZhcyxcbiAgcmVuZGVyIGFzIHJlbmRlclJlcHJvamVjdGVkLFxufSBmcm9tICcuL2dscmVwcm9qLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2dldEFyZWEsIGdldEludGVyc2VjdGlvbiwgZ2V0V2lkdGgsIHdyYXBBbmRTbGljZVh9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyKSA6IGltcG9ydChcIi4uL0RhdGFUaWxlLmpzXCIpLmRlZmF1bHR9IFRpbGVHZXR0ZXJcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbGVPZmZzZXRcbiAqIEBwcm9wZXJ0eSB7RGF0YVRpbGV9IHRpbGUgVGlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gc291cmNlVGlsZUdyaWQgU291cmNlIHRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRhcmdldFRpbGVHcmlkIFRhcmdldCB0aWxlIGdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbd3JhcHBlZFRpbGVDb29yZF0gQ29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB3cmFwcGVkIGluIFguXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2UgdGlsZXMuXG4gKiBAcHJvcGVydHkge1RpbGVHZXR0ZXJ9IGdldFRpbGVGdW5jdGlvbiBGdW5jdGlvbiByZXR1cm5pbmcgc291cmNlIHRpbGVzICh6LCB4LCB5LCBwaXhlbFJhdGlvKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPWZhbHNlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogdGhlIG5lYXJlc3QgbmVpZ2hib3IgaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Vycm9yVGhyZXNob2xkXSBBY2NlcHRhYmxlIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcHgpLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gQSBkdXJhdGlvbiBmb3IgdGlsZSBvcGFjaXR5XG4gKiB0cmFuc2l0aW9ucyBpbiBtaWxsaXNlY29uZHMuIEEgZHVyYXRpb24gb2YgMCBkaXNhYmxlcyB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBbdHJhbnNmb3JtTWF0cml4XSBTb3VyY2UgdHJhbnNmb3JtIG1hdHJpeC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlbmRlckVkZ2VzXSBSZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgZW5jYXBzdWxhdGluZyBzaW5nbGUgcmVwcm9qZWN0ZWQgZGF0YSB0aWxlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL0RhdGFUaWxlfkRhdGFUaWxlU291cmNlfS5cbiAqXG4gKi9cbmNsYXNzIFJlcHJvakRhdGFUaWxlIGV4dGVuZHMgRGF0YVRpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICB0aWxlQ29vcmQ6IG9wdGlvbnMudGlsZUNvb3JkLFxuICAgICAgbG9hZGVyOiAoKSA9PiBQcm9taXNlLnJlc29sdmUobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQpKSxcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbiB8IEFycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJFZGdlc18gPVxuICAgICAgb3B0aW9ucy5yZW5kZXJFZGdlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJFZGdlcyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBvcHRpb25zLnBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ndXR0ZXJfID0gb3B0aW9ucy5ndXR0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vRGF0YVRpbGUuanNcIikuRGF0YX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVwcm9qRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Vycm9yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZXByb2pFcnJvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vc2l6ZS5qcycpLlNpemV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlcHJvalNpemVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVRpbGVHcmlkXyA9IG9wdGlvbnMuc291cmNlVGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VGlsZUdyaWRfID0gb3B0aW9ucy50YXJnZXRUaWxlR3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gICAgICovXG4gICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyA9IG9wdGlvbnMud3JhcHBlZFRpbGVDb29yZCB8fCBvcHRpb25zLnRpbGVDb29yZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxUaWxlT2Zmc2V0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVRpbGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlWl8gPSAwO1xuXG4gICAgY29uc3Qgc291cmNlUHJvaiA9IG9wdGlvbnMuc291cmNlUHJvajtcbiAgICBjb25zdCBzb3VyY2VQcm9qRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgICBjb25zdCBzb3VyY2VUaWxlR3JpZEV4dGVudCA9IG9wdGlvbnMuc291cmNlVGlsZUdyaWQuZ2V0RXh0ZW50KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2xpcEV4dGVudF8gPSBzb3VyY2VQcm9qLmNhbldyYXBYKClcbiAgICAgID8gc291cmNlVGlsZUdyaWRFeHRlbnRcbiAgICAgICAgPyBnZXRJbnRlcnNlY3Rpb24oc291cmNlUHJvakV4dGVudCwgc291cmNlVGlsZUdyaWRFeHRlbnQpXG4gICAgICAgIDogc291cmNlUHJvakV4dGVudFxuICAgICAgOiBzb3VyY2VUaWxlR3JpZEV4dGVudDtcblxuICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8sXG4gICAgKTtcbiAgICBjb25zdCBtYXhUYXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcbiAgICBsZXQgbWF4U291cmNlRXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG5cbiAgICBjb25zdCBsaW1pdGVkVGFyZ2V0RXh0ZW50ID0gbWF4VGFyZ2V0RXh0ZW50XG4gICAgICA/IGdldEludGVyc2VjdGlvbih0YXJnZXRFeHRlbnQsIG1heFRhcmdldEV4dGVudClcbiAgICAgIDogdGFyZ2V0RXh0ZW50O1xuXG4gICAgaWYgKGdldEFyZWEobGltaXRlZFRhcmdldEV4dGVudCkgPT09IDApIHtcbiAgICAgIC8vIFRpbGUgaXMgY29tcGxldGVseSBvdXRzaWRlIHJhbmdlIC0+IEVNUFRZXG4gICAgICAvLyBUT0RPOiBpcyBpdCBhY3R1YWxseSBjb3JyZWN0IHRoYXQgdGhlIHNvdXJjZSBldmVuIGNyZWF0ZXMgdGhlIHRpbGUgP1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlUHJvakV4dGVudCkge1xuICAgICAgaWYgKCFtYXhTb3VyY2VFeHRlbnQpIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gc291cmNlUHJvakV4dGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heFNvdXJjZUV4dGVudCA9IGdldEludGVyc2VjdGlvbihtYXhTb3VyY2VFeHRlbnQsIHNvdXJjZVByb2pFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXSxcbiAgICApO1xuXG4gICAgY29uc3QgdGFyZ2V0UHJvaiA9IG9wdGlvbnMudGFyZ2V0UHJvajtcbiAgICBjb25zdCBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlRXh0ZW50UmVzb2x1dGlvbihcbiAgICAgIHNvdXJjZVByb2osXG4gICAgICB0YXJnZXRQcm9qLFxuICAgICAgbGltaXRlZFRhcmdldEV4dGVudCxcbiAgICAgIHRhcmdldFJlc29sdXRpb24sXG4gICAgKTtcblxuICAgIGlmICghaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgfHwgc291cmNlUmVzb2x1dGlvbiA8PSAwKSB7XG4gICAgICAvLyBpbnZhbGlkIHNvdXJjZVJlc29sdXRpb24gLT4gRU1QVFlcbiAgICAgIC8vIHByb2JhYmx5IGVkZ2VzIG9mIHRoZSBwcm9qZWN0aW9ucyB3aGVuIG5vIGV4dGVudCBpcyBkZWZpbmVkXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yVGhyZXNob2xkSW5QaXhlbHMgPVxuICAgICAgb3B0aW9ucy5lcnJvclRocmVzaG9sZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5lcnJvclRocmVzaG9sZFxuICAgICAgICA6IEVSUk9SX1RIUkVTSE9MRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFpbXBvcnQoXCIuL1RyaWFuZ3VsYXRpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ3VsYXRpb25fID0gbmV3IFRyaWFuZ3VsYXRpb24oXG4gICAgICBzb3VyY2VQcm9qLFxuICAgICAgdGFyZ2V0UHJvaixcbiAgICAgIGxpbWl0ZWRUYXJnZXRFeHRlbnQsXG4gICAgICBtYXhTb3VyY2VFeHRlbnQsXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uICogZXJyb3JUaHJlc2hvbGRJblBpeGVscyxcbiAgICAgIHRhcmdldFJlc29sdXRpb24sXG4gICAgICBvcHRpb25zLnRyYW5zZm9ybU1hdHJpeCxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMudHJpYW5ndWxhdGlvbl8uZ2V0VHJpYW5nbGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBubyB2YWxpZCB0cmlhbmdsZXMgLT4gRU1QVFlcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VaXyA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFpGb3JSZXNvbHV0aW9uKHNvdXJjZVJlc29sdXRpb24pO1xuICAgIGxldCBzb3VyY2VFeHRlbnQgPSB0aGlzLnRyaWFuZ3VsYXRpb25fLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCgpO1xuXG4gICAgaWYgKG1heFNvdXJjZUV4dGVudCkge1xuICAgICAgaWYgKHNvdXJjZVByb2ouY2FuV3JhcFgoKSkge1xuICAgICAgICBzb3VyY2VFeHRlbnRbMV0gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFszXSxcbiAgICAgICAgKTtcbiAgICAgICAgc291cmNlRXh0ZW50WzNdID0gY2xhbXAoXG4gICAgICAgICAgc291cmNlRXh0ZW50WzNdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFsxXSxcbiAgICAgICAgICBtYXhTb3VyY2VFeHRlbnRbM10sXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oc291cmNlRXh0ZW50LCBtYXhTb3VyY2VFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2V0QXJlYShzb3VyY2VFeHRlbnQpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgd29ybGRXaWR0aCA9IDA7XG4gICAgICBsZXQgd29ybGRzQXdheSA9IDA7XG4gICAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAgIHdvcmxkV2lkdGggPSBnZXRXaWR0aChzb3VyY2VQcm9qRXh0ZW50KTtcbiAgICAgICAgd29ybGRzQXdheSA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgKHNvdXJjZUV4dGVudFswXSAtIHNvdXJjZVByb2pFeHRlbnRbMF0pIC8gd29ybGRXaWR0aCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc291cmNlRXh0ZW50cyA9IHdyYXBBbmRTbGljZVgoXG4gICAgICAgIHNvdXJjZUV4dGVudC5zbGljZSgpLFxuICAgICAgICBzb3VyY2VQcm9qLFxuICAgICAgICB0cnVlLFxuICAgICAgKTtcbiAgICAgIHNvdXJjZUV4dGVudHMuZm9yRWFjaCgoZXh0ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVJhbmdlID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgICBleHRlbnQsXG4gICAgICAgICAgdGhpcy5zb3VyY2VaXyxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZ2V0VGlsZSA9IG9wdGlvbnMuZ2V0VGlsZUZ1bmN0aW9uO1xuICAgICAgICBmb3IgKGxldCBzcmNYID0gc291cmNlUmFuZ2UubWluWDsgc3JjWCA8PSBzb3VyY2VSYW5nZS5tYXhYOyBzcmNYKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBzcmNZID0gc291cmNlUmFuZ2UubWluWTsgc3JjWSA8PSBzb3VyY2VSYW5nZS5tYXhZOyBzcmNZKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGUgPSBnZXRUaWxlKHRoaXMuc291cmNlWl8sIHNyY1gsIHNyY1ksIHRoaXMucGl4ZWxSYXRpb18pO1xuICAgICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd29ybGRzQXdheSAqIHdvcmxkV2lkdGg7XG4gICAgICAgICAgICAgIHRoaXMuc291cmNlVGlsZXNfLnB1c2goe3RpbGUsIG9mZnNldH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICArK3dvcmxkc0F3YXk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgc2l6ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi9zaXplLmpzJykuU2l6ZX0gVGlsZSBzaXplLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwcm9qU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIGZvciB0aGUgdGlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRGF0YVRpbGUuanNcIikuRGF0YX0gVGlsZSBkYXRhLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwcm9qRGF0YV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFueSBsb2FkaW5nIGVycm9yLlxuICAgKiBAcmV0dXJuIHtFcnJvcn0gTG9hZGluZyBlcnJvci5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXByb2pFcnJvcl87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcHJvamVjdF8oKSB7XG4gICAgY29uc3QgZGF0YVNvdXJjZXMgPSBbXTtcbiAgICBsZXQgaW1hZ2VMaWtlID0gZmFsc2U7XG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICBjb25zdCB0aWxlID0gc291cmNlLnRpbGU7XG4gICAgICBpZiAoIXRpbGUgfHwgdGlsZS5nZXRTdGF0ZSgpICE9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aWxlLmdldFNpemUoKTtcbiAgICAgIGNvbnN0IGd1dHRlciA9IHRoaXMuZ3V0dGVyXztcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2ltcG9ydChcIi4uL0RhdGFUaWxlLmpzXCIpLkFycmF5TGlrZX1cbiAgICAgICAqL1xuICAgICAgbGV0IHRpbGVEYXRhO1xuICAgICAgY29uc3QgYXJyYXlEYXRhID0gYXNBcnJheUxpa2UodGlsZS5nZXREYXRhKCkpO1xuICAgICAgaWYgKGFycmF5RGF0YSkge1xuICAgICAgICB0aWxlRGF0YSA9IGFycmF5RGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlTGlrZSA9IHRydWU7XG4gICAgICAgIHRpbGVEYXRhID0gdG9BcnJheShhc0ltYWdlTGlrZSh0aWxlLmdldERhdGEoKSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGl4ZWxTaXplID0gW3NpemVbMF0gKyAyICogZ3V0dGVyLCBzaXplWzFdICsgMiAqIGd1dHRlcl07XG4gICAgICBjb25zdCBpc0Zsb2F0ID0gdGlsZURhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zdCBwaXhlbENvdW50ID0gcGl4ZWxTaXplWzBdICogcGl4ZWxTaXplWzFdO1xuICAgICAgY29uc3QgRGF0YVR5cGUgPSBpc0Zsb2F0ID8gRmxvYXQzMkFycmF5IDogVWludDhDbGFtcGVkQXJyYXk7XG4gICAgICBjb25zdCB0aWxlRGF0YVIgPSBuZXcgRGF0YVR5cGUodGlsZURhdGEuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGJ5dGVzUGVyRWxlbWVudCA9IERhdGFUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgY29uc3QgYnl0ZXNQZXJQaXhlbCA9IChieXRlc1BlckVsZW1lbnQgKiB0aWxlRGF0YVIubGVuZ3RoKSAvIHBpeGVsQ291bnQ7XG4gICAgICBjb25zdCBieXRlc1BlclJvdyA9IHRpbGVEYXRhUi5ieXRlTGVuZ3RoIC8gcGl4ZWxTaXplWzFdO1xuICAgICAgY29uc3QgYmFuZENvdW50ID0gTWF0aC5mbG9vcihcbiAgICAgICAgYnl0ZXNQZXJSb3cgLyBieXRlc1BlckVsZW1lbnQgLyBwaXhlbFNpemVbMF0sXG4gICAgICApO1xuICAgICAgY29uc3QgZXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGUudGlsZUNvb3JkKTtcbiAgICAgIGV4dGVudFswXSArPSBzb3VyY2Uub2Zmc2V0O1xuICAgICAgZXh0ZW50WzJdICs9IHNvdXJjZS5vZmZzZXQ7XG4gICAgICBjb25zdCBjbGlwRXh0ZW50ID0gdGhpcy5jbGlwRXh0ZW50Xz8uc2xpY2UoKTtcbiAgICAgIGlmIChjbGlwRXh0ZW50KSB7XG4gICAgICAgIGNsaXBFeHRlbnRbMF0gKz0gc291cmNlLm9mZnNldDtcbiAgICAgICAgY2xpcEV4dGVudFsyXSArPSBzb3VyY2Uub2Zmc2V0O1xuICAgICAgfVxuICAgICAgZGF0YVNvdXJjZXMucHVzaCh7XG4gICAgICAgIGV4dGVudDogZXh0ZW50LFxuICAgICAgICBjbGlwRXh0ZW50OiBjbGlwRXh0ZW50LFxuICAgICAgICBkYXRhOiB0aWxlRGF0YVIsXG4gICAgICAgIGRhdGFUeXBlOiBEYXRhVHlwZSxcbiAgICAgICAgYnl0ZXNQZXJQaXhlbDogYnl0ZXNQZXJQaXhlbCxcbiAgICAgICAgcGl4ZWxTaXplOiBwaXhlbFNpemUsXG4gICAgICAgIGJhbmRDb3VudDogYmFuZENvdW50LFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID0gMDtcblxuICAgIGlmIChkYXRhU291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB6ID0gdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXTtcbiAgICBjb25zdCBzaXplID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZVNpemUoeik7XG4gICAgY29uc3QgdGFyZ2V0V2lkdGggPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVswXTtcbiAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVsxXTtcbiAgICBjb25zdCBvdXRXaWR0aCA9IHRhcmdldFdpZHRoICogdGhpcy5waXhlbFJhdGlvXztcbiAgICBjb25zdCBvdXRIZWlnaHQgPSB0YXJnZXRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW9fO1xuICAgIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHopO1xuICAgIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHRoaXMuc291cmNlWl8pO1xuXG4gICAgY29uc3QgdGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyxcbiAgICApO1xuXG4gICAgY29uc3QgYmFuZENvdW50ID0gZGF0YVNvdXJjZXNbMF0uYmFuZENvdW50O1xuICAgIGNvbnN0IGRhdGFSID0gbmV3IGRhdGFTb3VyY2VzWzBdLmRhdGFUeXBlKGJhbmRDb3VudCAqIG91dFdpZHRoICogb3V0SGVpZ2h0KTtcblxuICAgIGNvbnN0IGdsID0gY3JlYXRlQ2FudmFzQ29udGV4dFdlYkdMKG91dFdpZHRoLCBvdXRIZWlnaHQsIGNhbnZhc0dMUG9vbCwge1xuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgfSk7XG5cbiAgICBsZXQgd2lsbEludGVycG9sYXRlO1xuICAgIGNvbnN0IGZvcm1hdCA9IGdsLlJHQkE7XG4gICAgbGV0IHRleHR1cmVUeXBlO1xuICAgIGlmIChkYXRhU291cmNlc1swXS5kYXRhVHlwZSA9PSBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRleHR1cmVUeXBlID0gZ2wuRkxPQVQ7XG4gICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfZmxvYXRfYmxlbmQnKTtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyk7XG4gICAgICBjb25zdCBjYW5JbnRlcnBvbGF0ZSA9IGV4dGVuc2lvbiAhPT0gbnVsbDtcbiAgICAgIHdpbGxJbnRlcnBvbGF0ZSA9IGNhbkludGVycG9sYXRlICYmIHRoaXMuaW50ZXJwb2xhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHR1cmVUeXBlID0gZ2wuVU5TSUdORURfQllURTtcbiAgICAgIHdpbGxJbnRlcnBvbGF0ZSA9IHRoaXMuaW50ZXJwb2xhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgQkFORFNfUFJfUkVQUk9KID0gNDtcbiAgICBjb25zdCByZXByb2pzID0gTWF0aC5jZWlsKGJhbmRDb3VudCAvIEJBTkRTX1BSX1JFUFJPSik7XG4gICAgZm9yIChsZXQgcmVwcm9qID0gcmVwcm9qcyAtIDE7IHJlcHJvaiA+PSAwOyAtLXJlcHJvaikge1xuICAgICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRhdGFTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBkYXRhU291cmNlc1tpXTtcblxuICAgICAgICBjb25zdCBwaXhlbFNpemUgPSBkYXRhU291cmNlLnBpeGVsU2l6ZTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwaXhlbFNpemVbMF07XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBpeGVsU2l6ZVsxXTtcblxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IGRhdGFTb3VyY2UuZGF0YVR5cGUoQkFORFNfUFJfUkVQUk9KICogd2lkdGggKiBoZWlnaHQpO1xuICAgICAgICBjb25zdCBkYXRhUyA9IGRhdGFTb3VyY2UuZGF0YTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHJlcHJvaiAqIEJBTkRTX1BSX1JFUFJPSjtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgbGVuOyBqICs9IEJBTkRTX1BSX1JFUFJPSikge1xuICAgICAgICAgIGRhdGFbal0gPSBkYXRhU1tvZmZzZXRdO1xuICAgICAgICAgIGRhdGFbaiArIDFdID0gZGF0YVNbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgZGF0YVtqICsgMl0gPSBkYXRhU1tvZmZzZXQgKyAyXTtcbiAgICAgICAgICBkYXRhW2ogKyAzXSA9IGRhdGFTW29mZnNldCArIDNdO1xuICAgICAgICAgIG9mZnNldCArPSBiYW5kQ291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICBpZiAod2lsbEludGVycG9sYXRlKSB7XG4gICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgfVxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgdGV4dHVyZVR5cGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcblxuICAgICAgICBzb3VyY2VzLnB1c2goe1xuICAgICAgICAgIGV4dGVudDogZGF0YVNvdXJjZS5leHRlbnQsXG4gICAgICAgICAgY2xpcEV4dGVudDogZGF0YVNvdXJjZS5jbGlwRXh0ZW50LFxuICAgICAgICAgIHRleHR1cmU6IHRleHR1cmUsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge2ZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0fSA9IHJlbmRlclJlcHJvamVjdGVkKFxuICAgICAgICBnbCxcbiAgICAgICAgdGFyZ2V0V2lkdGgsXG4gICAgICAgIHRhcmdldEhlaWdodCxcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgc291cmNlUmVzb2x1dGlvbixcbiAgICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICAgICAgdGFyZ2V0RXh0ZW50LFxuICAgICAgICB0aGlzLnRyaWFuZ3VsYXRpb25fLFxuICAgICAgICBzb3VyY2VzLFxuICAgICAgICB0aGlzLmd1dHRlcl8sXG4gICAgICAgIHRleHR1cmVUeXBlLFxuICAgICAgICB0aGlzLnJlbmRlckVkZ2VzXyxcbiAgICAgICAgd2lsbEludGVycG9sYXRlLFxuICAgICAgKTtcblxuICAgICAgLy8gVGhlIHRleHR1cmUgaXMgYWx3YXlzIFJHQkEuXG4gICAgICBjb25zdCByb3dzID0gd2lkdGg7XG4gICAgICBjb25zdCBjb2xzID0gaGVpZ2h0ICogQkFORFNfUFJfUkVQUk9KO1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBkYXRhU291cmNlc1swXS5kYXRhVHlwZShyb3dzICogY29scyk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgdGV4dHVyZVR5cGUsIGRhdGEpO1xuXG4gICAgICBsZXQgb2Zmc2V0ID0gcmVwcm9qICogQkFORFNfUFJfUkVQUk9KO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IEJBTkRTX1BSX1JFUFJPSikge1xuICAgICAgICAvLyBUaGUgZGF0YSByZWFkIGJ5IGByZWFkUGl4ZWxzYCBpcyBmbGlwcGVkIGluIHRoZSB5LWF4aXMgc28gZmxpcCBpdCBhZ2Fpbi5cbiAgICAgICAgY29uc3QgZmxpcFkgPSAocm93cyAtIDEgLSAoKGkgLyBjb2xzKSB8IDApKSAqIGNvbHMgKyAoaSAlIGNvbHMpO1xuICAgICAgICBkYXRhUltvZmZzZXRdID0gZGF0YVtmbGlwWV07XG4gICAgICAgIGRhdGFSW29mZnNldCArIDFdID0gZGF0YVtmbGlwWSArIDFdO1xuICAgICAgICBkYXRhUltvZmZzZXQgKyAyXSA9IGRhdGFbZmxpcFkgKyAyXTtcbiAgICAgICAgZGF0YVJbb2Zmc2V0ICsgM10gPSBkYXRhW2ZsaXBZICsgM107XG4gICAgICAgIG9mZnNldCArPSBiYW5kQ291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVsZWFzZUdMQ2FudmFzKGdsKTtcbiAgICBjYW52YXNHTFBvb2wucHVzaChnbC5jYW52YXMpO1xuXG4gICAgaWYgKGltYWdlTGlrZSkge1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCh0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEoZGF0YVIsIHRhcmdldFdpZHRoKTtcbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICB0aGlzLnJlcHJvakRhdGFfID0gY29udGV4dC5jYW52YXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVwcm9qRGF0YV8gPSBkYXRhUjtcbiAgICB9XG4gICAgdGhpcy5yZXByb2pTaXplXyA9IFtNYXRoLnJvdW5kKG91dFdpZHRoKSwgTWF0aC5yb3VuZChvdXRIZWlnaHQpXTtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBUaWxlU3RhdGUuSURMRSAmJiB0aGlzLnN0YXRlICE9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FESU5HO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuXG4gICAgbGV0IGxlZnRUb0xvYWQgPSAwO1xuXG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IFtdO1xuICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goKHt0aWxlfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdGUgIT09IFRpbGVTdGF0ZS5JRExFICYmIHN0YXRlICE9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZWZ0VG9Mb2FkKys7XG5cbiAgICAgIGNvbnN0IHNvdXJjZUxpc3RlbktleSA9IGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICAgICApIHtcbiAgICAgICAgICB1bmxpc3RlbkJ5S2V5KHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLnB1c2goc291cmNlTGlzdGVuS2V5KTtcbiAgICB9KTtcblxuICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMucmVwcm9qZWN0Xy5iaW5kKHRoaXMpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbiAoe3RpbGV9KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICB0aWxlLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlblNvdXJjZXNfKCkge1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXByb2pEYXRhVGlsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVGlsZVxuICovXG5pbXBvcnQge0VSUk9SX1RIUkVTSE9MRH0gZnJvbSAnLi9jb21tb24uanMnO1xuXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGUgZnJvbSAnLi4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVHJpYW5ndWxhdGlvbiBmcm9tICcuL1RyaWFuZ3VsYXRpb24uanMnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlU291cmNlRXh0ZW50UmVzb2x1dGlvbixcbiAgY2FudmFzUG9vbCxcbiAgcmVuZGVyIGFzIHJlbmRlclJlcHJvamVjdGVkLFxufSBmcm9tICcuLi9yZXByb2ouanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2dldEFyZWEsIGdldEludGVyc2VjdGlvbiwgZ2V0V2lkdGgsIHdyYXBBbmRTbGljZVh9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7cmVsZWFzZUNhbnZhc30gZnJvbSAnLi4vZG9tLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyKSA6IChpbXBvcnQoXCIuLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdCl9IEZ1bmN0aW9uVHlwZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGlsZU9mZnNldFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBlbmNhcHN1bGF0aW5nIHNpbmdsZSByZXByb2plY3RlZCB0aWxlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGVJbWFnZX5UaWxlSW1hZ2V9LlxuICpcbiAqL1xuY2xhc3MgUmVwcm9qVGlsZSBleHRlbmRzIFRpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBzb3VyY2VUaWxlR3JpZCBTb3VyY2UgdGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRhcmdldFRpbGVHcmlkIFRhcmdldCB0aWxlIGdyaWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIENvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gd3JhcHBlZFRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlIHdyYXBwZWQgaW4gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2UgdGlsZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25UeXBlfSBnZXRUaWxlRnVuY3Rpb25cbiAgICogICAgIEZ1bmN0aW9uIHJldHVybmluZyBzb3VyY2UgdGlsZXMgKHosIHgsIHksIHBpeGVsUmF0aW8pLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Vycm9yVGhyZXNob2xkXSBBY2NlcHRhYmxlIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcHgpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW5kZXJFZGdlc10gUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLk9wdGlvbnN9IFtvcHRpb25zXSBUaWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBzb3VyY2VQcm9qLFxuICAgIHNvdXJjZVRpbGVHcmlkLFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0VGlsZUdyaWQsXG4gICAgdGlsZUNvb3JkLFxuICAgIHdyYXBwZWRUaWxlQ29vcmQsXG4gICAgcGl4ZWxSYXRpbyxcbiAgICBndXR0ZXIsXG4gICAgZ2V0VGlsZUZ1bmN0aW9uLFxuICAgIGVycm9yVGhyZXNob2xkLFxuICAgIHJlbmRlckVkZ2VzLFxuICAgIG9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKHRpbGVDb29yZCwgVGlsZVN0YXRlLklETEUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckVkZ2VzXyA9IHJlbmRlckVkZ2VzICE9PSB1bmRlZmluZWQgPyByZW5kZXJFZGdlcyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ3V0dGVyXyA9IGd1dHRlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlVGlsZUdyaWRfID0gc291cmNlVGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VGlsZUdyaWRfID0gdGFyZ2V0VGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICAgICAqL1xuICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8gPSB3cmFwcGVkVGlsZUNvb3JkID8gd3JhcHBlZFRpbGVDb29yZCA6IHRpbGVDb29yZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxUaWxlT2Zmc2V0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVRpbGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlWl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNsaXBFeHRlbnRfID0gc291cmNlUHJvai5jYW5XcmFwWCgpXG4gICAgICA/IHNvdXJjZVByb2ouZ2V0RXh0ZW50KClcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgdGFyZ2V0RXh0ZW50ID0gdGFyZ2V0VGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyxcbiAgICApO1xuICAgIGNvbnN0IG1heFRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldEV4dGVudCgpO1xuICAgIGxldCBtYXhTb3VyY2VFeHRlbnQgPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcblxuICAgIGNvbnN0IGxpbWl0ZWRUYXJnZXRFeHRlbnQgPSBtYXhUYXJnZXRFeHRlbnRcbiAgICAgID8gZ2V0SW50ZXJzZWN0aW9uKHRhcmdldEV4dGVudCwgbWF4VGFyZ2V0RXh0ZW50KVxuICAgICAgOiB0YXJnZXRFeHRlbnQ7XG5cbiAgICBpZiAoZ2V0QXJlYShsaW1pdGVkVGFyZ2V0RXh0ZW50KSA9PT0gMCkge1xuICAgICAgLy8gVGlsZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgcmFuZ2UgLT4gRU1QVFlcbiAgICAgIC8vIFRPRE86IGlzIGl0IGFjdHVhbGx5IGNvcnJlY3QgdGhhdCB0aGUgc291cmNlIGV2ZW4gY3JlYXRlcyB0aGUgdGlsZSA/XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZVByb2pFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgIGlmIChzb3VyY2VQcm9qRXh0ZW50KSB7XG4gICAgICBpZiAoIW1heFNvdXJjZUV4dGVudCkge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qRXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKG1heFNvdXJjZUV4dGVudCwgc291cmNlUHJvakV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRhcmdldFRpbGVHcmlkLmdldFJlc29sdXRpb24oXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdLFxuICAgICk7XG5cbiAgICBjb25zdCBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlRXh0ZW50UmVzb2x1dGlvbihcbiAgICAgIHNvdXJjZVByb2osXG4gICAgICB0YXJnZXRQcm9qLFxuICAgICAgbGltaXRlZFRhcmdldEV4dGVudCxcbiAgICAgIHRhcmdldFJlc29sdXRpb24sXG4gICAgKTtcblxuICAgIGlmICghaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgfHwgc291cmNlUmVzb2x1dGlvbiA8PSAwKSB7XG4gICAgICAvLyBpbnZhbGlkIHNvdXJjZVJlc29sdXRpb24gLT4gRU1QVFlcbiAgICAgIC8vIHByb2JhYmx5IGVkZ2VzIG9mIHRoZSBwcm9qZWN0aW9ucyB3aGVuIG5vIGV4dGVudCBpcyBkZWZpbmVkXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yVGhyZXNob2xkSW5QaXhlbHMgPVxuICAgICAgZXJyb3JUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IGVycm9yVGhyZXNob2xkIDogRVJST1JfVEhSRVNIT0xEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4vVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5ndWxhdGlvbl8gPSBuZXcgVHJpYW5ndWxhdGlvbihcbiAgICAgIHNvdXJjZVByb2osXG4gICAgICB0YXJnZXRQcm9qLFxuICAgICAgbGltaXRlZFRhcmdldEV4dGVudCxcbiAgICAgIG1heFNvdXJjZUV4dGVudCxcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gKiBlcnJvclRocmVzaG9sZEluUGl4ZWxzLFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICApO1xuXG4gICAgaWYgKHRoaXMudHJpYW5ndWxhdGlvbl8uZ2V0VHJpYW5nbGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBubyB2YWxpZCB0cmlhbmdsZXMgLT4gRU1QVFlcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VaXyA9IHNvdXJjZVRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKHNvdXJjZVJlc29sdXRpb24pO1xuICAgIGxldCBzb3VyY2VFeHRlbnQgPSB0aGlzLnRyaWFuZ3VsYXRpb25fLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCgpO1xuXG4gICAgaWYgKG1heFNvdXJjZUV4dGVudCkge1xuICAgICAgaWYgKHNvdXJjZVByb2ouY2FuV3JhcFgoKSkge1xuICAgICAgICBzb3VyY2VFeHRlbnRbMV0gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFszXSxcbiAgICAgICAgKTtcbiAgICAgICAgc291cmNlRXh0ZW50WzNdID0gY2xhbXAoXG4gICAgICAgICAgc291cmNlRXh0ZW50WzNdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFsxXSxcbiAgICAgICAgICBtYXhTb3VyY2VFeHRlbnRbM10sXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oc291cmNlRXh0ZW50LCBtYXhTb3VyY2VFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2V0QXJlYShzb3VyY2VFeHRlbnQpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgd29ybGRXaWR0aCA9IDA7XG4gICAgICBsZXQgd29ybGRzQXdheSA9IDA7XG4gICAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAgIHdvcmxkV2lkdGggPSBnZXRXaWR0aChzb3VyY2VQcm9qRXh0ZW50KTtcbiAgICAgICAgd29ybGRzQXdheSA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgKHNvdXJjZUV4dGVudFswXSAtIHNvdXJjZVByb2pFeHRlbnRbMF0pIC8gd29ybGRXaWR0aCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc291cmNlRXh0ZW50cyA9IHdyYXBBbmRTbGljZVgoXG4gICAgICAgIHNvdXJjZUV4dGVudC5zbGljZSgpLFxuICAgICAgICBzb3VyY2VQcm9qLFxuICAgICAgICB0cnVlLFxuICAgICAgKTtcbiAgICAgIHNvdXJjZUV4dGVudHMuZm9yRWFjaCgoZXh0ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVJhbmdlID0gc291cmNlVGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgICBleHRlbnQsXG4gICAgICAgICAgdGhpcy5zb3VyY2VaXyxcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBzcmNYID0gc291cmNlUmFuZ2UubWluWDsgc3JjWCA8PSBzb3VyY2VSYW5nZS5tYXhYOyBzcmNYKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBzcmNZID0gc291cmNlUmFuZ2UubWluWTsgc3JjWSA8PSBzb3VyY2VSYW5nZS5tYXhZOyBzcmNZKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGUgPSBnZXRUaWxlRnVuY3Rpb24odGhpcy5zb3VyY2VaXywgc3JjWCwgc3JjWSwgcGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3b3JsZHNBd2F5ICogd29ybGRXaWR0aDtcbiAgICAgICAgICAgICAgdGhpcy5zb3VyY2VUaWxlc18ucHVzaCh7dGlsZSwgb2Zmc2V0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICsrd29ybGRzQXdheTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSFRNTCBDYW52YXMgZWxlbWVudCBmb3IgdGhpcyB0aWxlLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzLlxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwcm9qZWN0XygpIHtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICBjb25zdCB0aWxlID0gc291cmNlLnRpbGU7XG4gICAgICBpZiAodGlsZSAmJiB0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICBjb25zdCBleHRlbnQgPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS50aWxlQ29vcmQpO1xuICAgICAgICBleHRlbnRbMF0gKz0gc291cmNlLm9mZnNldDtcbiAgICAgICAgZXh0ZW50WzJdICs9IHNvdXJjZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNsaXBFeHRlbnQgPSB0aGlzLmNsaXBFeHRlbnRfPy5zbGljZSgpO1xuICAgICAgICBpZiAoY2xpcEV4dGVudCkge1xuICAgICAgICAgIGNsaXBFeHRlbnRbMF0gKz0gc291cmNlLm9mZnNldDtcbiAgICAgICAgICBjbGlwRXh0ZW50WzJdICs9IHNvdXJjZS5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlcy5wdXNoKHtcbiAgICAgICAgICBleHRlbnQ6IGV4dGVudCxcbiAgICAgICAgICBjbGlwRXh0ZW50OiBjbGlwRXh0ZW50LFxuICAgICAgICAgIGltYWdlOiB0aWxlLmdldEltYWdlKCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHogPSB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVTaXplKHopO1xuICAgICAgY29uc3Qgd2lkdGggPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzFdO1xuICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFJlc29sdXRpb24oeik7XG4gICAgICBjb25zdCBzb3VyY2VSZXNvbHV0aW9uID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbihcbiAgICAgICAgdGhpcy5zb3VyY2VaXyxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuY2FudmFzXyA9IHJlbmRlclJlcHJvamVjdGVkKFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgICBzb3VyY2VSZXNvbHV0aW9uLFxuICAgICAgICB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKSxcbiAgICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICAgICAgdGFyZ2V0RXh0ZW50LFxuICAgICAgICB0aGlzLnRyaWFuZ3VsYXRpb25fLFxuICAgICAgICBzb3VyY2VzLFxuICAgICAgICB0aGlzLmd1dHRlcl8sXG4gICAgICAgIHRoaXMucmVuZGVyRWRnZXNfLFxuICAgICAgICB0aGlzLmludGVycG9sYXRlLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuXG4gICAgICBsZXQgbGVmdFRvTG9hZCA9IDA7XG5cbiAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBbXTtcbiAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goKHt0aWxlfSkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5JRExFIHx8IHN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgICAgbGVmdFRvTG9hZCsrO1xuXG4gICAgICAgICAgY29uc3Qgc291cmNlTGlzdGVuS2V5ID0gbGlzdGVuKHRpbGUsIEV2ZW50VHlwZS5DSEFOR0UsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgICAgICAgICBzdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgfHxcbiAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkVNUFRZXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdW5saXN0ZW5CeUtleShzb3VyY2VMaXN0ZW5LZXkpO1xuICAgICAgICAgICAgICBsZWZ0VG9Mb2FkLS07XG4gICAgICAgICAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmxpc3RlblNvdXJjZXNfKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXByb2plY3RfKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLnB1c2goc291cmNlTGlzdGVuS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5yZXByb2plY3RfLmJpbmQodGhpcyksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbiAoe3RpbGV9LCBpLCBhcnIpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlblNvdXJjZXNfKCkge1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZnJvbSB0aGUgY2FjaGUgZHVlIHRvIGV4cGlyeVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbGVhc2UoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzXykge1xuICAgICAgcmVsZWFzZUNhbnZhcyh0aGlzLmNhbnZhc18uZ2V0Q29udGV4dCgnMmQnKSk7XG4gICAgICBjYW52YXNQb29sLnB1c2godGhpcy5jYW52YXNfKTtcbiAgICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLnJlbGVhc2UoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXByb2pUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9Ucmlhbmd1bGF0aW9uXG4gKi9cbmltcG9ydCB7YXBwbHkgYXMgYXBwbHlNYXRyaXh9IGZyb20gJy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge1xuICBib3VuZGluZ0V4dGVudCxcbiAgY3JlYXRlRW1wdHksXG4gIGV4dGVuZENvb3JkaW5hdGUsXG4gIGdldEFyZWEsXG4gIGdldEJvdHRvbUxlZnQsXG4gIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRUb3BSaWdodCxcbiAgZ2V0V2lkdGgsXG4gIGludGVyc2VjdHMsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybSxcbiAgZ2V0VHJhbnNmb3JtLFxuICB0cmFuc2Zvcm0sXG59IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIFNpbmdsZSB0cmlhbmdsZTsgY29uc2lzdHMgb2YgMyBzb3VyY2UgcG9pbnRzIGFuZCAzIHRhcmdldCBwb2ludHMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmlhbmdsZVxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBzb3VyY2UgU291cmNlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSB0YXJnZXQgVGFyZ2V0LlxuICovXG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygc3ViZGl2aXNpb24gc3RlcHMgZHVyaW5nIHJhc3RlciByZXByb2plY3Rpb24gdHJpYW5ndWxhdGlvbi5cbiAqIFByZXZlbnRzIGhpZ2ggbWVtb3J5IHVzYWdlIGFuZCBsYXJnZSBudW1iZXIgb2YgcHJvajQgY2FsbHMgKGZvciBjZXJ0YWluXG4gKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGFyZWFzKS4gQXQgbW9zdCBgMiooMl50aGlzKWAgdHJpYW5nbGVzIGFyZSBjcmVhdGVkIGZvclxuICogZWFjaCB0cmlhbmd1bGF0ZWQgZXh0ZW50ICh0aWxlL2ltYWdlKS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9TVUJESVZJU0lPTiA9IDEwO1xuXG4vKipcbiAqIE1heGltdW0gYWxsb3dlZCBzaXplIG9mIHRyaWFuZ2xlIHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoLiBXaGVuIHRyYW5zZm9ybWluZ1xuICogY29ybmVycyBvZiB3b3JsZCBleHRlbnQgYmV0d2VlbiBjZXJ0YWluIHByb2plY3Rpb25zLCB0aGUgcmVzdWx0aW5nXG4gKiB0cmlhbmd1bGF0aW9uIHNlZW1zIHRvIGhhdmUgemVybyBlcnJvciBhbmQgbm8gc3ViZGl2aXNpb24gaXMgcGVyZm9ybWVkLiBJZlxuICogdGhlIHRyaWFuZ2xlIHdpZHRoIGlzIG1vcmUgdGhhbiB0aGlzIChyZWxhdGl2ZSB0byB3b3JsZCB3aWR0aDsgMC0xKSxcbiAqIHN1YmRpdmlzb24gaXMgZm9yY2VkICh1cCB0byBgTUFYX1NVQkRJVklTSU9OYCkuIERlZmF1bHQgaXMgYDAuMjVgLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX1RSSUFOR0xFX1dJRFRIID0gMC4yNTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBjb250YWluaW5nIHRyaWFuZ3VsYXRpb24gb2YgdGhlIGdpdmVuIHRhcmdldCBleHRlbnQuXG4gKiBVc2VkIGZvciBkZXRlcm1pbmluZyBzb3VyY2UgZGF0YSBhbmQgdGhlIHJlcHJvamVjdGlvbiBpdHNlbGYuXG4gKi9cbmNsYXNzIFRyaWFuZ3VsYXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudCB0byB0cmlhbmd1bGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhTb3VyY2VFeHRlbnQgTWF4aW1hbCBzb3VyY2UgZXh0ZW50IHRoYXQgY2FuIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvclRocmVzaG9sZCBBY2NlcHRhYmxlIGVycm9yIChpbiBzb3VyY2UgdW5pdHMpLlxuICAgKiBAcGFyYW0gez9udW1iZXJ9IGRlc3RpbmF0aW9uUmVzb2x1dGlvbiBUaGUgKG9wdGlvbmFsKSByZXNvbHV0aW9uIG9mIHRoZSBkZXN0aW5hdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBbc291cmNlTWF0cml4XSBTb3VyY2UgdHJhbnNmb3JtIG1hdHJpeC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNvdXJjZVByb2osXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRFeHRlbnQsXG4gICAgbWF4U291cmNlRXh0ZW50LFxuICAgIGVycm9yVGhyZXNob2xkLFxuICAgIGRlc3RpbmF0aW9uUmVzb2x1dGlvbixcbiAgICBzb3VyY2VNYXRyaXgsXG4gICkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlUHJval8gPSBzb3VyY2VQcm9qO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQcm9qXyA9IHRhcmdldFByb2o7XG5cbiAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqL1xuICAgIGxldCB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICAgIGNvbnN0IHRyYW5zZm9ybUludiA9IHNvdXJjZU1hdHJpeFxuICAgICAgPyBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybSgoaW5wdXQpID0+XG4gICAgICAgICAgYXBwbHlNYXRyaXgoXG4gICAgICAgICAgICBzb3VyY2VNYXRyaXgsXG4gICAgICAgICAgICB0cmFuc2Zvcm0oaW5wdXQsIHRoaXMudGFyZ2V0UHJval8sIHRoaXMuc291cmNlUHJval8pLFxuICAgICAgICAgICksXG4gICAgICAgIClcbiAgICAgIDogZ2V0VHJhbnNmb3JtKHRoaXMudGFyZ2V0UHJval8sIHRoaXMuc291cmNlUHJval8pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgQSBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtSW52XyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBjb25zdCBrZXkgPSBjWzBdICsgJy8nICsgY1sxXTtcbiAgICAgIGlmICghdHJhbnNmb3JtSW52Q2FjaGVba2V5XSkge1xuICAgICAgICB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldID0gdHJhbnNmb3JtSW52KGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybUludkNhY2hlW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhTb3VyY2VFeHRlbnRfID0gbWF4U291cmNlRXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JUaHJlc2hvbGRTcXVhcmVkXyA9IGVycm9yVGhyZXNob2xkICogZXJyb3JUaHJlc2hvbGQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJpYW5nbGU+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmlhbmdsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgdHJpYW5ndWxhdGlvbiBjcm9zc2VzIGVkZ2Ugb2YgdGhlIHNvdXJjZSBwcm9qZWN0aW9uLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYW5XcmFwWEluU291cmNlXyA9XG4gICAgICB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICEhbWF4U291cmNlRXh0ZW50ICYmXG4gICAgICAhIXRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgJiZcbiAgICAgIGdldFdpZHRoKG1heFNvdXJjZUV4dGVudCkgPj0gZ2V0V2lkdGgodGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlV29ybGRXaWR0aF8gPSB0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpXG4gICAgICA/IGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8gPSB0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpXG4gICAgICA/IGdldFdpZHRoKHRoaXMudGFyZ2V0UHJval8uZ2V0RXh0ZW50KCkpXG4gICAgICA6IG51bGw7XG5cbiAgICBjb25zdCBkZXN0aW5hdGlvblRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Ub3BSaWdodCA9IGdldFRvcFJpZ2h0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Cb3R0b21SaWdodCA9IGdldEJvdHRvbVJpZ2h0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Cb3R0b21MZWZ0ID0gZ2V0Qm90dG9tTGVmdCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IHNvdXJjZVRvcExlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BMZWZ0KTtcbiAgICBjb25zdCBzb3VyY2VUb3BSaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcFJpZ2h0KTtcbiAgICBjb25zdCBzb3VyY2VCb3R0b21SaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0KTtcbiAgICBjb25zdCBzb3VyY2VCb3R0b21MZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tTGVmdCk7XG5cbiAgICAvKlxuICAgICAqIFRoZSBtYXhTdWJkaXZpc2lvbiBjb250cm9scyBob3cgbWFueSBzcGxpdHRpbmdzIG9mIHRoZSB0YXJnZXQgYXJlYSBjYW5cbiAgICAgKiBiZSBkb25lLiBUaGUgaWRlYSBoZXJlIGlzIHRvIGRvIGEgbGluZWFyIG1hcHBpbmcgb2YgdGhlIHRhcmdldCBhcmVhc1xuICAgICAqIGJ1dCB0aGUgYWN0dWFsIG92ZXJhbGwgcmVwcm9qZWN0aW9uIChjYW4gYmUpIGV4dHJlbWVseSBub24tbGluZWFyLiBUaGVcbiAgICAgKiBkZWZhdWx0IHZhbHVlIG9mIE1BWF9TVUJESVZJU0lPTiB3YXMgY2hvc2VuIGJhc2VkIG9uIG1hcHBpbmcgYSAyNTZ4MjU2XG4gICAgICogdGlsZSBzaXplLiBIb3dldmVyIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyBjYWxsZWQgdG8gcmVtYXAgY2FudmFzIHJlbmRlcmVkXG4gICAgICogbGF5ZXJzIHdoaWNoIGNhbiBiZSBtdWNoIGxhcmdlci4gVGhpcyBjYWxjdWxhdGlvbiBpbmNyZWFzZXMgdGhlIG1heFN1YmRpdmlzaW9uXG4gICAgICogdmFsdWUgYnkgdGhlIHJpZ2h0IGZhY3RvciBzbyB0aGF0IGVhY2ggMjU2eDI1NiBwaXhlbCBhcmVhIGhhc1xuICAgICAqIE1BWF9TVUJESVZJU0lPTiBkaXZpc2lvbnMuXG4gICAgICovXG4gICAgY29uc3QgbWF4U3ViZGl2aXNpb24gPVxuICAgICAgTUFYX1NVQkRJVklTSU9OICtcbiAgICAgIChkZXN0aW5hdGlvblJlc29sdXRpb25cbiAgICAgICAgPyBNYXRoLm1heChcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgIE1hdGgubG9nMihcbiAgICAgICAgICAgICAgICBnZXRBcmVhKHRhcmdldEV4dGVudCkgL1xuICAgICAgICAgICAgICAgICAgKGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIDI1NiAqIDI1NiksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApLFxuICAgICAgICAgIClcbiAgICAgICAgOiAwKTtcblxuICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICBkZXN0aW5hdGlvblRvcExlZnQsXG4gICAgICBkZXN0aW5hdGlvblRvcFJpZ2h0LFxuICAgICAgZGVzdGluYXRpb25Cb3R0b21SaWdodCxcbiAgICAgIGRlc3RpbmF0aW9uQm90dG9tTGVmdCxcbiAgICAgIHNvdXJjZVRvcExlZnQsXG4gICAgICBzb3VyY2VUb3BSaWdodCxcbiAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0LFxuICAgICAgc291cmNlQm90dG9tTGVmdCxcbiAgICAgIG1heFN1YmRpdmlzaW9uLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy53cmFwc1hJblNvdXJjZV8pIHtcbiAgICAgIGxldCBsZWZ0Qm91bmQgPSBJbmZpbml0eTtcbiAgICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICAgIGxlZnRCb3VuZCA9IE1hdGgubWluKFxuICAgICAgICAgIGxlZnRCb3VuZCxcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMF1bMF0sXG4gICAgICAgICAgdHJpYW5nbGUuc291cmNlWzFdWzBdLFxuICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVsyXVswXSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaGlmdCB0cmlhbmdsZXMgdG8gYmUgYXMgY2xvc2UgdG8gYGxlZnRCb3VuZGAgYXMgcG9zc2libGVcbiAgICAgIC8vIChpZiB0aGUgZGlzdGFuY2UgaXMgbW9yZSB0aGFuIGB3b3JsZFdpZHRoIC8gMmAgaXQgY2FuIGJlIGNsb3Nlci5cbiAgICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKCh0cmlhbmdsZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMF1bMF0sXG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sXG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMl1bMF0sXG4gICAgICAgICAgKSAtXG4gICAgICAgICAgICBsZWZ0Qm91bmQgPlxuICAgICAgICAgIHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1RyaWFuZ2xlID0gW1xuICAgICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzBdWzFdXSxcbiAgICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVsxXV0sXG4gICAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzJdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMV1dLFxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKG5ld1RyaWFuZ2xlWzBdWzBdIC0gbGVmdEJvdW5kID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdUcmlhbmdsZVsxXVswXSAtIGxlZnRCb3VuZCA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3VHJpYW5nbGVbMl1bMF0gLSBsZWZ0Qm91bmQgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMl1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSYXJlbHkgKGlmIHRoZSBleHRlbnQgY29udGFpbnMgYm90aCB0aGUgZGF0ZWxpbmUgYW5kIHByaW1lIG1lcmlkaWFuKVxuICAgICAgICAgIC8vIHRoZSBzaGlmdCBjYW4gaW4gdHVybiBicmVhayBzb21lIHRyaWFuZ2xlcy5cbiAgICAgICAgICAvLyBEZXRlY3QgdGhpcyBoZXJlIGFuZCBkb24ndCBzaGlmdCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICAgIGNvbnN0IG1pblggPSBNYXRoLm1pbihcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG1heFggPSBNYXRoLm1heChcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChtYXhYIC0gbWluWCA8IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2UgPSBuZXdUcmlhbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybUludkNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0cmlhbmdsZSB0byB0aGUgdHJpYW5ndWxhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGEgVGhlIHRhcmdldCBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFTcmMgVGhlIHNvdXJjZSBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZFRyaWFuZ2xlXyhhLCBiLCBjLCBhU3JjLCBiU3JjLCBjU3JjKSB7XG4gICAgdGhpcy50cmlhbmdsZXNfLnB1c2goe1xuICAgICAgc291cmNlOiBbYVNyYywgYlNyYywgY1NyY10sXG4gICAgICB0YXJnZXQ6IFthLCBiLCBjXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHF1YWQgKHBvaW50cyBpbiBjbG9jay13aXNlIG9yZGVyKSB0byB0aGUgdHJpYW5ndWxhdGlvblxuICAgKiAoYW5kIHJlcHJvamVjdHMgdGhlIHZlcnRpY2VzKSBpZiB2YWxpZC5cbiAgICogUGVyZm9ybXMgcXVhZCBzdWJkaXZpc2lvbiBpZiBuZWVkZWQgdG8gaW5jcmVhc2UgcHJlY2lzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGIgVGhlIHRhcmdldCBiIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIFRoZSB0YXJnZXQgYyBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZCBUaGUgdGFyZ2V0IGQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFTcmMgVGhlIHNvdXJjZSBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRTcmMgVGhlIHNvdXJjZSBkIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTdWJkaXZpc2lvbiBNYXhpbWFsIGFsbG93ZWQgc3ViZGl2aXNpb24gb2YgdGhlIHF1YWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRRdWFkXyhhLCBiLCBjLCBkLCBhU3JjLCBiU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbikge1xuICAgIGNvbnN0IHNvdXJjZVF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYVNyYywgYlNyYywgY1NyYywgZFNyY10pO1xuICAgIGNvbnN0IHNvdXJjZUNvdmVyYWdlWCA9IHRoaXMuc291cmNlV29ybGRXaWR0aF9cbiAgICAgID8gZ2V0V2lkdGgoc291cmNlUXVhZEV4dGVudCkgLyB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfXG4gICAgICA6IG51bGw7XG4gICAgY29uc3Qgc291cmNlV29ybGRXaWR0aCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zb3VyY2VXb3JsZFdpZHRoXyk7XG5cbiAgICAvLyB3aGVuIHRoZSBxdWFkIGlzIHdyYXBwZWQgaW4gdGhlIHNvdXJjZSBwcm9qZWN0aW9uXG4gICAgLy8gaXQgY292ZXJzIG1vc3Qgb2YgdGhlIHByb2plY3Rpb24gZXh0ZW50LCBidXQgbm90IGZ1bGx5XG4gICAgY29uc3Qgd3JhcHNYID1cbiAgICAgIHRoaXMuc291cmNlUHJval8uY2FuV3JhcFgoKSAmJlxuICAgICAgc291cmNlQ292ZXJhZ2VYID4gMC41ICYmXG4gICAgICBzb3VyY2VDb3ZlcmFnZVggPCAxO1xuXG4gICAgbGV0IG5lZWRzU3ViZGl2aXNpb24gPSBmYWxzZTtcblxuICAgIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldFByb2pfLmlzR2xvYmFsKCkgJiYgdGhpcy50YXJnZXRXb3JsZFdpZHRoXykge1xuICAgICAgICBjb25zdCB0YXJnZXRRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2EsIGIsIGMsIGRdKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q292ZXJhZ2VYID1cbiAgICAgICAgICBnZXRXaWR0aCh0YXJnZXRRdWFkRXh0ZW50KSAvIHRoaXMudGFyZ2V0V29ybGRXaWR0aF87XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPVxuICAgICAgICAgIHRhcmdldENvdmVyYWdlWCA+IE1BWF9UUklBTkdMRV9XSURUSCB8fCBuZWVkc1N1YmRpdmlzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKCF3cmFwc1ggJiYgdGhpcy5zb3VyY2VQcm9qXy5pc0dsb2JhbCgpICYmIHNvdXJjZUNvdmVyYWdlWCkge1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID1cbiAgICAgICAgICBzb3VyY2VDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEggfHwgbmVlZHNTdWJkaXZpc2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24gJiYgdGhpcy5tYXhTb3VyY2VFeHRlbnRfKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbMF0pICYmXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbMV0pICYmXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbMl0pICYmXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbM10pXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKHNvdXJjZVF1YWRFeHRlbnQsIHRoaXMubWF4U291cmNlRXh0ZW50XykpIHtcbiAgICAgICAgICAvLyB3aG9sZSBxdWFkIG91dHNpZGUgc291cmNlIHByb2plY3Rpb24gZXh0ZW50IC0+IGlnbm9yZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpc05vdEZpbml0ZSA9IDA7XG5cbiAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWlzRmluaXRlKGFTcmNbMF0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShhU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYlNyY1swXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGJTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShjU3JjWzBdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoY1NyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGRTcmNbMF0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShkU3JjWzFdKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdCBtaWdodCBiZSB0aGUgY2FzZSB0aGF0IG9ubHkgMSBvZiB0aGUgcG9pbnRzIGlzIGluZmluaXRlLiBJbiB0aGlzIGNhc2VcbiAgICAgICAgICAvLyB3ZSBjYW4gZHJhdyBhIHNpbmdsZSB0cmlhbmdsZSB3aXRoIHRoZSBvdGhlciB0aHJlZSBwb2ludHNcbiAgICAgICAgICBpc05vdEZpbml0ZSA9XG4gICAgICAgICAgICAoIWlzRmluaXRlKGFTcmNbMF0pIHx8ICFpc0Zpbml0ZShhU3JjWzFdKSA/IDggOiAwKSArXG4gICAgICAgICAgICAoIWlzRmluaXRlKGJTcmNbMF0pIHx8ICFpc0Zpbml0ZShiU3JjWzFdKSA/IDQgOiAwKSArXG4gICAgICAgICAgICAoIWlzRmluaXRlKGNTcmNbMF0pIHx8ICFpc0Zpbml0ZShjU3JjWzFdKSA/IDIgOiAwKSArXG4gICAgICAgICAgICAoIWlzRmluaXRlKGRTcmNbMF0pIHx8ICFpc0Zpbml0ZShkU3JjWzFdKSA/IDEgOiAwKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSAxICYmXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSAyICYmXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSA0ICYmXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSA4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IFsoYVswXSArIGNbMF0pIC8gMiwgKGFbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICBjb25zdCBjZW50ZXJTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oY2VudGVyKTtcblxuICAgICAgICBsZXQgZHg7XG4gICAgICAgIGlmICh3cmFwc1gpIHtcbiAgICAgICAgICBjb25zdCBjZW50ZXJTcmNFc3RpbVggPVxuICAgICAgICAgICAgKG1vZHVsbyhhU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKSArXG4gICAgICAgICAgICAgIG1vZHVsbyhjU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKSkgL1xuICAgICAgICAgICAgMjtcbiAgICAgICAgICBkeCA9IGNlbnRlclNyY0VzdGltWCAtIG1vZHVsbyhjZW50ZXJTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR4ID0gKGFTcmNbMF0gKyBjU3JjWzBdKSAvIDIgLSBjZW50ZXJTcmNbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHkgPSAoYVNyY1sxXSArIGNTcmNbMV0pIC8gMiAtIGNlbnRlclNyY1sxXTtcbiAgICAgICAgY29uc3QgY2VudGVyU3JjRXJyb3JTcXVhcmVkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSBjZW50ZXJTcmNFcnJvclNxdWFyZWQgPiB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF87XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgICBpZiAoTWF0aC5hYnMoYVswXSAtIGNbMF0pIDw9IE1hdGguYWJzKGFbMV0gLSBjWzFdKSkge1xuICAgICAgICAgIC8vIHNwbGl0IGhvcml6b250YWxseSAodG9wICYgYm90dG9tKVxuICAgICAgICAgIGNvbnN0IGJjID0gWyhiWzBdICsgY1swXSkgLyAyLCAoYlsxXSArIGNbMV0pIC8gMl07XG4gICAgICAgICAgY29uc3QgYmNTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oYmMpO1xuICAgICAgICAgIGNvbnN0IGRhID0gWyhkWzBdICsgYVswXSkgLyAyLCAoZFsxXSArIGFbMV0pIC8gMl07XG4gICAgICAgICAgY29uc3QgZGFTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oZGEpO1xuXG4gICAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYmMsXG4gICAgICAgICAgICBkYSxcbiAgICAgICAgICAgIGFTcmMsXG4gICAgICAgICAgICBiU3JjLFxuICAgICAgICAgICAgYmNTcmMsXG4gICAgICAgICAgICBkYVNyYyxcbiAgICAgICAgICAgIG1heFN1YmRpdmlzaW9uIC0gMSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBkYSxcbiAgICAgICAgICAgIGJjLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkYVNyYyxcbiAgICAgICAgICAgIGJjU3JjLFxuICAgICAgICAgICAgY1NyYyxcbiAgICAgICAgICAgIGRTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDEsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5IChsZWZ0ICYgcmlnaHQpXG4gICAgICAgICAgY29uc3QgYWIgPSBbKGFbMF0gKyBiWzBdKSAvIDIsIChhWzFdICsgYlsxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBhYlNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhhYik7XG4gICAgICAgICAgY29uc3QgY2QgPSBbKGNbMF0gKyBkWzBdKSAvIDIsIChjWzFdICsgZFsxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBjZFNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZCk7XG5cbiAgICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGFiLFxuICAgICAgICAgICAgY2QsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgYVNyYyxcbiAgICAgICAgICAgIGFiU3JjLFxuICAgICAgICAgICAgY2RTcmMsXG4gICAgICAgICAgICBkU3JjLFxuICAgICAgICAgICAgbWF4U3ViZGl2aXNpb24gLSAxLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICAgIGFiLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBjZCxcbiAgICAgICAgICAgIGFiU3JjLFxuICAgICAgICAgICAgYlNyYyxcbiAgICAgICAgICAgIGNTcmMsXG4gICAgICAgICAgICBjZFNyYyxcbiAgICAgICAgICAgIG1heFN1YmRpdmlzaW9uIC0gMSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod3JhcHNYKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuV3JhcFhJblNvdXJjZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEV4YWN0bHkgemVybyBvciBvbmUgb2YgKlNyYyBpcyBub3QgZmluaXRlXG4gICAgLy8gVGhlIHRyaWFuZ2xlcyBtdXN0IGhhdmUgdGhlIGRpYWdvbmFsIGxpbmUgYXMgdGhlIGZpcnN0IHNpZGVcbiAgICAvLyBUaGlzIGlzIHRvIGFsbG93IGVhc3kgY29kZSBpbiByZXByb2oucyB0byBtYWtlIGl0IHN0cmFpZ2h0IGZvciBicm9rZW5cbiAgICAvLyBicm93c2VycyB0aGF0IGNhbid0IGhhbmRsZSBkaWFnb25hbCBjbGlwcGluZ1xuICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGIpID09IDApIHtcbiAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGMsIGQsIGFTcmMsIGNTcmMsIGRTcmMpO1xuICAgIH1cbiAgICBpZiAoKGlzTm90RmluaXRlICYgMHhlKSA9PSAwKSB7XG4gICAgICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBjLCBiLCBhU3JjLCBjU3JjLCBiU3JjKTtcbiAgICB9XG4gICAgaWYgKGlzTm90RmluaXRlKSB7XG4gICAgICAvLyBUcnkgdGhlIG90aGVyIHR3byB0cmlhbmdsZXNcbiAgICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGQpID09IDApIHtcbiAgICAgICAgdGhpcy5hZGRUcmlhbmdsZV8oYiwgZCwgYSwgYlNyYywgZFNyYywgYVNyYyk7XG4gICAgICB9XG4gICAgICBpZiAoKGlzTm90RmluaXRlICYgMHg3KSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGIsIGQsIGMsIGJTcmMsIGRTcmMsIGNTcmMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGV4dGVudCBvZiB0aGUgYHNvdXJjZWAgY29vcmRpbmF0ZXMgZnJvbSBhbGwgdGhlIHRyaWFuZ2xlcy5cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gQ2FsY3VsYXRlZCBleHRlbnQuXG4gICAqL1xuICBjYWxjdWxhdGVTb3VyY2VFeHRlbnQoKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBjb25zdCBzcmMgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzBdKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMV0pO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1syXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PFRyaWFuZ2xlPn0gQXJyYXkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJpYW5nbGVzLlxuICAgKi9cbiAgZ2V0VHJpYW5nbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnRyaWFuZ2xlc187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJpYW5ndWxhdGlvbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovY29tbW9uXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gYWxsb3dlZCB0aHJlc2hvbGQgIChpbiBwaXhlbHMpIGZvciByZXByb2plY3Rpb25cbiAqIHRyaWFuZ3VsYXRpb24uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRVJST1JfVEhSRVNIT0xEID0gMC41O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9nbHJlcHJvalxuICovXG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJy4uL3ZlYy9tYXQ0LmpzJztcbmltcG9ydCB7V09SS0VSX09GRlNDUkVFTl9DQU5WQVN9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQge0NhbnZhcyBhcyBXZWJHTENhbnZhcywgY3JlYXRlUHJvZ3JhbX0gZnJvbSAnLi4vd2ViZ2wvQ2FudmFzLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZUVtcHR5LFxuICBleHRlbmQsXG4gIGdldEhlaWdodCxcbiAgZ2V0VG9wTGVmdCxcbiAgZ2V0V2lkdGgsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5cbmNvbnN0IEVER0VfVkVSVEVYX1NIQURFUiA9IGBcbiAgYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcblxuICB1bmlmb3JtIG1hdDQgdV9tYXRyaXg7XG5cbiAgdm9pZCBtYWluKCkge1xuICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogYV9wb3NpdGlvbjtcbiAgfVxuYDtcbmNvbnN0IEVER0VfRlJBR01FTlRfU0hBREVSID0gYFxuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICB1bmlmb3JtIHZlYzQgdV92YWw7XG4gIHZvaWQgbWFpbigpIHtcbiAgICAgZ2xfRnJhZ0NvbG9yID0gdV92YWw7XG4gIH1cbmA7XG5cbmNvbnN0IFRSSUFOR0xFX1ZFUlRFWF9TSEFERVIgPSBgXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XG4gIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XG5cbiAgdmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XG5cbiAgdW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xuXG4gIHZvaWQgbWFpbigpIHtcbiAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIGFfcG9zaXRpb247XG4gICAgIHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xuICB9XG5gO1xuY29uc3QgVFJJQU5HTEVfRlJBR01FTlRfU0hBREVSID0gYFxuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICB2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcblxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XG5cbiAgdm9pZCBtYWluKCkge1xuICAgIGlmICh2X3RleGNvb3JkLnggPCAwLjAgfHwgdl90ZXhjb29yZC54ID4gMS4wIHx8IHZfdGV4Y29vcmQueSA8IDAuMCB8fCB2X3RleGNvb3JkLnkgPiAxLjApIHtcbiAgICAgIGRpc2NhcmQ7XG4gICAgfVxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4Y29vcmQpO1xuICB9XG5gO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBodG1sIGNhbnZhcyBlbGVtZW50IGFuZCByZXR1cm5zIGl0cyB3ZWJnbCBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gQ2FudmFzIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIENhbnZhcyBoZWlnaHQuXG4gKiBAcGFyYW0ge0FycmF5PEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzPn0gW2NhbnZhc1Bvb2xdIENhbnZhcyBwb29sIHRvIHRha2UgZXhpc3RpbmcgY2FudmFzIGZyb20uXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dEF0dHJpYnV0ZXN9IFtzZXR0aW5nc10gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEU2V0dGluZ3NcbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXNDb250ZXh0V2ViR0wod2lkdGgsIGhlaWdodCwgY2FudmFzUG9vbCwgc2V0dGluZ3MpIHtcbiAgLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxPZmZzY3JlZW5DYW52YXN9ICovXG4gIGxldCBjYW52YXM7XG4gIGlmIChjYW52YXNQb29sICYmIGNhbnZhc1Bvb2wubGVuZ3RoKSB7XG4gICAgY2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGNhbnZhc1Bvb2wuc2hpZnQoKSk7XG4gIH0gZWxzZSBpZiAoV09SS0VSX09GRlNDUkVFTl9DQU5WQVMpIHtcbiAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoIHx8IDMwMCwgaGVpZ2h0IHx8IDMwMCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIH1cbiAgaWYgKHdpZHRoKSB7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIH1cbiAgaWYgKGhlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgLy9GSVhNRSBBbGxvdyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgYXMgcmV0dXJuIHR5cGVcbiAgcmV0dXJuIC8qKiBAdHlwZSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSAqLyAoXG4gICAgY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgc2V0dGluZ3MpXG4gICk7XG59XG5cbi8qKlxuICogUmVsZWFzZXMgY2FudmFzIG1lbW9yeSB0byBhdm9pZCBleGNlZWRpbmcgbWVtb3J5IGxpbWl0cyBpbiBTYWZhcmkuXG4gKiBTZWUgaHR0cHM6Ly9wcWluYS5ubC9ibG9nL3RvdGFsLWNhbnZhcy1tZW1vcnktdXNlLWV4Y2VlZHMtdGhlLW1heGltdW0tbGltaXQvXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQ29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VHTENhbnZhcyhnbCkge1xuICBjb25zdCBjYW52YXMgPSBnbC5jYW52YXM7XG4gIGNhbnZhcy53aWR0aCA9IDE7XG4gIGNhbnZhcy5oZWlnaHQgPSAxO1xuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG59XG5cbi8qKlxuICogQHR5cGUge0FycmF5PEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbnZhc0dMUG9vbCA9IFtdO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEltYWdlRXh0ZW50XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtjbGlwRXh0ZW50XSBDbGlwIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7V2ViR0xUZXh0dXJlfSB0ZXh0dXJlIFRleHR1cmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGV4dHVyZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRleHR1cmUuXG4gKi9cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzb3VyY2UgZGF0YSBpbnRvIG5ldyBjYW52YXMgYmFzZWQgb24gdGhlIHRyaWFuZ3VsYXRpb24uXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBjb250ZXh0IHRvIHJlbmRlciBpbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aF8gV2lkdGggb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRfIEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gc291cmNlUmVzb2x1dGlvbiBTb3VyY2UgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudCAodGlsZSkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzXCIpLmRlZmF1bHR9IHRyaWFuZ3VsYXRpb24gQ2FsY3VsYXRlZCB0cmlhbmd1bGF0aW9uLlxuICogQHBhcmFtIHtBcnJheTxJbWFnZUV4dGVudD59IHNvdXJjZXMgQXJyYXkgb2Ygc291cmNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFUeXBlIFdoYXQga2luZCBvZiBkYXRhIGlzIHRoZSB0ZXh0dXJlcywgbXVzdCBiZSBnbC5GTE9BVCBvciBnbC5VTlNJR05FRF9CWVRFXG4gKiBUT0RPOiBBbGxvdyBzZXR0aW5nIHJlbmRlckVkZ2VzIHZhbHVlIGluIHRoZSBkYXRhIGFzIHRoaXMgaXMgZG9uZSBpbiBcImRhdGEtc3BhY2VcIi5cbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFycmF5PG51bWJlcj59IFtyZW5kZXJFZGdlc10gUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlXSBVc2UgbGluZWFyIGludGVycG9sYXRpb24gd2hlbiByZXNhbXBsaW5nLlxuICogQHBhcmFtIHtib29sZWFufSBbZHJhd1NpbmdsZV0gRHJhdyBzaW5nbGUgc291cmNlIGltYWdlcyBkaXJlY3RseSB3aXRob3V0IHN0aXRjaFRleHR1cmUuXG4gKiBAcmV0dXJuIHt7ZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0ZXh0dXJlOiBXZWJHTFRleHR1cmV9fSBDYW52YXMgd2l0aCByZXByb2plY3RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKFxuICBnbCxcbiAgd2lkdGhfLFxuICBoZWlnaHRfLFxuICBwaXhlbFJhdGlvLFxuICBzb3VyY2VSZXNvbHV0aW9uLFxuICB0YXJnZXRSZXNvbHV0aW9uLFxuICB0YXJnZXRFeHRlbnQsXG4gIHRyaWFuZ3VsYXRpb24sXG4gIHNvdXJjZXMsXG4gIGd1dHRlcixcbiAgZGF0YVR5cGUsXG4gIHJlbmRlckVkZ2VzLFxuICBpbnRlcnBvbGF0ZSxcbiAgZHJhd1NpbmdsZSxcbikge1xuICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHdpZHRoXyk7XG4gIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIGhlaWdodF8pO1xuICBnbC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgZ2wuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAvKiogQHR5cGUge1dlYkdMRnJhbWVidWZmZXIgfCBudWxsfSAqL1xuICBsZXQgcmVzdWx0RnJhbWVCdWZmZXI7XG4gIC8qKiBAdHlwZSB7V2ViR0xUZXh0dXJlIHwgbnVsbH0gKi9cbiAgbGV0IHJlc3VsdFRleHR1cmU7XG4gIHtcbiAgICByZXN1bHRUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHJlc3VsdFRleHR1cmUpO1xuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgfVxuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCxcbiAgICAgIGdsLlJHQkEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIDAsXG4gICAgICBnbC5SR0JBLFxuICAgICAgZGF0YVR5cGUsXG4gICAgICBudWxsLFxuICAgICk7XG5cbiAgICByZXN1bHRGcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCByZXN1bHRGcmFtZUJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgIHJlc3VsdFRleHR1cmUsXG4gICAgICAwLFxuICAgICk7XG4gIH1cblxuICBpZiAocmVzdWx0RnJhbWVCdWZmZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgZnJhbWVidWZmZXInKTtcbiAgfVxuICBpZiAocmVzdWx0VGV4dHVyZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSB0ZXh0dXJlJyk7XG4gIH1cblxuICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBmcmFtZWJ1ZmZlcjogcmVzdWx0RnJhbWVCdWZmZXIsXG4gICAgICB0ZXh0dXJlOiByZXN1bHRUZXh0dXJlLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzb3VyY2VEYXRhRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMsIGksIGFycikge1xuICAgIGV4dGVuZChzb3VyY2VEYXRhRXh0ZW50LCBzcmMuZXh0ZW50KTtcbiAgfSk7XG5cbiAgLyoqIEB0eXBlIHtXZWJHTFRleHR1cmUgfCBudWxsfSAqL1xuICBsZXQgc3RpdGNoVGV4dHVyZTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGxldCBzdGl0Y2hXaWR0aDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGxldCBzdGl0Y2hIZWlnaHQ7XG4gIGNvbnN0IHN0aXRjaFNjYWxlID0gMSAvIHNvdXJjZVJlc29sdXRpb247XG5cbiAgaWYgKCFkcmF3U2luZ2xlIHx8IHNvdXJjZXMubGVuZ3RoICE9PSAxIHx8IGd1dHRlciAhPT0gMCkge1xuICAgIHN0aXRjaFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgaWYgKHJlc3VsdFRleHR1cmUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSB0ZXh0dXJlJyk7XG4gICAgfVxuICAgIHN0aXRjaFdpZHRoID0gTWF0aC5yb3VuZChnZXRXaWR0aChzb3VyY2VEYXRhRXh0ZW50KSAqIHN0aXRjaFNjYWxlKTtcbiAgICBzdGl0Y2hIZWlnaHQgPSBNYXRoLnJvdW5kKGdldEhlaWdodChzb3VyY2VEYXRhRXh0ZW50KSAqIHN0aXRjaFNjYWxlKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkbyBub3QgZXhjZWVkIHRoZSBtYXggdGV4dHVyZSBzaXplIGJ5IGxvd2VyaW5nIHRoZSByZXNvbHV0aW9uIGZvciB0aGlzIGltYWdlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVubGF5ZXJzL29wZW5sYXllcnMvcHVsbC8xNTg2MCNpc3N1ZWNvbW1lbnQtMjI1NDEyMzU4MFxuICAgIGNvbnN0IG1heFRleFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgY29uc3QgbGFyZ2VTaWRlID0gTWF0aC5tYXgoc3RpdGNoV2lkdGgsIHN0aXRjaEhlaWdodCk7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBsYXJnZVNpZGUgPiBtYXhUZXhTaXplID8gbWF4VGV4U2l6ZSAvIGxhcmdlU2lkZSA6IDE7XG4gICAgY29uc3Qgc3RpdGNoV2lkdGhGaXhlZCA9IE1hdGgucm91bmQoc3RpdGNoV2lkdGggKiBzY2FsZUZhY3Rvcik7XG4gICAgY29uc3Qgc3RpdGNoSGVpZ2h0Rml4ZWQgPSBNYXRoLnJvdW5kKHN0aXRjaEhlaWdodCAqIHNjYWxlRmFjdG9yKTtcblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHN0aXRjaFRleHR1cmUpO1xuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgfVxuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCxcbiAgICAgIGdsLlJHQkEsXG4gICAgICBzdGl0Y2hXaWR0aEZpeGVkLFxuICAgICAgc3RpdGNoSGVpZ2h0Rml4ZWQsXG4gICAgICAwLFxuICAgICAgZ2wuUkdCQSxcbiAgICAgIGRhdGFUeXBlLFxuICAgICAgbnVsbCxcbiAgICApO1xuXG4gICAgY29uc3QgZmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICBzdGl0Y2hUZXh0dXJlLFxuICAgICAgMCxcbiAgICApO1xuICAgIGNvbnN0IHdlYkdMQ2FudmFzID0gbmV3IFdlYkdMQ2FudmFzKGdsKTtcblxuICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc3JjLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHhQb3MgPVxuICAgICAgICAoc3JjLmV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF0pICogc3RpdGNoU2NhbGUgKiBzY2FsZUZhY3RvcjtcbiAgICAgIGNvbnN0IHlQb3MgPVxuICAgICAgICAtKHNyYy5leHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKSAqIHN0aXRjaFNjYWxlICogc2NhbGVGYWN0b3I7XG4gICAgICBjb25zdCBzcmNXaWR0aCA9IGdldFdpZHRoKHNyYy5leHRlbnQpICogc3RpdGNoU2NhbGUgKiBzY2FsZUZhY3RvcjtcbiAgICAgIGNvbnN0IHNyY0hlaWdodCA9IGdldEhlaWdodChzcmMuZXh0ZW50KSAqIHN0aXRjaFNjYWxlICogc2NhbGVGYWN0b3I7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiKTtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHN0aXRjaFdpZHRoRml4ZWQsIHN0aXRjaEhlaWdodEZpeGVkKTtcblxuICAgICAgaWYgKHNyYy5jbGlwRXh0ZW50KSB7XG4gICAgICAgIGNvbnN0IHhQb3MgPVxuICAgICAgICAgIChzcmMuY2xpcEV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF0pICogc3RpdGNoU2NhbGUgKiBzY2FsZUZhY3RvcjtcbiAgICAgICAgY29uc3QgeVBvcyA9XG4gICAgICAgICAgLShzcmMuY2xpcEV4dGVudFszXSAtIHNvdXJjZURhdGFFeHRlbnRbM10pICpcbiAgICAgICAgICBzdGl0Y2hTY2FsZSAqXG4gICAgICAgICAgc2NhbGVGYWN0b3I7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0V2lkdGgoc3JjLmNsaXBFeHRlbnQpICogc3RpdGNoU2NhbGUgKiBzY2FsZUZhY3RvcjtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KHNyYy5jbGlwRXh0ZW50KSAqIHN0aXRjaFNjYWxlICogc2NhbGVGYWN0b3I7XG4gICAgICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICBnbC5zY2lzc29yKFxuICAgICAgICAgIGludGVycG9sYXRlID8geFBvcyA6IE1hdGgucm91bmQoeFBvcyksXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPyB5UG9zIDogTWF0aC5yb3VuZCh5UG9zKSxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA/IHdpZHRoIDogTWF0aC5yb3VuZCh4UG9zICsgd2lkdGgpIC0gTWF0aC5yb3VuZCh4UG9zKSxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA/IGhlaWdodCA6IE1hdGgucm91bmQoeVBvcyArIGhlaWdodCkgLSBNYXRoLnJvdW5kKHlQb3MpLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB3ZWJHTENhbnZhcy5kcmF3SW1hZ2UoXG4gICAgICAgIHNyYy50ZXh0dXJlLFxuICAgICAgICBzcmMud2lkdGgsXG4gICAgICAgIHNyYy5oZWlnaHQsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgZ3V0dGVyLFxuICAgICAgICBzcmMud2lkdGggLSAyICogZ3V0dGVyLFxuICAgICAgICBzcmMuaGVpZ2h0IC0gMiAqIGd1dHRlcixcbiAgICAgICAgaW50ZXJwb2xhdGUgPyB4UG9zIDogTWF0aC5yb3VuZCh4UG9zKSxcbiAgICAgICAgaW50ZXJwb2xhdGUgPyB5UG9zIDogTWF0aC5yb3VuZCh5UG9zKSxcbiAgICAgICAgaW50ZXJwb2xhdGUgPyBzcmNXaWR0aCA6IE1hdGgucm91bmQoeFBvcyArIHNyY1dpZHRoKSAtIE1hdGgucm91bmQoeFBvcyksXG4gICAgICAgIGludGVycG9sYXRlXG4gICAgICAgICAgPyBzcmNIZWlnaHRcbiAgICAgICAgICA6IE1hdGgucm91bmQoeVBvcyArIHNyY0hlaWdodCkgLSBNYXRoLnJvdW5kKHlQb3MpLFxuICAgICAgICBzdGl0Y2hXaWR0aEZpeGVkLFxuICAgICAgICBzdGl0Y2hIZWlnaHRGaXhlZCxcbiAgICAgICk7XG5cbiAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9KTtcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYik7XG4gIH0gZWxzZSB7XG4gICAgc3RpdGNoVGV4dHVyZSA9IHNvdXJjZXNbMF0udGV4dHVyZTtcbiAgICBzdGl0Y2hXaWR0aCA9IHNvdXJjZXNbMF0ud2lkdGg7XG4gICAgc3RpdGNoSGVpZ2h0ID0gc291cmNlc1swXS53aWR0aDtcbiAgfVxuXG4gIGNvbnN0IHRhcmdldFRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG4gIGNvbnN0IHNvdXJjZVRvcExlZnQgPSBnZXRUb3BMZWZ0KHNvdXJjZURhdGFFeHRlbnQpO1xuXG4gIGNvbnN0IGdldFVWcyA9IChcbiAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovIHRhcmdldCxcbiAgKSA9PiB7XG4gICAgY29uc3QgdTAgPVxuICAgICAgKCh0YXJnZXRbMF1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb24pICogcGl4ZWxSYXRpbztcbiAgICBjb25zdCB2MCA9XG4gICAgICAoLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb24pICogcGl4ZWxSYXRpbztcbiAgICBjb25zdCB1MSA9XG4gICAgICAoKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbikgKiBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IHYxID1cbiAgICAgICgtKHRhcmdldFsxXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbikgKiBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IHUyID1cbiAgICAgICgodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uKSAqIHBpeGVsUmF0aW87XG4gICAgY29uc3QgdjIgPVxuICAgICAgKC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uKSAqIHBpeGVsUmF0aW87XG4gICAgcmV0dXJuIHt1MSwgdjEsIHUwLCB2MCwgdTIsIHYyfTtcbiAgfTtcblxuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHJlc3VsdEZyYW1lQnVmZmVyKTtcbiAgZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgLy8gRHJhdyBzb3VyY2UgdG8gcmVwcm9qdGlsZVxuICB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHRleGNvb3JkcyA9IFtdO1xuXG4gICAgY29uc3QgdHJpUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oXG4gICAgICBnbCxcbiAgICAgIFRSSUFOR0xFX0ZSQUdNRU5UX1NIQURFUixcbiAgICAgIFRSSUFOR0xFX1ZFUlRFWF9TSEFERVIsXG4gICAgKTtcbiAgICBnbC51c2VQcm9ncmFtKHRyaVByb2dyYW0pO1xuXG4gICAgLy8gQmluZCBpbWFnZVxuICAgIGNvbnN0IHRleHR1cmVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0cmlQcm9ncmFtLCAndV90ZXh0dXJlJyk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc3RpdGNoVGV4dHVyZSk7XG5cbiAgICAvLyBUZWxsIHRoZSBzaGFkZXIgdG8gZ2V0IHRoZSB0ZXh0dXJlIGZyb20gdGV4dHVyZSB1bml0IDBcbiAgICBnbC51bmlmb3JtMWkodGV4dHVyZUxvY2F0aW9uLCAwKTtcblxuICAgIC8vIENhbGN1bGF0ZSB2ZXJ0IGFuZCB0ZXggY29vcmRpbmF0ZXMuXG4gICAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBldmVyeXRoaW5nIGlzIG9uIHBpeGVsIGJvdW5kYXJpZXNcbiAgICAgIGNvbnN0IHt1MSwgdjEsIHUwLCB2MCwgdTIsIHYyfSA9IGdldFVWcyh0YXJnZXQpO1xuXG4gICAgICBjb25zdCBzdTAgPVxuICAgICAgICAoc291cmNlWzBdWzBdIC0gc291cmNlVG9wTGVmdFswXSkgLyBzb3VyY2VSZXNvbHV0aW9uIC8gc3RpdGNoV2lkdGg7XG4gICAgICBjb25zdCBzdjAgPVxuICAgICAgICAtKHNvdXJjZVswXVsxXSAtIHNvdXJjZVRvcExlZnRbMV0pIC8gc291cmNlUmVzb2x1dGlvbiAvIHN0aXRjaEhlaWdodDtcbiAgICAgIGNvbnN0IHN1MSA9XG4gICAgICAgIChzb3VyY2VbMV1bMF0gLSBzb3VyY2VUb3BMZWZ0WzBdKSAvIHNvdXJjZVJlc29sdXRpb24gLyBzdGl0Y2hXaWR0aDtcbiAgICAgIGNvbnN0IHN2MSA9XG4gICAgICAgIC0oc291cmNlWzFdWzFdIC0gc291cmNlVG9wTGVmdFsxXSkgLyBzb3VyY2VSZXNvbHV0aW9uIC8gc3RpdGNoSGVpZ2h0O1xuICAgICAgY29uc3Qgc3UyID1cbiAgICAgICAgKHNvdXJjZVsyXVswXSAtIHNvdXJjZVRvcExlZnRbMF0pIC8gc291cmNlUmVzb2x1dGlvbiAvIHN0aXRjaFdpZHRoO1xuICAgICAgY29uc3Qgc3YyID1cbiAgICAgICAgLShzb3VyY2VbMl1bMV0gLSBzb3VyY2VUb3BMZWZ0WzFdKSAvIHNvdXJjZVJlc29sdXRpb24gLyBzdGl0Y2hIZWlnaHQ7XG5cbiAgICAgIHZlcnRpY2VzLnB1c2godTEsIHYxLCB1MCwgdjAsIHUyLCB2Mik7XG4gICAgICB0ZXhjb29yZHMucHVzaChzdTEsIHN2MSwgc3UwLCBzdjAsIHN1Miwgc3YyKTtcbiAgICB9KTtcblxuICAgIC8vIENvbnZlcnQgcGl4ZWwgc3BhY2UgdG8gY2xpcCBzcGFjZS5cbiAgICBjb25zdCBtYXRyaXggPSBtYXQ0Lm9ydGhvZ3JhcGhpYygwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSk7XG4gICAgY29uc3QgbWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odHJpUHJvZ3JhbSwgJ3VfbWF0cml4Jyk7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIG1hdHJpeCk7XG5cbiAgICBjb25zdCBwb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odHJpUHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuXG4gICAgY29uc3QgdGV4Y29vcmRMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRyaVByb2dyYW0sICdhX3RleGNvb3JkJyk7XG4gICAgY29uc3QgdGV4Y29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGV4Y29vcmRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRleGNvb3JkcyksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleGNvb3JkTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Y29vcmRMb2NhdGlvbik7XG5cbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgdmVydGljZXMubGVuZ3RoIC8gMik7XG4gIH1cblxuICBpZiAocmVuZGVyRWRnZXMpIHtcbiAgICBjb25zdCBlZGdlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oXG4gICAgICBnbCxcbiAgICAgIEVER0VfRlJBR01FTlRfU0hBREVSLFxuICAgICAgRURHRV9WRVJURVhfU0hBREVSLFxuICAgICk7XG4gICAgZ2wudXNlUHJvZ3JhbShlZGdlUHJvZ3JhbSk7XG4gICAgY29uc3QgbWF0cml4ID0gbWF0NC5vcnRob2dyYXBoaWMoMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEpO1xuICAgIGNvbnN0IG1hdHJpeExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGVkZ2VQcm9ncmFtLCAndV9tYXRyaXgnKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgbWF0cml4KTtcblxuICAgIGNvbnN0IGJ1cm52YWwgPSBBcnJheS5pc0FycmF5KHJlbmRlckVkZ2VzKSA/IHJlbmRlckVkZ2VzIDogWzAsIDAsIDAsIDI1NV07XG4gICAgY29uc3QgYnVybnZhbExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGVkZ2VQcm9ncmFtLCAndV92YWwnKTtcbiAgICBjb25zdCBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICBpZiAoaXNGbG9hdCkge1xuICAgICAgZ2wudW5pZm9ybTRmdihidXJudmFsTG9jYXRpb24sIGJ1cm52YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC51bmlmb3JtNGl2KGJ1cm52YWxMb2NhdGlvbiwgYnVybnZhbCk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKGVkZ2VQcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG5cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgbGluZXMgPSB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLnJlZHVjZShmdW5jdGlvbiAoXG4gICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIGxpbmVzLFxuICAgICAgdHJpYW5nbGUsXG4gICAgKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgICBjb25zdCB7dTEsIHYxLCB1MCwgdjAsIHUyLCB2Mn0gPSBnZXRVVnModGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIGxpbmVzLmNvbmNhdChbdTEsIHYxLCB1MCwgdjAsIHUwLCB2MCwgdTIsIHYyLCB1MiwgdjIsIHUxLCB2MV0pO1xuICAgIH0sIFtdKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShsaW5lcyksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTLCAwLCBsaW5lcy5sZW5ndGggLyAyKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZyYW1lYnVmZmVyOiByZXN1bHRGcmFtZUJ1ZmZlcixcbiAgICB0ZXh0dXJlOiByZXN1bHRUZXh0dXJlLFxuICB9O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Jlc29sdXRpb25jb25zdHJhaW50XG4gKi9cbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2dldEhlaWdodCwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZWFyRmluZE5lYXJlc3R9IGZyb20gJy4vYXJyYXkuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobnVtYmVyfHVuZGVmaW5lZCksIG51bWJlciwgaW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemUsIGJvb2xlYW49KTogKG51bWJlcnx1bmRlZmluZWQpfSBUeXBlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgcmVzb2x1dGlvbiB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB2aWV3cG9ydCBzaXplIGFuZCBtYXhpbXVtXG4gKiBhbGxvd2VkIGV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb25cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4aW11bSBhbGxvd2VkIGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHZpZXdwb3J0U2l6ZSBWaWV3cG9ydCBzaXplLlxuICogQHBhcmFtIHtib29sZWFufSBzaG93RnVsbEV4dGVudCBXaGV0aGVyIHRvIHNob3cgdGhlIGZ1bGwgZXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBDYXBwZWQgcmVzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Vmlld3BvcnRDbGFtcGVkUmVzb2x1dGlvbihcbiAgcmVzb2x1dGlvbixcbiAgbWF4RXh0ZW50LFxuICB2aWV3cG9ydFNpemUsXG4gIHNob3dGdWxsRXh0ZW50LFxuKSB7XG4gIGNvbnN0IHhSZXNvbHV0aW9uID0gZ2V0V2lkdGgobWF4RXh0ZW50KSAvIHZpZXdwb3J0U2l6ZVswXTtcbiAgY29uc3QgeVJlc29sdXRpb24gPSBnZXRIZWlnaHQobWF4RXh0ZW50KSAvIHZpZXdwb3J0U2l6ZVsxXTtcblxuICBpZiAoc2hvd0Z1bGxFeHRlbnQpIHtcbiAgICByZXR1cm4gTWF0aC5taW4ocmVzb2x1dGlvbiwgTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJlc29sdXRpb24sIE1hdGgubWluKHhSZXNvbHV0aW9uLCB5UmVzb2x1dGlvbikpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBtb2RpZmllZCByZXNvbHV0aW9uIHRvIGJlIGJldHdlZW4gbWF4UmVzb2x1dGlvbiBhbmQgbWluUmVzb2x1dGlvbiB3aGlsZVxuICogc3RpbGwgYWxsb3dpbmcgdGhlIHZhbHVlIHRvIGJlIHNsaWdodGx5IG91dCBvZiBib3VuZHMuXG4gKiBOb3RlOiB0aGUgY29tcHV0YXRpb24gaXMgYmFzZWQgb24gdGhlIGxvZ2FyaXRobSBmdW5jdGlvbiAobG4pOlxuICogIC0gYXQgMSwgbG4oeCkgaXMgMFxuICogIC0gYWJvdmUgMSwgbG4oeCkga2VlcHMgaW5jcmVhc2luZyBidXQgYXQgYSBtdWNoIHNsb3dlciBwYWNlIHRoYW4geFxuICogVGhlIGZpbmFsIHJlc3VsdCBpcyBjbGFtcGVkIHRvIHByZXZlbnQgZ2V0dGluZyB0b28gZmFyIGF3YXkgZnJvbSBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBNaW4gcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gU21vb3RoZWQgcmVzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U21vb3RoQ2xhbXBlZFJlc29sdXRpb24ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbikge1xuICBsZXQgcmVzdWx0ID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbik7XG4gIGNvbnN0IHJhdGlvID0gNTA7XG5cbiAgcmVzdWx0ICo9XG4gICAgTWF0aC5sb2coMSArIHJhdGlvICogTWF0aC5tYXgoMCwgcmVzb2x1dGlvbiAvIG1heFJlc29sdXRpb24gLSAxKSkgLyByYXRpbyArXG4gICAgMTtcbiAgaWYgKG1pblJlc29sdXRpb24pIHtcbiAgICByZXN1bHQgPSBNYXRoLm1heChyZXN1bHQsIG1pblJlc29sdXRpb24pO1xuICAgIHJlc3VsdCAvPVxuICAgICAgTWF0aC5sb2coMSArIHJhdGlvICogTWF0aC5tYXgoMCwgbWluUmVzb2x1dGlvbiAvIHJlc29sdXRpb24gLSAxKSkgL1xuICAgICAgICByYXRpbyArXG4gICAgICAxO1xuICB9XG4gIHJldHVybiBjbGFtcChyZXN1bHQsIG1pblJlc29sdXRpb24gLyAyLCBtYXhSZXNvbHV0aW9uICogMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Ntb290aF0gSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIHNsaWdodGx5IGV4Y2VlZCByZXNvbHV0aW9uIGxpbWl0cy4gRGVmYXVsdDogdHJ1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbWF4RXh0ZW50XSBNYXhpbXVtIGFsbG93ZWQgZXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd0Z1bGxFeHRlbnRdIElmIHRydWUsIGFsbG93cyB1cyB0byBzaG93IHRoZSBmdWxsIGV4dGVudC4gRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvUmVzb2x1dGlvbnMoXG4gIHJlc29sdXRpb25zLFxuICBzbW9vdGgsXG4gIG1heEV4dGVudCxcbiAgc2hvd0Z1bGxFeHRlbnQsXG4pIHtcbiAgc21vb3RoID0gc21vb3RoICE9PSB1bmRlZmluZWQgPyBzbW9vdGggOiB0cnVlO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgVmlld3BvcnQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gVHJ1ZSBpZiBhbiBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVzb2x1dGlvbiwgZGlyZWN0aW9uLCBzaXplLCBpc01vdmluZykge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBtYXhSZXNvbHV0aW9uID0gcmVzb2x1dGlvbnNbMF07XG4gICAgICAgIGNvbnN0IG1pblJlc29sdXRpb24gPSByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgY2FwcGVkTWF4UmVzID0gbWF4RXh0ZW50XG4gICAgICAgICAgPyBnZXRWaWV3cG9ydENsYW1wZWRSZXNvbHV0aW9uKFxuICAgICAgICAgICAgICBtYXhSZXNvbHV0aW9uLFxuICAgICAgICAgICAgICBtYXhFeHRlbnQsXG4gICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgIHNob3dGdWxsRXh0ZW50LFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbWF4UmVzb2x1dGlvbjtcblxuICAgICAgICAvLyBkdXJpbmcgaW50ZXJhY3Rpbmcgb3IgYW5pbWF0aW5nLCBhbGxvdyBpbnRlcm1lZGlhcnkgdmFsdWVzXG4gICAgICAgIGlmIChpc01vdmluZykge1xuICAgICAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXAocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiwgY2FwcGVkTWF4UmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldFNtb290aENsYW1wZWRSZXNvbHV0aW9uKFxuICAgICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICAgIGNhcHBlZE1heFJlcyxcbiAgICAgICAgICAgIG1pblJlc29sdXRpb24sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhcHBlZCA9IE1hdGgubWluKGNhcHBlZE1heFJlcywgcmVzb2x1dGlvbik7XG4gICAgICAgIGNvbnN0IHogPSBNYXRoLmZsb29yKGxpbmVhckZpbmROZWFyZXN0KHJlc29sdXRpb25zLCBjYXBwZWQsIGRpcmVjdGlvbikpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbnNbel0gPiBjYXBwZWRNYXhSZXMgJiYgeiA8IHJlc29sdXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnNbeiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uc1t6XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3dlciBQb3dlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIE1heGltdW0gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gTWluaW11bSByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbc21vb3RoXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGJlIGFibGUgdG8gc2xpZ2h0bHkgZXhjZWVkIHJlc29sdXRpb24gbGltaXRzLiBEZWZhdWx0OiB0cnVlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFttYXhFeHRlbnRdIE1heGltdW0gYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG93RnVsbEV4dGVudF0gSWYgdHJ1ZSwgYWxsb3dzIHVzIHRvIHNob3cgdGhlIGZ1bGwgZXh0ZW50LiBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge1R5cGV9IFpvb20gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFwVG9Qb3dlcihcbiAgcG93ZXIsXG4gIG1heFJlc29sdXRpb24sXG4gIG1pblJlc29sdXRpb24sXG4gIHNtb290aCxcbiAgbWF4RXh0ZW50LFxuICBzaG93RnVsbEV4dGVudCxcbikge1xuICBzbW9vdGggPSBzbW9vdGggIT09IHVuZGVmaW5lZCA/IHNtb290aCA6IHRydWU7XG4gIG1pblJlc29sdXRpb24gPSBtaW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgPyBtaW5SZXNvbHV0aW9uIDogMDtcblxuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgVmlld3BvcnQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gVHJ1ZSBpZiBhbiBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVzb2x1dGlvbiwgZGlyZWN0aW9uLCBzaXplLCBpc01vdmluZykge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjYXBwZWRNYXhSZXMgPSBtYXhFeHRlbnRcbiAgICAgICAgICA/IGdldFZpZXdwb3J0Q2xhbXBlZFJlc29sdXRpb24oXG4gICAgICAgICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgICAgICAgIG1heEV4dGVudCxcbiAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgc2hvd0Z1bGxFeHRlbnQsXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBtYXhSZXNvbHV0aW9uO1xuXG4gICAgICAgIC8vIGR1cmluZyBpbnRlcmFjdGluZyBvciBhbmltYXRpbmcsIGFsbG93IGludGVybWVkaWFyeSB2YWx1ZXNcbiAgICAgICAgaWYgKGlzTW92aW5nKSB7XG4gICAgICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcChyZXNvbHV0aW9uLCBtaW5SZXNvbHV0aW9uLCBjYXBwZWRNYXhSZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0U21vb3RoQ2xhbXBlZFJlc29sdXRpb24oXG4gICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgY2FwcGVkTWF4UmVzLFxuICAgICAgICAgICAgbWluUmVzb2x1dGlvbixcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gMWUtOTtcbiAgICAgICAgY29uc3QgbWluWm9vbUxldmVsID0gTWF0aC5jZWlsKFxuICAgICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBjYXBwZWRNYXhSZXMpIC8gTWF0aC5sb2cocG93ZXIpIC0gdG9sZXJhbmNlLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAtZGlyZWN0aW9uICogKDAuNSAtIHRvbGVyYW5jZSkgKyAwLjU7XG4gICAgICAgIGNvbnN0IGNhcHBlZCA9IE1hdGgubWluKGNhcHBlZE1heFJlcywgcmVzb2x1dGlvbik7XG4gICAgICAgIGNvbnN0IGNhcHBlZFpvb21MZXZlbCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIGNhcHBlZCkgLyBNYXRoLmxvZyhwb3dlcikgKyBvZmZzZXQsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHpvb21MZXZlbCA9IE1hdGgubWF4KG1pblpvb21MZXZlbCwgY2FwcGVkWm9vbUxldmVsKTtcbiAgICAgICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhwb3dlciwgem9vbUxldmVsKTtcbiAgICAgICAgcmV0dXJuIGNsYW1wKG5ld1Jlc29sdXRpb24sIG1pblJlc29sdXRpb24sIGNhcHBlZE1heFJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBNYXggcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIE1pbiByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbc21vb3RoXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGJlIGFibGUgdG8gc2xpZ2h0bHkgZXhjZWVkIHJlc29sdXRpb24gbGltaXRzLiBEZWZhdWx0OiB0cnVlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFttYXhFeHRlbnRdIE1heGltdW0gYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG93RnVsbEV4dGVudF0gSWYgdHJ1ZSwgYWxsb3dzIHVzIHRvIHNob3cgdGhlIGZ1bGwgZXh0ZW50LiBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge1R5cGV9IFpvb20gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNaW5NYXhSZXNvbHV0aW9uKFxuICBtYXhSZXNvbHV0aW9uLFxuICBtaW5SZXNvbHV0aW9uLFxuICBzbW9vdGgsXG4gIG1heEV4dGVudCxcbiAgc2hvd0Z1bGxFeHRlbnQsXG4pIHtcbiAgc21vb3RoID0gc21vb3RoICE9PSB1bmRlZmluZWQgPyBzbW9vdGggOiB0cnVlO1xuXG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUsIGlzTW92aW5nKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNhcHBlZE1heFJlcyA9IG1heEV4dGVudFxuICAgICAgICAgID8gZ2V0Vmlld3BvcnRDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgbWF4RXh0ZW50LFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICBzaG93RnVsbEV4dGVudCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG1heFJlc29sdXRpb247XG5cbiAgICAgICAgaWYgKCFzbW9vdGggfHwgIWlzTW92aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGNsYW1wKHJlc29sdXRpb24sIG1pblJlc29sdXRpb24sIGNhcHBlZE1heFJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFNtb290aENsYW1wZWRSZXNvbHV0aW9uKFxuICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgY2FwcGVkTWF4UmVzLFxuICAgICAgICAgIG1pblJlc29sdXRpb24sXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yb3RhdGlvbmNvbnN0cmFpbnRcbiAqL1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChudW1iZXJ8dW5kZWZpbmVkKSwgYm9vbGVhbj0pOiAobnVtYmVyfHVuZGVmaW5lZCl9IFR5cGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGUocm90YXRpb24pIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbmUocm90YXRpb24pIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBOLlxuICogQHJldHVybiB7VHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb04obikge1xuICBjb25zdCB0aGV0YSA9ICgyICogTWF0aC5QSSkgLyBuO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb3ZpbmddIFRydWUgaWYgYW4gaW50ZXJhY3Rpb24gb3IgYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb3RhdGlvbiwgaXNNb3ZpbmcpIHtcbiAgICAgIGlmIChpc01vdmluZykge1xuICAgICAgICByZXR1cm4gcm90YXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdGF0aW9uID0gTWF0aC5mbG9vcihyb3RhdGlvbiAvIHRoZXRhICsgMC41KSAqIHRoZXRhO1xuICAgICAgICByZXR1cm4gcm90YXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gW3RvbGVyYW5jZV0gVG9sZXJhbmNlLlxuICogQHJldHVybiB7VHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb1plcm8odG9sZXJhbmNlKSB7XG4gIGNvbnN0IHQgPSB0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCA/IHRvUmFkaWFucyg1KSA6IHRvbGVyYW5jZTtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocm90YXRpb24sIGlzTW92aW5nKSB7XG4gICAgICBpZiAoaXNNb3ZpbmcgfHwgcm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcm90YXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPD0gdCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICB9XG4gICk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc2l6ZVxuICovXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYSBzaXplOiBgW3dpZHRoLCBoZWlnaHRdYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBTaXplXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyZWQgc2l6ZS5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRvIGJ1ZmZlci5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBUaGUgYnVmZmVyZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihzaXplLCBudW0sIGRlc3QpIHtcbiAgaWYgKGRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3QgPSBbMCwgMF07XG4gIH1cbiAgZGVzdFswXSA9IHNpemVbMF0gKyAyICogbnVtO1xuICBkZXN0WzFdID0gc2l6ZVsxXSArIDIgKiBudW07XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgVGhlIHNpemUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNBcmVhKHNpemUpIHtcbiAgcmV0dXJuIHNpemVbMF0gPiAwICYmIHNpemVbMV0gPiAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaXplIHNjYWxlZCBieSBhIHJhdGlvLiBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnMuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyBSYXRpby5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBUaGUgc2NhbGVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShzaXplLCByYXRpbywgZGVzdCkge1xuICBpZiAoZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdCA9IFswLCAwXTtcbiAgfVxuICBkZXN0WzBdID0gKHNpemVbMF0gKiByYXRpbyArIDAuNSkgfCAwO1xuICBkZXN0WzFdID0gKHNpemVbMV0gKiByYXRpbyArIDAuNSkgfCAwO1xuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGBTaXplYCBhcnJheSBmb3IgdGhlIHBhc3NlZCBpbiBudW1iZXIgKG1lYW5pbmc6IHNxdWFyZSkgb3JcbiAqIGBTaXplYCBhcnJheS5cbiAqIChtZWFuaW5nOiBub24tc3F1YXJlKSxcbiAqIEBwYXJhbSB7bnVtYmVyfFNpemV9IHNpemUgV2lkdGggYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBTaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TaXplKHNpemUsIGRlc3QpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBpZiAoZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdCA9IFtzaXplLCBzaXplXTtcbiAgfSBlbHNlIHtcbiAgICBkZXN0WzBdID0gc2l6ZTtcbiAgICBkZXN0WzFdID0gc2l6ZTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvT1NNXG4gKi9cblxuaW1wb3J0IFhZWiBmcm9tICcuL1hZWi5qcyc7XG5cbi8qKlxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRhaW5pbmcgYSBsaW5rIHRvIHRoZSBPcGVuU3RyZWV0TWFwIENvcHlyaWdodCBhbmQgTGljZW5zZVxuICogcGFnZS5cbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IEFUVFJJQlVUSU9OID1cbiAgJyYjMTY5OyAnICtcbiAgJzxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5PcGVuU3RyZWV0TWFwPC9hPiAnICtcbiAgJ2NvbnRyaWJ1dG9ycy4nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gRGVwcmVjYXRlZC4gIFVzZSB0aGUgY2FjaGVTaXplIG9wdGlvbiBvbiB0aGUgbGF5ZXIgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbj0nYW5vbnltb3VzJ10gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9dHJ1ZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLiAgU2V0IHRvIGZhbHNlIHRvIHVzZSB0aGUgbmVhcmVzdCBuZWlnaGJvciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTE5XSBNYXggem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbj0yNTBdIER1cmF0aW9uIG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24gZm9yIHJlbmRlcmluZy5cbiAqIFRvIGRpc2FibGUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiwgcGFzcyBgdHJhbnNpdGlvbjogMGAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybD0naHR0cHM6Ly90aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZyddIFVSTCB0ZW1wbGF0ZS5cbiAqIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLCBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV2hldGhlciB0byB3cmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFt6RGlyZWN0aW9uPTBdXG4gKiBDaG9vc2Ugd2hldGhlciB0byB1c2UgdGlsZXMgd2l0aCBhIGhpZ2hlciBvciBsb3dlciB6b29tIGxldmVsIHdoZW4gYmV0d2VlbiBpbnRlZ2VyXG4gKiB6b29tIGxldmVscy4gU2VlIHtAbGluayBtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR+VGlsZUdyaWQjZ2V0WkZvclJlc29sdXRpb259LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aGUgT3BlblN0cmVldE1hcCB0aWxlIHNlcnZlci5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgT1NNIGV4dGVuZHMgWFlaIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wZW4gU3RyZWV0IE1hcCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgbGV0IGF0dHJpYnV0aW9ucztcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXR0cmlidXRpb25zID0gb3B0aW9ucy5hdHRyaWJ1dGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IFtBVFRSSUJVVElPTl07XG4gICAgfVxuXG4gICAgY29uc3QgY3Jvc3NPcmlnaW4gPVxuICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc09yaWdpbiA6ICdhbm9ueW1vdXMnO1xuXG4gICAgY29uc3QgdXJsID1cbiAgICAgIG9wdGlvbnMudXJsICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnVybFxuICAgICAgICA6ICdodHRwczovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJztcblxuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogYXR0cmlidXRpb25zLFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IGZhbHNlLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgICAgbWF4Wm9vbTogb3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFpvb20gOiAxOSxcbiAgICAgIHJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkOiBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIHpEaXJlY3Rpb246IG9wdGlvbnMuekRpcmVjdGlvbixcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPU007XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1NvdXJjZVxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyd1bmRlZmluZWQnIHwgJ2xvYWRpbmcnIHwgJ3JlYWR5JyB8ICdlcnJvcid9IFN0YXRlXG4gKiBTdGF0ZSBvZiB0aGUgc291cmNlLCBvbmUgb2YgJ3VuZGVmaW5lZCcsICdsb2FkaW5nJywgJ3JlYWR5JyBvciAnZXJyb3InLlxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIGltcG9ydChcIi4uL1ZpZXcuanNcIikuVmlld1N0YXRlTGF5ZXJTdGF0ZUV4dGVudH0gYW5kIHJldHVybnMgYSBzdHJpbmcgb3JcbiAqIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHNvdXJjZSBhdHRyaWJ1dGlvbnMuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL1ZpZXcuanNcIikuVmlld1N0YXRlTGF5ZXJTdGF0ZUV4dGVudCk6IChzdHJpbmd8QXJyYXk8c3RyaW5nPil9IEF0dHJpYnV0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGF0dHJpYnV0aW9uIGluZm9ybWF0aW9uIGZvciBkYXRhIHNvdXJjZXMuXG4gKlxuICogSXQgcmVwcmVzZW50cyBlaXRoZXJcbiAqICogYSBzaW1wbGUgc3RyaW5nIChlLmcuIGAnwqkgQWNtZSBJbmMuJ2ApXG4gKiAqIGFuIGFycmF5IG9mIHNpbXBsZSBzdHJpbmdzIChlLmcuIGBbJ8KpIEFjbWUgSW5jLicsICfCqSBCYWNtZSBJbmMuJ11gKVxuICogKiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzICh7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259KVxuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd8QXJyYXk8c3RyaW5nPnxBdHRyaWJ1dGlvbn0gQXR0cmlidXRpb25MaWtlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0F0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uIERlZmF1bHQgaXMgdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IFtzdGF0ZT0ncmVhZHknXSBTdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPWZhbHNlXSBXcmFwWC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPWZhbHNlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogdGhlIG5lYXJlc3QgbmVpZ2hib3IgaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyfSBzb3VyY2VzLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSBjaGFuZ2VzLlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIFNvdXJjZSBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFNvdXJjZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0F0dHJpYnV0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRpb25zXyA9IGFkYXB0QXR0cmlidXRpb25zKG9wdGlvbnMuYXR0cmlidXRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZV8gPSBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlID8/IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNvdXJjZSBpcyBjdXJyZW50bHkgbG9hZGluZyBkYXRhLiBTb3VyY2VzIHRoYXQgZGVmZXIgbG9hZGluZyB0byB0aGVcbiAgICAgKiBtYXAncyB0aWxlIHF1ZXVlIG5ldmVyIHNldCB0aGlzIHRvIGB0cnVlYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVfID0gb3B0aW9ucy5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGF0ZSA6ICdyZWFkeSc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMud3JhcFhfID0gb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlXyA9ICEhb3B0aW9ucy5pbnRlcnBvbGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3T3B0aW9ucyk6dm9pZH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdSZXNvbHZlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKEVycm9yKTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMudmlld1JlamVjdG9yID0gbnVsbDtcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1Byb21pc2U8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3T3B0aW9ucz59XG4gICAgICovXG4gICAgdGhpcy52aWV3UHJvbWlzZV8gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzZWxmLnZpZXdSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICBzZWxmLnZpZXdSZWplY3RvciA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF0dHJpYnV0aW9uIGZ1bmN0aW9uIGZvciB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHs/QXR0cmlidXRpb259IEF0dHJpYnV0aW9uIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBdHRyaWJ1dGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRpb25zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcm9qZWN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fG51bGx9IFByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByb2plY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvblwiKS5kZWZhdWx0fSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBSZXNvbHV0aW9ucy5cbiAgICovXG4gIGdldFJlc29sdXRpb25zKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPGltcG9ydChcIi4uL1ZpZXcuanNcIikuVmlld09wdGlvbnM+fSBBIHByb21pc2UgZm9yIHZpZXctcmVsYXRlZCBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgZ2V0VmlldygpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3UHJvbWlzZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlLCBzZWUge0BsaW5rIGltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBmb3IgcG9zc2libGUgc3RhdGVzLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX0gU3RhdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gV3JhcCBYLlxuICAgKi9cbiAgZ2V0V3JhcFgoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aGVuIHJlc2FtcGxpbmcuXG4gICAqL1xuICBnZXRJbnRlcnBvbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaGVzIHRoZSBzb3VyY2UuIFRoZSBzb3VyY2Ugd2lsbCBiZSBjbGVhcmVkLCBhbmQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgd2lsbCBiZSByZWxvYWRlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGF0dHJpYnV0aW9ucyBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge0F0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9ucyBBdHRyaWJ1dGlvbnMuXG4gICAqICAgICBDYW4gYmUgcGFzc2VkIGFzIGBzdHJpbmdgLCBgQXJyYXk8c3RyaW5nPmAsIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn0sXG4gICAqICAgICBvciBgdW5kZWZpbmVkYC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0QXR0cmlidXRpb25zKGF0dHJpYnV0aW9ucykge1xuICAgIHRoaXMuYXR0cmlidXRpb25zXyA9IGFkYXB0QXR0cmlidXRpb25zKGF0dHJpYnV0aW9ucyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICovXG4gIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIFR1cm5zIHRoZSBhdHRyaWJ1dGlvbnMgb3B0aW9uIGludG8gYW4gYXR0cmlidXRpb25zIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBdHRyaWJ1dGlvbkxpa2V8dW5kZWZpbmVkfSBhdHRyaWJ1dGlvbkxpa2UgVGhlIGF0dHJpYnV0aW9uIG9wdGlvbi5cbiAqIEByZXR1cm4ge0F0dHJpYnV0aW9ufG51bGx9IEFuIGF0dHJpYnV0aW9uIGZ1bmN0aW9uIChvciBudWxsKS5cbiAqL1xuZnVuY3Rpb24gYWRhcHRBdHRyaWJ1dGlvbnMoYXR0cmlidXRpb25MaWtlKSB7XG4gIGlmICghYXR0cmlidXRpb25MaWtlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGlvbkxpa2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXR0cmlidXRpb25MaWtlO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShhdHRyaWJ1dGlvbkxpa2UpKSB7XG4gICAgYXR0cmlidXRpb25MaWtlID0gW2F0dHJpYnV0aW9uTGlrZV07XG4gIH1cbiAgcmV0dXJuIChmcmFtZVN0YXRlKSA9PiBhdHRyaWJ1dGlvbkxpa2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNvdXJjZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZVxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IHthYnN0cmFjdCwgZ2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7XG4gIGdldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uLFxuICB3cmFwWCxcbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuaW1wb3J0IHtzY2FsZSBhcyBzY2FsZVNpemUsIHRvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5pbXBvcnQge3dpdGhpbkV4dGVudEFuZFp9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlcywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL1RpbGVFdmVudFR5cGVcIikuVGlsZVNvdXJjZUV2ZW50VHlwZXMsIFRpbGVTb3VyY2VFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgIGltcG9ydChcIi4vVGlsZUV2ZW50VHlwZVwiKS5UaWxlU291cmNlRXZlbnRUeXBlcywgUmV0dXJuPn0gVGlsZVNvdXJjZU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXSBEZXByZWNhdGVkLiAgVXNlIHRoZSBjYWNoZVNpemUgb3B0aW9uIG9uIHRoZSBsYXllciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb10gVGlsZVBpeGVsUmF0aW8uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX0gW3N0YXRlXSBTdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gW3RpbGVHcmlkXSBUaWxlR3JpZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPWZhbHNlXSBXcmFwWC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gVHJhbnNpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XSBLZXkuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFt6RGlyZWN0aW9uPTBdIFpEaXJlY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgaW1hZ2VzIGRpdmlkZWQgaW50byBhIHRpbGUgZ3JpZC5cbiAqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gW1RpbGVUeXBlPWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdF1cbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG5jbGFzcyBUaWxlU291cmNlIGV4dGVuZHMgU291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBTb3VyY2VUaWxlIHNvdXJjZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICBpbnRlcnBvbGF0ZTogb3B0aW9ucy5pbnRlcnBvbGF0ZSxcbiAgICB9KTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VGlsZVNvdXJjZU9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1RpbGVTb3VyY2VPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1RpbGVTb3VyY2VPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW9fID1cbiAgICAgIG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy50aWxlR3JpZCA9IG9wdGlvbnMudGlsZUdyaWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZUdyaWQgOiBudWxsO1xuXG4gICAgY29uc3QgdGlsZVNpemUgPSBbMjU2LCAyNTZdO1xuICAgIGlmICh0aGlzLnRpbGVHcmlkKSB7XG4gICAgICB0b1NpemUodGhpcy50aWxlR3JpZC5nZXRUaWxlU2l6ZSh0aGlzLnRpbGVHcmlkLmdldE1pblpvb20oKSksIHRpbGVTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFNpemUgPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5rZXlfID0gb3B0aW9ucy5rZXkgfHwgZ2V0VWlkKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLk9wdGlvbnN9XG4gICAgICovXG4gICAgdGhpcy50aWxlT3B0aW9ucyA9IHtcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB6RGlyZWN0aW9uIGhpbnQsIHJlYWQgYnkgdGhlIHJlbmRlcmVyLiBJbmRpY2F0ZXMgd2hpY2ggcmVzb2x1dGlvbiBzaG91bGQgYmUgdXNlZFxuICAgICAqIGJ5IGEgcmVuZGVyZXIgaWYgdGhlIHZpZXdzIHJlc29sdXRpb24gZG9lcyBub3QgbWF0Y2ggYW55IHJlc29sdXRpb24gb2YgdGhlIHRpbGUgc291cmNlLlxuICAgICAqIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAxLCB0aGUgbmVhcmVzdCBsb3dlciByZXNvbHV0aW9uXG4gICAgICogd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3QgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ8aW1wb3J0KFwiLi4vYXJyYXkuanNcIikuTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuekRpcmVjdGlvbiA9IG9wdGlvbnMuekRpcmVjdGlvbiA/IG9wdGlvbnMuekRpcmVjdGlvbiA6IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICovXG4gIGdldEd1dHRlckZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUga2V5IHRvIGJlIHVzZWQgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBrZXkgZm9yIGFsbCB0aWxlcy5cbiAgICovXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUga2V5IGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aWxlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0S2V5KGtleSkge1xuICAgIGlmICh0aGlzLmtleV8gIT09IGtleSkge1xuICAgICAgdGhpcy5rZXlfID0ga2V5O1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uXCIpLmRlZmF1bHR9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFJlc29sdXRpb25zLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFJlc29sdXRpb25zKHByb2plY3Rpb24pIHtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHByb2plY3Rpb25cbiAgICAgID8gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbilcbiAgICAgIDogdGhpcy50aWxlR3JpZDtcbiAgICBpZiAoIXRpbGVHcmlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGVHcmlkLmdldFJlc29sdXRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge1RpbGVUeXBlfG51bGx9IFRpbGUuXG4gICAqL1xuICBnZXRUaWxlKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRpbGUgZ3JpZCBvZiB0aGUgdGlsZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR8bnVsbH0gVGlsZSBncmlkLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlR3JpZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBUaWxlIGdyaWQuXG4gICAqL1xuICBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIGlmICghdGhpcy50aWxlR3JpZCkge1xuICAgICAgcmV0dXJuIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlsZUdyaWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIHBpeGVsIHJhdGlvIGZvciB0aGlzIHNvdXJjZS4gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuICAgKiBtZXRob2QsIHdoaWNoIGlzIG1lYW50IHRvIHJldHVybiBhIHN1cHBvcnRlZCBwaXhlbCByYXRpbyB0aGF0IG1hdGNoZXMgdGhlXG4gICAqIHByb3ZpZGVkIGBwaXhlbFJhdGlvYCBhcyBjbG9zZSBhcyBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwaXhlbCByYXRpby5cbiAgICovXG4gIGdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy50aWxlUGl4ZWxSYXRpb187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBUaWxlIHNpemUuXG4gICAqL1xuICBnZXRUaWxlUGl4ZWxTaXplKHosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aWxlR3JpZC5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplKTtcbiAgICBpZiAodGlsZVBpeGVsUmF0aW8gPT0gMSkge1xuICAgICAgcmV0dXJuIHRpbGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGVTaXplKHRpbGVTaXplLCB0aWxlUGl4ZWxSYXRpbywgdGhpcy50bXBTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGlsZSBjb29yZGluYXRlIHdyYXBwZWQgYXJvdW5kIHRoZSB4LWF4aXMuIFdoZW4gdGhlIHRpbGUgY29vcmRpbmF0ZVxuICAgKiBpcyBvdXRzaWRlIHRoZSByZXNvbHV0aW9uIGFuZCBleHRlbnQgcmFuZ2Ugb2YgdGhlIHRpbGUgZ3JpZCwgYG51bGxgIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZSB0byBiZSBwYXNzZWQgdG8gdGhlIHRpbGVVcmxGdW5jdGlvbiBvclxuICAgKiAgICAgbnVsbCBpZiBubyB0aWxlIFVSTCBzaG91bGQgYmUgY3JlYXRlZCBmb3IgdGhlIHBhc3NlZCBgdGlsZUNvb3JkYC5cbiAgICovXG4gIGdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIHByb2plY3Rpb24pIHtcbiAgICBjb25zdCBncmlkUHJvamVjdGlvbiA9XG4gICAgICBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPVxuICAgICAgcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24oZ3JpZFByb2plY3Rpb24pXG4gICAgICAgIDogdGhpcy50aWxlR3JpZCB8fCB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihncmlkUHJvamVjdGlvbik7XG4gICAgaWYgKHRoaXMuZ2V0V3JhcFgoKSAmJiBncmlkUHJvamVjdGlvbi5pc0dsb2JhbCgpKSB7XG4gICAgICB0aWxlQ29vcmQgPSB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBncmlkUHJvamVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpID8gdGlsZUNvb3JkIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGNhY2hlZCByZXByb2plY3RlZCB0aWxlcyBmcm9tIHRoZSBzb3VyY2UuIFRoZSBuZXh0IHJlbmRlciBjeWNsZSB3aWxsIGNyZWF0ZSBuZXcgdGlsZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsZWFyKCkge31cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBzdXBlci5yZWZyZXNoKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaWxlU291cmNlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaGUgdGlsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHRpbGUpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aWxlIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudGlsZSA9IHRpbGU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVNvdXJjZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIHN0YXJ0cyBsb2FkaW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FEU1RBUlQ6ICd0aWxlbG9hZHN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIGZpbmlzaGVzIGxvYWRpbmcsIGVpdGhlciB3aGVuIGl0cyBkYXRhIGlzIGxvYWRlZCxcbiAgICogb3Igd2hlbiBsb2FkaW5nIHdhcyBhYm9ydGVkIGJlY2F1c2UgdGhlIHRpbGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZS5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURFTkQ6ICd0aWxlbG9hZGVuZCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBpZiB0aWxlIGxvYWRpbmcgcmVzdWx0cyBpbiBhbiBlcnJvci4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IHRoZVxuICAgKiByaWdodCBwbGFjZSB0byByZS1mZXRjaCB0aWxlcy4gU2VlIHtAbGluayBtb2R1bGU6b2wvSW1hZ2VUaWxlfkltYWdlVGlsZSNsb2FkfVxuICAgKiBmb3IgZGV0YWlscy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZS5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRlcnJvclxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BREVSUk9SOiAndGlsZWxvYWRlcnJvcicsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHsndGlsZWxvYWRzdGFydCd8J3RpbGVsb2FkZW5kJ3wndGlsZWxvYWRlcnJvcid9IFRpbGVTb3VyY2VFdmVudFR5cGVzXG4gKi9cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUltYWdlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVXJsVGlsZSBmcm9tICcuL1VybFRpbGUuanMnO1xuaW1wb3J0IHtlcXVpdmFsZW50LCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2dldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gRGVwcmVjYXRlZC4gIFVzZSB0aGUgY2FjaGVTaXplIG9wdGlvbiBvbiB0aGUgbGF5ZXIgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9dHJ1ZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLiAgU2V0IHRvIGZhbHNlIHRvIHVzZSB0aGUgbmVhcmVzdCBuZWlnaGJvciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi4gRGVmYXVsdCBpcyB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGVdIFNvdXJjZSBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGltcG9ydChcIi4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSBbdGlsZUNsYXNzXSBDbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIGltYWdlIHRpbGVzLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL0ltYWdlVGlsZX5JbWFnZVRpbGV9LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuIEZvciBleGFtcGxlLCBpZiB0aGUgdGlsZVxuICogc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBhbmQgcHJvdmlkZSBhIGZ1bmN0aW9uXG4gKiBmb3IgdGhlIHVybCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLCBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLlxuICogQSBgez8tP31gIHRlbXBsYXRlIHBhdHRlcm4sIGZvciBleGFtcGxlIGBzdWJkb21haW57YS1mfS5kb21haW4uY29tYCwgbWF5IGJlXG4gKiB1c2VkIGluc3RlYWQgb2YgZGVmaW5pbmcgZWFjaCBvbmUgc2VwYXJhdGVseSBpbiB0aGUgYHVybHNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIEFuIGFycmF5IG9mIFVSTCB0ZW1wbGF0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWF0gV2hldGhlciB0byB3cmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuIFRoZSBkZWZhdWx0LCBpcyB0b1xuICogcmVxdWVzdCBvdXQtb2YtYm91bmRzIHRpbGVzIGZyb20gdGhlIHNlcnZlci4gV2hlbiBzZXQgdG8gYGZhbHNlYCwgb25seSBvbmVcbiAqIHdvcmxkIHdpbGwgYmUgcmVuZGVyZWQuIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGlsZXMgd2lsbCBiZSByZXF1ZXN0ZWQgZm9yIG9uZVxuICogd29ybGQgb25seSwgYnV0IHRoZXkgd2lsbCBiZSB3cmFwcGVkIGhvcml6b250YWxseSB0byByZW5kZXIgbXVsdGlwbGUgd29ybGRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBEdXJhdGlvbiBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uIGZvciByZW5kZXJpbmcuXG4gKiBUbyBkaXNhYmxlIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24sIHBhc3MgYHRyYW5zaXRpb246IDBgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldIE9wdGlvbmFsIHRpbGUga2V5IGZvciBwcm9wZXIgY2FjaGUgZmV0Y2hpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF1cbiAqIENob29zZSB3aGV0aGVyIHRvIHVzZSB0aWxlcyB3aXRoIGEgaGlnaGVyIG9yIGxvd2VyIHpvb20gbGV2ZWwgd2hlbiBiZXR3ZWVuIGludGVnZXJcbiAqIHpvb20gbGV2ZWxzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5UaWxlR3JpZCNnZXRaRm9yUmVzb2x1dGlvbn0uXG4gKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIG9sL3NvdXJjZS9JbWFnZVRpbGUuanMgaW5zdGVhZC5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9UaWxlLmpzXCIpLlRpbGVTb3VyY2VFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBUaWxlSW1hZ2UgZXh0ZW5kcyBVcmxUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9wdGlvbnN9IG9wdGlvbnMgSW1hZ2UgdGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB0aWxlR3JpZDogb3B0aW9ucy50aWxlR3JpZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvblxuICAgICAgICA/IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvblxuICAgICAgICA6IGRlZmF1bHRUaWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB0aWxlVXJsRnVuY3Rpb246IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgaW50ZXJwb2xhdGU6XG4gICAgICAgIG9wdGlvbnMuaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGUgOiB0cnVlLFxuICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgekRpcmVjdGlvbjogb3B0aW9ucy56RGlyZWN0aW9uLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPVxuICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc09yaWdpbiA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge3R5cGVvZiBJbWFnZVRpbGV9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2xhc3MgPVxuICAgICAgb3B0aW9ucy50aWxlQ2xhc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZUNsYXNzIDogSW1hZ2VUaWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZF8gPSBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0R3V0dGVyRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiZcbiAgICAgIHByb2plY3Rpb24gJiZcbiAgICAgICFlcXVpdmFsZW50KHRoaXMuZ2V0UHJvamVjdGlvbigpLCBwcm9qZWN0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEd1dHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgZ2V0R3V0dGVyKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUga2V5IHRvIGJlIHVzZWQgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBrZXkgZm9yIGFsbCB0aWxlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgbGV0IGtleSA9IHN1cGVyLmdldEtleSgpO1xuICAgIGlmICghdGhpcy5nZXRJbnRlcnBvbGF0ZSgpKSB7XG4gICAgICBrZXkgKz0gJzpkaXNhYmxlLWludGVycG9sYXRpb24nO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHRoaXMudGlsZUdyaWQgJiYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICAgIH1cbiAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pO1xuICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24pKSB7XG4gICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9XG4gICAgICAgIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uW3Byb2pLZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBzZXQgb24gdGhlIHRpbGUuXG4gICAqIEByZXR1cm4geyFJbWFnZVRpbGV9IFRpbGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpIHtcbiAgICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgY29uc3QgdXJsVGlsZUNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24oXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICBwcm9qZWN0aW9uLFxuICAgICk7XG4gICAgY29uc3QgdGlsZVVybCA9IHVybFRpbGVDb29yZFxuICAgICAgPyB0aGlzLnRpbGVVcmxGdW5jdGlvbih1cmxUaWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB0aWxlID0gbmV3IHRoaXMudGlsZUNsYXNzKFxuICAgICAgdGlsZUNvb3JkLFxuICAgICAgdGlsZVVybCAhPT0gdW5kZWZpbmVkID8gVGlsZVN0YXRlLklETEUgOiBUaWxlU3RhdGUuRU1QVFksXG4gICAgICB0aWxlVXJsICE9PSB1bmRlZmluZWQgPyB0aWxlVXJsIDogJycsXG4gICAgICB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGhpcy50aWxlT3B0aW9ucyxcbiAgICApO1xuICAgIHRpbGUua2V5ID0ga2V5O1xuICAgIHRpbGUuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IShJbWFnZVRpbGV8UmVwcm9qVGlsZSl9IFRpbGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGlmIChcbiAgICAgICFzb3VyY2VQcm9qZWN0aW9uIHx8XG4gICAgICAhcHJvamVjdGlvbiB8fFxuICAgICAgZXF1aXZhbGVudChzb3VyY2VQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUludGVybmFsKFxuICAgICAgICB6LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwaXhlbFJhdGlvLFxuICAgICAgICBzb3VyY2VQcm9qZWN0aW9uIHx8IHByb2plY3Rpb24sXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICBjb25zdCBzb3VyY2VUaWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHNvdXJjZVByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRhcmdldFRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgY29uc3Qgd3JhcHBlZFRpbGVDb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uKFxuICAgICAgdGlsZUNvb3JkLFxuICAgICAgcHJvamVjdGlvbixcbiAgICApO1xuICAgIGNvbnN0IHRpbGUgPSBuZXcgUmVwcm9qVGlsZShcbiAgICAgIHNvdXJjZVByb2plY3Rpb24sXG4gICAgICBzb3VyY2VUaWxlR3JpZCxcbiAgICAgIHByb2plY3Rpb24sXG4gICAgICB0YXJnZXRUaWxlR3JpZCxcbiAgICAgIHRpbGVDb29yZCxcbiAgICAgIHdyYXBwZWRUaWxlQ29vcmQsXG4gICAgICB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pLFxuICAgICAgdGhpcy5nZXRHdXR0ZXIoKSxcbiAgICAgICh6LCB4LCB5LCBwaXhlbFJhdGlvKSA9PlxuICAgICAgICB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uKSxcbiAgICAgIHRoaXMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfLFxuICAgICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18sXG4gICAgICB0aGlzLnRpbGVPcHRpb25zLFxuICAgICk7XG4gICAgdGlsZS5rZXkgPSBrZXk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFJbWFnZVRpbGV9IFRpbGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byByZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzIG9yIG5vdCAodXN1YWxseSBmb3IgZGVidWdnaW5nKS5cbiAgICogQHBhcmFtIHtib29sZWFufSByZW5kZXIgUmVuZGVyIHRoZSBlZGdlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVuZGVyUmVwcm9qZWN0aW9uRWRnZXMocmVuZGVyKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID09IHJlbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IHJlbmRlcjtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aWxlIGdyaWQgdG8gdXNlIHdoZW4gcmVwcm9qZWN0aW5nIHRoZSB0aWxlcyB0byB0aGUgZ2l2ZW5cbiAgICogcHJvamVjdGlvbiBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IHRpbGUgZ3JpZCBmb3IgdGhlIHByb2plY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSBkZWZhdWx0IHRpbGUgZ3JpZCBjYW5ub3QgYmUgY3JlYXRlZFxuICAgKiAoZS5nLiBwcm9qZWN0aW9uIGhhcyBubyBleHRlbnQgZGVmaW5lZCkgb3JcbiAgICogZm9yIG9wdGltaXphdGlvbiByZWFzb25zIChjdXN0b20gdGlsZSBzaXplLCByZXNvbHV0aW9ucywgLi4uKS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZWdyaWQgVGlsZSBncmlkIHRvIHVzZSBmb3IgdGhlIHByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uLCB0aWxlZ3JpZCkge1xuICAgIGNvbnN0IHByb2ogPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmIChwcm9qKSB7XG4gICAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2opO1xuICAgICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbikpIHtcbiAgICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPSB0aWxlZ3JpZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlVGlsZX0gaW1hZ2VUaWxlIEltYWdlIHRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChpbWFnZVRpbGUuZ2V0SW1hZ2UoKSkuc3JjID1cbiAgICBzcmM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVJbWFnZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVXJsVGlsZVxuICovXG5pbXBvcnQgVGlsZUV2ZW50VHlwZSBmcm9tICcuL1RpbGVFdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVTb3VyY2UsIHtUaWxlU291cmNlRXZlbnR9IGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUZyb21UZW1wbGF0ZXN9IGZyb20gJy4uL3RpbGV1cmxmdW5jdGlvbi5qcyc7XG5pbXBvcnQge2V4cGFuZFVybH0gZnJvbSAnLi4vdXJpLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXSBEZXByZWNhdGVkLiAgVXNlIHRoZSBjYWNoZVNpemUgb3B0aW9uIG9uIHRoZSBsYXllciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IFtzdGF0ZV0gU3RhdGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFt0aWxlR3JpZF0gVGlsZUdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGVMb2FkRnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXSBUaWxlUGl4ZWxSYXRpby5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGFuZCBwcm92aWRlIGEgZnVuY3Rpb25cbiAqIGZvciB0aGUgdXJsIG9wdGlvbiBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVybC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIFVybHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwWC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gVHJhbnNpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XSBLZXkuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFt6RGlyZWN0aW9uPTBdIFpEaXJlY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBvbC9zb3VyY2UvSW1hZ2VUaWxlLmpzIGluc3RlYWQuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vVGlsZS5qc1wiKS5UaWxlU291cmNlRXZlbnRcbiAqL1xuY2xhc3MgVXJsVGlsZSBleHRlbmRzIFRpbGVTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEltYWdlIHRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgdGlsZUdyaWQ6IG9wdGlvbnMudGlsZUdyaWQsXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUsXG4gICAgICB6RGlyZWN0aW9uOiBvcHRpb25zLnpEaXJlY3Rpb24sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2VuZXJhdGVUaWxlVXJsRnVuY3Rpb25fID1cbiAgICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID09PSBVcmxUaWxlLnByb3RvdHlwZS50aWxlVXJsRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbjtcblxuICAgIGlmIChvcHRpb25zLnRpbGVVcmxGdW5jdGlvbikge1xuICAgICAgdGhpcy50aWxlVXJsRnVuY3Rpb24gPSBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy51cmxzID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLnVybHMpIHtcbiAgICAgIHRoaXMuc2V0VXJscyhvcHRpb25zLnVybHMpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgIHRoaXMuc2V0VXJsKG9wdGlvbnMudXJsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZGluZ0tleXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGluc3RlYWQuXG4gICAqIFJldHVybiB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBUaWxlTG9hZEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVMb2FkRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUxvYWRGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiAgVXNlIGFuIEltYWdlVGlsZSBzb3VyY2UgaW5zdGVhZC5cbiAgICogUmV0dXJuIHRoZSB0aWxlIFVSTCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlVXJsRnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZVVybEZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykudGlsZVVybEZ1bmN0aW9uID09PSB0aGlzLnRpbGVVcmxGdW5jdGlvblxuICAgICAgPyB0aGlzLnRpbGVVcmxGdW5jdGlvbi5iaW5kKHRoaXMpXG4gICAgICA6IHRoaXMudGlsZVVybEZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBpbnN0ZWFkLlxuICAgKiBSZXR1cm4gdGhlIFVSTHMgdXNlZCBmb3IgdGhpcyBzb3VyY2UuXG4gICAqIFdoZW4gYSB0aWxlVXJsRnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIHVybCBvciB1cmxzLFxuICAgKiBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fG51bGx9IFVSTHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJscztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGlsZSBjaGFuZ2UgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlVGlsZUNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgY29uc3QgdWlkID0gZ2V0VWlkKHRpbGUpO1xuICAgIGNvbnN0IHRpbGVTdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgdHlwZTtcbiAgICBpZiAodGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXSA9IHRydWU7XG4gICAgICB0eXBlID0gVGlsZUV2ZW50VHlwZS5USUxFTE9BRFNUQVJUO1xuICAgIH0gZWxzZSBpZiAodWlkIGluIHRoaXMudGlsZUxvYWRpbmdLZXlzXykge1xuICAgICAgZGVsZXRlIHRoaXMudGlsZUxvYWRpbmdLZXlzX1t1aWRdO1xuICAgICAgdHlwZSA9XG4gICAgICAgIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1JcbiAgICAgICAgICA/IFRpbGVFdmVudFR5cGUuVElMRUxPQURFUlJPUlxuICAgICAgICAgIDogdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FERURcbiAgICAgICAgICAgID8gVGlsZUV2ZW50VHlwZS5USUxFTE9BREVORFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUaWxlU291cmNlRXZlbnQodHlwZSwgdGlsZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiAgVXNlIGFuIEltYWdlVGlsZSBzb3VyY2UgaW5zdGVhZC5cbiAgICogU2V0IHRoZSB0aWxlIGxvYWQgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlIGxvYWQgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVMb2FkRnVuY3Rpb24odGlsZUxvYWRGdW5jdGlvbikge1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IHRpbGVMb2FkRnVuY3Rpb247XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGluc3RlYWQuXG4gICAqIFNldCB0aGUgdGlsZSBVUkwgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSB0aWxlVXJsRnVuY3Rpb24gVGlsZSBVUkwgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBPcHRpb25hbCBuZXcgdGlsZSBrZXkgZm9yIHRoZSBzb3VyY2UuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVVcmxGdW5jdGlvbih0aWxlVXJsRnVuY3Rpb24sIGtleSkge1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGlsZVVybEZ1bmN0aW9uO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zZXRLZXkoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRVcmwodXJsKSB7XG4gICAgY29uc3QgdXJscyA9IGV4cGFuZFVybCh1cmwpO1xuICAgIHRoaXMudXJscyA9IHVybHM7XG4gICAgdGhpcy5zZXRVcmxzKHVybHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBpbnN0ZWFkLlxuICAgKiBTZXQgdGhlIFVSTHMgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzIFVSTHMuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFVybHModXJscykge1xuICAgIHRoaXMudXJscyA9IHVybHM7XG4gICAgY29uc3Qga2V5ID0gdXJscy5qb2luKCdcXG4nKTtcbiAgICBpZiAodGhpcy5nZW5lcmF0ZVRpbGVVcmxGdW5jdGlvbl8pIHtcbiAgICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKGNyZWF0ZUZyb21UZW1wbGF0ZXModXJscywgdGhpcy50aWxlR3JpZCksIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0S2V5KGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAqL1xuICB0aWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVcmxUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9YWVpcbiAqL1xuXG5pbXBvcnQgVGlsZUltYWdlIGZyb20gJy4vVGlsZUltYWdlLmpzJztcbmltcG9ydCB7Y3JlYXRlWFlaLCBleHRlbnRGcm9tUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdIERlcHJlY2F0ZWQuICBVc2UgdGhlIGNhY2hlU2l6ZSBvcHRpb24gb24gdGhlIGxheWVyIGluc3RlYWQuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPXRydWVdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy4gIFNldCB0byBmYWxzZSB0byB1c2UgdGhlIG5lYXJlc3QgbmVpZ2hib3IgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkPTAuNV0gTWF4aW11bSBhbGxvd2VkIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcGl4ZWxzKS5cbiAqIEhpZ2hlciB2YWx1ZXMgY2FuIGluY3JlYXNlIHJlcHJvamVjdGlvbiBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT00Ml0gT3B0aW9uYWwgbWF4IHpvb20gbGV2ZWwuIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gT3B0aW9uYWwgbWluIHpvb20gbGV2ZWwuIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIE9wdGlvbmFsIHRpbGUgZ3JpZCByZXNvbHV0aW9uIGF0IGxldmVsIHplcm8uIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFt0aWxlR3JpZF0gVGlsZSBncmlkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSB3aXRoIGEgbG9hZGVyXG4gKiBpbnN0ZWFkLiAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpbz0xXSBUaGUgcGl4ZWwgcmF0aW8gdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSB0aWxlIHNlcnZpY2UgYWR2ZXJ0aXplcyAyNTZweCBieSAyNTZweCB0aWxlcyBidXQgYWN0dWFsbHkgc2VuZHMgNTEycHhcbiAqIGJ5IDUxMnB4IGltYWdlcyAoZm9yIHJldGluYS9oaWRwaSBkZXZpY2VzKSB0aGVuIGB0aWxlUGl4ZWxSYXRpb2BcbiAqIHNob3VsZCBiZSBzZXQgdG8gYDJgLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGhlIHRpbGUgc2l6ZSB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuXG4gKiBOb3QgdXNlZCBpZiBgdGlsZUdyaWRgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtndXR0ZXI9MF0gVGhlIHNpemUgaW4gcGl4ZWxzIG9mIHRoZSBndXR0ZXIgYXJvdW5kIGltYWdlIHRpbGVzIHRvIGlnbm9yZS5cbiAqIFRoaXMgYWxsb3dzIGFydGlmYWN0cyBvZiByZW5kZXJpbmcgYXQgdGlsZSBlZGdlcyB0byBiZSBpZ25vcmVkLlxuICogU3VwcG9ydGVkIGltYWdlcyBzaG91bGQgYmUgd2lkZXIgYW5kIHRhbGxlciB0aGFuIHRoZSB0aWxlIHNpemUgYnkgYSB2YWx1ZSBvZiBgMiB4IGd1dHRlcmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBhbmQgcHJvdmlkZSBhIGZ1bmN0aW9uXG4gKiBmb3IgdGhlIHVybCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLFxuICogYW5kIGB7en1gIHBsYWNlaG9sZGVycy4gQSBgez8tP31gIHRlbXBsYXRlIHBhdHRlcm4sIGZvciBleGFtcGxlIGBzdWJkb21haW57YS1mfS5kb21haW4uY29tYCxcbiAqIG1heSBiZSB1c2VkIGluc3RlYWQgb2YgZGVmaW5pbmcgZWFjaCBvbmUgc2VwYXJhdGVseSBpbiB0aGUgYHVybHNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBhbmQgcHJvdmlkZSBhbiBhcnJheSBvZiBVUkxzIGZvciB0aGVcbiAqIHVybCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF1cbiAqIENob29zZSB3aGV0aGVyIHRvIHVzZSB0aWxlcyB3aXRoIGEgaGlnaGVyIG9yIGxvd2VyIHpvb20gbGV2ZWwgd2hlbiBiZXR3ZWVuIGludGVnZXJcbiAqIHpvb20gbGV2ZWxzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5UaWxlR3JpZCNnZXRaRm9yUmVzb2x1dGlvbn0uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRpbGUgZGF0YSB3aXRoIFVSTHMgaW4gYSBzZXQgWFlaIGZvcm1hdCB0aGF0IGFyZVxuICogZGVmaW5lZCBpbiBhIFVSTCB0ZW1wbGF0ZS4gQnkgZGVmYXVsdCwgdGhpcyBmb2xsb3dzIHRoZSB3aWRlbHktdXNlZFxuICogR29vZ2xlIGdyaWQgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgdG9wIGxlZnQuIEdyaWRzIGxpa2VcbiAqIFRNUyB3aGVyZSBgeGAgMCBhbmQgYHlgIDAgYXJlIGluIHRoZSBib3R0b20gbGVmdCBjYW4gYmUgdXNlZCBieVxuICogdXNpbmcgdGhlIGB7LXl9YCBwbGFjZWhvbGRlciBpbiB0aGUgVVJMIHRlbXBsYXRlLCBzbyBsb25nIGFzIHRoZVxuICogc291cmNlIGRvZXMgbm90IGhhdmUgYSBjdXN0b20gdGlsZSBncmlkLiBJbiB0aGlzIGNhc2VcbiAqIGEgYHRpbGVVcmxGdW5jdGlvbmAgY2FuIGJlIHVzZWQsIHN1Y2ggYXM6XG4gKiBgYGBqc1xuICogIHRpbGVVcmxGdW5jdGlvbjogZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICogICAgcmV0dXJuICdodHRwOi8vbWFwc2VydmVyLmNvbS8nICsgY29vcmRpbmF0ZVswXSArICcvJyArXG4gKiAgICAgIGNvb3JkaW5hdGVbMV0gKyAnLycgKyAoLWNvb3JkaW5hdGVbMl0gLSAxKSArICcucG5nJztcbiAqICB9XG4gKiBgYGBcbiAqIEBhcGlcbiAqL1xuY2xhc3MgWFlaIGV4dGVuZHMgVGlsZUltYWdlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIFhZWiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgcHJvamVjdGlvbiA9XG4gICAgICBvcHRpb25zLnByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnO1xuXG4gICAgY29uc3QgdGlsZUdyaWQgPVxuICAgICAgb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy50aWxlR3JpZFxuICAgICAgICA6IGNyZWF0ZVhZWih7XG4gICAgICAgICAgICBleHRlbnQ6IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pLFxuICAgICAgICAgICAgbWF4UmVzb2x1dGlvbjogb3B0aW9ucy5tYXhSZXNvbHV0aW9uLFxuICAgICAgICAgICAgbWF4Wm9vbTogb3B0aW9ucy5tYXhab29tLFxuICAgICAgICAgICAgbWluWm9vbTogb3B0aW9ucy5taW5ab29tLFxuICAgICAgICAgICAgdGlsZVNpemU6IG9wdGlvbnMudGlsZVNpemUsXG4gICAgICAgICAgfSk7XG5cbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxuICAgICAgcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ6IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQsXG4gICAgICB0aWxlR3JpZDogdGlsZUdyaWQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHRpbGVVcmxGdW5jdGlvbjogb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgdXJsczogb3B0aW9ucy51cmxzLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUsXG4gICAgICB6RGlyZWN0aW9uOiBvcHRpb25zLnpEaXJlY3Rpb24sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ndXR0ZXJfID0gb3B0aW9ucy5ndXR0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ3V0dGVyIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRHdXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3V0dGVyXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBYWVo7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3BoZXJlXG4gKi9cbmltcG9ydCB7dG9EZWdyZWVzLCB0b1JhZGlhbnN9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBvcHRpb25zIGZvciB0aGUge0BsaW5rIGdldExlbmd0aH0gb3Ige0BsaW5rIGdldEFyZWF9XG4gKiBmdW5jdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcGhlcmVNZXRyaWNPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddXG4gKiBQcm9qZWN0aW9uIG9mIHRoZSAgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgaXMgYXNzdW1lZCB0byBiZSBpblxuICogV2ViIE1lcmNhdG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXM9NjM3MTAwOC44XSBTcGhlcmUgcmFkaXVzLiAgQnkgZGVmYXVsdCwgdGhlXG4gKiBbbWVhbiBFYXJ0aCByYWRpdXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VhcnRoX3JhZGl1cyNNZWFuX3JhZGl1cylcbiAqIGZvciB0aGUgV0dTODQgZWxsaXBzb2lkIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgbWVhbiBFYXJ0aCByYWRpdXMgKDEvMyAqICgyYSArIGIpKSBmb3IgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VhcnRoX3JhZGl1cyNNZWFuX3JhZGl1c1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkFESVVTID0gNjM3MTAwOC44O1xuXG4vKipcbiAqIEdldCB0aGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIChpbiBtZXRlcnMpIGJldHdlZW4gdHdvIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBjMSBTdGFydGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheX0gYzIgRW5kaW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1c10gVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGMxLCBjMiwgcmFkaXVzKSB7XG4gIHJhZGl1cyA9IHJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIGNvbnN0IGxhdDIgPSB0b1JhZGlhbnMoYzJbMV0pO1xuICBjb25zdCBkZWx0YUxhdEJ5MiA9IChsYXQyIC0gbGF0MSkgLyAyO1xuICBjb25zdCBkZWx0YUxvbkJ5MiA9IHRvUmFkaWFucyhjMlswXSAtIGMxWzBdKSAvIDI7XG4gIGNvbnN0IGEgPVxuICAgIE1hdGguc2luKGRlbHRhTGF0QnkyKSAqIE1hdGguc2luKGRlbHRhTGF0QnkyKSArXG4gICAgTWF0aC5zaW4oZGVsdGFMb25CeTIpICpcbiAgICAgIE1hdGguc2luKGRlbHRhTG9uQnkyKSAqXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqXG4gICAgICBNYXRoLmNvcyhsYXQyKTtcbiAgcmV0dXJuIDIgKiByYWRpdXMgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdW11bGF0aXZlIGdyZWF0IGNpcmNsZSBsZW5ndGggb2YgbGluZXN0cmluZyBjb29yZGluYXRlcyAoZ2VvZ3JhcGhpYykuXG4gKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBMaW5lc3RyaW5nIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggKGluIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpIC0gMTsgKytpKSB7XG4gICAgbGVuZ3RoICs9IGdldERpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tpICsgMV0sIHJhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwaGVyaWNhbCBsZW5ndGggb2YgYSBnZW9tZXRyeS4gIFRoaXMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlXG4gKiBncmVhdCBjaXJjbGUgZGlzdGFuY2VzIGJldHdlZW4gY29vcmRpbmF0ZXMuICBGb3IgcG9seWdvbnMsIHRoZSBsZW5ndGggaXNcbiAqIHRoZSBzdW0gb2YgYWxsIHJpbmdzLiAgRm9yIHBvaW50cywgdGhlIGxlbmd0aCBpcyB6ZXJvLiAgRm9yIG11bHRpLXBhcnRcbiAqIGdlb21ldHJpZXMsIHRoZSBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgbGVuZ3RoIG9mIGVhY2ggcGFydC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEEgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1NwaGVyZU1ldHJpY09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGVcbiAqIGxlbmd0aCBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiB8fCAnRVBTRzozODU3JztcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50Jzoge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ0xpbmVhclJpbmcnOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGxlbmd0aCA9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBjb29yZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID1cbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICApLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGgoZ2VvbWV0cmllc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3BoZXJpY2FsIGFyZWEgZm9yIGEgbGlzdCBvZiBjb29yZGluYXRlcy5cbiAqXG4gKiBbUmVmZXJlbmNlXShodHRwczovL3Rycy5qcGwubmFzYS5nb3YvaGFuZGxlLzIwMTQvNDA0MDkpXG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3XG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIExpc3Qgb2YgY29vcmRpbmF0ZXMgb2YgYSBsaW5lYXJcbiAqIHJpbmcuIElmIHRoZSByaW5nIGlzIG9yaWVudGVkIGNsb2Nrd2lzZSwgdGhlIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSxcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cy5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgY29uc3QgbGVuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICBsZXQgeDEgPSBjb29yZGluYXRlc1tsZW4gLSAxXVswXTtcbiAgbGV0IHkxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCB4MiA9IGNvb3JkaW5hdGVzW2ldWzBdO1xuICAgIGNvbnN0IHkyID0gY29vcmRpbmF0ZXNbaV1bMV07XG4gICAgYXJlYSArPVxuICAgICAgdG9SYWRpYW5zKHgyIC0geDEpICpcbiAgICAgICgyICsgTWF0aC5zaW4odG9SYWRpYW5zKHkxKSkgKyBNYXRoLnNpbih0b1JhZGlhbnMoeTIpKSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiAoYXJlYSAqIHJhZGl1cyAqIHJhZGl1cykgLyAyLjA7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgYXJlYSBvZiBhIGdlb21ldHJ5LiAgVGhpcyBpcyB0aGUgYXJlYSAoaW4gbWV0ZXJzKSBhc3N1bWluZ1xuICogdGhhdCBwb2x5Z29uIGVkZ2VzIGFyZSBzZWdtZW50cyBvZiBncmVhdCBjaXJjbGVzIG9uIGEgc3BoZXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7U3BoZXJlTWV0cmljT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBhcmVhXG4gKiAgICAgY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogICAgIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBhcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ0xpbmVhclJpbmcnOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBhcmVhID0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzWzBdLCByYWRpdXMpKTtcbiAgICAgIGZvciAoaSA9IDEsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1swXSwgcmFkaXVzKSk7XG4gICAgICAgIGZvciAoaiA9IDEsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzoge1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgKS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhICs9IGdldEFyZWEoZ2VvbWV0cmllc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgdGhlIGdpdmVuIGRpc3RhbmNlIGFuZCBiZWFyaW5nIGZyb20gYGMxYC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjMSBUaGUgb3JpZ2luIHBvaW50IChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvcmlnaW5cbiAqICAgICBwb2ludCBhbmQgdGhlIHRhcmdldCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBiZWFyaW5nIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzXSBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIHRhcmdldCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjMSwgZGlzdGFuY2UsIGJlYXJpbmcsIHJhZGl1cykge1xuICByYWRpdXMgPSByYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIGNvbnN0IGxhdDEgPSB0b1JhZGlhbnMoYzFbMV0pO1xuICBjb25zdCBsb24xID0gdG9SYWRpYW5zKGMxWzBdKTtcbiAgY29uc3QgZEJ5UiA9IGRpc3RhbmNlIC8gcmFkaXVzO1xuICBjb25zdCBsYXQgPSBNYXRoLmFzaW4oXG4gICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhkQnlSKSArXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGRCeVIpICogTWF0aC5jb3MoYmVhcmluZyksXG4gICk7XG4gIGNvbnN0IGxvbiA9XG4gICAgbG9uMSArXG4gICAgTWF0aC5hdGFuMihcbiAgICAgIE1hdGguc2luKGJlYXJpbmcpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhsYXQxKSxcbiAgICAgIE1hdGguY29zKGRCeVIpIC0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQpLFxuICAgICk7XG4gIHJldHVybiBbdG9EZWdyZWVzKGxvbiksIHRvRGVncmVlcyhsYXQpXTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJpbmdcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgTnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbl0gUHJlY2lzaW9uIG9mIHRoZSBvdXRwdXQgc3RyaW5nIChpLmUuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcylcbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTnVtYmVyKG51bWJlciwgd2lkdGgsIHByZWNpc2lvbikge1xuICBjb25zdCBudW1iZXJTdHJpbmcgPVxuICAgIHByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gbnVtYmVyLnRvRml4ZWQocHJlY2lzaW9uKSA6ICcnICsgbnVtYmVyO1xuICBsZXQgZGVjaW1hbCA9IG51bWJlclN0cmluZy5pbmRleE9mKCcuJyk7XG4gIGRlY2ltYWwgPSBkZWNpbWFsID09PSAtMSA/IG51bWJlclN0cmluZy5sZW5ndGggOiBkZWNpbWFsO1xuICByZXR1cm4gZGVjaW1hbCA+IHdpZHRoXG4gICAgPyBudW1iZXJTdHJpbmdcbiAgICA6IG5ldyBBcnJheSgxICsgd2lkdGggLSBkZWNpbWFsKS5qb2luKCcwJykgKyBudW1iZXJTdHJpbmc7XG59XG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vbWljaGVsc2VuL2NvbXBhcmUtdmVyc2lvbnMvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdjEgRmlyc3QgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2MiBTZWNvbmQgdmVyc2lvblxuICogQHJldHVybiB7bnVtYmVyfSBWYWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKHYxLCB2Mikge1xuICBjb25zdCBzMSA9ICgnJyArIHYxKS5zcGxpdCgnLicpO1xuICBjb25zdCBzMiA9ICgnJyArIHYyKS5zcGxpdCgnLicpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgoczEubGVuZ3RoLCBzMi5sZW5ndGgpOyBpKyspIHtcbiAgICBjb25zdCBuMSA9IHBhcnNlSW50KHMxW2ldIHx8ICcwJywgMTApO1xuICAgIGNvbnN0IG4yID0gcGFyc2VJbnQoczJbaV0gfHwgJzAnLCAxMCk7XG5cbiAgICBpZiAobjEgPiBuMikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChuMiA+IG4xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9MUlVDYWNoZVxuICovXG5cbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5XyBLZXkuXG4gKiBAcHJvcGVydHkge0VudHJ5fG51bGx9IG5ld2VyIE5ld2VyLlxuICogQHByb3BlcnR5IHtFbnRyeXxudWxsfSBvbGRlciBPbGRlci5cbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfIFZhbHVlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50cyBhIExlYXN0LVJlY2VudGx5LVVzZWQgY2FjaGUgd2hlcmUgdGhlIGtleXMgZG8gbm90IGNvbmZsaWN0IHdpdGhcbiAqIE9iamVjdCdzIHByb3BlcnRpZXMgKGUuZy4gJ2hhc093blByb3BlcnR5JyBpcyBub3QgYWxsb3dlZCBhcyBhIGtleSkuIEV4cGlyaW5nXG4gKiBpdGVtcyBmcm9tIHRoZSBjYWNoZSBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHVzZXIuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hpZ2hXYXRlck1hcmtdIEhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhpZ2hXYXRlck1hcmspIHtcbiAgICAvKipcbiAgICAgKiBEZXNpcmVkIG1heCBjYWNoZSBzaXplIGFmdGVyIGV4cGlyZUNhY2hlKCkuIElmIHNldCB0byAwLCBubyBjYWNoZSBlbnRyaWVzXG4gICAgICogd2lsbCBiZSBwcnVuZWQgYXQgYWxsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gaGlnaFdhdGVyTWFyayA6IDIwNDg7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb3VudF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEVudHJ5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmVudHJpZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RW50cnl9XG4gICAgICovXG4gICAgdGhpcy5vbGRlc3RfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICB9XG5cbiAgZGVsZXRlT2xkZXN0KCkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5wb3AoKTtcbiAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBEaXNwb3NhYmxlKSB7XG4gICAgICBlbnRyeS5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBjYW5FeHBpcmVDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoV2F0ZXJNYXJrID4gMCAmJiB0aGlzLmdldENvdW50KCkgPiB0aGlzLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogRXhwaXJlIHRoZSBjYWNoZS4gV2hlbiB0aGUgY2FjaGUgZW50cnkgaXMgYSB7QGxpbmsgbW9kdWxlOm9sL0Rpc3Bvc2FibGV+RGlzcG9zYWJsZX0sXG4gICAqIHRoZSBlbnRyeSB3aWxsIGJlIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gW2tlZXBdIEtleXMgdG8ga2VlcC4gVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlcy5cbiAgICovXG4gIGV4cGlyZUNhY2hlKGtlZXApIHtcbiAgICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICB0aGlzLmRlbGV0ZU9sZGVzdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHdoaWxlICh0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMuZGVsZXRlT2xkZXN0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBrZXkuXG4gICAqL1xuICBjb250YWluc0tleShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzXy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCwgc3RyaW5nLCBMUlVDYWNoZTxUPik6ID99IGYgVGhlIGZ1bmN0aW9uXG4gICAqICAgICB0byBjYWxsIGZvciBldmVyeSBlbnRyeSBmcm9tIHRoZSBvbGRlc3QgdG8gdGhlIG5ld2VyLiBUaGlzIGZ1bmN0aW9uIHRha2VzXG4gICAqICAgICAzIGFyZ3VtZW50cyAodGhlIGVudHJ5IHZhbHVlLCB0aGUgZW50cnkga2V5IGFuZCB0aGUgTFJVQ2FjaGUgb2JqZWN0KS5cbiAgICogICAgIFRoZSByZXR1cm4gdmFsdWUgaXMgaWdub3JlZC5cbiAgICovXG4gIGZvckVhY2goZikge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub2xkZXN0XztcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGYoZW50cnkudmFsdWVfLCBlbnRyeS5rZXlfLCB0aGlzKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPcHRpb25zIChyZXNlcnZlZCBmb3Igc3ViY2xhc3NlcykuXG4gICAqIEByZXR1cm4ge1R9IFZhbHVlLlxuICAgKi9cbiAgZ2V0KGtleSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChcbiAgICAgIGVudHJ5ICE9PSB1bmRlZmluZWQsXG4gICAgICAnVHJpZWQgdG8gZ2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlJyxcbiAgICApO1xuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICAgIH1cbiAgICBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKHRoaXMub2xkZXN0Xy5uZXdlcik7XG4gICAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZW50cnkubmV3ZXIgPSBudWxsO1xuICAgIGVudHJ5Lm9sZGVyID0gdGhpcy5uZXdlc3RfO1xuICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBlbnRyeSBrZXkuXG4gICAqIEByZXR1cm4ge1R9IFRoZSByZW1vdmVkIGVudHJ5LlxuICAgKi9cbiAgcmVtb3ZlKGtleSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChcbiAgICAgIGVudHJ5ICE9PSB1bmRlZmluZWQsXG4gICAgICAnVHJpZWQgdG8gZ2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlJyxcbiAgICApO1xuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgICB0aGlzLm5ld2VzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkub2xkZXIpO1xuICAgICAgaWYgKHRoaXMubmV3ZXN0Xykge1xuICAgICAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKGVudHJ5Lm5ld2VyKTtcbiAgICAgIGlmICh0aGlzLm9sZGVzdF8pIHtcbiAgICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2tleV07XG4gICAgLS10aGlzLmNvdW50XztcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQ291bnQuXG4gICAqL1xuICBnZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gS2V5cy5cbiAgICovXG4gIGdldEtleXMoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBBcnJheSh0aGlzLmNvdW50Xyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBlbnRyeTtcbiAgICBmb3IgKGVudHJ5ID0gdGhpcy5uZXdlc3RfOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5vbGRlcikge1xuICAgICAga2V5c1tpKytdID0gZW50cnkua2V5XztcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8VD59IFZhbHVlcy5cbiAgICovXG4gIGdldFZhbHVlcygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZW50cnk7XG4gICAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICAgIHZhbHVlc1tpKytdID0gZW50cnkudmFsdWVfO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1R9IExhc3QgdmFsdWUuXG4gICAqL1xuICBwZWVrTGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vbGRlc3RfLnZhbHVlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IExhc3Qga2V5LlxuICAgKi9cbiAgcGVla0xhc3RLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMub2xkZXN0Xy5rZXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUga2V5IG9mIHRoZSBuZXdlc3QgaXRlbSBpbiB0aGUgY2FjaGUuICBUaHJvd3MgaWYgdGhlIGNhY2hlIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuZXdlc3Qga2V5LlxuICAgKi9cbiAgcGVla0ZpcnN0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLm5ld2VzdF8ua2V5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gZW50cnkgd2l0aG91dCB1cGRhdGluZyBsZWFzdCByZWNlbnRseSB1c2VkIHRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVmFsdWUuXG4gICAqL1xuICBwZWVrKGtleSkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXNfW2tleV0/LnZhbHVlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHBvcCgpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMub2xkZXN0XztcbiAgICBkZWxldGUgdGhpcy5lbnRyaWVzX1tlbnRyeS5rZXlfXTtcbiAgICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKGVudHJ5Lm5ld2VyKTtcbiAgICBpZiAoIXRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgICB9XG4gICAgLS10aGlzLmNvdW50XztcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgcmVwbGFjZShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5nZXQoa2V5KTsgLy8gdXBkYXRlIGBuZXdlc3RfYFxuICAgIHRoaXMuZW50cmllc19ba2V5XS52YWx1ZV8gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgIShrZXkgaW4gdGhpcy5lbnRyaWVzXyksXG4gICAgICAnVHJpZWQgdG8gc2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgaXMgdXNlZCBhbHJlYWR5JyxcbiAgICApO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAga2V5Xzoga2V5LFxuICAgICAgbmV3ZXI6IG51bGwsXG4gICAgICBvbGRlcjogdGhpcy5uZXdlc3RfLFxuICAgICAgdmFsdWVfOiB2YWx1ZSxcbiAgICB9O1xuICAgIGlmICghdGhpcy5uZXdlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSBlbnRyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHRoaXMuZW50cmllc19ba2V5XSA9IGVudHJ5O1xuICAgICsrdGhpcy5jb3VudF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBmb3IgdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBDYWNoZSBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTaXplKHNpemUpIHtcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBzaXplO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExSVUNhY2hlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBEUk9QID0gSW5maW5pdHk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJpb3JpdHkgcXVldWUuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGZyb20gdGhlIENsb3N1cmUgTGlicmFyeSdzIEhlYXAgY2xhc3MgYW5kXG4gKiBQeXRob24ncyBoZWFwcSBtb2R1bGUuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9zdHJ1Y3RzL2hlYXAuanNcbiAqIGFuZCBodHRwczovL2hnLnB5dGhvbi5vcmcvY3B5dGhvbi9maWxlLzIuNy9MaWIvaGVhcHEucHkuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiBudW1iZXJ9IHByaW9yaXR5RnVuY3Rpb24gUHJpb3JpdHkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6IHN0cmluZ30ga2V5RnVuY3Rpb24gS2V5IGZ1bmN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpb3JpdHlGdW5jdGlvbiwga2V5RnVuY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVCk6IG51bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucHJpb3JpdHlGdW5jdGlvbl8gPSBwcmlvcml0eUZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFQpOiBzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmtleUZ1bmN0aW9uXyA9IGtleUZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wcmlvcml0aWVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucXVldWVkRWxlbWVudHNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzXy5sZW5ndGggPSAwO1xuICAgIHRoaXMucHJpb3JpdGllc18ubGVuZ3RoID0gMDtcbiAgICBjbGVhcih0aGlzLnF1ZXVlZEVsZW1lbnRzXyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGhpZ2hlc3QtcHJpb3JpdHkgZWxlbWVudC4gTyhsb2cgTikuXG4gICAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgIHByaW9yaXRpZXMubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHNbMF0gPSAvKiogQHR5cGUge1R9ICovIChlbGVtZW50cy5wb3AoKSk7XG4gICAgICBwcmlvcml0aWVzWzBdID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwcmlvcml0aWVzLnBvcCgpKTtcbiAgICAgIHRoaXMuc2lmdFVwXygwKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudEtleSA9IHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZEVsZW1lbnRzX1tlbGVtZW50S2V5XTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGFuIGVsZW1lbnQuIE8obG9nIE4pLlxuICAgKiBAcGFyYW0ge1R9IGVsZW1lbnQgRWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICovXG4gIGVucXVldWUoZWxlbWVudCkge1xuICAgIGFzc2VydChcbiAgICAgICEodGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCkgaW4gdGhpcy5xdWV1ZWRFbGVtZW50c18pLFxuICAgICAgJ1RyaWVkIHRvIGVucXVldWUgYW4gYGVsZW1lbnRgIHRoYXQgd2FzIGFscmVhZHkgYWRkZWQgdG8gdGhlIHF1ZXVlJyxcbiAgICApO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gdGhpcy5wcmlvcml0eUZ1bmN0aW9uXyhlbGVtZW50KTtcbiAgICBpZiAocHJpb3JpdHkgIT0gRFJPUCkge1xuICAgICAgdGhpcy5lbGVtZW50c18ucHVzaChlbGVtZW50KTtcbiAgICAgIHRoaXMucHJpb3JpdGllc18ucHVzaChwcmlvcml0eSk7XG4gICAgICB0aGlzLnF1ZXVlZEVsZW1lbnRzX1t0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KV0gPSB0cnVlO1xuICAgICAgdGhpcy5zaWZ0RG93bl8oMCwgdGhpcy5lbGVtZW50c18ubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQ291bnQuXG4gICAqL1xuICBnZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c18ubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBsZWZ0IGNoaWxkIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXQgdGhlIGxlZnQgY2hpbGQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldExlZnRDaGlsZEluZGV4XyhpbmRleCkge1xuICAgIHJldHVybiBpbmRleCAqIDIgKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSByaWdodCBjaGlsZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSByaWdodCBjaGlsZCBmb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSByaWdodCBjaGlsZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFJpZ2h0Q2hpbGRJbmRleF8oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggKiAyICsgMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcGFyZW50IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBwYXJlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXJlbnRJbmRleF8oaW5kZXgpIHtcbiAgICByZXR1cm4gKGluZGV4IC0gMSkgPj4gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgYSBoZWFwLiBPKE4pLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGVhcGlmeV8oKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gKHRoaXMuZWxlbWVudHNfLmxlbmd0aCA+PiAxKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnNpZnRVcF8oaSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c18ubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBrZXkgcXVldWVkLlxuICAgKi9cbiAgaXNLZXlRdWV1ZWQoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB0aGlzLnF1ZXVlZEVsZW1lbnRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1R9IGVsZW1lbnQgRWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgcXVldWVkLlxuICAgKi9cbiAgaXNRdWV1ZWQoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmlzS2V5UXVldWVkKHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIG1vdmUgZG93bi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNpZnRVcF8oaW5kZXgpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICAgIGNvbnN0IHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICAgIGNvbnN0IGNvdW50ID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XG4gICAgY29uc3QgcHJpb3JpdHkgPSBwcmlvcml0aWVzW2luZGV4XTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXg7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBjb3VudCA+PiAxKSB7XG4gICAgICBjb25zdCBsSW5kZXggPSB0aGlzLmdldExlZnRDaGlsZEluZGV4XyhpbmRleCk7XG4gICAgICBjb25zdCBySW5kZXggPSB0aGlzLmdldFJpZ2h0Q2hpbGRJbmRleF8oaW5kZXgpO1xuXG4gICAgICBjb25zdCBzbWFsbGVyQ2hpbGRJbmRleCA9XG4gICAgICAgIHJJbmRleCA8IGNvdW50ICYmIHByaW9yaXRpZXNbckluZGV4XSA8IHByaW9yaXRpZXNbbEluZGV4XVxuICAgICAgICAgID8gckluZGV4XG4gICAgICAgICAgOiBsSW5kZXg7XG5cbiAgICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3NtYWxsZXJDaGlsZEluZGV4XTtcbiAgICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdGllc1tzbWFsbGVyQ2hpbGRJbmRleF07XG4gICAgICBpbmRleCA9IHNtYWxsZXJDaGlsZEluZGV4O1xuICAgIH1cblxuICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnQ7XG4gICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgICB0aGlzLnNpZnREb3duXyhzdGFydEluZGV4LCBpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIGluZGV4IG9mIHRoZSByb290LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIG1vdmUgdXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaWZ0RG93bl8oc3RhcnRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICAgIGNvbnN0IHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XG4gICAgY29uc3QgcHJpb3JpdHkgPSBwcmlvcml0aWVzW2luZGV4XTtcblxuICAgIHdoaWxlIChpbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gdGhpcy5nZXRQYXJlbnRJbmRleF8oaW5kZXgpO1xuICAgICAgaWYgKHByaW9yaXRpZXNbcGFyZW50SW5kZXhdID4gcHJpb3JpdHkpIHtcbiAgICAgICAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudHNbcGFyZW50SW5kZXhdO1xuICAgICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbcGFyZW50SW5kZXhdO1xuICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnQ7XG4gICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIHJlcHJpb3JpdGl6ZSgpIHtcbiAgICBjb25zdCBwcmlvcml0eUZ1bmN0aW9uID0gdGhpcy5wcmlvcml0eUZ1bmN0aW9uXztcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICAgIGNvbnN0IHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgbiA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBsZXQgZWxlbWVudCwgaSwgcHJpb3JpdHk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgcHJpb3JpdHkgPSBwcmlvcml0eUZ1bmN0aW9uKGVsZW1lbnQpO1xuICAgICAgaWYgKHByaW9yaXR5ID09IERST1ApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucXVldWVkRWxlbWVudHNfW3RoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gICAgICAgIGVsZW1lbnRzW2luZGV4KytdID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudHMubGVuZ3RoID0gaW5kZXg7XG4gICAgcHJpb3JpdGllcy5sZW5ndGggPSBpbmRleDtcbiAgICB0aGlzLmhlYXBpZnlfKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdHlRdWV1ZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9DaXJjbGVcbiAqL1xuXG5pbXBvcnQgUmVndWxhclNoYXBlIGZyb20gJy4vUmVndWxhclNoYXBlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYWRpdXMgQ2lyY2xlIHJhZGl1cy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbZGlzcGxhY2VtZW50PVswLDBdXSBkaXNwbGFjZW1lbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlPTFdIFNjYWxlLiBBIHR3byBkaW1lbnNpb25hbCBzY2FsZSB3aWxsIHByb2R1Y2UgYW4gZWxsaXBzZS5cbiAqIFVubGVzcyB0d28gZGltZW5zaW9uYWwgc2NhbGluZyBpcyByZXF1aXJlZCBhIGJldHRlciByZXN1bHQgbWF5IGJlIG9idGFpbmVkIHdpdGggYW4gYXBwcm9wcmlhdGUgc2V0dGluZyBmb3IgYHJhZGl1c2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UsIG1lYW5pbmdmdWwgb25seSB3aGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHR3byBkaW1lbnNpb25hbCBzY2FsZSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGVXaXRoVmlldz1mYWxzZV0gV2hldGhlciB0byByb3RhdGUgdGhlIHNoYXBlIHdpdGggdGhlIHZpZXdcbiAqIChtZWFuaW5nZnVsIG9ubHkgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSB0d28gZGltZW5zaW9uYWwgc2NhbGUpLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vU3R5bGUuanMnKS5EZWNsdXR0ZXJNb2RlfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBjaXJjbGUgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2lyY2xlU3R5bGUgZXh0ZW5kcyBSZWd1bGFyU2hhcGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7cmFkaXVzOiA1fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIHBvaW50czogSW5maW5pdHksXG4gICAgICBmaWxsOiBvcHRpb25zLmZpbGwsXG4gICAgICByYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuICAgICAgc3Ryb2tlOiBvcHRpb25zLnN0cm9rZSxcbiAgICAgIHNjYWxlOiBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMCxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OlxuICAgICAgICBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3IDogZmFsc2UsXG4gICAgICBkaXNwbGFjZW1lbnQ6XG4gICAgICAgIG9wdGlvbnMuZGlzcGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRpc3BsYWNlbWVudCA6IFswLCAwXSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IG9wdGlvbnMuZGVjbHV0dGVyTW9kZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtDaXJjbGVTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgIGNvbnN0IHN0eWxlID0gbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHJhZGl1czogdGhpcy5nZXRSYWRpdXMoKSxcbiAgICAgIHNjYWxlOiBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgZGlzcGxhY2VtZW50OiB0aGlzLmdldERpc3BsYWNlbWVudCgpLnNsaWNlKCksXG4gICAgICBkZWNsdXR0ZXJNb2RlOiB0aGlzLmdldERlY2x1dHRlck1vZGUoKSxcbiAgICB9KTtcbiAgICBzdHlsZS5zZXRPcGFjaXR5KHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjaXJjbGUgcmFkaXVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIENpcmNsZSByYWRpdXMuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJhZGl1cyhyYWRpdXMpIHtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENpcmNsZVN0eWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ZpbGxcbiAqL1xuXG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCB7YXNBcnJheX0gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0SWNvbkltYWdlfSBmcm9tICcuL0ljb25JbWFnZS5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfGltcG9ydCgnLi4vY29sb3JsaWtlLmpzJykuUGF0dGVybkRlc2NyaXB0b3J8bnVsbH0gW2NvbG9yPW51bGxdIEEgY29sb3IsXG4gKiBncmFkaWVudCBvciBwYXR0ZXJuLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGZvciBwb3NzaWJsZSBmb3JtYXRzLiBGb3IgcG9seWdvbiBmaWxscyAobm90IGZvciB7QGxpbmsgaW1wb3J0KFwiLi9SZWd1bGFyU2hhcGUuanNcIikuZGVmYXVsdH0gZmlsbHMpLFxuICogYSBwYXR0ZXJuIGNhbiBhbHNvIGJlIHByb3ZpZGVkIGFzIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlflBhdHRlcm5EZXNjcmlwdG9yfS5cbiAqIERlZmF1bHQgbnVsbDsgaWYgbnVsbCwgdGhlIENhbnZhcy9yZW5kZXJlciBkZWZhdWx0IGJsYWNrIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBmaWxsIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEZpbGwge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhdHRlcm5JbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZXxpbXBvcnQoJy4uL2NvbG9ybGlrZS5qcycpLlBhdHRlcm5EZXNjcmlwdG9yfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0Q29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuIFRoZSBjb2xvciBpcyBub3QgY2xvbmVkIGlmIGl0IGlzIGEge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAgICogQHJldHVybiB7RmlsbH0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIG5ldyBGaWxsKHtcbiAgICAgIGNvbG9yOiBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yLnNsaWNlKCkgOiBjb2xvciB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfGltcG9ydCgnLi4vY29sb3JsaWtlLmpzJykuUGF0dGVybkRlc2NyaXB0b3J8bnVsbH0gQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V8aW1wb3J0KCcuLi9jb2xvcmxpa2UuanMnKS5QYXR0ZXJuRGVzY3JpcHRvcnxudWxsfSBjb2xvciBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICBpZiAoY29sb3IgIT09IG51bGwgJiYgdHlwZW9mIGNvbG9yID09PSAnb2JqZWN0JyAmJiAnc3JjJyBpbiBjb2xvcikge1xuICAgICAgY29uc3QgcGF0dGVybkltYWdlID0gZ2V0SWNvbkltYWdlKFxuICAgICAgICBudWxsLFxuICAgICAgICBjb2xvci5zcmMsXG4gICAgICAgICdhbm9ueW1vdXMnLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGNvbG9yLm9mZnNldCA/IG51bGwgOiBjb2xvci5jb2xvciA/IGNvbG9yLmNvbG9yIDogbnVsbCxcbiAgICAgICAgIShjb2xvci5vZmZzZXQgJiYgY29sb3Iuc2l6ZSksXG4gICAgICApO1xuICAgICAgcGF0dGVybkltYWdlLnJlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMucGF0dGVybkltYWdlXyA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXR0ZXJuSW1hZ2UuZ2V0SW1hZ2VTdGF0ZSgpID09PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgICAgcGF0dGVybkltYWdlLmxvYWQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXR0ZXJuSW1hZ2UuZ2V0SW1hZ2VTdGF0ZSgpID09PSBJbWFnZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuSW1hZ2VfID0gcGF0dGVybkltYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gS2V5IG9mIHRoZSBmaWxsIGZvciBjYWNoZSBsb29rdXAuXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgY29uc3QgZmlsbCA9IHRoaXMuZ2V0Q29sb3IoKTtcbiAgICBpZiAoIWZpbGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGZpbGwgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8IGZpbGwgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudFxuICAgICAgPyBnZXRVaWQoZmlsbClcbiAgICAgIDogdHlwZW9mIGZpbGwgPT09ICdvYmplY3QnICYmICdzcmMnIGluIGZpbGxcbiAgICAgICAgPyBmaWxsLnNyYyArICc6JyArIGZpbGwub2Zmc2V0XG4gICAgICAgIDogYXNBcnJheShmaWxsKS50b1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBmaWxsIHN0eWxlIGlzIGxvYWRpbmcgYW4gaW1hZ2UgcGF0dGVybi5cbiAgICovXG4gIGxvYWRpbmcoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wYXR0ZXJuSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IGBmYWxzZWAgb3IgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc3R5bGUgaXMgcmVhZHkgdG8gdXNlLlxuICAgKi9cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVybkltYWdlXyA/IHRoaXMucGF0dGVybkltYWdlXy5yZWFkeSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsbDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JY29uXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRJY29uSW1hZ2V9IGZyb20gJy4vSWNvbkltYWdlLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J2ZyYWN0aW9uJyB8ICdwaXhlbHMnfSBJY29uQW5jaG9yVW5pdHNcbiAqIEFuY2hvciB1bml0IGNhbiBiZSBlaXRoZXIgYSBmcmFjdGlvbiBvZiB0aGUgaWNvbiBzaXplIG9yIGluIHBpeGVscy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1yaWdodCcgfCAndG9wLWxlZnQnIHwgJ3RvcC1yaWdodCd9IEljb25PcmlnaW5cbiAqIEljb24gb3JpZ2luLiBPbmUgb2YgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbYW5jaG9yPVswLjUsIDAuNV1dIEFuY2hvci4gRGVmYXVsdCB2YWx1ZSBpcyB0aGUgaWNvbiBjZW50ZXIuXG4gKiBAcHJvcGVydHkge0ljb25PcmlnaW59IFthbmNob3JPcmlnaW49J3RvcC1sZWZ0J10gT3JpZ2luIG9mIHRoZSBhbmNob3I6IGBib3R0b20tbGVmdGAsIGBib3R0b20tcmlnaHRgLFxuICogYHRvcC1sZWZ0YCBvciBgdG9wLXJpZ2h0YC5cbiAqIEBwcm9wZXJ0eSB7SWNvbkFuY2hvclVuaXRzfSBbYW5jaG9yWFVuaXRzPSdmcmFjdGlvbiddIFVuaXRzIGluIHdoaWNoIHRoZSBhbmNob3IgeCB2YWx1ZSBpc1xuICogc3BlY2lmaWVkLiBBIHZhbHVlIG9mIGAnZnJhY3Rpb24nYCBpbmRpY2F0ZXMgdGhlIHggdmFsdWUgaXMgYSBmcmFjdGlvbiBvZiB0aGUgaWNvbi4gQSB2YWx1ZSBvZiBgJ3BpeGVscydgIGluZGljYXRlc1xuICogdGhlIHggdmFsdWUgaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtJY29uQW5jaG9yVW5pdHN9IFthbmNob3JZVW5pdHM9J2ZyYWN0aW9uJ10gVW5pdHMgaW4gd2hpY2ggdGhlIGFuY2hvciB5IHZhbHVlIGlzXG4gKiBzcGVjaWZpZWQuIEEgdmFsdWUgb2YgYCdmcmFjdGlvbidgIGluZGljYXRlcyB0aGUgeSB2YWx1ZSBpcyBhIGZyYWN0aW9uIG9mIHRoZSBpY29uLiBBIHZhbHVlIG9mIGAncGl4ZWxzJ2AgaW5kaWNhdGVzXG4gKiB0aGUgeSB2YWx1ZSBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ30gW2NvbG9yXSBDb2xvciB0byB0aW50IHRoZSBpY29uLiBJZiBub3Qgc3BlY2lmaWVkLFxuICogdGhlIGljb24gd2lsbCBiZSBsZWZ0IGFzIGlzLlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuIE5vdGUgdGhhdCB5b3UgbXVzdCBwcm92aWRlIGFcbiAqIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gW2ltZ10gSW1hZ2Ugb2JqZWN0IGZvciB0aGUgaWNvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwgMF1dIERpc3BsYWNlbWVudCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuXG4gKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBzaGlmdCB0aGUgaWNvbiByaWdodCBhbmQgdXAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSBvZiB0aGUgaWNvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIFRoZSB3aWR0aCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuIFRoaXMgY2FuJ3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIGBzY2FsZWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gVGhlIGhlaWdodCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuIFRoaXMgY2FuJ3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIGBzY2FsZWAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZT0xXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgaWNvbiB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbb2Zmc2V0PVswLCAwXV0gT2Zmc2V0IHdoaWNoLCB0b2dldGhlciB3aXRoIGBzaXplYCBhbmQgYG9mZnNldE9yaWdpbmAsIGRlZmluZXMgdGhlXG4gKiBzdWItcmVjdGFuZ2xlIHRvIHVzZSBmcm9tIHRoZSBvcmlnaW5hbCAoc3ByaXRlKSBpbWFnZS5cbiAqIEBwcm9wZXJ0eSB7SWNvbk9yaWdpbn0gW29mZnNldE9yaWdpbj0ndG9wLWxlZnQnXSBPcmlnaW4gb2YgdGhlIG9mZnNldDogYGJvdHRvbS1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsXG4gKiBgdG9wLWxlZnRgIG9yIGB0b3AtcmlnaHRgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBJY29uIHNpemUgaW4gcGl4ZWxzLiBVc2VkIHRvZ2V0aGVyIHdpdGggYG9mZnNldGAgdG8gZGVmaW5lIHRoZVxuICogc3ViLXJlY3RhbmdsZSB0byB1c2UgZnJvbSB0aGUgb3JpZ2luYWwgKHNwcml0ZSkgaW1hZ2UuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NyY10gSW1hZ2Ugc291cmNlIFVSSS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHlsZS5qc1wiKS5EZWNsdXR0ZXJNb2RlfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGUuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB3YW50ZWRXaWR0aCBUaGUgd2FudGVkIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB3YW50ZWRIZWlnaHQgVGhlIHdhbnRlZCBoZWlnaHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ8QXJyYXk8bnVtYmVyPn0gVGhlIHNjYWxlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTY2FsZSh3aWR0aCwgaGVpZ2h0LCB3YW50ZWRXaWR0aCwgd2FudGVkSGVpZ2h0KSB7XG4gIGlmICh3YW50ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIHdhbnRlZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt3YW50ZWRXaWR0aCAvIHdpZHRoLCB3YW50ZWRIZWlnaHQgLyBoZWlnaHRdO1xuICB9XG4gIGlmICh3YW50ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHdhbnRlZFdpZHRoIC8gd2lkdGg7XG4gIH1cbiAgaWYgKHdhbnRlZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHdhbnRlZEhlaWdodCAvIGhlaWdodDtcbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgaWNvbiBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBJY29uIGV4dGVuZHMgSW1hZ2VTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCBvcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYWNpdHkgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0ZVdpdGhWaWV3ID1cbiAgICAgIG9wdGlvbnMucm90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlV2l0aFZpZXcgOiBmYWxzZTtcblxuICAgIHN1cGVyKHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBkaXNwbGFjZW1lbnQ6XG4gICAgICAgIG9wdGlvbnMuZGlzcGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRpc3BsYWNlbWVudCA6IFswLCAwXSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlldyxcbiAgICAgIGRlY2x1dHRlck1vZGU6IG9wdGlvbnMuZGVjbHV0dGVyTW9kZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gb3B0aW9ucy5hbmNob3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5jaG9yIDogWzAuNSwgMC41XTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtJY29uT3JpZ2lufVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9XG4gICAgICBvcHRpb25zLmFuY2hvck9yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JPcmlnaW4gOiAndG9wLWxlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbkFuY2hvclVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWFVuaXRzXyA9XG4gICAgICBvcHRpb25zLmFuY2hvclhVbml0cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JYVW5pdHMgOiAnZnJhY3Rpb24nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbkFuY2hvclVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWVVuaXRzXyA9XG4gICAgICBvcHRpb25zLmFuY2hvcllVbml0cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JZVW5pdHMgOiAnZnJhY3Rpb24nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNyb3NzT3JpZ2luIDogbnVsbDtcblxuICAgIGNvbnN0IGltYWdlID0gb3B0aW9ucy5pbWcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW1nIDogbnVsbDtcblxuICAgIGxldCBjYWNoZUtleSA9IG9wdGlvbnMuc3JjO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgIShjYWNoZUtleSAhPT0gdW5kZWZpbmVkICYmIGltYWdlKSxcbiAgICAgICdgaW1hZ2VgIGFuZCBgc3JjYCBjYW5ub3QgYmUgcHJvdmlkZWQgYXQgdGhlIHNhbWUgdGltZScsXG4gICAgKTtcblxuICAgIGlmICgoY2FjaGVLZXkgPT09IHVuZGVmaW5lZCB8fCBjYWNoZUtleS5sZW5ndGggPT09IDApICYmIGltYWdlKSB7XG4gICAgICBjYWNoZUtleSA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKGltYWdlKS5zcmMgfHwgZ2V0VWlkKGltYWdlKTtcbiAgICB9XG4gICAgYXNzZXJ0KFxuICAgICAgY2FjaGVLZXkgIT09IHVuZGVmaW5lZCAmJiBjYWNoZUtleS5sZW5ndGggPiAwLFxuICAgICAgJ0EgZGVmaW5lZCBhbmQgbm9uLWVtcHR5IGBzcmNgIG9yIGBpbWFnZWAgbXVzdCBiZSBwcm92aWRlZCcsXG4gICAgKTtcblxuICAgIGFzc2VydChcbiAgICAgICEoXG4gICAgICAgIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkXG4gICAgICApLFxuICAgICAgJ2B3aWR0aGAgb3IgYGhlaWdodGAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyIHdpdGggYHNjYWxlYCcsXG4gICAgKTtcblxuICAgIGxldCBpbWFnZVN0YXRlO1xuICAgIGlmIChvcHRpb25zLnNyYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbWFnZVN0YXRlID0gSW1hZ2VTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSBpZiAoaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdjb21wbGV0ZScgaW4gaW1hZ2UpIHtcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlLnNyYyA/IEltYWdlU3RhdGUuTE9BREVEIDogSW1hZ2VTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltYWdlU3RhdGUgPSBJbWFnZVN0YXRlLkxPQURJTkc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlU3RhdGUgPSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGFzQXJyYXkob3B0aW9ucy5jb2xvcikgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmljb25JbWFnZV8gPSBnZXRJY29uSW1hZ2UoXG4gICAgICBpbWFnZSxcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY2FjaGVLZXkpLFxuICAgICAgdGhpcy5jcm9zc09yaWdpbl8sXG4gICAgICBpbWFnZVN0YXRlLFxuICAgICAgdGhpcy5jb2xvcl8sXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRfID0gb3B0aW9ucy5vZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0IDogWzAsIDBdO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0ljb25PcmlnaW59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRPcmlnaW5fID1cbiAgICAgIG9wdGlvbnMub2Zmc2V0T3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldE9yaWdpbiA6ICd0b3AtbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaXplIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbml0aWFsT3B0aW9uc187XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNjYWxlIGlmIHdpZHRoIG9yIGhlaWdodCB3ZXJlIGdpdmVuLlxuICAgICAqL1xuICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgICBpZiAob3B0aW9ucy5zaXplKSB7XG4gICAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IG9wdGlvbnMuc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5nZXRJbWFnZSgxKTtcbiAgICAgICAgaWYgKGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodCkge1xuICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbE9wdGlvbnNfID0gb3B0aW9ucztcbiAgICAgICAgICBjb25zdCBvbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVubGlzdGVuSW1hZ2VDaGFuZ2Uob25sb2FkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbml0aWFsT3B0aW9uc18pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW1hZ2VTaXplID0gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NhbGUoXG4gICAgICAgICAgICAgIGNhbGN1bGF0ZVNjYWxlKFxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZVswXSxcbiAgICAgICAgICAgICAgICBpbWFnZVNpemVbMV0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxpc3RlbkltYWdlQ2hhbmdlKG9ubG9hZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFNjYWxlKFxuICAgICAgICAgIGNhbGN1bGF0ZVNjYWxlKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS4gVGhlIHVuZGVybHlpbmcgSW1hZ2UvSFRNTENhbnZhc0VsZW1lbnQgaXMgbm90IGNsb25lZC5cbiAgICogQHJldHVybiB7SWNvbn0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGxldCBzY2FsZSwgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAodGhpcy5pbml0aWFsT3B0aW9uc18pIHtcbiAgICAgIHdpZHRoID0gdGhpcy5pbml0aWFsT3B0aW9uc18ud2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmluaXRpYWxPcHRpb25zXy5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgICAgc2NhbGUgPSBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJY29uKHtcbiAgICAgIGFuY2hvcjogdGhpcy5hbmNob3JfLnNsaWNlKCksXG4gICAgICBhbmNob3JPcmlnaW46IHRoaXMuYW5jaG9yT3JpZ2luXyxcbiAgICAgIGFuY2hvclhVbml0czogdGhpcy5hbmNob3JYVW5pdHNfLFxuICAgICAgYW5jaG9yWVVuaXRzOiB0aGlzLmFuY2hvcllVbml0c18sXG4gICAgICBjb2xvcjpcbiAgICAgICAgdGhpcy5jb2xvcl8gJiYgdGhpcy5jb2xvcl8uc2xpY2VcbiAgICAgICAgICA/IHRoaXMuY29sb3JfLnNsaWNlKClcbiAgICAgICAgICA6IHRoaXMuY29sb3JfIHx8IHVuZGVmaW5lZCxcbiAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luXyxcbiAgICAgIG9mZnNldDogdGhpcy5vZmZzZXRfLnNsaWNlKCksXG4gICAgICBvZmZzZXRPcmlnaW46IHRoaXMub2Zmc2V0T3JpZ2luXyxcbiAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICBzY2FsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgc2l6ZTogdGhpcy5zaXplXyAhPT0gbnVsbCA/IHRoaXMuc2l6ZV8uc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4gICAqIHN5bWJvbGl6ZXIuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuY2hvci5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEFuY2hvcigpIHtcbiAgICBsZXQgYW5jaG9yID0gdGhpcy5ub3JtYWxpemVkQW5jaG9yXztcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmFuY2hvclhVbml0c18gPT0gJ2ZyYWN0aW9uJyB8fFxuICAgICAgICB0aGlzLmFuY2hvcllVbml0c18gPT0gJ2ZyYWN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFuY2hvciA9IHRoaXMuYW5jaG9yXy5zbGljZSgpO1xuICAgICAgICBpZiAodGhpcy5hbmNob3JYVW5pdHNfID09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBhbmNob3JbMF0gKj0gc2l6ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbmNob3JZVW5pdHNfID09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBhbmNob3JbMV0gKj0gc2l6ZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hbmNob3JPcmlnaW5fICE9ICd0b3AtbGVmdCcpIHtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvciA9PT0gdGhpcy5hbmNob3JfKSB7XG4gICAgICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAndG9wLXJpZ2h0JyB8fFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgICApIHtcbiAgICAgICAgICBhbmNob3JbMF0gPSAtYW5jaG9yWzBdICsgc2l6ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5hbmNob3JPcmlnaW5fID09ICdib3R0b20tbGVmdCcgfHxcbiAgICAgICAgICB0aGlzLmFuY2hvck9yaWdpbl8gPT0gJ2JvdHRvbS1yaWdodCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgYW5jaG9yWzFdID0gLWFuY2hvclsxXSArIHNpemVbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubm9ybWFsaXplZEFuY2hvcl8gPSBhbmNob3I7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCk7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlQXJyYXkoKTtcbiAgICAvLyBhbmNob3IgaXMgc2NhbGVkIGJ5IHJlbmRlcmVyIGJ1dCBkaXNwbGFjZW1lbnQgc2hvdWxkIG5vdCBiZSBzY2FsZWRcbiAgICAvLyBzbyBkaXZpZGUgYnkgc2NhbGUgaGVyZVxuICAgIHJldHVybiBbXG4gICAgICBhbmNob3JbMF0gLSBkaXNwbGFjZW1lbnRbMF0gLyBzY2FsZVswXSxcbiAgICAgIGFuY2hvclsxXSArIGRpc3BsYWNlbWVudFsxXSAvIHNjYWxlWzFdLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAgICogc3ltYm9saXplci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgQW5jaG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBbmNob3IoYW5jaG9yKSB7XG4gICAgdGhpcy5hbmNob3JfID0gYW5jaG9yO1xuICAgIHRoaXMubm9ybWFsaXplZEFuY2hvcl8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWNvbiBjb2xvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBpY29uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2Ugb3IgQ2FudmFzIGVsZW1lbnQuIElmIHRoZSBJY29uXG4gICAqIHN0eWxlIHdhcyBjb25maWd1cmVkIHdpdGggYHNyY2Agb3Igd2l0aCBhIG5vdCBsZXQgbG9hZGVkIGBpbWdgLCBhbiBgSW1hZ2VCaXRtYXBgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRJbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRJbWFnZShwaXhlbFJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIGltYWdlLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRJbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRJbWFnZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2VTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IEltYWdlIGVsZW1lbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRIaXREZXRlY3Rpb25JbWFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIG9mIHRoZSBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luXykge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0XztcblxuICAgIGlmICh0aGlzLm9mZnNldE9yaWdpbl8gIT0gJ3RvcC1sZWZ0Jykge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgY29uc3QgaWNvbkltYWdlU2l6ZSA9IHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCk7XG4gICAgICBpZiAoIXNpemUgfHwgIWljb25JbWFnZVNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSBvZmZzZXQuc2xpY2UoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vZmZzZXRPcmlnaW5fID09ICd0b3AtcmlnaHQnIHx8XG4gICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgKSB7XG4gICAgICAgIG9mZnNldFswXSA9IGljb25JbWFnZVNpemVbMF0gLSBzaXplWzBdIC0gb2Zmc2V0WzBdO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ2JvdHRvbS1sZWZ0JyB8fFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ2JvdHRvbS1yaWdodCdcbiAgICAgICkge1xuICAgICAgICBvZmZzZXRbMV0gPSBpY29uSW1hZ2VTaXplWzFdIC0gc2l6ZVsxXSAtIG9mZnNldFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vcmlnaW5fID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBVUkwuXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IEltYWdlIHNyYy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3JjKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0U3JjKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBpY29uIChpbiBwaXhlbHMpLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIHJldHVybiAhdGhpcy5zaXplXyA/IHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCkgOiB0aGlzLnNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGljb24gKGluIHBpeGVscykuIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCB3aGVuIHRoZSBpY29uIGltYWdlIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEljb24gd2lkdGggKGluIHBpeGVscykuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZUFycmF5KCk7XG4gICAgaWYgKHRoaXMuc2l6ZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemVfWzBdICogc2NhbGVbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2VTdGF0ZSgpID09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKVswXSAqIHNjYWxlWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBpY29uIChpbiBwaXhlbHMpLiBXaWxsIHJldHVybiB1bmRlZmluZWQgd2hlbiB0aGUgaWNvbiBpbWFnZSBpcyBub3QgeWV0IGxvYWRlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJY29uIGhlaWdodCAoaW4gcGl4ZWxzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZUFycmF5KCk7XG4gICAgaWYgKHRoaXMuc2l6ZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemVfWzFdICogc2NhbGVbMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2VTdGF0ZSgpID09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKVsxXSAqIHNjYWxlWzFdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIGRlbGV0ZSB0aGlzLmluaXRpYWxPcHRpb25zXztcbiAgICBzdXBlci5zZXRTY2FsZShzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5pY29uSW1hZ2VfLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBXaGVuIHJlbmRlcmluZyBhIGZlYXR1cmUgd2l0aCBhbiBpY29uIHN0eWxlLCB0aGUgdmVjdG9yIHJlbmRlcmVyIHdpbGxcbiAgICogYXV0b21hdGljYWxseSBjYWxsIHRoaXMgbWV0aG9kLiBIb3dldmVyLCB5b3UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXNcbiAgICogbWV0aG9kIHlvdXJzZWxmIGZvciBwcmVsb2FkaW5nIG9yIG90aGVyIHB1cnBvc2VzLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICB0aGlzLmljb25JbWFnZV8ubG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5pY29uSW1hZ2VfLnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5yZWFkeSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvbkltYWdlXG4gKi9cblxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2RlY29kZUZhbGxiYWNrfSBmcm9tICcuLi9JbWFnZS5qcyc7XG5pbXBvcnQge3NoYXJlZCBhcyBpY29uSW1hZ2VDYWNoZX0gZnJvbSAnLi9JY29uSW1hZ2VDYWNoZS5qcyc7XG5cbi8qKlxuICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xubGV0IHRhaW50ZWRUZXN0Q29udGV4dCA9IG51bGw7XG5cbmNsYXNzIEljb25JbWFnZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcHxudWxsfSBpbWFnZSBJbWFnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzcmMgU3JjLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBpbWFnZVN0YXRlIEltYWdlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfSBjb2xvciBDb2xvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGltYWdlLCBzcmMsIGNyb3NzT3JpZ2luLCBpbWFnZVN0YXRlLCBjb2xvcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbl8gPSBjcm9zc09yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxudW1iZXIsIEhUTUxDYW52YXNFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29sb3JfID0gY29sb3I7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVN0YXRlXyA9IGltYWdlU3RhdGUgPT09IHVuZGVmaW5lZCA/IEltYWdlU3RhdGUuSURMRSA6IGltYWdlU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnNpemVfID1cbiAgICAgIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodCA/IFtpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0XSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc3JjXyA9IHNyYztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50YWludGVkXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1Byb21pc2U8dm9pZD58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWR5XyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemVJbWFnZV8oKSB7XG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBpbWFnZSBjYW52YXMgaXMgdGFpbnRlZC5cbiAgICovXG4gIGlzVGFpbnRlZF8oKSB7XG4gICAgaWYgKHRoaXMudGFpbnRlZF8gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmltYWdlU3RhdGVfID09PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgaWYgKCF0YWludGVkVGVzdENvbnRleHQpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEsIHVuZGVmaW5lZCwge1xuICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0YWludGVkVGVzdENvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2VfLCAwLCAwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhaW50ZWRUZXN0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgIHRoaXMudGFpbnRlZF8gPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWludGVkXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhaW50ZWRfID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZUV2ZW50XygpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBJbWFnZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMuZGlzcGF0Y2hDaGFuZ2VFdmVudF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VMb2FkXygpIHtcbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gICAgdGhpcy5zaXplXyA9IFt0aGlzLmltYWdlXy53aWR0aCwgdGhpcy5pbWFnZV8uaGVpZ2h0XTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlRXZlbnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IEltYWdlIG9yIENhbnZhcyBlbGVtZW50IG9yIGltYWdlIGJpdG1hcC5cbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG4gICAgdGhpcy5yZXBsYWNlQ29sb3JfKHBpeGVsUmF0aW8pO1xuICAgIHJldHVybiB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPyB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gOiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHRoaXMucmVwbGFjZUNvbG9yXyhwaXhlbFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dID8gcGl4ZWxSYXRpbyA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VTdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUltYWdlXygpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfKSB7XG4gICAgICBpZiAodGhpcy5pc1RhaW50ZWRfKCkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemVfWzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSB0aGlzLmltYWdlXztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBJbWFnZSBzcmMuXG4gICAqL1xuICBnZXRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JjXztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VTdGF0ZV8gIT09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zcmNfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAodGhpcy5pbWFnZV8pLnNyYyA9IHRoaXMuc3JjXztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlXyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGRlY29kZUZhbGxiYWNrKHRoaXMuaW1hZ2VfLCB0aGlzLnNyY18pXG4gICAgICAgIC50aGVuKChpbWFnZSkgPT4ge1xuICAgICAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gICAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUltYWdlRXJyb3JfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGxhY2VDb2xvcl8ocGl4ZWxSYXRpbykge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmNvbG9yXyB8fFxuICAgICAgdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dIHx8XG4gICAgICB0aGlzLmltYWdlU3RhdGVfICE9PSBJbWFnZVN0YXRlLkxPQURFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZV87XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgTWF0aC5jZWlsKGltYWdlLndpZHRoICogcGl4ZWxSYXRpbyksXG4gICAgICBNYXRoLmNlaWwoaW1hZ2UuaGVpZ2h0ICogcGl4ZWxSYXRpbyksXG4gICAgKTtcbiAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuXG4gICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGFzU3RyaW5nKHRoaXMuY29sb3JfKTtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbywgY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW8pO1xuXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG5cbiAgICB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPSBjYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGltYWdlIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWR5KCkge1xuICAgIGlmICghdGhpcy5yZWFkeV8pIHtcbiAgICAgIHRoaXMucmVhZHlfID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPT09IEltYWdlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgdGhpcy5pbWFnZVN0YXRlXyA9PT0gSW1hZ2VTdGF0ZS5FUlJPUlxuICAgICAgICApIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPT09IEltYWdlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPT09IEltYWdlU3RhdGUuRVJST1JcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgb25DaGFuZ2UpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgb25DaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZHlfO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfG51bGx9IGltYWdlIEltYWdlLlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBjYWNoZUtleSBTcmMuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gaW1hZ2VTdGF0ZSBJbWFnZSBzdGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfG51bGx9IGNvbG9yIENvbG9yLlxuICogQHBhcmFtIHtib29sZWFufSBbcGF0dGVybl0gQWxzbyBjYWNoZSBhIGByZXBlYXRgIHBhdHRlcm4gd2l0aCB0aGUgaWNvbiBpbWFnZS5cbiAqIEByZXR1cm4ge0ljb25JbWFnZX0gSWNvbiBpbWFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChpbWFnZSwgY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBpbWFnZVN0YXRlLCBjb2xvciwgcGF0dGVybikge1xuICBsZXQgaWNvbkltYWdlID1cbiAgICBjYWNoZUtleSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBpY29uSW1hZ2VDYWNoZS5nZXQoY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gIGlmICghaWNvbkltYWdlKSB7XG4gICAgaWNvbkltYWdlID0gbmV3IEljb25JbWFnZShcbiAgICAgIGltYWdlLFxuICAgICAgaW1hZ2UgJiYgJ3NyYycgaW4gaW1hZ2UgPyBpbWFnZS5zcmMgfHwgdW5kZWZpbmVkIDogY2FjaGVLZXksXG4gICAgICBjcm9zc09yaWdpbixcbiAgICAgIGltYWdlU3RhdGUsXG4gICAgICBjb2xvcixcbiAgICApO1xuICAgIGljb25JbWFnZUNhY2hlLnNldChjYWNoZUtleSwgY3Jvc3NPcmlnaW4sIGNvbG9yLCBpY29uSW1hZ2UsIHBhdHRlcm4pO1xuICB9XG4gIGlmIChcbiAgICBwYXR0ZXJuICYmXG4gICAgaWNvbkltYWdlICYmXG4gICAgIWljb25JbWFnZUNhY2hlLmdldFBhdHRlcm4oY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBjb2xvcilcbiAgKSB7XG4gICAgaWNvbkltYWdlQ2FjaGUuc2V0KGNhY2hlS2V5LCBjcm9zc09yaWdpbiwgY29sb3IsIGljb25JbWFnZSwgcGF0dGVybik7XG4gIH1cbiAgcmV0dXJuIGljb25JbWFnZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSWNvbkltYWdlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25JbWFnZUNhY2hlXG4gKi9cbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2dldFNoYXJlZENhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTaW5nbGV0b24gY2xhc3MuIEF2YWlsYWJsZSB0aHJvdWdoIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbkltYWdlQ2FjaGUuc2hhcmVkfS5cbiAqL1xuY2xhc3MgSWNvbkltYWdlQ2FjaGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYWNoZV8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgQ2FudmFzUGF0dGVybj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBhdHRlcm5DYWNoZV8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlU2l6ZV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4Q2FjaGVTaXplXyA9IDEwMjQ7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuICAgIHRoaXMucGF0dGVybkNhY2hlXyA9IHt9O1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlU2l6ZV8gPiB0aGlzLm1heENhY2hlU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBleHBpcmUoKSB7XG4gICAgaWYgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZV8pIHtcbiAgICAgICAgY29uc3QgaWNvbkltYWdlID0gdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCAmJiAhaWNvbkltYWdlLmhhc0xpc3RlbmVyKCkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wYXR0ZXJuQ2FjaGVfW2tleV07XG4gICAgICAgICAgLS10aGlzLmNhY2hlU2l6ZV87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfSBjb2xvciBDb2xvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdH0gSWNvbiBpbWFnZS5cbiAgICovXG4gIGdldChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGdldENhY2hlS2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMuY2FjaGVfID8gdGhpcy5jYWNoZV9ba2V5XSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfSBjb2xvciBDb2xvci5cbiAgICogQHJldHVybiB7Q2FudmFzUGF0dGVybn0gSWNvbiBpbWFnZS5cbiAgICovXG4gIGdldFBhdHRlcm4oc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRDYWNoZUtleShzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gICAgcmV0dXJuIGtleSBpbiB0aGlzLnBhdHRlcm5DYWNoZV8gPyB0aGlzLnBhdHRlcm5DYWNoZV9ba2V5XSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfSBjb2xvciBDb2xvci5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fG51bGx9IGljb25JbWFnZSBJY29uIGltYWdlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXR0ZXJuXSBBbHNvIGNhY2hlIGEgYCdyZXBlYXQnYCBwYXR0ZXJuIHdpdGggdGhpcyBgaWNvbkltYWdlYC5cbiAgICovXG4gIHNldChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlLCBwYXR0ZXJuKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0Q2FjaGVLZXkoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IGtleSBpbiB0aGlzLmNhY2hlXztcbiAgICB0aGlzLmNhY2hlX1trZXldID0gaWNvbkltYWdlO1xuICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICBpZiAoaWNvbkltYWdlLmdldEltYWdlU3RhdGUoKSA9PT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICAgIGljb25JbWFnZS5sb2FkKCk7XG4gICAgICB9XG4gICAgICBpZiAoaWNvbkltYWdlLmdldEltYWdlU3RhdGUoKSA9PT0gSW1hZ2VTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgIGljb25JbWFnZS5yZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMucGF0dGVybkNhY2hlX1trZXldID0gZ2V0U2hhcmVkQ2FudmFzQ29udGV4dDJEKCkuY3JlYXRlUGF0dGVybihcbiAgICAgICAgICAgIGljb25JbWFnZS5nZXRJbWFnZSgxKSxcbiAgICAgICAgICAgICdyZXBlYXQnLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuQ2FjaGVfW2tleV0gPSBnZXRTaGFyZWRDYW52YXNDb250ZXh0MkQoKS5jcmVhdGVQYXR0ZXJuKFxuICAgICAgICAgIGljb25JbWFnZS5nZXRJbWFnZSgxKSxcbiAgICAgICAgICAncmVwZWF0JyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF1cGRhdGUpIHtcbiAgICAgICsrdGhpcy5jYWNoZVNpemVfO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhY2hlIHNpemUgb2YgdGhlIGljb24gY2FjaGUuIERlZmF1bHQgaXMgYDEwMjRgLiBDaGFuZ2UgdGhpcyB2YWx1ZSB3aGVuXG4gICAqIHlvdXIgbWFwIHVzZXMgbW9yZSB0aGFuIDEwMjQgZGlmZmVyZW50IGljb24gaW1hZ2VzIGFuZCB5b3UgYXJlIG5vdCBjYWNoaW5nIGljb25cbiAgICogc3R5bGVzIG9uIHRoZSBhcHBsaWNhdGlvbiBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heENhY2hlU2l6ZSBDYWNoZSBtYXggc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2l6ZShtYXhDYWNoZVNpemUpIHtcbiAgICB0aGlzLm1heENhY2hlU2l6ZV8gPSBtYXhDYWNoZVNpemU7XG4gICAgdGhpcy5leHBpcmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU3JjLlxuICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ2FjaGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpIHtcbiAgY29uc3QgY29sb3JTdHJpbmcgPSBjb2xvciA/IGFzQXJyYXkoY29sb3IpIDogJ251bGwnO1xuICByZXR1cm4gY3Jvc3NPcmlnaW4gKyAnOicgKyBzcmMgKyAnOicgKyBjb2xvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgSWNvbkltYWdlQ2FjaGU7XG5cbi8qKlxuICogVGhlIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbkltYWdlQ2FjaGV+SWNvbkltYWdlQ2FjaGV9IGZvclxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29ufkljb259IGltYWdlcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYXJlZCA9IG5ldyBJY29uSW1hZ2VDYWNoZSgpO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ltYWdlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJvdGF0ZVdpdGhWaWV3IElmIHRoZSBpbWFnZSBzaG91bGQgZ2V0IHJvdGF0ZWQgd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gc2NhbGUgU2NhbGUuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGRpc3BsYWNlbWVudCBEaXNwbGFjZW1lbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vc3R5bGUvU3R5bGUuanMnKS5EZWNsdXR0ZXJNb2RlfSBkZWNsdXR0ZXJNb2RlIERlY2x1dHRlciBtb2RlOiBgZGVjbHV0dGVyYCwgYG9ic3RhY2xlYCwgYG5vbmVgLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBiYXNlIGNsYXNzIHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdCBpbnN0YW50aWF0ZWQgaW5cbiAqIGFwcHMuIEJhc2UgY2xhc3MgZm9yIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbn5JY29ufSwge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9DaXJjbGV+Q2lyY2xlU3R5bGV9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9SZWd1bGFyU2hhcGV+UmVndWxhclNoYXBlfS5cbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG5jbGFzcyBJbWFnZVN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9wYWNpdHlfID0gb3B0aW9ucy5vcGFjaXR5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IG9wdGlvbnMucm90YXRlV2l0aFZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlXyA9IG9wdGlvbnMuc2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZUFycmF5XyA9IHRvU2l6ZShvcHRpb25zLnNjYWxlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5kaXNwbGFjZW1lbnRfID0gb3B0aW9ucy5kaXNwbGFjZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uL3N0eWxlL1N0eWxlLmpzJykuRGVjbHV0dGVyTW9kZX1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlck1vZGVfID0gb3B0aW9ucy5kZWNsdXR0ZXJNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge0ltYWdlU3R5bGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgIHJldHVybiBuZXcgSW1hZ2VTdHlsZSh7XG4gICAgICBvcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICAgIHNjYWxlOiBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgZGlzcGxhY2VtZW50OiB0aGlzLmdldERpc3BsYWNlbWVudCgpLnNsaWNlKCksXG4gICAgICBkZWNsdXR0ZXJNb2RlOiB0aGlzLmdldERlY2x1dHRlck1vZGUoKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bWJvbGl6ZXIgb3BhY2l0eS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBPcGFjaXR5LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHlfO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBzeW1ib2xpemVyIHJvdGF0ZXMgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0ZVdpdGhWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZVdpdGhWaWV3XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bW9ibGl6ZXIgcm90YXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bWJvbGl6ZXIgc2NhbGUuXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNjYWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzeW1ib2xpemVyIHNjYWxlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNjYWxlIGFycmF5LlxuICAgKi9cbiAgZ2V0U2NhbGVBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZUFycmF5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRpc3BsYWNlbWVudCBvZiB0aGUgc2hhcGVcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gU2hhcGUncyBjZW50ZXIgZGlzcGxhY2VtZW50XG4gICAqIEBhcGlcbiAgICovXG4gIGdldERpc3BsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwbGFjZW1lbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVjbHV0dGVyIG1vZGUgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3R5bGUuanNcIikuRGVjbHV0dGVyTW9kZX0gU2hhcGUncyBkZWNsdXR0ZXIgbW9kZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXREZWNsdXR0ZXJNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2x1dHRlck1vZGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IGluIHBpeGVscy4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW5jaG9yLlxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgZWxlbWVudCBmb3IgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgcGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsIHJhdGlvLlxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3RhdGUuXG4gICAqL1xuICBnZXRJbWFnZVN0YXRlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqL1xuICBnZXRJbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzeW1ib2xpemVyIChpbiBwaXhlbHMpLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRpc3BsYWNlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkaXNwbGFjZW1lbnQgRGlzcGxhY2VtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXREaXNwbGFjZW1lbnQoZGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRfID0gZGlzcGxhY2VtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5vcGFjaXR5XyA9IG9wYWNpdHk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdG8gcm90YXRlIHRoZSBzdHlsZSB3aXRoIHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvdGF0ZVdpdGhWaWV3IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRlV2l0aFZpZXcocm90YXRlV2l0aFZpZXcpIHtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHJvdGF0ZVdpdGhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcm90YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgdW5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gYGZhbHNlYCBvciBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc3R5bGUgaXMgcmVhZHkgdG8gdXNlLlxuICAgKi9cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlU3R5bGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvUmVndWxhclNoYXBlXG4gKi9cblxuaW1wb3J0IEljb25JbWFnZSBmcm9tICcuL0ljb25JbWFnZS5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0TGluZUNhcCxcbiAgZGVmYXVsdExpbmVKb2luLFxuICBkZWZhdWx0TGluZVdpZHRoLFxuICBkZWZhdWx0TWl0ZXJMaW1pdCxcbiAgZGVmYXVsdFN0cm9rZVN0eWxlLFxufSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCB7c2hhcmVkIGFzIGljb25JbWFnZUNhY2hlfSBmcm9tICcuL0ljb25JbWFnZUNhY2hlLmpzJztcblxuLyoqXG4gKiBTcGVjaWZ5IHJhZGl1cyBmb3IgcmVndWxhciBwb2x5Z29ucywgb3IgYm90aCByYWRpdXMgYW5kIHJhZGl1czIgZm9yIHN0YXJzLlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9pbnRzIE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLiBJbiBjYXNlIG9mIGEgcG9seWdvbiwgdGhlIG51bWJlciBvZiBwb2ludHNcbiAqIGlzIHRoZSBudW1iZXIgb2Ygc2lkZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMl0gU2Vjb25kIHJhZGl1cyB0byBtYWtlIGEgc3RhciBpbnN0ZWFkIG9mIGEgcmVndWxhciBwb2x5Z29uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthbmdsZT0wXSBTaGFwZSdzIGFuZ2xlIGluIHJhZGlhbnMuIEEgdmFsdWUgb2YgMCB3aWxsIGhhdmUgb25lIG9mIHRoZSBzaGFwZSdzIHBvaW50cyBmYWNpbmcgdXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtkaXNwbGFjZW1lbnQ9WzAsIDBdXSBEaXNwbGFjZW1lbnQgb2YgdGhlIHNoYXBlIGluIHBpeGVscy5cbiAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIHNoaWZ0IHRoZSBzaGFwZSByaWdodCBhbmQgdXAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb249MF0gUm90YXRpb24gaW4gcmFkaWFucyAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgc2hhcGUgd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlPTFdIFNjYWxlLiBVbmxlc3MgdHdvIGRpbWVuc2lvbmFsIHNjYWxpbmcgaXMgcmVxdWlyZWQgYSBiZXR0ZXJcbiAqIHJlc3VsdCBtYXkgYmUgb2J0YWluZWQgd2l0aCBhcHByb3ByaWF0ZSBzZXR0aW5ncyBmb3IgYHJhZGl1c2AgYW5kIGByYWRpdXMyYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL1N0eWxlLmpzJykuRGVjbHV0dGVyTW9kZX0gW2RlY2x1dHRlck1vZGVdIERlY2x1dHRlciBtb2RlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfHVuZGVmaW5lZH0gc3Ryb2tlU3R5bGUgU3Ryb2tlU3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3Ryb2tlV2lkdGggU3Ryb2tlV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBTaXplLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBsaW5lQ2FwIExpbmVDYXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj58bnVsbH0gbGluZURhc2ggTGluZURhc2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXQgTGluZURhc2hPZmZzZXQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBsaW5lSm9pbiBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0IE1pdGVyTGltaXQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgcmVndWxhciBzaGFwZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLiBUaGUgcmVzdWx0aW5nIHNoYXBlIHdpbGwgYmVcbiAqIGEgcmVndWxhciBwb2x5Z29uIHdoZW4gYHJhZGl1c2AgaXMgcHJvdmlkZWQsIG9yIGEgc3RhciB3aGVuIGJvdGggYHJhZGl1c2AgYW5kXG4gKiBgcmFkaXVzMmAgYXJlIHByb3ZpZGVkLlxuICogQGFwaVxuICovXG5jbGFzcyBSZWd1bGFyU2hhcGUgZXh0ZW5kcyBJbWFnZVN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICByb3RhdGVXaXRoVmlldzpcbiAgICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlLFxuICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwLFxuICAgICAgc2NhbGU6IG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2NhbGUgOiAxLFxuICAgICAgZGlzcGxhY2VtZW50OlxuICAgICAgICBvcHRpb25zLmRpc3BsYWNlbWVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kaXNwbGFjZW1lbnQgOiBbMCwgMF0sXG4gICAgICBkZWNsdXR0ZXJNb2RlOiBvcHRpb25zLmRlY2x1dHRlck1vZGUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbF8gPSBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZmlsbCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50c18gPSBvcHRpb25zLnBvaW50cztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzMl8gPSBvcHRpb25zLnJhZGl1czI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZV8gPSBvcHRpb25zLmFuZ2xlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuZ2xlIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyT3B0aW9uc187XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPVxuICAgICAgdGhpcy5maWxsXyAmJiB0aGlzLmZpbGxfLmxvYWRpbmcoKVxuICAgICAgICA/IEltYWdlU3RhdGUuTE9BRElOR1xuICAgICAgICA6IEltYWdlU3RhdGUuTE9BREVEO1xuICAgIGlmICh0aGlzLmltYWdlU3RhdGVfID09PSBJbWFnZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgIHRoaXMucmVhZHkoKS50aGVuKCgpID0+ICh0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FERUQpKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtSZWd1bGFyU2hhcGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICBjb25zdCBzdHlsZSA9IG5ldyBSZWd1bGFyU2hhcGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcG9pbnRzOiB0aGlzLmdldFBvaW50cygpLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgcmFkaXVzMjogdGhpcy5nZXRSYWRpdXMyKCksXG4gICAgICBhbmdsZTogdGhpcy5nZXRBbmdsZSgpLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBzY2FsZTogQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGUsXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICAgIHN0eWxlLnNldE9wYWNpdHkodGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBpbiBwaXhlbHMuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAgICogc3ltYm9saXplci5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW5jaG9yLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemVfO1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCk7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlQXJyYXkoKTtcbiAgICAvLyBhbmNob3IgaXMgc2NhbGVkIGJ5IHJlbmRlcmVyIGJ1dCBkaXNwbGFjZW1lbnQgc2hvdWxkIG5vdCBiZSBzY2FsZWRcbiAgICAvLyBzbyBkaXZpZGUgYnkgc2NhbGUgaGVyZVxuICAgIHJldHVybiBbXG4gICAgICBzaXplWzBdIC8gMiAtIGRpc3BsYWNlbWVudFswXSAvIHNjYWxlWzBdLFxuICAgICAgc2l6ZVsxXSAvIDIgKyBkaXNwbGFjZW1lbnRbMV0gLyBzY2FsZVsxXSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5nbGUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBTaGFwZSdzIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLmFuZ2xlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18oXG4gICAgICAgIHRoaXMucmVuZGVyT3B0aW9uc18sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgaWNvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBjb25zdCBmaWxsS2V5ID0gdGhpcy5maWxsXz8uZ2V0S2V5KCk7XG4gICAgY29uc3QgY2FjaGVLZXkgPVxuICAgICAgYCR7cGl4ZWxSYXRpb30sJHt0aGlzLmFuZ2xlX30sJHt0aGlzLnJhZGl1c30sJHt0aGlzLnJhZGl1czJffSwke3RoaXMucG9pbnRzX30sJHtmaWxsS2V5fWAgK1xuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLnJlbmRlck9wdGlvbnNfKS5qb2luKCcsJyk7XG4gICAgbGV0IGltYWdlID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKFxuICAgICAgaWNvbkltYWdlQ2FjaGUuZ2V0KGNhY2hlS2V5LCBudWxsLCBudWxsKT8uZ2V0SW1hZ2UoMSlcbiAgICApO1xuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB0aGlzLnJlbmRlck9wdGlvbnNfO1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguY2VpbChyZW5kZXJPcHRpb25zLnNpemUgKiBwaXhlbFJhdGlvKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoc2l6ZSwgc2l6ZSk7XG4gICAgICB0aGlzLmRyYXdfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQsIHBpeGVsUmF0aW8pO1xuXG4gICAgICBpbWFnZSA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgaWNvbkltYWdlQ2FjaGUuc2V0KFxuICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3IEljb25JbWFnZShpbWFnZSwgdW5kZWZpbmVkLCBudWxsLCBJbWFnZVN0YXRlLkxPQURFRCwgbnVsbCksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBwaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gUGl4ZWwgcmF0aW8uXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEltYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VTdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWdpbi5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIHBvaW50cyBmb3IgZ2VuZXJhdGluZyB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHBvaW50cyBmb3Igc3RhcnMgYW5kIHJlZ3VsYXIgcG9seWdvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgKHByaW1hcnkpIHJhZGl1cyBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZGFyeSByYWRpdXMgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmFkaXVzMi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmFkaXVzMigpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXMyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIHN5bWJvbGl6ZXIgKGluIHBpeGVscykuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gU2l6ZS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJva2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3Ryb2tlIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuc3Ryb2tlXyA9IHN0cm9rZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBsaXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcikge31cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbG9hZCgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7fVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYWRkaXRpb25hbCBjYW52YXMgc2l6ZSBuZWVkZWQgZm9yIHRoZSBtaXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmVKb2luIExpbmUgam9pblxuICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlV2lkdGggU3Ryb2tlIHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaXRlckxpbWl0IE1pdGVyIGxpbWl0XG4gICAqIEByZXR1cm4ge251bWJlcn0gQWRkaXRpb25hbCBjYW52YXMgc2l6ZSBuZWVkZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZUxpbmVKb2luU2l6ZV8obGluZUpvaW4sIHN0cm9rZVdpZHRoLCBtaXRlckxpbWl0KSB7XG4gICAgaWYgKFxuICAgICAgc3Ryb2tlV2lkdGggPT09IDAgfHxcbiAgICAgIHRoaXMucG9pbnRzXyA9PT0gSW5maW5pdHkgfHxcbiAgICAgIChsaW5lSm9pbiAhPT0gJ2JldmVsJyAmJiBsaW5lSm9pbiAhPT0gJ21pdGVyJylcbiAgICApIHtcbiAgICAgIHJldHVybiBzdHJva2VXaWR0aDtcbiAgICB9XG4gICAgLy8gbSAgfCBeXG4gICAgLy8gaSAgfCB8XFwgICAgICAgICAgICAgICAgICAuXG4gICAgLy8gdCA+fCAgI1xcXG4gICAgLy8gZSAgfCB8XFwgXFwgICAgICAgICAgICAgIC5cbiAgICAvLyByICAgICAgXFxzXFxcbiAgICAvLyAgICAgIHwgIFxcdFxcICAgICAgICAgIC4gICAgICAgICAgICAgICAgIC5cbiAgICAvLyAgICAgICAgICBcXHJcXCAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgfCAgICBcXG9cXCAgICAgIC4gICAgICAgICAgLiAgLiAuIC5cbiAgICAvLyAgICAgICAgICBlIFxca1xcICAgICAgICAgICAgLiAgLiAgICAuIC5cbiAgICAvLyAgICAgIHwgICAgICBcXGVcXCAgLiAgICAuICAuICAgICAgIC4gLlxuICAgIC8vICAgICAgIGQgICAgICBcXCBcXCAgLiAgLiAgICAgICAgICAuIC5cbiAgICAvLyAgICAgIHwgXyBfYV8gX1xcIyAgLiAgICAgICAgICAgIC4gLlxuICAgIC8vICAgcjEgICAgICAgICAgLyBgICAgICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICAgYiAgICAgLyAgICAgICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgfCAgICAgICAgICAgICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgICAgICAvIHIyICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgLiAgIC5cbiAgICAvLyAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgfM6xICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICDCsCBjZW50ZXJcbiAgICBsZXQgcjEgPSB0aGlzLnJhZGl1cztcbiAgICBsZXQgcjIgPSB0aGlzLnJhZGl1czJfID09PSB1bmRlZmluZWQgPyByMSA6IHRoaXMucmFkaXVzMl87XG4gICAgaWYgKHIxIDwgcjIpIHtcbiAgICAgIGNvbnN0IHRtcCA9IHIxO1xuICAgICAgcjEgPSByMjtcbiAgICAgIHIyID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPVxuICAgICAgdGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkID8gdGhpcy5wb2ludHNfIDogdGhpcy5wb2ludHNfICogMjtcbiAgICBjb25zdCBhbHBoYSA9ICgyICogTWF0aC5QSSkgLyBwb2ludHM7XG4gICAgY29uc3QgYSA9IHIyICogTWF0aC5zaW4oYWxwaGEpO1xuICAgIGNvbnN0IGIgPSBNYXRoLnNxcnQocjIgKiByMiAtIGEgKiBhKTtcbiAgICBjb25zdCBkID0gcjEgLSBiO1xuICAgIGNvbnN0IGUgPSBNYXRoLnNxcnQoYSAqIGEgKyBkICogZCk7XG4gICAgY29uc3QgbWl0ZXJSYXRpbyA9IGUgLyBhO1xuICAgIGlmIChsaW5lSm9pbiA9PT0gJ21pdGVyJyAmJiBtaXRlclJhdGlvIDw9IG1pdGVyTGltaXQpIHtcbiAgICAgIHJldHVybiBtaXRlclJhdGlvICogc3Ryb2tlV2lkdGg7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSBjZW50ZXIgdG8gdGhlIHN0cm9rZSBjb3JuZXIgd2hlcmVcbiAgICAvLyBpdCB3YXMgY3V0IHNob3J0IGJlY2F1c2Ugb2YgdGhlIG1pdGVyIGxpbWl0LlxuICAgIC8vICAgICAgICAgICAgICBsXG4gICAgLy8gICAgICAgIC0tLS0rLS0tLSA8PSBkaXN0YW5jZSBmcm9tIGNlbnRlciB0byBoZXJlIGlzIG1heHJcbiAgICAvLyAgICAgICAvIyMjI3xrICMjXFxcbiAgICAvLyAgICAgIC8jIyMjI14jIyMjI1xcXG4gICAgLy8gICAgIC8jIyMjIC8rXFwjIHMgI1xcXG4gICAgLy8gICAgLyMjIyBoLysrK1xcIyB0ICNcXFxuICAgIC8vICAgLyMjIyB0LysrKysrXFwjIHIgI1xcXG4gICAgLy8gIC8jIyMgYS8rKysrKysrXFwjIG8gI1xcXG4gICAgLy8gLyMjIyBwLysrIGZpbGwgK1xcIyBrICNcXFxuICAgIC8vLyMjIyMgLysrKysrXisrKysrXFwjIGUgI1xcXG4gICAgLy8jIyMjIy8rKysrKy8rXFwrKysrK1xcIyMjIyNcXFxuICAgIGNvbnN0IGsgPSBzdHJva2VXaWR0aCAvIDIgLyBtaXRlclJhdGlvO1xuICAgIGNvbnN0IGwgPSAoc3Ryb2tlV2lkdGggLyAyKSAqIChkIC8gZSk7XG4gICAgY29uc3QgbWF4ciA9IE1hdGguc3FydCgocjEgKyBrKSAqIChyMSArIGspICsgbCAqIGwpO1xuICAgIGNvbnN0IGJldmVsQWRkID0gbWF4ciAtIHIxO1xuICAgIGlmICh0aGlzLnJhZGl1czJfID09PSB1bmRlZmluZWQgfHwgbGluZUpvaW4gPT09ICdiZXZlbCcpIHtcbiAgICAgIHJldHVybiBiZXZlbEFkZCAqIDI7XG4gICAgfVxuICAgIC8vIElmIG91dGVyIG1pdGVyIGlzIG92ZXIgdGhlIG1pdGVyIGxpbWl0IHRoZSBpbm5lciBtaXRlciBtYXkgcmVhY2ggdGhyb3VnaCB0aGVcbiAgICAvLyBjZW50ZXIgYW5kIGJlIGxvbmdlciB0aGFuIHRoZSBiZXZlbCwgc2FtZSBjYWxjdWxhdGlvbiBhcyBhYm92ZSBidXQgc3dhcCByMSAvIHIyLlxuICAgIGNvbnN0IGFhID0gcjEgKiBNYXRoLnNpbihhbHBoYSk7XG4gICAgY29uc3QgYmIgPSBNYXRoLnNxcnQocjEgKiByMSAtIGFhICogYWEpO1xuICAgIGNvbnN0IGRkID0gcjIgLSBiYjtcbiAgICBjb25zdCBlZSA9IE1hdGguc3FydChhYSAqIGFhICsgZGQgKiBkZCk7XG4gICAgY29uc3QgaW5uZXJNaXRlclJhdGlvID0gZWUgLyBhYTtcbiAgICBpZiAoaW5uZXJNaXRlclJhdGlvIDw9IG1pdGVyTGltaXQpIHtcbiAgICAgIGNvbnN0IGlubmVyTGVuZ3RoID0gKGlubmVyTWl0ZXJSYXRpbyAqIHN0cm9rZVdpZHRoKSAvIDIgLSByMiAtIHIxO1xuICAgICAgcmV0dXJuIDIgKiBNYXRoLm1heChiZXZlbEFkZCwgaW5uZXJMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gYmV2ZWxBZGQgKiAyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1JlbmRlck9wdGlvbnN9ICBUaGUgcmVuZGVyIG9wdGlvbnNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY3JlYXRlUmVuZGVyT3B0aW9ucygpIHtcbiAgICBsZXQgbGluZUNhcCA9IGRlZmF1bHRMaW5lQ2FwO1xuICAgIGxldCBsaW5lSm9pbiA9IGRlZmF1bHRMaW5lSm9pbjtcbiAgICBsZXQgbWl0ZXJMaW1pdCA9IDA7XG4gICAgbGV0IGxpbmVEYXNoID0gbnVsbDtcbiAgICBsZXQgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgIGxldCBzdHJva2VTdHlsZTtcbiAgICBsZXQgc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgc3Ryb2tlU3R5bGUgPSBhc0NvbG9yTGlrZSh0aGlzLnN0cm9rZV8uZ2V0Q29sb3IoKSA/PyBkZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZV8uZ2V0V2lkdGgoKSA/PyBkZWZhdWx0TGluZVdpZHRoO1xuICAgICAgbGluZURhc2ggPSB0aGlzLnN0cm9rZV8uZ2V0TGluZURhc2goKTtcbiAgICAgIGxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VfLmdldExpbmVEYXNoT2Zmc2V0KCkgPz8gMDtcbiAgICAgIGxpbmVKb2luID0gdGhpcy5zdHJva2VfLmdldExpbmVKb2luKCkgPz8gZGVmYXVsdExpbmVKb2luO1xuICAgICAgbGluZUNhcCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lQ2FwKCkgPz8gZGVmYXVsdExpbmVDYXA7XG4gICAgICBtaXRlckxpbWl0ID0gdGhpcy5zdHJva2VfLmdldE1pdGVyTGltaXQoKSA/PyBkZWZhdWx0TWl0ZXJMaW1pdDtcbiAgICB9XG5cbiAgICBjb25zdCBhZGQgPSB0aGlzLmNhbGN1bGF0ZUxpbmVKb2luU2l6ZV8obGluZUpvaW4sIHN0cm9rZVdpZHRoLCBtaXRlckxpbWl0KTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heCh0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMyXyB8fCAwKTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5jZWlsKDIgKiBtYXhSYWRpdXMgKyBhZGQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdHlsZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBsaW5lQ2FwOiBsaW5lQ2FwLFxuICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgbGluZUpvaW46IGxpbmVKb2luLFxuICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlck9wdGlvbnNfID0gdGhpcy5jcmVhdGVSZW5kZXJPcHRpb25zKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVuZGVyT3B0aW9uc18uc2l6ZTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBudWxsO1xuICAgIHRoaXMuc2l6ZV8gPSBbc2l6ZSwgc2l6ZV07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFRoZSBwaXhlbCByYXRpby5cbiAgICovXG4gIGRyYXdfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQsIHBpeGVsUmF0aW8pIHtcbiAgICBjb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIC8vIHNldCBvcmlnaW4gdG8gY2FudmFzIGNlbnRlclxuICAgIGNvbnRleHQudHJhbnNsYXRlKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIpO1xuXG4gICAgdGhpcy5jcmVhdGVQYXRoXyhjb250ZXh0KTtcblxuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICBsZXQgY29sb3IgPSB0aGlzLmZpbGxfLmdldENvbG9yKCk7XG4gICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgY29sb3IgPSBkZWZhdWx0RmlsbFN0eWxlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShjb2xvcik7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGUpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJPcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSByZW5kZXJPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHJlbmRlck9wdGlvbnMubGluZURhc2gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHJlbmRlck9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSByZW5kZXJPcHRpb25zLmxpbmVDYXA7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gcmVuZGVyT3B0aW9ucy5saW5lSm9pbjtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHJlbmRlck9wdGlvbnMubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcyBjb250YWluaW5nIHRoZSBpY29uXG4gICAqL1xuICBjcmVhdGVIaXREZXRlY3Rpb25DYW52YXNfKHJlbmRlck9wdGlvbnMpIHtcbiAgICBsZXQgY29udGV4dDtcbiAgICBpZiAodGhpcy5maWxsXykge1xuICAgICAgbGV0IGNvbG9yID0gdGhpcy5maWxsXy5nZXRDb2xvcigpO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgaWYgZmlsbCBpcyB0cmFuc3BhcmVudCAob3IgcGF0dGVybiBvciBncmFkaWVudClcbiAgICAgIGxldCBvcGFjaXR5ID0gMDtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbG9yID0gYXNBcnJheShjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgIG9wYWNpdHkgPSBjb2xvci5sZW5ndGggPT09IDQgPyBjb2xvclszXSA6IDE7XG4gICAgICB9XG4gICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAvLyBpZiBhIHRyYW5zcGFyZW50IGZpbGwgc3R5bGUgaXMgc2V0LCBjcmVhdGUgYW4gZXh0cmEgaGl0LWRldGVjdGlvbiBpbWFnZVxuICAgICAgICAvLyB3aXRoIGEgZGVmYXVsdCBmaWxsIHN0eWxlXG4gICAgICAgIGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQocmVuZGVyT3B0aW9ucy5zaXplLCByZW5kZXJPcHRpb25zLnNpemUpO1xuICAgICAgICB0aGlzLmRyYXdIaXREZXRlY3Rpb25DYW52YXNfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuY2FudmFzIDogdGhpcy5nZXRJbWFnZSgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dCB0byBkcmF3IGluLlxuICAgKi9cbiAgY3JlYXRlUGF0aF8oY29udGV4dCkge1xuICAgIGxldCBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgaWYgKHBvaW50cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByYWRpdXMyID0gdGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkID8gcmFkaXVzIDogdGhpcy5yYWRpdXMyXztcbiAgICAgIGlmICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnRzICo9IDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5hbmdsZV8gLSBNYXRoLlBJIC8gMjtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoMiAqIE1hdGguUEkpIC8gcG9pbnRzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHM7IGkrKykge1xuICAgICAgICBjb25zdCBhbmdsZTAgPSBzdGFydEFuZ2xlICsgaSAqIHN0ZXA7XG4gICAgICAgIGNvbnN0IHJhZGl1c0MgPSBpICUgMiA9PT0gMCA/IHJhZGl1cyA6IHJhZGl1czI7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHJhZGl1c0MgKiBNYXRoLmNvcyhhbmdsZTApLCByYWRpdXNDICogTWF0aC5zaW4oYW5nbGUwKSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnMgUmVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IFRoZSBjb250ZXh0LlxuICAgKi9cbiAgZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCkge1xuICAgIC8vIHNldCBvcmlnaW4gdG8gY2FudmFzIGNlbnRlclxuICAgIGNvbnRleHQudHJhbnNsYXRlKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIpO1xuXG4gICAgdGhpcy5jcmVhdGVQYXRoXyhjb250ZXh0KTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5zdHJva2VTdHlsZSkge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSByZW5kZXJPcHRpb25zLmxpbmVKb2luO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gcmVuZGVyT3B0aW9ucy5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXyA/IHRoaXMuZmlsbF8ucmVhZHkoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlZ3VsYXJTaGFwZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9TdHJva2VcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2NvbG9yXSBBIGNvbG9yLCBncmFkaWVudCBvciBwYXR0ZXJuLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGZvciBwb3NzaWJsZSBmb3JtYXRzLlxuICogRGVmYXVsdCBudWxsOyBpZiBudWxsLCB0aGUgQ2FudmFzL3JlbmRlcmVyIGRlZmF1bHQgYmxhY2sgd2lsbCBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBbbGluZUNhcD0ncm91bmQnXSBMaW5lIGNhcCBzdHlsZTogYGJ1dHRgLCBgcm91bmRgLCBvciBgc3F1YXJlYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFtsaW5lSm9pbj0ncm91bmQnXSBMaW5lIGpvaW4gc3R5bGU6IGBiZXZlbGAsIGByb3VuZGAsIG9yIGBtaXRlcmAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtsaW5lRGFzaF0gTGluZSBkYXNoIHBhdHRlcm4uIERlZmF1bHQgaXMgYG51bGxgIChubyBkYXNoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZURhc2hPZmZzZXQ9MF0gTGluZSBkYXNoIG9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWl0ZXJMaW1pdD0xMF0gTWl0ZXIgbGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXSBXaWR0aC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBzdHJva2Ugc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIE5vdGUgdGhhdCB0aGUgZGVmYXVsdHMgZ2l2ZW4gYXJlIHRoZSBDYW52YXMgZGVmYXVsdHMsIHdoaWNoIHdpbGwgYmUgdXNlZCBpZlxuICogb3B0aW9uIGlzIG5vdCBkZWZpbmVkLiBUaGUgYGdldGAgZnVuY3Rpb25zIHJldHVybiB3aGF0ZXZlciB3YXMgZW50ZXJlZCBpblxuICogdGhlIG9wdGlvbnM7IHRoZXkgd2lsbCBub3QgcmV0dXJuIHRoZSBkZWZhdWx0LlxuICogQGFwaVxuICovXG5jbGFzcyBTdHJva2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc0xpbmVDYXB8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZUNhcF8gPSBvcHRpb25zLmxpbmVDYXA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5saW5lRGFzaF8gPSBvcHRpb25zLmxpbmVEYXNoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxpbmVEYXNoIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5saW5lRGFzaE9mZnNldF8gPSBvcHRpb25zLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzTGluZUpvaW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZUpvaW5fID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5taXRlckxpbWl0XyA9IG9wdGlvbnMubWl0ZXJMaW1pdDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy53aWR0aF8gPSBvcHRpb25zLndpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge1N0cm9rZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJva2Uoe1xuICAgICAgY29sb3I6IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3Iuc2xpY2UoKSA6IGNvbG9yIHx8IHVuZGVmaW5lZCxcbiAgICAgIGxpbmVDYXA6IHRoaXMuZ2V0TGluZUNhcCgpLFxuICAgICAgbGluZURhc2g6IHRoaXMuZ2V0TGluZURhc2goKSA/IHRoaXMuZ2V0TGluZURhc2goKS5zbGljZSgpIDogdW5kZWZpbmVkLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMuZ2V0TGluZURhc2hPZmZzZXQoKSxcbiAgICAgIGxpbmVKb2luOiB0aGlzLmdldExpbmVKb2luKCksXG4gICAgICBtaXRlckxpbWl0OiB0aGlzLmdldE1pdGVyTGltaXQoKSxcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2UgY29sb3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGNhcCB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtDYW52YXNMaW5lQ2FwfHVuZGVmaW5lZH0gTGluZSBjYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVDYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZUNhcF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGRhc2ggc3R5bGUgZm9yIHRoZSBzdHJva2UuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58bnVsbH0gTGluZSBkYXNoLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0IGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBMaW5lIGRhc2ggb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaE9mZnNldF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGpvaW4gdHlwZSBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7Q2FudmFzTGluZUpvaW58dW5kZWZpbmVkfSBMaW5lIGpvaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVKb2luKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVKb2luXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pdGVyIGxpbWl0IGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNaXRlciBsaW1pdC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5taXRlckxpbWl0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSB3aWR0aC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gV2lkdGguXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGNvbG9yIENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb2xvcihjb2xvcikge1xuICAgIHRoaXMuY29sb3JfID0gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGNhcC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNMaW5lQ2FwfHVuZGVmaW5lZH0gbGluZUNhcCBMaW5lIGNhcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZUNhcChsaW5lQ2FwKSB7XG4gICAgdGhpcy5saW5lQ2FwXyA9IGxpbmVDYXA7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGRhc2guXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxudWxsfSBsaW5lRGFzaCBMaW5lIGRhc2guXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVEYXNoKGxpbmVEYXNoKSB7XG4gICAgdGhpcy5saW5lRGFzaF8gPSBsaW5lRGFzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpbmUgZGFzaCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gbGluZURhc2hPZmZzZXQgTGluZSBkYXNoIG9mZnNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpIHtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA9IGxpbmVEYXNoT2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGluZSBqb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc0xpbmVKb2lufHVuZGVmaW5lZH0gbGluZUpvaW4gTGluZSBqb2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMaW5lSm9pbihsaW5lSm9pbikge1xuICAgIHRoaXMubGluZUpvaW5fID0gbGluZUpvaW47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaXRlciBsaW1pdC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBtaXRlckxpbWl0IE1pdGVyIGxpbWl0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaXRlckxpbWl0KG1pdGVyTGltaXQpIHtcbiAgICB0aGlzLm1pdGVyTGltaXRfID0gbWl0ZXJMaW1pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdpZHRoLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHdpZHRoIFdpZHRoLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIHRoaXMud2lkdGhfID0gd2lkdGg7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3Ryb2tlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1N0eWxlXG4gKi9cblxuaW1wb3J0IENpcmNsZVN0eWxlIGZyb20gJy4vQ2lyY2xlLmpzJztcbmltcG9ydCBGaWxsIGZyb20gJy4vRmlsbC5qcyc7XG5pbXBvcnQgU3Ryb2tlIGZyb20gJy4vU3Ryb2tlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBEZWZpbmVzIGhvdyBzeW1ib2xzIGFuZCB0ZXh0IGFyZSBkZWNsdXR0ZXJlZCBvbiBsYXllcnMgaXRoIGBkZWNsdXR0ZXJgIHNldCB0byBgdHJ1ZWBcbiAqICogKipkZWNsdXR0ZXIqKjogT3ZlcmxhcHBpbmcgc3ltYm9scyBhbmQgdGV4dCBhcmUgZGVjbHV0dGVyZWQuXG4gKiAqICoqb2JzdGFjbGUqKjogU3ltYm9scyBhbmQgdGV4dCBhcmUgcmVuZGVyZWQsIGJ1dCBzZXJ2ZSBhcyBvYnN0YWNsZSBmb3Igc3Vic2VxdWVudCBhdHRlbXB0c1xuICogICB0byBwbGFjZSBhIHN5bWJvbCBvciB0ZXh0IGF0IHRoZSBzYW1lIGxvY2F0aW9uLlxuICogKiAqKm5vbmUqKjogTm8gZGVjbHV0dGVyaW5nIGlzIGRvbmUuXG4gKlxuICogQHR5cGVkZWYge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifSBEZWNsdXR0ZXJNb2RlXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gYW5kIGEgYHtudW1iZXJ9YFxuICogcmVwcmVzZW50aW5nIHRoZSB2aWV3J3MgcmVzb2x1dGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYVxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX0gb3IgYW4gYXJyYXkgb2YgdGhlbS4gVGhpcyB3YXkgZS5nLiBhXG4gKiB2ZWN0b3IgbGF5ZXIgY2FuIGJlIHN0eWxlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZVxuICogZmVhdHVyZSB3aWxsIG5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgbnVtYmVyKTooU3R5bGV8QXJyYXk8U3R5bGU+fHZvaWQpfSBTdHlsZUZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHtAbGluayBTdHlsZX0sIGFuIGFycmF5IG9mIHtAbGluayBTdHlsZX0sIG9yIGEge0BsaW5rIFN0eWxlRnVuY3Rpb259LlxuICogQHR5cGVkZWYge1N0eWxlfEFycmF5PFN0eWxlPnxTdHlsZUZ1bmN0aW9ufSBTdHlsZUxpa2VcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJucyBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYW5kIHN0eWxlZCBmb3IgdGhlIGZlYXR1cmUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UpOlxuICogICAgIChpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWQpfSBHZW9tZXRyeUZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uIFRha2VzIHR3byBhcmd1bWVudHM6XG4gKlxuICogMS4gVGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBnZW9tZXRyeSBpbiBHZW9KU09OIG5vdGF0aW9uLlxuICogMi4gVGhlIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyflN0YXRlfSBvZiB0aGUgbGF5ZXIgcmVuZGVyZXIuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+PnxBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj4pLGltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5TdGF0ZSk6IHZvaWR9IFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn0gW2dlb21ldHJ5XSBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5XG4gKiBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBnZW9tZXRyeSB0byByZW5kZXIgZm9yIHRoaXMgc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBbaW1hZ2VdIEltYWdlIHN0eWxlLlxuICogQHByb3BlcnR5IHtSZW5kZXJGdW5jdGlvbn0gW3JlbmRlcmVyXSBDdXN0b20gcmVuZGVyZXIuIFdoZW4gY29uZmlndXJlZCwgYGZpbGxgLCBgc3Ryb2tlYCBhbmQgYGltYWdlYCB3aWxsIGJlXG4gKiBpZ25vcmVkLCBhbmQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggZWFjaCByZW5kZXIgZnJhbWUgZm9yIGVhY2ggZ2VvbWV0cnkuXG4gKiBAcHJvcGVydHkge1JlbmRlckZ1bmN0aW9ufSBbaGl0RGV0ZWN0aW9uUmVuZGVyZXJdIEN1c3RvbSByZW5kZXJlciBmb3IgaGl0IGRldGVjdGlvbi4gSWYgcHJvdmlkZWQgd2lsbCBiZSB1c2VkXG4gKiBpbiBoaXQgZGV0ZWN0aW9uIHJlbmRlcmluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gW3RleHRdIFRleHQgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gWiBpbmRleC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRhaW5lciBmb3IgdmVjdG9yIGZlYXR1cmUgcmVuZGVyaW5nIHN0eWxlcy4gQW55IGNoYW5nZXMgbWFkZSB0byB0aGUgc3R5bGVcbiAqIG9yIGl0cyBjaGlsZHJlbiB0aHJvdWdoIGBzZXQqKClgIG1ldGhvZHMgd2lsbCBub3QgdGFrZSBlZmZlY3QgdW50aWwgdGhlXG4gKiBmZWF0dXJlIG9yIGxheWVyIHRoYXQgdXNlcyB0aGUgc3R5bGUgaXMgcmUtcmVuZGVyZWQuXG4gKlxuICogIyMgRmVhdHVyZSBzdHlsZXNcbiAqXG4gKiBJZiBubyBzdHlsZSBpcyBkZWZpbmVkLCB0aGUgZm9sbG93aW5nIGRlZmF1bHQgc3R5bGUgaXMgdXNlZDpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtDaXJjbGUsIEZpbGwsIFN0cm9rZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlLmpzJztcbiAqXG4gKiAgY29uc3QgZmlsbCA9IG5ldyBGaWxsKHtcbiAqICAgIGNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyxcbiAqICB9KTtcbiAqICBjb25zdCBzdHJva2UgPSBuZXcgU3Ryb2tlKHtcbiAqICAgIGNvbG9yOiAnIzMzOTlDQycsXG4gKiAgICB3aWR0aDogMS4yNSxcbiAqICB9KTtcbiAqICBjb25zdCBzdHlsZXMgPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBpbWFnZTogbmV3IENpcmNsZSh7XG4gKiAgICAgICAgZmlsbDogZmlsbCxcbiAqICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAqICAgICAgICByYWRpdXM6IDUsXG4gKiAgICAgIH0pLFxuICogICAgICBmaWxsOiBmaWxsLFxuICogICAgICBzdHJva2U6IHN0cm9rZSxcbiAqICAgIH0pLFxuICogIF07XG4gKiBgYGBcbiAqXG4gKiBBIHNlcGFyYXRlIGVkaXRpbmcgc3R5bGUgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdHM6XG4gKiBgYGBqc1xuICogIGltcG9ydCB7Q2lyY2xlLCBGaWxsLCBTdHJva2UsIFN0eWxlfSBmcm9tICdvbC9zdHlsZS5qcyc7XG4gKlxuICogIGNvbnN0IHN0eWxlcyA9IHt9O1xuICogIGNvbnN0IHdoaXRlID0gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICogIGNvbnN0IGJsdWUgPSBbMCwgMTUzLCAyNTUsIDFdO1xuICogIGNvbnN0IHdpZHRoID0gMztcbiAqICBzdHlsZXNbJ1BvbHlnb24nXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTUsIDAuNV0sXG4gKiAgICAgIH0pLFxuICogICAgfSksXG4gKiAgXTtcbiAqICBzdHlsZXNbJ011bHRpUG9seWdvbiddID1cbiAqICAgICAgc3R5bGVzWydQb2x5Z29uJ107XG4gKiAgc3R5bGVzWydMaW5lU3RyaW5nJ10gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGggKyAyLFxuICogICAgICB9KSxcbiAqICAgIH0pLFxuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICBjb2xvcjogYmx1ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGgsXG4gKiAgICAgIH0pLFxuICogICAgfSksXG4gKiAgXTtcbiAqICBzdHlsZXNbJ011bHRpTGluZVN0cmluZyddID0gc3R5bGVzWydMaW5lU3RyaW5nJ107XG4gKlxuICogIHN0eWxlc1snQ2lyY2xlJ10gPSBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoXG4gKiAgICBzdHlsZXNbJ0xpbmVTdHJpbmcnXVxuICogICk7XG4gKlxuICogIHN0eWxlc1snUG9pbnQnXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICByYWRpdXM6IHdpZHRoICogMixcbiAqICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gKiAgICAgICAgICBjb2xvcjogYmx1ZSxcbiAqICAgICAgICB9KSxcbiAqICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgICAgY29sb3I6IHdoaXRlLFxuICogICAgICAgICAgd2lkdGg6IHdpZHRoIC8gMixcbiAqICAgICAgICB9KSxcbiAqICAgICAgfSksXG4gKiAgICAgIHpJbmRleDogSW5maW5pdHksXG4gKiAgICB9KSxcbiAqICBdO1xuICogIHN0eWxlc1snTXVsdGlQb2ludCddID1cbiAqICAgICAgc3R5bGVzWydQb2ludCddO1xuICogIHN0eWxlc1snR2VvbWV0cnlDb2xsZWN0aW9uJ10gPVxuICogICAgICBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoXG4gKiAgICAgICAgICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSxcbiAqICAgICAgICAgIHN0eWxlc1snUG9pbnQnXVxuICogICAgICApO1xuICogYGBgXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBTdHlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufG51bGx9XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUdlb21ldHJ5RnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uO1xuXG4gICAgaWYgKG9wdGlvbnMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRHZW9tZXRyeShvcHRpb25zLmdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbF8gPSBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZmlsbCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG9wdGlvbnMuaW1hZ2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW1hZ2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyRnVuY3Rpb258bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IG9wdGlvbnMucmVuZGVyZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyZXIgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyRnVuY3Rpb258bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvblJlbmRlcmVyXyA9XG4gICAgICBvcHRpb25zLmhpdERldGVjdGlvblJlbmRlcmVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmhpdERldGVjdGlvblJlbmRlcmVyXG4gICAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gb3B0aW9ucy50ZXh0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRleHQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnpJbmRleF8gPSBvcHRpb25zLnpJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgbGV0IGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSAmJiB0eXBlb2YgZ2VvbWV0cnkgPT09ICdvYmplY3QnKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3R5bGUoe1xuICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5ID8/IHVuZGVmaW5lZCxcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIGltYWdlOiB0aGlzLmdldEltYWdlKCkgPyB0aGlzLmdldEltYWdlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlcmVyOiB0aGlzLmdldFJlbmRlcmVyKCkgPz8gdW5kZWZpbmVkLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdGhpcy5nZXRUZXh0KCkgPyB0aGlzLmdldFRleHQoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgekluZGV4OiB0aGlzLmdldFpJbmRleCgpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIHRoYXQgd2FzIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiB7QGxpbmsgI3NldFJlbmRlcmVyfSBvciB0aGUgYHJlbmRlcmVyYCBjb25zdHJ1Y3RvciBvcHRpb24uXG4gICAqIEByZXR1cm4ge1JlbmRlckZ1bmN0aW9ufG51bGx9IEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gZm9yIHRoaXMgc3R5bGUuIFdoZW4gc2V0LCBgZmlsbGAsIGBzdHJva2VgXG4gICAqIGFuZCBgaW1hZ2VgIG9wdGlvbnMgb2YgdGhlIHN0eWxlIHdpbGwgYmUgaWdub3JlZC5cbiAgICogQHBhcmFtIHtSZW5kZXJGdW5jdGlvbnxudWxsfSByZW5kZXJlciBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlcl8gPSByZW5kZXJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIGZvciB0aGlzIHN0eWxlIHVzZWRcbiAgICogaW4gaGl0IGRldGVjdGlvbi5cbiAgICogQHBhcmFtIHtSZW5kZXJGdW5jdGlvbnxudWxsfSByZW5kZXJlciBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEhpdERldGVjdGlvblJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25SZW5kZXJlcl8gPSByZW5kZXJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiB0aGF0IHdhcyBjb25maWd1cmVkIHdpdGhcbiAgICoge0BsaW5rICNzZXRIaXREZXRlY3Rpb25SZW5kZXJlcn0gb3IgdGhlIGBoaXREZXRlY3Rpb25SZW5kZXJlcmAgY29uc3RydWN0b3Igb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJGdW5jdGlvbnxudWxsfSBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEhpdERldGVjdGlvblJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLmhpdERldGVjdGlvblJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGdlb21ldHJ5IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb258bnVsbH1cbiAgICogRmVhdHVyZSBwcm9wZXJ0eSBvciBnZW9tZXRyeSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGdlb21ldHJ5IHRoYXQgd2lsbFxuICAgKiBiZSByZW5kZXJlZCB3aXRoIHRoaXMgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgYSBnZW9tZXRyeSBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcmV0dXJuIHshR2VvbWV0cnlGdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhIGZlYXR1cmVcbiAgICogYW5kIHJldHVybnMgdGhlIGdlb21ldHJ5IHRvIHJlbmRlciBpbnN0ZWFkIG9mIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJ5RnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfSBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmlsbCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfSBmaWxsIEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEZpbGwoZmlsbCkge1xuICAgIHRoaXMuZmlsbF8gPSBmaWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2Ugc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdHxudWxsfSBJbWFnZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1hZ2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBpbWFnZSBJbWFnZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0SW1hZ2UoaW1hZ2UpIHtcbiAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3Ryb2tlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCBzdHlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR8bnVsbH0gVGV4dCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9IHRleHQgVGV4dCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGV4dCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0XyA9IHRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB6LWluZGV4IGZvciB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFpJbmRleC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0WkluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnpJbmRleF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgZ2VvbWV0cnkgdGhhdCBpcyByZW5kZXJlZCBpbnN0ZWFkIG9mIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufSBnZW9tZXRyeVxuICAgKiAgICAgRmVhdHVyZSBwcm9wZXJ0eSBvciBnZW9tZXRyeSBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBnZW9tZXRyeSB0byByZW5kZXJcbiAgICogICAgIGZvciB0aGlzIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGlmICh0eXBlb2YgZ2VvbWV0cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBnZW9tZXRyeTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBmZWF0dXJlLmdldChnZW9tZXRyeSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBkZWZhdWx0R2VvbWV0cnlGdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZ2VvbWV0cnlfID0gZ2VvbWV0cnk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB6LWluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHpJbmRleCBaSW5kZXguXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFpJbmRleCh6SW5kZXgpIHtcbiAgICB0aGlzLnpJbmRleF8gPSB6SW5kZXg7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwcm92aWRlZCBvYmplY3QgaW50byBhIHN0eWxlIGZ1bmN0aW9uLiAgRnVuY3Rpb25zIHBhc3NlZCB0aHJvdWdoXG4gKiB1bmNoYW5nZWQuICBBcnJheXMgb2YgU3R5bGUgb3Igc2luZ2xlIHN0eWxlIG9iamVjdHMgd3JhcHBlZCBpbiBhXG4gKiBuZXcgc3R5bGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0eWxlRnVuY3Rpb258QXJyYXk8U3R5bGU+fFN0eWxlfSBvYmpcbiAqICAgICBBIHN0eWxlIGZ1bmN0aW9uLCBhIHNpbmdsZSBzdHlsZSwgb3IgYW4gYXJyYXkgb2Ygc3R5bGVzLlxuICogQHJldHVybiB7U3R5bGVGdW5jdGlvbn0gQSBzdHlsZSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRnVuY3Rpb24ob2JqKSB7XG4gIGxldCBzdHlsZUZ1bmN0aW9uO1xuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGVGdW5jdGlvbiA9IG9iajtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgICAqL1xuICAgIGxldCBzdHlsZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgc3R5bGVzID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob2JqKS5nZXRaSW5kZXgpID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAnRXhwZWN0ZWQgYW4gYFN0eWxlYCBvciBhbiBhcnJheSBvZiBgU3R5bGVgJyxcbiAgICAgICk7XG4gICAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7U3R5bGV9ICovIChvYmopO1xuICAgICAgc3R5bGVzID0gW3N0eWxlXTtcbiAgICB9XG4gICAgc3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3R5bGVGdW5jdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8U3R5bGU+fG51bGx9XG4gKi9cbmxldCBkZWZhdWx0U3R5bGVzID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxTdHlsZT59IFN0eWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFN0eWxlKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgLy8gV2UgZG9uJ3QgdXNlIGFuIGltbWVkaWF0ZWx5LWludm9rZWQgZnVuY3Rpb25cbiAgLy8gYW5kIGEgY2xvc3VyZSBzbyB3ZSBkb24ndCBnZXQgYW4gZXJyb3IgYXQgc2NyaXB0IGV2YWx1YXRpb24gdGltZSBpblxuICAvLyBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IENhbnZhcy4gKGltcG9ydChcIi4vQ2lyY2xlLmpzXCIpLkNpcmNsZVN0eWxlIGRvZXNcbiAgLy8gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXQgY29uc3RydWN0aW9uIHRpbWUsIHdoaWNoIHdpbGwgY2F1c2UgYW4uZXJyb3JcbiAgLy8gaW4gc3VjaCBicm93c2Vycy4pXG4gIGlmICghZGVmYXVsdFN0eWxlcykge1xuICAgIGNvbnN0IGZpbGwgPSBuZXcgRmlsbCh7XG4gICAgICBjb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScsXG4gICAgfSk7XG4gICAgY29uc3Qgc3Ryb2tlID0gbmV3IFN0cm9rZSh7XG4gICAgICBjb2xvcjogJyMzMzk5Q0MnLFxuICAgICAgd2lkdGg6IDEuMjUsXG4gICAgfSk7XG4gICAgZGVmYXVsdFN0eWxlcyA9IFtcbiAgICAgIG5ldyBTdHlsZSh7XG4gICAgICAgIGltYWdlOiBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgcmFkaXVzOiA1LFxuICAgICAgICB9KSxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICB9KSxcbiAgICBdO1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3R5bGVzO1xufVxuXG4vKipcbiAqIERlZmF1bHQgc3R5bGVzIGZvciBlZGl0aW5nIGZlYXR1cmVzLlxuICogQHJldHVybiB7T2JqZWN0PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuVHlwZSwgQXJyYXk8U3R5bGU+Pn0gU3R5bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGl0aW5nU3R5bGUoKSB7XG4gIC8qKiBAdHlwZSB7T2JqZWN0PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuVHlwZSwgQXJyYXk8U3R5bGU+Pn0gKi9cbiAgY29uc3Qgc3R5bGVzID0ge307XG4gIGNvbnN0IHdoaXRlID0gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICBjb25zdCBibHVlID0gWzAsIDE1MywgMjU1LCAxXTtcbiAgY29uc3Qgd2lkdGggPSAzO1xuICBzdHlsZXNbJ1BvbHlnb24nXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTUsIDAuNV0sXG4gICAgICB9KSxcbiAgICB9KSxcbiAgXTtcbiAgc3R5bGVzWydNdWx0aVBvbHlnb24nXSA9IHN0eWxlc1snUG9seWdvbiddO1xuXG4gIHN0eWxlc1snTGluZVN0cmluZyddID0gW1xuICAgIG5ldyBTdHlsZSh7XG4gICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICBjb2xvcjogd2hpdGUsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArIDIsXG4gICAgICB9KSxcbiAgICB9KSxcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgY29sb3I6IGJsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIH0pLFxuICAgIH0pLFxuICBdO1xuICBzdHlsZXNbJ011bHRpTGluZVN0cmluZyddID0gc3R5bGVzWydMaW5lU3RyaW5nJ107XG5cbiAgc3R5bGVzWydDaXJjbGUnXSA9IHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChzdHlsZXNbJ0xpbmVTdHJpbmcnXSk7XG5cbiAgc3R5bGVzWydQb2ludCddID0gW1xuICAgIG5ldyBTdHlsZSh7XG4gICAgICBpbWFnZTogbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgICAgcmFkaXVzOiB3aWR0aCAqIDIsXG4gICAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAgICAgICAgICBjb2xvcjogYmx1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgICAgY29sb3I6IHdoaXRlLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIDIsXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgICB6SW5kZXg6IEluZmluaXR5LFxuICAgIH0pLFxuICBdO1xuICBzdHlsZXNbJ011bHRpUG9pbnQnXSA9IHN0eWxlc1snUG9pbnQnXTtcblxuICBzdHlsZXNbJ0dlb21ldHJ5Q29sbGVjdGlvbiddID0gc3R5bGVzWydQb2x5Z29uJ10uY29uY2F0KFxuICAgIHN0eWxlc1snTGluZVN0cmluZyddLFxuICAgIHN0eWxlc1snUG9pbnQnXSxcbiAgKTtcblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlIGFuZCByZXR1cm5zIGl0cyBkZWZhdWx0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUgdG8gZ2V0IHRoZSBnZW9tZXRyeSBmb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IEdlb21ldHJ5IHRvIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb24oZmVhdHVyZSkge1xuICByZXR1cm4gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdHlsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9UZXh0XG4gKi9cbmltcG9ydCBGaWxsIGZyb20gJy4vRmlsbC5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydwb2ludCcgfCAnbGluZSd9IFRleHRQbGFjZW1lbnRcbiAqIERlZmF1bHQgdGV4dCBwbGFjZW1lbnQgaXMgYCdwb2ludCdgLiBOb3RlIHRoYXRcbiAqIGAnbGluZSdgIHJlcXVpcmVzIHRoZSB1bmRlcmx5aW5nIGdlb21ldHJ5IHRvIGJlIGEge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd+TGluZVN0cmluZ30sXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vUG9seWdvbn5Qb2x5Z29ufSwge0BsaW5rIG1vZHVsZTpvbC9nZW9tL011bHRpTGluZVN0cmluZ35NdWx0aUxpbmVTdHJpbmd9IG9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufk11bHRpUG9seWdvbn0uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2xlZnQnIHwgJ2NlbnRlcicgfCAncmlnaHQnfSBUZXh0SnVzdGlmeVxuICovXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZmlsbCBjb2xvciB0byB1c2UgaWYgbm8gZmlsbCB3YXMgc2V0IGF0IGNvbnN0cnVjdGlvbiB0aW1lOyBhXG4gKiBibGFja2lzaCBgIzMzM2AuXG4gKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbmNvbnN0IERFRkFVTFRfRklMTF9DT0xPUiA9ICcjMzMzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnRdIEZvbnQgc3R5bGUgYXMgQ1NTIGBmb250YCB2YWx1ZSwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9mb250LiBEZWZhdWx0IGlzIGAnMTBweCBzYW5zLXNlcmlmJ2BcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4QW5nbGU9TWF0aC5QSS80XSBXaGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYCwgYWxsb3cgYSBtYXhpbXVtIGFuZ2xlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cbiAqIFRoZSBleHBlY3RlZCB2YWx1ZSBpcyBpbiByYWRpYW5zLCBhbmQgdGhlIGRlZmF1bHQgaXMgNDXCsCAoYE1hdGguUEkgLyA0YCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldFg9MF0gSG9yaXpvbnRhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCByaWdodC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0WT0wXSBWZXJ0aWNhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCBkb3duLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3c9ZmFsc2VdIEZvciBwb2x5Z29uIGxhYmVscyBvciB3aGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYCwgYWxsb3cgdGV4dCB0byBleGNlZWRcbiAqIHRoZSB3aWR0aCBvZiB0aGUgcG9seWdvbiBhdCB0aGUgbGFiZWwgcG9zaXRpb24gb3IgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gKiBAcHJvcGVydHkge1RleHRQbGFjZW1lbnR9IFtwbGFjZW1lbnQ9J3BvaW50J10gVGV4dCBwbGFjZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcGVhdF0gUmVwZWF0IGludGVydmFsLiBXaGVuIHNldCwgdGhlIHRleHQgd2lsbCBiZSByZXBlYXRlZCBhdCB0aGlzIGludGVydmFsLCB3aGljaCBzcGVjaWZpZXNcbiAqIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0ZXh0IGFuY2hvcnMgaW4gcGl4ZWxzLiBPbmx5IGF2YWlsYWJsZSB3aGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYC4gT3ZlcnJpZGVzICd0ZXh0QWxpZ24nLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGVdIFNjYWxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSB0ZXh0IHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwVXByaWdodD10cnVlXSBXaGV0aGVyIHRoZSB0ZXh0IGNhbiBiZSByb3RhdGVkIDE4MMKwIHRvIHByZXZlbnQgYmVpbmcgcmVuZGVyZWQgdXBzaWRlIGRvd24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnMgKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSkuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBbdGV4dF0gVGV4dCBjb250ZW50IG9yIHJpY2ggdGV4dCBjb250ZW50LiBGb3IgcGxhaW4gdGV4dCBwcm92aWRlIGEgc3RyaW5nLCB3aGljaCBjYW5cbiAqIGNvbnRhaW4gbGluZSBicmVha3MgKGBcXG5gKS4gRm9yIHJpY2ggdGV4dCBwcm92aWRlIGFuIGFycmF5IG9mIHRleHQvZm9udCB0dXBsZXMuIEEgdHVwbGUgY29uc2lzdHMgb2YgdGhlIHRleHQgdG9cbiAqIHJlbmRlciBhbmQgdGhlIGZvbnQgdG8gdXNlIChvciBgJydgIHRvIHVzZSB0aGUgdGV4dCBzdHlsZSdzIGZvbnQpLiBBIGxpbmUgYnJlYWsgaGFzIHRvIGJlIGEgc2VwYXJhdGUgdHVwbGUgKGkuZS4gYCdcXG4nLCAnJ2ApLlxuICogKipFeGFtcGxlOioqIGBbJ2ZvbycsICdib2xkIDEwcHggc2Fucy1zZXJpZicsICcgYmFyJywgJ2l0YWxpYyAxMHB4IHNhbnMtc2VyaWYnLCAnIGJheicsICcnXWAgd2lsbCB5aWVsZCBcIioqZm9vKiogKmJhciogYmF6XCIuXG4gKiAqKk5vdGU6KiogUmljaCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2Agb3IgdGhlIGltbWVkaWF0ZSByZW5kZXJpbmcgQVBJLlxuICogQHByb3BlcnR5IHtDYW52YXNUZXh0QWxpZ259IFt0ZXh0QWxpZ25dIFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IGAnbGVmdCdgLCBgJ3JpZ2h0J2AsIGAnY2VudGVyJ2AsIGAnZW5kJ2Agb3IgYCdzdGFydCdgLlxuICogRGVmYXVsdCBpcyBgJ2NlbnRlcidgIGZvciBgcGxhY2VtZW50OiAncG9pbnQnYC4gRm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2AsIHRoZSBkZWZhdWx0IGlzIHRvIGxldCB0aGUgcmVuZGVyZXIgY2hvb3NlIGFcbiAqIHBsYWNlbWVudCB3aGVyZSBgbWF4QW5nbGVgIGlzIG5vdCBleGNlZWRlZC5cbiAqIEBwcm9wZXJ0eSB7VGV4dEp1c3RpZnl9IFtqdXN0aWZ5XSBUZXh0IGp1c3RpZmljYXRpb24gd2l0aGluIHRoZSB0ZXh0IGJveC5cbiAqIElmIG5vdCBzZXQsIHRleHQgaXMganVzdGlmaWVkIHRvd2FyZHMgdGhlIGB0ZXh0QWxpZ25gIGFuY2hvci5cbiAqIE90aGVyd2lzZSwgdXNlIG9wdGlvbnMgYCdsZWZ0J2AsIGAnY2VudGVyJ2AsIG9yIGAncmlnaHQnYCB0byBqdXN0aWZ5IHRoZSB0ZXh0IHdpdGhpbiB0aGUgdGV4dCBib3guXG4gKiAqKk5vdGU6KiogYGp1c3RpZnlgIGlzIGlnbm9yZWQgZm9yIGltbWVkaWF0ZSByZW5kZXJpbmcgYW5kIGFsc28gZm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2AuXG4gKiBAcHJvcGVydHkge0NhbnZhc1RleHRCYXNlbGluZX0gW3RleHRCYXNlbGluZT0nbWlkZGxlJ10gVGV4dCBiYXNlIGxpbmUuIFBvc3NpYmxlIHZhbHVlczogYCdib3R0b20nYCwgYCd0b3AnYCwgYCdtaWRkbGUnYCwgYCdhbHBoYWJldGljJ2AsXG4gKiBgJ2hhbmdpbmcnYCwgYCdpZGVvZ3JhcGhpYydgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfSBbZmlsbF0gRmlsbCBzdHlsZS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgd2UnbGwgdXNlIGEgZGFyayBmaWxsLXN0eWxlICgjMzMzKS4gU3BlY2lmeSBgbnVsbGAgZm9yIG5vIGZpbGwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kRmlsbF0gRmlsbCBzdHlsZSBmb3IgdGhlIHRleHQgYmFja2dyb3VuZCB3aGVuIGBwbGFjZW1lbnRgIGlzXG4gKiBgJ3BvaW50J2AuIERlZmF1bHQgaXMgbm8gZmlsbC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRTdHJva2VdIFN0cm9rZSBzdHlsZSBmb3IgdGhlIHRleHQgYmFja2dyb3VuZCAgd2hlbiBgcGxhY2VtZW50YFxuICogaXMgYCdwb2ludCdgLiBEZWZhdWx0IGlzIG5vIHN0cm9rZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIGluIHBpeGVscyBhcm91bmQgdGhlIHRleHQgZm9yIGRlY2x1dHRlcmluZyBhbmQgYmFja2dyb3VuZC4gVGhlIG9yZGVyIG9mXG4gKiB2YWx1ZXMgaW4gdGhlIGFycmF5IGlzIGBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XWAuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vc3R5bGUvU3R5bGUuanMnKS5EZWNsdXR0ZXJNb2RlfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGU6IGBkZWNsdXR0ZXJgLCBgb2JzdGFjbGVgLCBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCB0ZXh0IHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mb250XyA9IG9wdGlvbnMuZm9udDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5rZWVwVXByaWdodF8gPSBvcHRpb25zLmtlZXBVcHJpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zY2FsZSA6IDEpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduXyA9IG9wdGlvbnMudGV4dEFsaWduO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGV4dEp1c3RpZnl8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuanVzdGlmeV8gPSBvcHRpb25zLmp1c3RpZnk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVwZWF0XyA9IG9wdGlvbnMucmVwZWF0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRCYXNlbGluZV8gPSBvcHRpb25zLnRleHRCYXNlbGluZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9XG4gICAgICBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuZmlsbFxuICAgICAgICA6IG5ldyBGaWxsKHtjb2xvcjogREVGQVVMVF9GSUxMX0NPTE9SfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhBbmdsZV8gPVxuICAgICAgb3B0aW9ucy5tYXhBbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhBbmdsZSA6IE1hdGguUEkgLyA0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGV4dFBsYWNlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnBsYWNlbWVudF8gPVxuICAgICAgb3B0aW9ucy5wbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGxhY2VtZW50IDogJ3BvaW50JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVyZmxvd18gPSAhIW9wdGlvbnMub3ZlcmZsb3c7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFhfID0gb3B0aW9ucy5vZmZzZXRYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldFggOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0WV8gPSBvcHRpb25zLm9mZnNldFkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0WSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuYmFja2dyb3VuZEZpbGxfID0gb3B0aW9ucy5iYWNrZ3JvdW5kRmlsbFxuICAgICAgPyBvcHRpb25zLmJhY2tncm91bmRGaWxsXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5iYWNrZ3JvdW5kU3Ryb2tlXyA9IG9wdGlvbnMuYmFja2dyb3VuZFN0cm9rZVxuICAgICAgPyBvcHRpb25zLmJhY2tncm91bmRTdHJva2VcbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmdfID0gb3B0aW9ucy5wYWRkaW5nID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5wYWRkaW5nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi9zdHlsZS9TdHlsZS5qcycpLkRlY2x1dHRlck1vZGV9XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJNb2RlXyA9IG9wdGlvbnMuZGVjbHV0dGVyTW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtUZXh0fSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICByZXR1cm4gbmV3IFRleHQoe1xuICAgICAgZm9udDogdGhpcy5nZXRGb250KCksXG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuZ2V0UGxhY2VtZW50KCksXG4gICAgICByZXBlYXQ6IHRoaXMuZ2V0UmVwZWF0KCksXG4gICAgICBtYXhBbmdsZTogdGhpcy5nZXRNYXhBbmdsZSgpLFxuICAgICAgb3ZlcmZsb3c6IHRoaXMuZ2V0T3ZlcmZsb3coKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAga2VlcFVwcmlnaHQ6IHRoaXMuZ2V0S2VlcFVwcmlnaHQoKSxcbiAgICAgIHNjYWxlOiBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZSxcbiAgICAgIHRleHQ6IHRoaXMuZ2V0VGV4dCgpLFxuICAgICAgdGV4dEFsaWduOiB0aGlzLmdldFRleHRBbGlnbigpLFxuICAgICAganVzdGlmeTogdGhpcy5nZXRKdXN0aWZ5KCksXG4gICAgICB0ZXh0QmFzZWxpbmU6IHRoaXMuZ2V0VGV4dEJhc2VsaW5lKCksXG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBvZmZzZXRYOiB0aGlzLmdldE9mZnNldFgoKSxcbiAgICAgIG9mZnNldFk6IHRoaXMuZ2V0T2Zmc2V0WSgpLFxuICAgICAgYmFja2dyb3VuZEZpbGw6IHRoaXMuZ2V0QmFja2dyb3VuZEZpbGwoKVxuICAgICAgICA/IHRoaXMuZ2V0QmFja2dyb3VuZEZpbGwoKS5jbG9uZSgpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgYmFja2dyb3VuZFN0cm9rZTogdGhpcy5nZXRCYWNrZ3JvdW5kU3Ryb2tlKClcbiAgICAgICAgPyB0aGlzLmdldEJhY2tncm91bmRTdHJva2UoKS5jbG9uZSgpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgcGFkZGluZzogdGhpcy5nZXRQYWRkaW5nKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBgb3ZlcmZsb3dgIGNvbmZpZ3VyYXRpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExldCB0ZXh0IG92ZXJmbG93IHRoZSBsZW5ndGggb2YgdGhlIHBhdGggdGhleSBmb2xsb3cuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE92ZXJmbG93KCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJmbG93XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZvbnQgbmFtZS5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gRm9udC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Rm9udCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb250XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIHJhZGlhbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heEFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLm1heEFuZ2xlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhYmVsIHBsYWNlbWVudC5cbiAgICogQHJldHVybiB7VGV4dFBsYWNlbWVudH0gVGV4dCBwbGFjZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVwZWF0IGludGVydmFsIG9mIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXBlYXQgaW50ZXJ2YWwgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXBlYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwZWF0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHgtb2Zmc2V0IGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIb3Jpem9udGFsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPZmZzZXRYKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldFhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeS1vZmZzZXQgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZlcnRpY2FsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPZmZzZXRZKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldFlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlsbCBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbF87XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHRleHQgcm90YXRlcyB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0ZVdpdGhWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZVdpdGhWaWV3XztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdGV4dCBjYW4gYmUgcmVuZGVyZWQgdXBzaWRlIGRvd24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBLZWVwIHRleHQgdXByaWdodC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0S2VlcFVwcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VlcFVwcmlnaHRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRleHQgc2NhbGUuXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZSBhcnJheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTY2FsZSBhcnJheS5cbiAgICovXG4gIGdldFNjYWxlQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVBcnJheV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IFRleHQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGFsaWdubWVudC5cbiAgICogQHJldHVybiB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH0gVGV4dCBhbGlnbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGV4dEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLnRleHRBbGlnbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBqdXN0aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJuIHtUZXh0SnVzdGlmeXx1bmRlZmluZWR9IEp1c3RpZmljYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEp1c3RpZnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuanVzdGlmeV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGJhc2VsaW5lLlxuICAgKiBAcmV0dXJuIHtDYW52YXNUZXh0QmFzZWxpbmV8dW5kZWZpbmVkfSBUZXh0IGJhc2VsaW5lLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEJhc2VsaW5lXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgZmlsbCBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEJhY2tncm91bmRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRGaWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgc3Ryb2tlIHN0eWxlIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEJhY2tncm91bmRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZFN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYWRkaW5nIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBQYWRkaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBhZGRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVjbHV0dGVyIG1vZGUgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3R5bGUuanNcIikuRGVjbHV0dGVyTW9kZX0gU2hhcGUncyBkZWNsdXR0ZXIgbW9kZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXREZWNsdXR0ZXJNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2x1dHRlck1vZGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVyZmxvdyBMZXQgdGV4dCBvdmVyZmxvdyB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE92ZXJmbG93KG92ZXJmbG93KSB7XG4gICAgdGhpcy5vdmVyZmxvd18gPSBvdmVyZmxvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9udCBGb250LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGb250KGZvbnQpIHtcbiAgICB0aGlzLmZvbnRfID0gZm9udDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgQW5nbGUgaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4QW5nbGUobWF4QW5nbGUpIHtcbiAgICB0aGlzLm1heEFuZ2xlXyA9IG1heEFuZ2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIEhvcml6b250YWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9mZnNldFgob2Zmc2V0WCkge1xuICAgIHRoaXMub2Zmc2V0WF8gPSBvZmZzZXRYO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeSBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIFZlcnRpY2FsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRPZmZzZXRZKG9mZnNldFkpIHtcbiAgICB0aGlzLm9mZnNldFlfID0gb2Zmc2V0WTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgcGxhY2VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRQbGFjZW1lbnR9IHBsYWNlbWVudCBQbGFjZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICB0aGlzLnBsYWNlbWVudF8gPSBwbGFjZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXBlYXQgaW50ZXJ2YWwgb2YgdGhlIHRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gW3JlcGVhdF0gUmVwZWF0IGludGVydmFsIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVwZWF0KHJlcGVhdCkge1xuICAgIHRoaXMucmVwZWF0XyA9IHJlcGVhdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0byByb3RhdGUgdGhlIHRleHQgd2l0aCB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByb3RhdGVXaXRoVmlldyBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0ZVdpdGhWaWV3KHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0aGUgdGV4dCBjYW4gYmUgcmVuZGVyZWQgdXBzaWRlIGRvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFVwcmlnaHQgS2VlcCB0ZXh0IHVwcmlnaHQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEtlZXBVcHJpZ2h0KGtlZXBVcHJpZ2h0KSB7XG4gICAgdGhpcy5rZWVwVXByaWdodF8gPSBrZWVwVXByaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3Ryb2tlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuc3Ryb2tlXyA9IHN0cm9rZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfSB0ZXh0IFRleHQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHQodGV4dCkge1xuICAgIHRoaXMudGV4dF8gPSB0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBhbGlnbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH0gdGV4dEFsaWduIFRleHQgYWxpZ24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHRBbGlnbih0ZXh0QWxpZ24pIHtcbiAgICB0aGlzLnRleHRBbGlnbl8gPSB0ZXh0QWxpZ247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBqdXN0aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRKdXN0aWZ5fHVuZGVmaW5lZH0ganVzdGlmeSBKdXN0aWZpY2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRKdXN0aWZ5KGp1c3RpZnkpIHtcbiAgICB0aGlzLmp1c3RpZnlfID0ganVzdGlmeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgYmFzZWxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH0gdGV4dEJhc2VsaW5lIFRleHQgYmFzZWxpbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpIHtcbiAgICB0aGlzLnRleHRCYXNlbGluZV8gPSB0ZXh0QmFzZWxpbmU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBiYWNrZ3JvdW5kIGZpbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kRmlsbChmaWxsKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRmlsbF8gPSBmaWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFja2dyb3VuZCBzdHJva2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kU3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuYmFja2dyb3VuZFN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwYWRkaW5nIChgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF1gKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fG51bGx9IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UGFkZGluZyhwYWRkaW5nKSB7XG4gICAgdGhpcy5wYWRkaW5nXyA9IHBhZGRpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlY29vcmRcbiAqL1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIHRocmVlIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHRpbGUgaW4gYSB0aWxlXG4gKiBncmlkLiBUaGUgb3JkZXIgaXMgYHpgICh6b29tIGxldmVsKSwgYHhgIChjb2x1bW4pLCBhbmQgYHlgIChyb3cpLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IFRpbGVDb29yZFxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IFt0aWxlQ29vcmRdIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge1RpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUoeiwgeCwgeSwgdGlsZUNvb3JkKSB7XG4gIGlmICh0aWxlQ29vcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbGVDb29yZFswXSA9IHo7XG4gICAgdGlsZUNvb3JkWzFdID0geDtcbiAgICB0aWxlQ29vcmRbMl0gPSB5O1xuICAgIHJldHVybiB0aWxlQ29vcmQ7XG4gIH1cbiAgcmV0dXJuIFt6LCB4LCB5XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleVpYWSh6LCB4LCB5KSB7XG4gIHJldHVybiB6ICsgJy8nICsgeCArICcvJyArIHk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBrZXkgZm9yIGEgdGlsZSBjb29yZC5cbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGhlIHRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleSh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIGdldEtleVpYWSh0aWxlQ29vcmRbMF0sIHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRpbGUgY2FjaGUga2V5IGZvciBhIHRpbGUga2V5IG9idGFpbmVkIHRocm91Z2ggYHRpbGUuZ2V0S2V5KClgLlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbGVLZXkgVGhlIHRpbGUga2V5LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2FjaGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVLZXlGb3JUaWxlS2V5KHRpbGVLZXkpIHtcbiAgY29uc3QgW3osIHgsIHldID0gdGlsZUtleVxuICAgIC5zdWJzdHJpbmcodGlsZUtleS5sYXN0SW5kZXhPZignLycpICsgMSwgdGlsZUtleS5sZW5ndGgpXG4gICAgLnNwbGl0KCcsJylcbiAgICAubWFwKE51bWJlcik7XG4gIHJldHVybiBnZXRLZXlaWFkoeiwgeCwgeSk7XG59XG5cbi8qKlxuICogR2V0IGEgdGlsZSBjb29yZCBnaXZlbiBhIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHRpbGUgY29vcmQga2V5LlxuICogQHJldHVybiB7VGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHRpbGVDb29yZCkge1xuICByZXR1cm4gaGFzaFpYWSh0aWxlQ29vcmRbMF0sIHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaGUgdGlsZSB6IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgdGlsZSB4IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgdGlsZSB5IGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoWlhZKHosIHgsIHkpIHtcbiAgcmV0dXJuICh4IDw8IHopICsgeTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7IWltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBjb29yZGluYXRlIGlzIHdpdGhpbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpIHtcbiAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgY29uc3QgeCA9IHRpbGVDb29yZFsxXTtcbiAgY29uc3QgeSA9IHRpbGVDb29yZFsyXTtcblxuICBpZiAodGlsZUdyaWQuZ2V0TWluWm9vbSgpID4geiB8fCB6ID4gdGlsZUdyaWQuZ2V0TWF4Wm9vbSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gIGlmICghdGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHRpbGVSYW5nZS5jb250YWluc1hZKHgsIHkpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkXG4gKi9cbmltcG9ydCBUaWxlR3JpZCBmcm9tICcuL3RpbGVncmlkL1RpbGVHcmlkLmpzJztcbmltcG9ydCB7REVGQVVMVF9NQVhfWk9PTSwgREVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vdGlsZWdyaWQvY29tbW9uLmpzJztcbmltcG9ydCB7TUVURVJTX1BFUl9VTklULCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlT3JVcGRhdGUsXG4gIGdldENvcm5lcixcbiAgZ2V0SGVpZ2h0LFxuICBnZXRXaWR0aCxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4vc2l6ZS5qcyc7XG5cbmV4cG9ydCB7VGlsZUdyaWR9O1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdNVFN9IGZyb20gJy4vdGlsZWdyaWQvV01UUy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IERlZmF1bHQgdGlsZSBncmlkIGZvciB0aGVcbiAqIHBhc3NlZCBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGxldCB0aWxlR3JpZCA9IHByb2plY3Rpb24uZ2V0RGVmYXVsdFRpbGVHcmlkKCk7XG4gIGlmICghdGlsZUdyaWQpIHtcbiAgICB0aWxlR3JpZCA9IGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgcHJvamVjdGlvbi5zZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiB0aWxlR3JpZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIGNvbnN0IGNlbnRlciA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpO1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGlmICghY29udGFpbnNDb29yZGluYXRlKHByb2plY3Rpb25FeHRlbnQsIGNlbnRlcikpIHtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgY29uc3Qgd29ybGRzQXdheSA9IE1hdGguY2VpbChcbiAgICAgIChwcm9qZWN0aW9uRXh0ZW50WzBdIC0gY2VudGVyWzBdKSAvIHdvcmxkV2lkdGgsXG4gICAgKTtcbiAgICBjZW50ZXJbMF0gKz0gd29ybGRXaWR0aCAqIHdvcmxkc0F3YXk7XG4gICAgcmV0dXJuIHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjZW50ZXIsIHopO1xuICB9XG4gIHJldHVybiB0aWxlQ29vcmQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkNvcm5lcn0gW2Nvcm5lcl0gRXh0ZW50IGNvcm5lciAoZGVmYXVsdCBpcyBgJ3RvcC1sZWZ0J2ApLlxuICogQHJldHVybiB7IVRpbGVHcmlkfSBUaWxlR3JpZCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvckV4dGVudChleHRlbnQsIG1heFpvb20sIHRpbGVTaXplLCBjb3JuZXIpIHtcbiAgY29ybmVyID0gY29ybmVyICE9PSB1bmRlZmluZWQgPyBjb3JuZXIgOiAndG9wLWxlZnQnO1xuXG4gIGNvbnN0IHJlc29sdXRpb25zID0gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUpO1xuXG4gIHJldHVybiBuZXcgVGlsZUdyaWQoe1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG9yaWdpbjogZ2V0Q29ybmVyKGV4dGVudCwgY29ybmVyKSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnMsXG4gICAgdGlsZVNpemU6IHRpbGVTaXplLFxuICB9KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYWVpPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50IGZvciB0aGUgdGlsZSBncmlkLiBUaGUgb3JpZ2luIGZvciBhbiBYWVogdGlsZSBncmlkIGlzIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBleHRlbnQuIElmIGBtYXhSZXNvbHV0aW9uYCBpcyBub3QgcHJvdmlkZWQgdGhlIHplcm8gbGV2ZWwgb2YgdGhlIGdyaWQgaXMgZGVmaW5lZCBieSB0aGUgcmVzb2x1dGlvblxuICogYXQgd2hpY2ggb25lIHRpbGUgZml0cyBpbiB0aGUgcHJvdmlkZWQgZXh0ZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBleHRlbnQgb2YgdGhlIEVQU0c6Mzg1NyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFJlc29sdXRpb24gYXQgbGV2ZWwgemVyby5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tLiBUaGUgZGVmYXVsdCBpcyBgNDJgLiBUaGlzIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBsZXZlbHNcbiAqIGluIHRoZSBncmlkIHNldC4gRm9yIGV4YW1wbGUsIGEgYG1heFpvb21gIG9mIDIxIG1lYW5zIHRoZXJlIGFyZSAyMiBsZXZlbHMgaW4gdGhlIGdyaWQgc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGlsZSBzaXplIGluIHBpeGVscy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aWxlIGdyaWQgd2l0aCBhIHN0YW5kYXJkIFhZWiB0aWxpbmcgc2NoZW1lLlxuICogQHBhcmFtIHtYWVpPcHRpb25zfSBbb3B0aW9uc10gVGlsZSBncmlkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGUgZ3JpZCBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhZWihvcHRpb25zKSB7XG4gIGNvbnN0IHh5ek9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGV4dGVudCA9IHh5ek9wdGlvbnMuZXh0ZW50IHx8IGdldFByb2plY3Rpb24oJ0VQU0c6Mzg1NycpLmdldEV4dGVudCgpO1xuXG4gIGNvbnN0IGdyaWRPcHRpb25zID0ge1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG1pblpvb206IHh5ek9wdGlvbnMubWluWm9vbSxcbiAgICB0aWxlU2l6ZTogeHl6T3B0aW9ucy50aWxlU2l6ZSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnNGcm9tRXh0ZW50KFxuICAgICAgZXh0ZW50LFxuICAgICAgeHl6T3B0aW9ucy5tYXhab29tLFxuICAgICAgeHl6T3B0aW9ucy50aWxlU2l6ZSxcbiAgICAgIHh5ek9wdGlvbnMubWF4UmVzb2x1dGlvbixcbiAgICApLFxuICB9O1xuICByZXR1cm4gbmV3IFRpbGVHcmlkKGdyaWRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZXNvbHV0aW9ucyBhcnJheSBmcm9tIGFuIGV4dGVudC4gIEEgem9vbSBmYWN0b3Igb2YgMiBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFJlc29sdXRpb25dIFJlc29sdXRpb24gYXQgbGV2ZWwgemVyby5cbiAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBSZXNvbHV0aW9ucyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUsIG1heFJlc29sdXRpb24pIHtcbiAgbWF4Wm9vbSA9IG1heFpvb20gIT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBERUZBVUxUX01BWF9aT09NO1xuICB0aWxlU2l6ZSA9IHRvU2l6ZSh0aWxlU2l6ZSAhPT0gdW5kZWZpbmVkID8gdGlsZVNpemUgOiBERUZBVUxUX1RJTEVfU0laRSk7XG5cbiAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIGNvbnN0IHdpZHRoID0gZ2V0V2lkdGgoZXh0ZW50KTtcblxuICBtYXhSZXNvbHV0aW9uID1cbiAgICBtYXhSZXNvbHV0aW9uID4gMFxuICAgICAgPyBtYXhSZXNvbHV0aW9uXG4gICAgICA6IE1hdGgubWF4KHdpZHRoIC8gdGlsZVNpemVbMF0sIGhlaWdodCAvIHRpbGVTaXplWzFdKTtcblxuICBjb25zdCBsZW5ndGggPSBtYXhab29tICsgMTtcbiAgY29uc3QgcmVzb2x1dGlvbnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgeiA9IDA7IHogPCBsZW5ndGg7ICsreikge1xuICAgIHJlc29sdXRpb25zW3pdID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KDIsIHopO1xuICB9XG4gIHJldHVybiByZXNvbHV0aW9ucztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5Db3JuZXJ9IFtjb3JuZXJdIEV4dGVudCBjb3JuZXIgKGRlZmF1bHQgaXMgYCd0b3AtbGVmdCdgKS5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gVGlsZUdyaWQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24sIG1heFpvb20sIHRpbGVTaXplLCBjb3JuZXIpIHtcbiAgY29uc3QgZXh0ZW50ID0gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIHJldHVybiBjcmVhdGVGb3JFeHRlbnQoZXh0ZW50LCBtYXhab29tLCB0aWxlU2l6ZSwgY29ybmVyKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRpbGUgZ3JpZCBleHRlbnQgZnJvbSBhIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBoYXMgYW5cbiAqIGV4dGVudCwgaXQgaXMgdXNlZC4gIElmIG5vdCwgYSBnbG9iYWwgZXh0ZW50IGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBsZXQgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgaWYgKCFleHRlbnQpIHtcbiAgICBjb25zdCBoYWxmID1cbiAgICAgICgxODAgKiBNRVRFUlNfUEVSX1VOSVQuZGVncmVlcykgLyBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZSgtaGFsZiwgLWhhbGYsIGhhbGYsIGhhbGYpO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWdyaWQvVGlsZUdyaWRcbiAqL1xuaW1wb3J0IFRpbGVSYW5nZSwge1xuICBjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZSxcbn0gZnJvbSAnLi4vVGlsZVJhbmdlLmpzJztcbmltcG9ydCB7REVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vY29tbW9uLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2VpbCwgY2xhbXAsIGZsb29yfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUsIGdldFRvcExlZnR9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlIGFzIGNyZWF0ZU9yVXBkYXRlVGlsZUNvb3JkfSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZWFyUmluZ30gZnJvbSAnLi4vZ2VvbS9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtpc1NvcnRlZCwgbGluZWFyRmluZE5lYXJlc3R9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gKi9cbmNvbnN0IHRtcFRpbGVDb29yZCA9IFswLCAwLCAwXTtcblxuLyoqXG4gKiBOdW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMgdG8gY29uc2lkZXIgaW4gaW50ZWdlciB2YWx1ZXMgd2hlbiByb3VuZGluZy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IERFQ0lNQUxTID0gNTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudCBmb3IgdGhlIHRpbGUgZ3JpZC4gTm8gdGlsZXMgb3V0c2lkZSB0aGlzXG4gKiBleHRlbnQgd2lsbCBiZSByZXF1ZXN0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlfSBzb3VyY2VzLiBXaGVuIG5vIGBvcmlnaW5gIG9yXG4gKiBgb3JpZ2luc2AgYXJlIGNvbmZpZ3VyZWQsIHRoZSBgb3JpZ2luYCB3aWxsIGJlIHNldCB0byB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtvcmlnaW5dIFRoZSB0aWxlIGdyaWQgb3JpZ2luLCBpLmUuIHdoZXJlIHRoZSBgeGBcbiAqIGFuZCBgeWAgYXhlcyBtZWV0IChgW3osIDAsIDBdYCkuIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgZG93bndhcmRzLiBJZiBub3RcbiAqIHNwZWNpZmllZCwgYGV4dGVudGAgb3IgYG9yaWdpbnNgIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IFtvcmlnaW5zXSBUaWxlIGdyaWQgb3JpZ2lucywgaS5lLiB3aGVyZVxuICogdGhlIGB4YCBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLCBmb3IgZWFjaCB6b29tIGxldmVsLiBJZiBnaXZlbiwgdGhlIGFycmF5IGxlbmd0aFxuICogc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS4gZWFjaCByZXNvbHV0aW9uIGNhbiBoYXZlIGEgZGlmZmVyZW50XG4gKiBvcmlnaW4uIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgZG93bndhcmRzLiBJZiBub3Qgc3BlY2lmaWVkLCBgZXh0ZW50YCBvclxuICogYG9yaWdpbmAgbXVzdCBiZSBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5PG51bWJlcj59IHJlc29sdXRpb25zIFJlc29sdXRpb25zLiBUaGUgYXJyYXkgaW5kZXggb2YgZWFjaCByZXNvbHV0aW9uIG5lZWRzXG4gKiB0byBtYXRjaCB0aGUgem9vbSBsZXZlbC4gVGhpcyBtZWFucyB0aGF0IGV2ZW4gaWYgYSBgbWluWm9vbWAgaXMgY29uZmlndXJlZCwgdGhlIHJlc29sdXRpb25zXG4gKiBhcnJheSB3aWxsIGhhdmUgYSBsZW5ndGggb2YgYG1heFpvb20gKyAxYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplPn0gW3NpemVzXSBOdW1iZXIgb2YgdGlsZSByb3dzIGFuZCBjb2x1bW5zXG4gKiBvZiB0aGUgZ3JpZCBmb3IgZWFjaCB6b29tIGxldmVsLiBJZiBzcGVjaWZpZWQgdGhlIHZhbHVlc1xuICogZGVmaW5lIGVhY2ggem9vbSBsZXZlbCdzIGV4dGVudCB0b2dldGhlciB3aXRoIHRoZSBgb3JpZ2luYCBvciBgb3JpZ2luc2AuXG4gKiBBIGdyaWQgYGV4dGVudGAgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gYWRkaXRpb24sIGFuZCB3aWxsIGZ1cnRoZXIgbGltaXQgdGhlIGV4dGVudFxuICogZm9yIHdoaWNoIHRpbGUgcmVxdWVzdHMgYXJlIG1hZGUgYnkgc291cmNlcy4gSWYgdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZlxuICogYW4gZXh0ZW50IGlzIHVzZWQgYXMgYG9yaWdpbmAgb3IgYG9yaWdpbnNgLCB0aGVuIHRoZSBgeWAgdmFsdWUgbXVzdCBiZVxuICogbmVnYXRpdmUgYmVjYXVzZSBPcGVuTGF5ZXJzIHRpbGUgY29vcmRpbmF0ZXMgdXNlIHRoZSB0b3AgbGVmdCBhcyB0aGUgb3JpZ2luLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZS5cbiAqIERlZmF1bHQgaXMgYFsyNTYsIDI1Nl1gLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplPn0gW3RpbGVTaXplc10gVGlsZSBzaXplcy4gSWYgZ2l2ZW4sIHRoZSBhcnJheSBsZW5ndGhcbiAqIHNob3VsZCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBgcmVzb2x1dGlvbnNgIGFycmF5LCBpLmUuIGVhY2ggcmVzb2x1dGlvbiBjYW4gaGF2ZSBhIGRpZmZlcmVudFxuICogdGlsZSBzaXplLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc2V0dGluZyB0aGUgZ3JpZCBwYXR0ZXJuIGZvciBzb3VyY2VzIGFjY2Vzc2luZyB0aWxlZC1pbWFnZVxuICogc2VydmVycy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVGlsZUdyaWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFRpbGUgZ3JpZCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5ab29tIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbnNfID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgICBhc3NlcnQoXG4gICAgICBpc1NvcnRlZChcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc18sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYSBGaXJzdCByZXNvbHV0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIFNlY29uZCByZXNvbHV0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQ29tcGFyaXNvbiByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIChhLCBiKSA9PiBiIC0gYSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICksXG4gICAgICAnYHJlc29sdXRpb25zYCBtdXN0IGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyJyxcbiAgICApO1xuXG4gICAgLy8gY2hlY2sgaWYgd2UndmUgZ290IGEgY29uc2lzdGVudCB6b29tIGZhY3RvciBhbmQgb3JpZ2luXG4gICAgbGV0IHpvb21GYWN0b3I7XG4gICAgaWYgKCFvcHRpb25zLm9yaWdpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGlmICghem9vbUZhY3Rvcikge1xuICAgICAgICAgIHpvb21GYWN0b3IgPSB0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5yZXNvbHV0aW9uc19baV0gLyB0aGlzLnJlc29sdXRpb25zX1tpICsgMV0gIT09IHpvb21GYWN0b3IpIHtcbiAgICAgICAgICAgIHpvb21GYWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuem9vbUZhY3Rvcl8gPSB6b29tRmFjdG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhab29tID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IG9wdGlvbnMub3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9yaWdpbiA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luc18gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLm9yaWdpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcmlnaW5zXyA9IG9wdGlvbnMub3JpZ2lucztcbiAgICAgIGFzc2VydChcbiAgICAgICAgdGhpcy5vcmlnaW5zXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgICAnTnVtYmVyIG9mIGBvcmlnaW5zYCBhbmQgYHJlc29sdXRpb25zYCBtdXN0IGJlIGVxdWFsJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQ7XG5cbiAgICBpZiAoZXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgIXRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXykge1xuICAgICAgdGhpcy5vcmlnaW5fID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICAgIH1cblxuICAgIGFzc2VydChcbiAgICAgICghdGhpcy5vcmlnaW5fICYmIHRoaXMub3JpZ2luc18pIHx8ICh0aGlzLm9yaWdpbl8gJiYgIXRoaXMub3JpZ2luc18pLFxuICAgICAgJ0VpdGhlciBgb3JpZ2luYCBvciBgb3JpZ2luc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoJyxcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59XG4gICAgICovXG4gICAgdGhpcy50aWxlU2l6ZXNfID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy50aWxlU2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50aWxlU2l6ZXNfID0gb3B0aW9ucy50aWxlU2l6ZXM7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMudGlsZVNpemVzXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgICAnTnVtYmVyIG9mIGB0aWxlU2l6ZXNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWwnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVNpemVfID1cbiAgICAgIG9wdGlvbnMudGlsZVNpemUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudGlsZVNpemVcbiAgICAgICAgOiAhdGhpcy50aWxlU2l6ZXNfXG4gICAgICAgICAgPyBERUZBVUxUX1RJTEVfU0laRVxuICAgICAgICAgIDogbnVsbDtcbiAgICBhc3NlcnQoXG4gICAgICAoIXRoaXMudGlsZVNpemVfICYmIHRoaXMudGlsZVNpemVzXykgfHxcbiAgICAgICAgKHRoaXMudGlsZVNpemVfICYmICF0aGlzLnRpbGVTaXplc18pLFxuICAgICAgJ0VpdGhlciBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIG11c3QgYmUgY29uZmlndXJlZCwgbmV2ZXIgYm90aCcsXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50ICE9PSB1bmRlZmluZWQgPyBleHRlbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFNpemVfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcEV4dGVudF8gPSBbMCwgMCwgMCwgMF07XG5cbiAgICBpZiAob3B0aW9ucy5zaXplcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IG9wdGlvbnMuc2l6ZXMubWFwKChzaXplLCB6KSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbGVSYW5nZSA9IG5ldyBUaWxlUmFuZ2UoXG4gICAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVswXSksXG4gICAgICAgICAgTWF0aC5tYXgoc2l6ZVswXSAtIDEsIC0xKSxcbiAgICAgICAgICBNYXRoLm1pbigwLCBzaXplWzFdKSxcbiAgICAgICAgICBNYXRoLm1heChzaXplWzFdIC0gMSwgLTEpLFxuICAgICAgICApO1xuICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgY29uc3QgcmVzdHJpY3RlZFRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgICAgICAgIHRpbGVSYW5nZS5taW5YID0gTWF0aC5tYXgocmVzdHJpY3RlZFRpbGVSYW5nZS5taW5YLCB0aWxlUmFuZ2UubWluWCk7XG4gICAgICAgICAgdGlsZVJhbmdlLm1heFggPSBNYXRoLm1pbihyZXN0cmljdGVkVGlsZVJhbmdlLm1heFgsIHRpbGVSYW5nZS5tYXhYKTtcbiAgICAgICAgICB0aWxlUmFuZ2UubWluWSA9IE1hdGgubWF4KHJlc3RyaWN0ZWRUaWxlUmFuZ2UubWluWSwgdGlsZVJhbmdlLm1pblkpO1xuICAgICAgICAgIHRpbGVSYW5nZS5tYXhZID0gTWF0aC5taW4ocmVzdHJpY3RlZFRpbGVSYW5nZS5tYXhZLCB0aWxlUmFuZ2UubWF4WSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbGVSYW5nZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZXh0ZW50KSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVRpbGVSYW5nZXNfKGV4dGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aXRoIGVhY2ggdGlsZSBjb29yZGluYXRlIGZvciBhIGdpdmVuIGV4dGVudCBhbmQgem9vbSBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCk6IHZvaWR9IGNhbGxiYWNrIEZ1bmN0aW9uIGNhbGxlZCB3aXRoIGVhY2ggdGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoVGlsZUNvb3JkKGV4dGVudCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6b29tKTtcbiAgICBmb3IgKGxldCBpID0gdGlsZVJhbmdlLm1pblgsIGlpID0gdGlsZVJhbmdlLm1heFg7IGkgPD0gaWk7ICsraSkge1xuICAgICAgZm9yIChsZXQgaiA9IHRpbGVSYW5nZS5taW5ZLCBqaiA9IHRpbGVSYW5nZS5tYXhZOyBqIDw9IGpqOyArK2opIHtcbiAgICAgICAgY2FsbGJhY2soW3pvb20sIGksIGpdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gW3RlbXBUaWxlUmFuZ2VdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3RlbXBFeHRlbnRdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FsbGJhY2sgc3VjY2VlZGVkLlxuICAgKi9cbiAgZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZShcbiAgICB0aWxlQ29vcmQsXG4gICAgY2FsbGJhY2ssXG4gICAgdGVtcFRpbGVSYW5nZSxcbiAgICB0ZW1wRXh0ZW50LFxuICApIHtcbiAgICBsZXQgdGlsZVJhbmdlLCB4LCB5O1xuICAgIGxldCB0aWxlQ29vcmRFeHRlbnQgPSBudWxsO1xuICAgIGxldCB6ID0gdGlsZUNvb3JkWzBdIC0gMTtcbiAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgeCA9IHRpbGVDb29yZFsxXTtcbiAgICAgIHkgPSB0aWxlQ29vcmRbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZEV4dGVudCA9IHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGVtcEV4dGVudCk7XG4gICAgfVxuICAgIHdoaWxlICh6ID49IHRoaXMubWluWm9vbSkge1xuICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCAmJiB5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeCA9IE1hdGguZmxvb3IoeCAvIDIpO1xuICAgICAgICB5ID0gTWF0aC5mbG9vcih5IC8gMik7XG4gICAgICAgIHRpbGVSYW5nZSA9IGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKHgsIHgsIHksIHksIHRlbXBUaWxlUmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICAgIHRpbGVDb29yZEV4dGVudCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIHRlbXBUaWxlUmFuZ2UsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2soeiwgdGlsZVJhbmdlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC0tejtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZCwgaWYgaXQgd2FzIGNvbmZpZ3VyZWQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1heCB6b29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhab29tKCkge1xuICAgIHJldHVybiB0aGlzLm1heFpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbiB6b29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNaW5ab29tKCkge1xuICAgIHJldHVybiB0aGlzLm1pblpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gZm9yIHRoZSBncmlkIGF0IHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gT3JpZ2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcmlnaW4oeikge1xuICAgIGlmICh0aGlzLm9yaWdpbl8pIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yaWdpbnNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKHopIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bel07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIHJlc29sdXRpb25zIGZvciB0aGUgdGlsZSBncmlkLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBSZXNvbHV0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gW3RlbXBUaWxlUmFuZ2VdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3RlbXBFeHRlbnRdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR8bnVsbH0gVGlsZSByYW5nZS5cbiAgICovXG4gIGdldFRpbGVDb29yZENoaWxkVGlsZVJhbmdlKHRpbGVDb29yZCwgdGVtcFRpbGVSYW5nZSwgdGVtcEV4dGVudCkge1xuICAgIGlmICh0aWxlQ29vcmRbMF0gPCB0aGlzLm1heFpvb20pIHtcbiAgICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICAgIGNvbnN0IG1pblggPSB0aWxlQ29vcmRbMV0gKiAyO1xuICAgICAgICBjb25zdCBtaW5ZID0gdGlsZUNvb3JkWzJdICogMjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKFxuICAgICAgICAgIG1pblgsXG4gICAgICAgICAgbWluWCArIDEsXG4gICAgICAgICAgbWluWSxcbiAgICAgICAgICBtaW5ZICsgMSxcbiAgICAgICAgICB0ZW1wVGlsZVJhbmdlLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQoXG4gICAgICAgIHRpbGVDb29yZCxcbiAgICAgICAgdGVtcEV4dGVudCB8fCB0aGlzLnRtcEV4dGVudF8sXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgdGlsZUNvb3JkRXh0ZW50LFxuICAgICAgICB0aWxlQ29vcmRbMF0gKyAxLFxuICAgICAgICB0ZW1wVGlsZVJhbmdlLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFt0ZW1wVGlsZVJhbmdlXSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZ2V0VGlsZVJhbmdlRm9yVGlsZUNvb3JkQW5kWih0aWxlQ29vcmQsIHosIHRlbXBUaWxlUmFuZ2UpIHtcbiAgICBpZiAoeiA+IHRoaXMubWF4Wm9vbSB8fCB6IDwgdGhpcy5taW5ab29tKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB0aWxlQ29vcmRaID0gdGlsZUNvb3JkWzBdO1xuICAgIGNvbnN0IHRpbGVDb29yZFggPSB0aWxlQ29vcmRbMV07XG4gICAgY29uc3QgdGlsZUNvb3JkWSA9IHRpbGVDb29yZFsyXTtcblxuICAgIGlmICh6ID09PSB0aWxlQ29vcmRaKSB7XG4gICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoXG4gICAgICAgIHRpbGVDb29yZFgsXG4gICAgICAgIHRpbGVDb29yZFksXG4gICAgICAgIHRpbGVDb29yZFgsXG4gICAgICAgIHRpbGVDb29yZFksXG4gICAgICAgIHRlbXBUaWxlUmFuZ2UsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfKSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCB6IC0gdGlsZUNvb3JkWik7XG4gICAgICBjb25zdCBtaW5YID0gTWF0aC5mbG9vcih0aWxlQ29vcmRYICogZmFjdG9yKTtcbiAgICAgIGNvbnN0IG1pblkgPSBNYXRoLmZsb29yKHRpbGVDb29yZFkgKiBmYWN0b3IpO1xuICAgICAgaWYgKHogPCB0aWxlQ29vcmRaKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCBtaW5YLCBtaW5ZLCBtaW5ZLCB0ZW1wVGlsZVJhbmdlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF4WCA9IE1hdGguZmxvb3IoZmFjdG9yICogKHRpbGVDb29yZFggKyAxKSkgLSAxO1xuICAgICAgY29uc3QgbWF4WSA9IE1hdGguZmxvb3IoZmFjdG9yICogKHRpbGVDb29yZFkgKyAxKSkgLSAxO1xuICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFksIHRlbXBUaWxlUmFuZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbGVDb29yZEV4dGVudCA9IHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGhpcy50bXBFeHRlbnRfKTtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKHRpbGVDb29yZEV4dGVudCwgeiwgdGVtcFRpbGVSYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGlsZSByYW5nZSBmb3IgdGhlIGdpdmVuIGV4dGVudCBhbmQgaW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gW3RlbXBUaWxlUmFuZ2VdIFRlbXBvcmFyeSB0aWxlIHJhbmdlIG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFRpbGUgcmFuZ2UuXG4gICAqL1xuICBnZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeiwgdGVtcFRpbGVSYW5nZSkge1xuICAgIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMF0sIGV4dGVudFszXSwgeiwgZmFsc2UsIHRtcFRpbGVDb29yZCk7XG4gICAgY29uc3QgbWluWCA9IHRtcFRpbGVDb29yZFsxXTtcbiAgICBjb25zdCBtaW5ZID0gdG1wVGlsZUNvb3JkWzJdO1xuICAgIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMl0sIGV4dGVudFsxXSwgeiwgdHJ1ZSwgdG1wVGlsZUNvb3JkKTtcbiAgICBjb25zdCBtYXhYID0gdG1wVGlsZUNvb3JkWzFdO1xuICAgIGNvbnN0IG1heFkgPSB0bXBUaWxlQ29vcmRbMl07XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFksIHRlbXBUaWxlUmFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaWxlIGNlbnRlci5cbiAgICovXG4gIGdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICAgIHJldHVybiBbXG4gICAgICBvcmlnaW5bMF0gKyAodGlsZUNvb3JkWzFdICsgMC41KSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbixcbiAgICAgIG9yaWdpblsxXSAtICh0aWxlQ29vcmRbMl0gKyAwLjUpICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgb2YgYSB0aWxlIGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbdGVtcEV4dGVudF0gVGVtcG9yYXJ5IGV4dGVudCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGVtcEV4dGVudCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHRpbGVDb29yZFswXSk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUodGlsZUNvb3JkWzBdKSwgdGhpcy50bXBTaXplXyk7XG4gICAgY29uc3QgbWluWCA9IG9yaWdpblswXSArIHRpbGVDb29yZFsxXSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtaW5ZID0gb3JpZ2luWzFdIC0gKHRpbGVDb29yZFsyXSArIDEpICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IG1heFggPSBtaW5YICsgdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IG1heFkgPSBtaW5ZICsgdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB0ZW1wRXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBmb3IgdGhlIGdpdmVuIG1hcCBjb29yZGluYXRlIGFuZCByZXNvbHV0aW9uLiAgVGhpc1xuICAgKiBtZXRob2QgY29uc2lkZXJzIHRoYXQgY29vcmRpbmF0ZXMgdGhhdCBpbnRlcnNlY3QgdGlsZSBib3VuZGFyaWVzIHNob3VsZCBiZVxuICAgKiBhc3NpZ25lZCB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRSZXNvbHV0aW9uKGNvb3JkaW5hdGUsIHJlc29sdXRpb24sIG9wdF90aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fKFxuICAgICAgY29vcmRpbmF0ZVswXSxcbiAgICAgIGNvb3JkaW5hdGVbMV0sXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRfdGlsZUNvb3JkLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyB0aGF0IGNvcnJlc3BvbmRcbiAgICogdG8gYW4gaW50ZWdlciB6b29tIGxldmVsLiAgSW5zdGVhZCBjYWxsIHRoZSBgZ2V0VGlsZUNvb3JkRm9yWFlBbmRaX2AgbWV0aG9kLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIChmb3IgYSBub24taW50ZWdlciB6b29tIGxldmVsKS5cbiAgICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IEluc3RlYWQgb2YgbGV0dGluZyBlZGdlXG4gICAqICAgICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gICAqICAgICBnbyB0byB0aGUgbG93ZXIgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFtvcHRfdGlsZUNvb3JkXSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oXG4gICAgeCxcbiAgICB5LFxuICAgIHJlc29sdXRpb24sXG4gICAgcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSxcbiAgICBvcHRfdGlsZUNvb3JkLFxuICApIHtcbiAgICBjb25zdCB6ID0gdGhpcy5nZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICBjb25zdCBzY2FsZSA9IHJlc29sdXRpb24gLyB0aGlzLmdldFJlc29sdXRpb24oeik7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplXyk7XG5cbiAgICBsZXQgdGlsZUNvb3JkWCA9IChzY2FsZSAqICh4IC0gb3JpZ2luWzBdKSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMF07XG4gICAgbGV0IHRpbGVDb29yZFkgPSAoc2NhbGUgKiAob3JpZ2luWzFdIC0geSkpIC8gcmVzb2x1dGlvbiAvIHRpbGVTaXplWzFdO1xuXG4gICAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICAgIHRpbGVDb29yZFggPSBjZWlsKHRpbGVDb29yZFgsIERFQ0lNQUxTKSAtIDE7XG4gICAgICB0aWxlQ29vcmRZID0gY2VpbCh0aWxlQ29vcmRZLCBERUNJTUFMUykgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlQ29vcmRYID0gZmxvb3IodGlsZUNvb3JkWCwgREVDSU1BTFMpO1xuICAgICAgdGlsZUNvb3JkWSA9IGZsb29yKHRpbGVDb29yZFksIERFQ0lNQUxTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmQoeiwgdGlsZUNvb3JkWCwgdGlsZUNvb3JkWSwgb3B0X3RpbGVDb29yZCk7XG4gIH1cblxuICAvKipcbiAgICogQWx0aG91Z2ggdGhlcmUgaXMgcmVwZXRpdGlvbiBiZXR3ZWVuIHRoaXMgbWV0aG9kIGFuZCBgZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uX2AsXG4gICAqIHRoZXkgc2hvdWxkIGhhdmUgc2VwYXJhdGUgaW1wbGVtZW50YXRpb25zLiAgVGhpcyBtZXRob2QgaXMgZm9yIGludGVnZXIgem9vbVxuICAgKiBsZXZlbHMuICBUaGUgb3RoZXIgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgY29ycmVzcG9uZGluZ1xuICAgKiB0byBub24taW50ZWdlciB6b29tIGxldmVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTWFwIHggY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgTWFwIHkgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgSW5zdGVhZCBvZiBsZXR0aW5nIGVkZ2VcbiAgICogICAgIGludGVyc2VjdGlvbnMgZ28gdG8gdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUsIGxldCBlZGdlIGludGVyc2VjdGlvbnNcbiAgICogICAgIGdvIHRvIHRoZSBsb3dlciB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gW29wdF90aWxlQ29vcmRdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyh4LCB5LCB6LCByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5LCBvcHRfdGlsZUNvb3JkKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICAgIGxldCB0aWxlQ29vcmRYID0gKHggLSBvcmlnaW5bMF0pIC8gcmVzb2x1dGlvbiAvIHRpbGVTaXplWzBdO1xuICAgIGxldCB0aWxlQ29vcmRZID0gKG9yaWdpblsxXSAtIHkpIC8gcmVzb2x1dGlvbiAvIHRpbGVTaXplWzFdO1xuXG4gICAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICAgIHRpbGVDb29yZFggPSBjZWlsKHRpbGVDb29yZFgsIERFQ0lNQUxTKSAtIDE7XG4gICAgICB0aWxlQ29vcmRZID0gY2VpbCh0aWxlQ29vcmRZLCBERUNJTUFMUykgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlQ29vcmRYID0gZmxvb3IodGlsZUNvb3JkWCwgREVDSU1BTFMpO1xuICAgICAgdGlsZUNvb3JkWSA9IGZsb29yKHRpbGVDb29yZFksIERFQ0lNQUxTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmQoeiwgdGlsZUNvb3JkWCwgdGlsZUNvb3JkWSwgb3B0X3RpbGVDb29yZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGlsZSBjb29yZGluYXRlIGdpdmVuIGEgbWFwIGNvb3JkaW5hdGUgYW5kIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbCwgZS5nLiB0aGUgcmVzdWx0IG9mIGEgYGdldFpGb3JSZXNvbHV0aW9uKClgIG1ldGhvZCBjYWxsXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gW29wdF90aWxlQ29vcmRdIERlc3RpbmF0aW9uIGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjb29yZGluYXRlLCB6LCBvcHRfdGlsZUNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhcbiAgICAgIGNvb3JkaW5hdGVbMF0sXG4gICAgICBjb29yZGluYXRlWzFdLFxuICAgICAgeixcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0X3RpbGVDb29yZCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRUaWxlQ29vcmRSZXNvbHV0aW9uKHRpbGVDb29yZCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zX1t0aWxlQ29vcmRbMF1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBzaXplIGZvciBhIHpvb20gbGV2ZWwuIFRoZSB0eXBlIG9mIHRoZSByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGVcbiAgICogYHRpbGVTaXplYCBvciBgdGlsZVNpemVzYCB0aGF0IHRoZSB0aWxlIGdyaWQgd2FzIGNvbmZpZ3VyZWQgd2l0aC4gVG8gYWx3YXlzXG4gICAqIGdldCBhbiB7QGxpbmsgaW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSwgcnVuIHRoZSByZXN1bHQgdGhyb3VnaCB7QGxpbmsgbW9kdWxlOm9sL3NpemUudG9TaXplfS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHJldHVybiB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gVGlsZSBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlU2l6ZSh6KSB7XG4gICAgaWYgKHRoaXMudGlsZVNpemVfKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZV87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpbGVTaXplc19bel07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR8bnVsbH0gRXh0ZW50IHRpbGUgcmFuZ2UgZm9yIHRoZSBzcGVjaWZpZWQgem9vbSBsZXZlbC5cbiAgICovXG4gIGdldEZ1bGxUaWxlUmFuZ2Uoeikge1xuICAgIGlmICghdGhpcy5mdWxsVGlsZVJhbmdlc18pIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dGVudF9cbiAgICAgICAgPyB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFoodGhpcy5leHRlbnRfLCB6KVxuICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZ1bGxUaWxlUmFuZ2VzX1t6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFtvcHRfZGlyZWN0aW9uXVxuICAgKiAgICAgSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuXG4gICAqICAgICBJZiAxLCB0aGUgbmVhcmVzdCBoaWdoZXIgcmVzb2x1dGlvbiAobG93ZXIgWikgd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlXG4gICAqICAgICBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb24gKGhpZ2hlciBaKSB3aWxsIGJlIHVzZWQuIERlZmF1bHQgaXMgMC5cbiAgICogICAgIFVzZSBhIHtAbGluayBtb2R1bGU6b2wvYXJyYXl+TmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufSBmb3IgbW9yZSBwcmVjaXNlIGNvbnRyb2wuXG4gICAqXG4gICAqIEZvciBleGFtcGxlIHRvIGNoYW5nZSB0aWxlIFogYXQgdGhlIG1pZHBvaW50IG9mIHpvb20gbGV2ZWxzXG4gICAqIGBgYGpzXG4gICAqIGZ1bmN0aW9uKHZhbHVlLCBoaWdoLCBsb3cpIHtcbiAgICogICByZXR1cm4gdmFsdWUgLSBsb3cgKiBNYXRoLnNxcnQoaGlnaCAvIGxvdyk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqIEByZXR1cm4ge251bWJlcn0gWi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0WkZvclJlc29sdXRpb24ocmVzb2x1dGlvbiwgb3B0X2RpcmVjdGlvbikge1xuICAgIGNvbnN0IHogPSBsaW5lYXJGaW5kTmVhcmVzdChcbiAgICAgIHRoaXMucmVzb2x1dGlvbnNfLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIG9wdF9kaXJlY3Rpb24gfHwgMCxcbiAgICApO1xuICAgIHJldHVybiBjbGFtcCh6LCB0aGlzLm1pblpvb20sIHRoaXMubWF4Wm9vbSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbGUgd2l0aCB0aGUgcHJvdmlkZWQgdGlsZSBjb29yZGluYXRlIGludGVyc2VjdHMgdGhlIGdpdmVuIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vdGlsZWNvb3JkLmpzJykuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZpZXdwb3J0IFZpZXdwb3J0IGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTpvbC9leHRlbnQuZ2V0Um90YXRlZFZpZXdwb3J0fS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgd2l0aCB0aGUgcHJvdmlkZWQgdGlsZSBjb29yZGluYXRlIGludGVyc2VjdHMgdGhlIGdpdmVuIHZpZXdwb3J0LlxuICAgKi9cbiAgdGlsZUNvb3JkSW50ZXJzZWN0c1ZpZXdwb3J0KHRpbGVDb29yZCwgdmlld3BvcnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVhclJpbmcoXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIDAsXG4gICAgICB2aWV3cG9ydC5sZW5ndGgsXG4gICAgICAyLFxuICAgICAgdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxUaWxlUmFuZ2VzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgICBmdWxsVGlsZVJhbmdlc1t6XSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IGZ1bGxUaWxlUmFuZ2VzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVHcmlkO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL1dNVFNcbiAqL1xuXG5pbXBvcnQgVGlsZUdyaWQgZnJvbSAnLi9UaWxlR3JpZC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudCBmb3IgdGhlIHRpbGUgZ3JpZC4gTm8gdGlsZXNcbiAqIG91dHNpZGUgdGhpcyBleHRlbnQgd2lsbCBiZSByZXF1ZXN0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlfSBzb3VyY2VzLlxuICogV2hlbiBubyBgb3JpZ2luYCBvciBgb3JpZ2luc2AgYXJlIGNvbmZpZ3VyZWQsIHRoZSBgb3JpZ2luYCB3aWxsIGJlIHNldCB0byB0aGVcbiAqIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgZXh0ZW50LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtvcmlnaW5dIFRoZSB0aWxlIGdyaWQgb3JpZ2luLCBpLmUuXG4gKiB3aGVyZSB0aGUgYHhgIGFuZCBgeWAgYXhlcyBtZWV0IChgW3osIDAsIDBdYCkuIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdFxuICogdG8gcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3IgYG9yaWdpbnNgIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IFtvcmlnaW5zXSBUaWxlIGdyaWQgb3JpZ2lucyxcbiAqIGkuZS4gd2hlcmUgdGhlIGB4YCBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLCBmb3IgZWFjaCB6b29tIGxldmVsLiBJZlxuICogZ2l2ZW4sIHRoZSBhcnJheSBsZW5ndGggc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS5cbiAqIGVhY2ggcmVzb2x1dGlvbiBjYW4gaGF2ZSBhIGRpZmZlcmVudCBvcmlnaW4uIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0b1xuICogcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3IgYG9yaWdpbmAgbXVzdCBiZSBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5PG51bWJlcj59IHJlc29sdXRpb25zIFJlc29sdXRpb25zLiBUaGUgYXJyYXkgaW5kZXggb2YgZWFjaFxuICogcmVzb2x1dGlvbiBuZWVkcyB0byBtYXRjaCB0aGUgem9vbSBsZXZlbC4gVGhpcyBtZWFucyB0aGF0IGV2ZW4gaWYgYSBgbWluWm9vbWBcbiAqIGlzIGNvbmZpZ3VyZWQsIHRoZSByZXNvbHV0aW9ucyBhcnJheSB3aWxsIGhhdmUgYSBsZW5ndGggb2YgYG1heFpvb20gKyAxYFxuICogQHByb3BlcnR5IHshQXJyYXk8c3RyaW5nPn0gbWF0cml4SWRzIG1hdHJpeCBJRHMuIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBuZWVkc1xuICogdG8gbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplPn0gW3NpemVzXSBOdW1iZXIgb2YgdGlsZSByb3dzIGFuZCBjb2x1bW5zXG4gKiBvZiB0aGUgZ3JpZCBmb3IgZWFjaCB6b29tIGxldmVsLiBUaGUgdmFsdWVzIGhlcmUgYXJlIHRoZSBgVGlsZU1hdHJpeFdpZHRoYCBhbmRcbiAqIGBUaWxlTWF0cml4SGVpZ2h0YCBhZHZlcnRpc2VkIGluIHRoZSBHZXRDYXBhYmlsaXRpZXMgcmVzcG9uc2Ugb2YgdGhlIFdNVFMsIGFuZFxuICogZGVmaW5lIGVhY2ggem9vbSBsZXZlbCdzIGV4dGVudCB0b2dldGhlciB3aXRoIHRoZSBgb3JpZ2luYCBvciBgb3JpZ2luc2AuXG4gKiBBIGdyaWQgYGV4dGVudGAgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gYWRkaXRpb24sIGFuZCB3aWxsIGZ1cnRoZXIgbGltaXQgdGhlIGV4dGVudCBmb3JcbiAqIHdoaWNoIHRpbGUgcmVxdWVzdHMgYXJlIG1hZGUgYnkgc291cmNlcy4gSWYgdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZlxuICogYW4gZXh0ZW50IGlzIHVzZWQgYXMgYG9yaWdpbmAgb3IgYG9yaWdpbnNgLCB0aGVuIHRoZSBgeWAgdmFsdWUgbXVzdCBiZVxuICogbmVnYXRpdmUgYmVjYXVzZSBPcGVuTGF5ZXJzIHRpbGUgY29vcmRpbmF0ZXMgdXNlIHRoZSB0b3AgbGVmdCBhcyB0aGUgb3JpZ2luLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIFRoZSBsZW5ndGggb2ZcbiAqIHRoaXMgYXJyYXkgbmVlZHMgdG8gbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCB0aGUgZ3JpZCBwYXR0ZXJuIGZvciBzb3VyY2VzIGFjY2Vzc2luZyBXTVRTIHRpbGVkLWltYWdlIHNlcnZlcnMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFdNVFNUaWxlR3JpZCBleHRlbmRzIFRpbGVHcmlkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBXTVRTIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgZXh0ZW50OiBvcHRpb25zLmV4dGVudCxcbiAgICAgIG9yaWdpbjogb3B0aW9ucy5vcmlnaW4sXG4gICAgICBvcmlnaW5zOiBvcHRpb25zLm9yaWdpbnMsXG4gICAgICByZXNvbHV0aW9uczogb3B0aW9ucy5yZXNvbHV0aW9ucyxcbiAgICAgIHRpbGVTaXplOiBvcHRpb25zLnRpbGVTaXplLFxuICAgICAgdGlsZVNpemVzOiBvcHRpb25zLnRpbGVTaXplcyxcbiAgICAgIHNpemVzOiBvcHRpb25zLnNpemVzLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5tYXRyaXhJZHNfID0gb3B0aW9ucy5tYXRyaXhJZHM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXRyaXhJZC4uXG4gICAqL1xuICBnZXRNYXRyaXhJZCh6KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4SWRzX1t6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgbWF0cml4IGlkZW50aWZpZXJzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBNYXRyaXhJZHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1hdHJpeElkcygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRyaXhJZHNfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdNVFNUaWxlR3JpZDtcblxuLyoqXG4gKiBDcmVhdGUgYSB0aWxlIGdyaWQgZnJvbSBhIFdNVFMgY2FwYWJpbGl0aWVzIG1hdHJpeCBzZXQgYW5kIGFuXG4gKiBvcHRpb25hbCBUaWxlTWF0cml4U2V0TGltaXRzLlxuICogQHBhcmFtIHtPYmplY3R9IG1hdHJpeFNldCBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbWF0cml4U2V0IGluIHRoZVxuICogICAgIGNhcGFiaWxpdGllcyBkb2N1bWVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gQW4gb3B0aW9uYWwgZXh0ZW50IHRvIHJlc3RyaWN0IHRoZSB0aWxlXG4gKiAgICAgcmFuZ2VzIHRoZSBzZXJ2ZXIgcHJvdmlkZXMuXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFttYXRyaXhMaW1pdHNdIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmdcbiAqICAgICB0aGUgYXZhaWxhYmxlIG1hdHJpY2VzIGZvciB0aWxlR3JpZC5cbiAqIEByZXR1cm4ge1dNVFNUaWxlR3JpZH0gV01UUyB0aWxlR3JpZCBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21DYXBhYmlsaXRpZXNNYXRyaXhTZXQoXG4gIG1hdHJpeFNldCxcbiAgZXh0ZW50LFxuICBtYXRyaXhMaW1pdHMsXG4pIHtcbiAgLyoqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgcmVzb2x1dGlvbnMgPSBbXTtcbiAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgbWF0cml4SWRzID0gW107XG4gIC8qKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovXG4gIGNvbnN0IG9yaWdpbnMgPSBbXTtcbiAgLyoqIEB0eXBlIHshQXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59ICovXG4gIGNvbnN0IHRpbGVTaXplcyA9IFtdO1xuICAvKiogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemU+fSAqL1xuICBjb25zdCBzaXplcyA9IFtdO1xuXG4gIG1hdHJpeExpbWl0cyA9IG1hdHJpeExpbWl0cyAhPT0gdW5kZWZpbmVkID8gbWF0cml4TGltaXRzIDogW107XG5cbiAgY29uc3Qgc3VwcG9ydGVkQ1JTUHJvcE5hbWUgPSAnU3VwcG9ydGVkQ1JTJztcbiAgY29uc3QgbWF0cml4SWRzUHJvcE5hbWUgPSAnVGlsZU1hdHJpeCc7XG4gIGNvbnN0IGlkZW50aWZpZXJQcm9wTmFtZSA9ICdJZGVudGlmaWVyJztcbiAgY29uc3Qgc2NhbGVEZW5vbWluYXRvclByb3BOYW1lID0gJ1NjYWxlRGVub21pbmF0b3InO1xuICBjb25zdCB0b3BMZWZ0Q29ybmVyUHJvcE5hbWUgPSAnVG9wTGVmdENvcm5lcic7XG4gIGNvbnN0IHRpbGVXaWR0aFByb3BOYW1lID0gJ1RpbGVXaWR0aCc7XG4gIGNvbnN0IHRpbGVIZWlnaHRQcm9wTmFtZSA9ICdUaWxlSGVpZ2h0JztcblxuICBjb25zdCBjb2RlID0gbWF0cml4U2V0W3N1cHBvcnRlZENSU1Byb3BOYW1lXTtcbiAgY29uc3QgcHJvamVjdGlvbiA9IGdldFByb2plY3Rpb24oY29kZSk7XG4gIGNvbnN0IG1ldGVyc1BlclVuaXQgPSBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgLy8gc3dhcCBvcmlnaW4geCBhbmQgeSBjb29yZGluYXRlcyBpZiBheGlzIG9yaWVudGF0aW9uIGlzIGxhdC9sb25nXG4gIGNvbnN0IHN3aXRjaE9yaWdpblhZID0gcHJvamVjdGlvbi5nZXRBeGlzT3JpZW50YXRpb24oKS5zdGFydHNXaXRoKCduZScpO1xuXG4gIG1hdHJpeFNldFttYXRyaXhJZHNQcm9wTmFtZV0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiW3NjYWxlRGVub21pbmF0b3JQcm9wTmFtZV0gLSBhW3NjYWxlRGVub21pbmF0b3JQcm9wTmFtZV07XG4gIH0pO1xuXG4gIG1hdHJpeFNldFttYXRyaXhJZHNQcm9wTmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoZWx0KSB7XG4gICAgbGV0IG1hdHJpeEF2YWlsYWJsZTtcbiAgICAvLyB1c2Ugb2YgbWF0cml4TGltaXRzIHRvIGZpbHRlciBUaWxlTWF0cmljZXMgZnJvbSBHZXRDYXBhYmlsaXRpZXNcbiAgICAvLyBUaWxlTWF0cml4U2V0IGZyb20gdW5hdmFpbGFibGUgbWF0cml4IGxldmVscy5cbiAgICBpZiAobWF0cml4TGltaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hdHJpeEF2YWlsYWJsZSA9IG1hdHJpeExpbWl0cy5maW5kKGZ1bmN0aW9uIChlbHRfbWwpIHtcbiAgICAgICAgaWYgKGVsdFtpZGVudGlmaWVyUHJvcE5hbWVdID09IGVsdF9tbFttYXRyaXhJZHNQcm9wTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjayBmb3IgdGlsZU1hdHJpeCBpZGVudGlmaWVycyB0aGF0IGRvbid0IGdldCBwcmVmaXhlZFxuICAgICAgICAvLyBieSB0aGVpciB0aWxlTWF0cml4U2V0IGlkZW50aWZpZXJzLlxuICAgICAgICBpZiAoIWVsdFtpZGVudGlmaWVyUHJvcE5hbWVdLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbWF0cml4U2V0W2lkZW50aWZpZXJQcm9wTmFtZV0gKyAnOicgKyBlbHRbaWRlbnRpZmllclByb3BOYW1lXSA9PT1cbiAgICAgICAgICAgIGVsdF9tbFttYXRyaXhJZHNQcm9wTmFtZV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRyaXhBdmFpbGFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRyaXhBdmFpbGFibGUpIHtcbiAgICAgIG1hdHJpeElkcy5wdXNoKGVsdFtpZGVudGlmaWVyUHJvcE5hbWVdKTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPVxuICAgICAgICAoZWx0W3NjYWxlRGVub21pbmF0b3JQcm9wTmFtZV0gKiAwLjI4ZS0zKSAvIG1ldGVyc1BlclVuaXQ7XG4gICAgICBjb25zdCB0aWxlV2lkdGggPSBlbHRbdGlsZVdpZHRoUHJvcE5hbWVdO1xuICAgICAgY29uc3QgdGlsZUhlaWdodCA9IGVsdFt0aWxlSGVpZ2h0UHJvcE5hbWVdO1xuICAgICAgaWYgKHN3aXRjaE9yaWdpblhZKSB7XG4gICAgICAgIG9yaWdpbnMucHVzaChbXG4gICAgICAgICAgZWx0W3RvcExlZnRDb3JuZXJQcm9wTmFtZV1bMV0sXG4gICAgICAgICAgZWx0W3RvcExlZnRDb3JuZXJQcm9wTmFtZV1bMF0sXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2lucy5wdXNoKGVsdFt0b3BMZWZ0Q29ybmVyUHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdXRpb25zLnB1c2gocmVzb2x1dGlvbik7XG4gICAgICB0aWxlU2l6ZXMucHVzaChcbiAgICAgICAgdGlsZVdpZHRoID09IHRpbGVIZWlnaHQgPyB0aWxlV2lkdGggOiBbdGlsZVdpZHRoLCB0aWxlSGVpZ2h0XSxcbiAgICAgICk7XG4gICAgICBzaXplcy5wdXNoKFtlbHRbJ01hdHJpeFdpZHRoJ10sIGVsdFsnTWF0cml4SGVpZ2h0J11dKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXcgV01UU1RpbGVHcmlkKHtcbiAgICBleHRlbnQ6IGV4dGVudCxcbiAgICBvcmlnaW5zOiBvcmlnaW5zLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9ucyxcbiAgICBtYXRyaXhJZHM6IG1hdHJpeElkcyxcbiAgICB0aWxlU2l6ZXM6IHRpbGVTaXplcyxcbiAgICBzaXplczogc2l6ZXMsXG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIHpvb20gZm9yIGRlZmF1bHQgdGlsZSBncmlkcy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX01BWF9aT09NID0gNDI7XG5cbi8qKlxuICogRGVmYXVsdCB0aWxlIHNpemUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9USUxFX1NJWkUgPSAyNTY7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZXVybGZ1bmN0aW9uXG4gKi9cbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtyZW5kZXJYWVpUZW1wbGF0ZX0gZnJvbSAnLi91cmkuanMnO1xuaW1wb3J0IHtoYXNoIGFzIHRpbGVDb29yZEhhc2h9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVGVtcGxhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdHxudWxsfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB0aWxlR3JpZCkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBDb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRpbGUgVVJMLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICAgIGlmICghdGlsZUNvb3JkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsZXQgbWF4WTtcbiAgICAgIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gICAgICBpZiAodGlsZUdyaWQpIHtcbiAgICAgICAgLy8gVGhlIGB7LXl9YCBwbGFjZWhvbGRlciBvbmx5IHdvcmtzIGZvciBzb3VyY2VzIHRoYXQgaGF2ZSBhIHRpbGUgZ3JpZCBhdCBjb25zdHJ1Y3Rpb25cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWxlR3JpZC5nZXRGdWxsVGlsZVJhbmdlKHopO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBtYXhZID0gcmFuZ2UuZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVuZGVyWFlaVGVtcGxhdGUodGVtcGxhdGUsIHosIHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdLCBtYXhZKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB0ZW1wbGF0ZXMgVGVtcGxhdGVzLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGVtcGxhdGVzKHRlbXBsYXRlcywgdGlsZUdyaWQpIHtcbiAgY29uc3QgbGVuID0gdGVtcGxhdGVzLmxlbmd0aDtcbiAgY29uc3QgdGlsZVVybEZ1bmN0aW9ucyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGlsZVVybEZ1bmN0aW9uc1tpXSA9IGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZXNbaV0sIHRpbGVHcmlkKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRnJvbVRpbGVVcmxGdW5jdGlvbnModGlsZVVybEZ1bmN0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb24+fSB0aWxlVXJsRnVuY3Rpb25zIFRpbGUgVVJMIEZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKSB7XG4gIGlmICh0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zWzBdO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGggPSB0aWxlQ29vcmRIYXNoKHRpbGVDb29yZCk7XG4gICAgICBjb25zdCBpbmRleCA9IG1vZHVsbyhoLCB0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGlsZVVybEZ1bmN0aW9uc1tpbmRleF0odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRPRE86IFVwZGF0ZSBvbC1tYXBib3gtc3R5bGUgdG8gaW1wb3J0IHRoaXMgZnJvbSB0aGUgdXJpLmpzIG1vZHVsZS5cbiAqL1xuZXhwb3J0IHtleHBhbmRVcmx9IGZyb20gJy4vdXJpLmpzJztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC90cmFuc2Zvcm1cbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvdHJhbnNmb3JtfSBmdW5jdGlvbnMuIFRoZSBhcnJheSBoYXMgNiBlbGVtZW50cy5cbiAqIEB0eXBlZGVmIHshQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMuIFRoZSBmdW5jdGlvbnMgd29yayBvbiBhblxuICogYXJyYXkgb2YgNiBlbGVtZW50cy4gVGhlIGVsZW1lbnQgb3JkZXIgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBbU1ZHTWF0cml4XG4gKiBpbnRlcmZhY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdNYXRyaXgpIGFuZCBpc1xuICogYSBzdWJzZXQgKGVsZW1lbnRzIGEgdG8gZikgb2YgYSAzw5czIG1hdHJpeDpcbiAqIGBgYFxuICogWyBhIGMgZSBdXG4gKiBbIGIgZCBmIF1cbiAqIFsgMCAwIDEgXVxuICogYGBgXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge1RyYW5zZm9ybX1cbiAqL1xuY29uc3QgdG1wXyA9IG5ldyBBcnJheSg2KTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaWRlbnRpdHkgdHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gSWRlbnRpdHkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIHRvIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHRyYW5zZm9ybSkge1xuICByZXR1cm4gc2V0KHRyYW5zZm9ybSwgMSwgMCwgMCwgMSwgMCwgMCk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIHVuZGVybHlpbmcgbWF0cmljZXMgb2YgdHdvIHRyYW5zZm9ybXMgYW5kIHJldHVybiB0aGUgcmVzdWx0IGluXG4gKiB0aGUgZmlyc3QgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIFRyYW5zZm9ybSBwYXJhbWV0ZXJzIG9mIG1hdHJpeCAxLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0yIFRyYW5zZm9ybSBwYXJhbWV0ZXJzIG9mIG1hdHJpeCAyLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBtdWx0aXBsaWVkIHdpdGggdHJhbnNmb3JtMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgY29uc3QgYTEgPSB0cmFuc2Zvcm0xWzBdO1xuICBjb25zdCBiMSA9IHRyYW5zZm9ybTFbMV07XG4gIGNvbnN0IGMxID0gdHJhbnNmb3JtMVsyXTtcbiAgY29uc3QgZDEgPSB0cmFuc2Zvcm0xWzNdO1xuICBjb25zdCBlMSA9IHRyYW5zZm9ybTFbNF07XG4gIGNvbnN0IGYxID0gdHJhbnNmb3JtMVs1XTtcbiAgY29uc3QgYTIgPSB0cmFuc2Zvcm0yWzBdO1xuICBjb25zdCBiMiA9IHRyYW5zZm9ybTJbMV07XG4gIGNvbnN0IGMyID0gdHJhbnNmb3JtMlsyXTtcbiAgY29uc3QgZDIgPSB0cmFuc2Zvcm0yWzNdO1xuICBjb25zdCBlMiA9IHRyYW5zZm9ybTJbNF07XG4gIGNvbnN0IGYyID0gdHJhbnNmb3JtMls1XTtcblxuICB0cmFuc2Zvcm0xWzBdID0gYTEgKiBhMiArIGMxICogYjI7XG4gIHRyYW5zZm9ybTFbMV0gPSBiMSAqIGEyICsgZDEgKiBiMjtcbiAgdHJhbnNmb3JtMVsyXSA9IGExICogYzIgKyBjMSAqIGQyO1xuICB0cmFuc2Zvcm0xWzNdID0gYjEgKiBjMiArIGQxICogZDI7XG4gIHRyYW5zZm9ybTFbNF0gPSBhMSAqIGUyICsgYzEgKiBmMiArIGUxO1xuICB0cmFuc2Zvcm0xWzVdID0gYjEgKiBlMiArIGQxICogZjIgKyBmMTtcblxuICByZXR1cm4gdHJhbnNmb3JtMTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHRyYW5zZm9ybSBjb21wb25lbnRzIGEtZiBvbiBhIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBhIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIGIgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYyBUaGUgYyBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkIFRoZSBkIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGUgVGhlIGUgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZiBUaGUgZiBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IE1hdHJpeCB3aXRoIHRyYW5zZm9ybSBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRyYW5zZm9ybSwgYSwgYiwgYywgZCwgZSwgZikge1xuICB0cmFuc2Zvcm1bMF0gPSBhO1xuICB0cmFuc2Zvcm1bMV0gPSBiO1xuICB0cmFuc2Zvcm1bMl0gPSBjO1xuICB0cmFuc2Zvcm1bM10gPSBkO1xuICB0cmFuc2Zvcm1bNF0gPSBlO1xuICB0cmFuc2Zvcm1bNV0gPSBmO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIFNldCB0cmFuc2Zvcm0gb24gb25lIG1hdHJpeCBmcm9tIGFub3RoZXIgbWF0cml4LlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIHRvLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0yIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIGZyb20uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIHdpdGggdHJhbnNmb3JtIGZyb20gdHJhbnNmb3JtMiBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RnJvbUFycmF5KHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgdHJhbnNmb3JtMVswXSA9IHRyYW5zZm9ybTJbMF07XG4gIHRyYW5zZm9ybTFbMV0gPSB0cmFuc2Zvcm0yWzFdO1xuICB0cmFuc2Zvcm0xWzJdID0gdHJhbnNmb3JtMlsyXTtcbiAgdHJhbnNmb3JtMVszXSA9IHRyYW5zZm9ybTJbM107XG4gIHRyYW5zZm9ybTFbNF0gPSB0cmFuc2Zvcm0yWzRdO1xuICB0cmFuc2Zvcm0xWzVdID0gdHJhbnNmb3JtMls1XTtcbiAgcmV0dXJuIHRyYW5zZm9ybTE7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm0gcmV0dXJuaW5nIHRoZVxuICogcmVzdWx0aW5nLCB0cmFuc2Zvcm1lZCBjb29yZGluYXRlLiBUaGUgY29vcmRpbmF0ZSB3aWxsIGJlIG1vZGlmaWVkIGluLXBsYWNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfGltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHJldHVybiBjb29yZGluYXRlIHNvIHRoYXQgb3BlcmF0aW9ucyBjYW4gYmVcbiAqICAgICBjaGFpbmVkIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkodHJhbnNmb3JtLCBjb29yZGluYXRlKSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgY29vcmRpbmF0ZVswXSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdO1xuICBjb29yZGluYXRlWzFdID0gdHJhbnNmb3JtWzFdICogeCArIHRyYW5zZm9ybVszXSAqIHkgKyB0cmFuc2Zvcm1bNV07XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgcm90YXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHJvdGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKHRyYW5zZm9ybSwgYW5nbGUpIHtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCBjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwKSk7XG59XG5cbi8qKlxuICogQXBwbGllcyBzY2FsZSB0byBhIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjYWxlIGZhY3RvciB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgc2NhbGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgeCwgeSkge1xuICByZXR1cm4gbXVsdGlwbHkodHJhbnNmb3JtLCBzZXQodG1wXywgeCwgMCwgMCwgeSwgMCwgMCkpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzY2FsZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRhcmdldCBUcmFuc2Zvcm0gdG8gb3ZlcndyaXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBTY2FsZSBmYWN0b3IgeS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBzY2FsZSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2NhbGUodGFyZ2V0LCB4LCB5KSB7XG4gIHJldHVybiBzZXQodGFyZ2V0LCB4LCAwLCAwLCB5LCAwLCAwKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRyYW5zbGF0aW9uIHRvIHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZHggVHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeSBUcmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHRyYW5zbGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgZHgsIGR5KSB7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCAxLCAwLCAwLCAxLCBkeCwgZHkpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcG9zaXRlIHRyYW5zZm9ybSBnaXZlbiBhbiBpbml0aWFsIHRyYW5zbGF0aW9uLCBzY2FsZSwgcm90YXRpb24sIGFuZFxuICogZmluYWwgdHJhbnNsYXRpb24gKGluIHRoYXQgb3JkZXIgb25seSwgbm90IGNvbW11dGF0aXZlKS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRoZSB0cmFuc2Zvcm0gKHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MSBJbml0aWFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkxIEluaXRpYWwgdHJhbnNsYXRpb24geS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiAoaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgyIEZpbmFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkyIEZpbmFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgY29tcG9zaXRlIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2UodHJhbnNmb3JtLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHRyYW5zZm9ybVswXSA9IHN4ICogY29zO1xuICB0cmFuc2Zvcm1bMV0gPSBzeSAqIHNpbjtcbiAgdHJhbnNmb3JtWzJdID0gLXN4ICogc2luO1xuICB0cmFuc2Zvcm1bM10gPSBzeSAqIGNvcztcbiAgdHJhbnNmb3JtWzRdID0gZHgyICogc3ggKiBjb3MgLSBkeTIgKiBzeCAqIHNpbiArIGR4MTtcbiAgdHJhbnNmb3JtWzVdID0gZHgyICogc3kgKiBzaW4gKyBkeTIgKiBzeSAqIGNvcyArIGR5MTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcG9zaXRlIHRyYW5zZm9ybSBnaXZlbiBhbiBpbml0aWFsIHRyYW5zbGF0aW9uLCBzY2FsZSwgcm90YXRpb24sIGFuZFxuICogZmluYWwgdHJhbnNsYXRpb24gKGluIHRoYXQgb3JkZXIgb25seSwgbm90IGNvbW11dGF0aXZlKS4gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1cbiAqIHN0cmluZyBjYW4gYmUgYXBwbGllZCBhcyBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBvZiBhbiBIVE1MRWxlbWVudCdzIHN0eWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MSBJbml0aWFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkxIEluaXRpYWwgdHJhbnNsYXRpb24geS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiAoaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgyIEZpbmFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkyIEZpbmFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wb3NpdGUgY3NzIHRyYW5zZm9ybS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VDc3NUcmFuc2Zvcm0oZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKSB7XG4gIHJldHVybiB0b1N0cmluZyhjb21wb3NlKGNyZWF0ZSgpLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpKTtcbn1cblxuLyoqXG4gKiBJbnZlcnQgdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gc291cmNlIFRoZSBzb3VyY2UgdHJhbnNmb3JtIHRvIGludmVydC5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBpbnZlcnRlZCAoc291cmNlKSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQoc291cmNlKSB7XG4gIHJldHVybiBtYWtlSW52ZXJzZShzb3VyY2UsIHNvdXJjZSk7XG59XG5cbi8qKlxuICogSW52ZXJ0IHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRhcmdldCBUcmFuc2Zvcm0gdG8gYmUgc2V0IGFzIHRoZSBpbnZlcnNlIG9mXG4gKiAgICAgdGhlIHNvdXJjZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHNvdXJjZSBUaGUgc291cmNlIHRyYW5zZm9ybSB0byBpbnZlcnQuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgaW52ZXJ0ZWQgKHRhcmdldCkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUludmVyc2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgY29uc3QgZGV0ID0gZGV0ZXJtaW5hbnQoc291cmNlKTtcbiAgYXNzZXJ0KGRldCAhPT0gMCwgJ1RyYW5zZm9ybWF0aW9uIG1hdHJpeCBjYW5ub3QgYmUgaW52ZXJ0ZWQnKTtcblxuICBjb25zdCBhID0gc291cmNlWzBdO1xuICBjb25zdCBiID0gc291cmNlWzFdO1xuICBjb25zdCBjID0gc291cmNlWzJdO1xuICBjb25zdCBkID0gc291cmNlWzNdO1xuICBjb25zdCBlID0gc291cmNlWzRdO1xuICBjb25zdCBmID0gc291cmNlWzVdO1xuXG4gIHRhcmdldFswXSA9IGQgLyBkZXQ7XG4gIHRhcmdldFsxXSA9IC1iIC8gZGV0O1xuICB0YXJnZXRbMl0gPSAtYyAvIGRldDtcbiAgdGFyZ2V0WzNdID0gYSAvIGRldDtcbiAgdGFyZ2V0WzRdID0gKGMgKiBmIC0gZCAqIGUpIC8gZGV0O1xuICB0YXJnZXRbNV0gPSAtKGEgKiBmIC0gYiAqIGUpIC8gZGV0O1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gbWF0IE1hdHJpeC5cbiAqIEByZXR1cm4ge251bWJlcn0gRGV0ZXJtaW5hbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtYXQpIHtcbiAgcmV0dXJuIG1hdFswXSAqIG1hdFszXSAtIG1hdFsxXSAqIG1hdFsyXTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbmNvbnN0IG1hdHJpeFByZWNpc2lvbiA9IFsxZTYsIDFlNiwgMWU2LCAxZTYsIDIsIDJdO1xuXG4vKipcbiAqIEEgcm91bmRlZCBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgdHJhbnNmb3JtLiAgVGhpcyBjYW4gYmUgdXNlZFxuICogZm9yIENTUyB0cmFuc2Zvcm1zLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSBtYXQgTWF0cml4LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtIGFzIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcobWF0KSB7XG4gIGNvbnN0IHRyYW5zZm9ybVN0cmluZyA9XG4gICAgJ21hdHJpeCgnICtcbiAgICBtYXRcbiAgICAgIC5tYXAoXG4gICAgICAgICh2YWx1ZSwgaSkgPT5cbiAgICAgICAgICBNYXRoLnJvdW5kKHZhbHVlICogbWF0cml4UHJlY2lzaW9uW2ldKSAvIG1hdHJpeFByZWNpc2lvbltpXSxcbiAgICAgIClcbiAgICAgIC5qb2luKCcsICcpICtcbiAgICAnKSc7XG4gIHJldHVybiB0cmFuc2Zvcm1TdHJpbmc7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdXJpXG4gKi9cblxuaW1wb3J0IHtoYXNoWlhZfSBmcm9tICcuL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcblxuLyoqXG4gKiBBcHBlbmRzIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSBUaGUgb3JpZ2luYWwgVVJJLCB3aGljaCBtYXkgYWxyZWFkeSBoYXZlIHF1ZXJ5IGRhdGEuXG4gKiBAcGFyYW0geyFPYmplY3R9IHBhcmFtcyBBbiBvYmplY3Qgd2hlcmUga2V5cyBhcmUgVVJJLWVuY29kZWQgcGFyYW1ldGVyIGtleXMsXG4gKiAgICAgYW5kIHRoZSB2YWx1ZXMgYXJlIGFyYml0cmFyeSB0eXBlcyBvciBhcnJheXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuZXcgVVJJLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kUGFyYW1zKHVyaSwgcGFyYW1zKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3Qga2V5UGFyYW1zID0gW107XG4gIC8vIFNraXAgYW55IG51bGwgb3IgdW5kZWZpbmVkIHBhcmFtZXRlciB2YWx1ZXNcbiAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKHBhcmFtc1trXSAhPT0gbnVsbCAmJiBwYXJhbXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5UGFyYW1zLnB1c2goayArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba10pKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBxcyA9IGtleVBhcmFtcy5qb2luKCcmJyk7XG4gIC8vIHJlbW92ZSBhbnkgdHJhaWxpbmcgPyBvciAmXG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9bPyZdJC8sICcnKTtcbiAgLy8gYXBwZW5kID8gb3IgJiBkZXBlbmRpbmcgb24gd2hldGhlciB1cmkgaGFzIGV4aXN0aW5nIHBhcmFtZXRlcnNcbiAgdXJpICs9IHVyaS5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xuICByZXR1cm4gdXJpICsgcXM7XG59XG5cbmNvbnN0IHpSZWdFeCA9IC9cXHt6XFx9L2c7XG5jb25zdCB4UmVnRXggPSAvXFx7eFxcfS9nO1xuY29uc3QgeVJlZ0V4ID0gL1xce3lcXH0vZztcbmNvbnN0IGRhc2hZUmVnRXggPSAvXFx7LXlcXH0vZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVGhlIFVSTCB0ZW1wbGF0ZS4gIFNob3VsZCBoYXZlIGB7eH1gLCBge3l9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy4gIElmXG4gKiB0aGUgdGVtcGxhdGUgaGFzIGEgYHsteX1gIHBsYWNlaG9sZGVyLCB0aGUgYG1heFlgIHBhcmFtZXRlciBtdXN0IGJlIHN1cHBsaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIHRpbGUgeiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHRpbGUgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHRpbGUgeSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhZXSBUaGUgbWF4aW11bSB5IGNvb3JkaW5hdGUgYXQgdGhlIGdpdmVuIHogbGV2ZWwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJYWVpUZW1wbGF0ZSh0ZW1wbGF0ZSwgeiwgeCwgeSwgbWF4WSkge1xuICByZXR1cm4gdGVtcGxhdGVcbiAgICAucmVwbGFjZSh6UmVnRXgsIHoudG9TdHJpbmcoKSlcbiAgICAucmVwbGFjZSh4UmVnRXgsIHgudG9TdHJpbmcoKSlcbiAgICAucmVwbGFjZSh5UmVnRXgsIHkudG9TdHJpbmcoKSlcbiAgICAucmVwbGFjZShkYXNoWVJlZ0V4LCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWF4WSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSWYgdGhlIFVSTCB0ZW1wbGF0ZSBoYXMgYSB7LXl9IHBsYWNlaG9sZGVyLCB0aGUgZ3JpZCBleHRlbnQgbXVzdCBiZSBrbm93bicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1heFkgLSB5KS50b1N0cmluZygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdXJscyBMaXN0IG9mIFVSTHMuXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaGUgdGlsZSB6IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgdGlsZSB4IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgdGlsZSB5IGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjaG9zZW4gVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlja1VybCh1cmxzLCB6LCB4LCB5KSB7XG4gIGNvbnN0IGhhc2ggPSBoYXNoWlhZKHosIHgsIHkpO1xuICBjb25zdCBpbmRleCA9IG1vZHVsbyhoYXNoLCB1cmxzLmxlbmd0aCk7XG4gIHJldHVybiB1cmxzW2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTC5cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEFycmF5IG9mIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRVcmwodXJsKSB7XG4gIGNvbnN0IHVybHMgPSBbXTtcbiAgbGV0IG1hdGNoID0gL1xceyhbYS16XSktKFthLXpdKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBjaGFyIHJhbmdlXG4gICAgY29uc3Qgc3RhcnRDaGFyQ29kZSA9IG1hdGNoWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3Qgc3RvcENoYXJDb2RlID0gbWF0Y2hbMl0uY2hhckNvZGVBdCgwKTtcbiAgICBsZXQgY2hhckNvZGU7XG4gICAgZm9yIChjaGFyQ29kZSA9IHN0YXJ0Q2hhckNvZGU7IGNoYXJDb2RlIDw9IHN0b3BDaGFyQ29kZTsgKytjaGFyQ29kZSkge1xuICAgICAgdXJscy5wdXNoKHVybC5yZXBsYWNlKG1hdGNoWzBdLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICBtYXRjaCA9IC9cXHsoXFxkKyktKFxcZCspXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIG51bWJlciByYW5nZVxuICAgIGNvbnN0IHN0b3AgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuICAgIGZvciAobGV0IGkgPSBwYXJzZUludChtYXRjaFsxXSwgMTApOyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgdXJscy5wdXNoKHVybC5yZXBsYWNlKG1hdGNoWzBdLCBpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgdXJscy5wdXNoKHVybCk7XG4gIHJldHVybiB1cmxzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3V0aWxcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge25ldmVyfSBBbnkgcmV0dXJuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QuJyk7XG59XG5cbi8qKlxuICogQ291bnRlciBmb3IgZ2V0VWlkLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB1aWRDb3VudGVyXyA9IDA7XG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFVuaXF1ZSBJRHMgYXJlIGdlbmVyYXRlZFxuICogYXMgYSBzdHJpY3RseSBpbmNyZWFzaW5nIHNlcXVlbmNlLiBBZGFwdGVkIGZyb20gZ29vZy5nZXRVaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVpZChvYmopIHtcbiAgcmV0dXJuIG9iai5vbF91aWQgfHwgKG9iai5vbF91aWQgPSBTdHJpbmcoKyt1aWRDb3VudGVyXykpO1xufVxuXG4vKipcbiAqIE9wZW5MYXllcnMgdmVyc2lvbi5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzEwLjMuMSc7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdmVjL21hdDRcbiAqL1xuXG4vKiogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IE1hdDQgKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtNYXQ0fSBcIjR4NCBtYXRyaXggcmVwcmVzZW50aW5nIGEgM0QgaWRlbnRpdHkgdHJhbnNmb3JtLlwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtNYXQ0fSBtYXQ0IEZsYXR0ZW5lZCA0eDQgbWF0cml4IHJlY2VpdmluZyB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICogQHJldHVybiB7TWF0NH0gXCIyRCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYXMgZmxhdHRlbmVkIDR4NCBtYXRyaXguXCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2Zvcm0obWF0NCwgdHJhbnNmb3JtKSB7XG4gIG1hdDRbMF0gPSB0cmFuc2Zvcm1bMF07XG4gIG1hdDRbMV0gPSB0cmFuc2Zvcm1bMV07XG4gIG1hdDRbNF0gPSB0cmFuc2Zvcm1bMl07XG4gIG1hdDRbNV0gPSB0cmFuc2Zvcm1bM107XG4gIG1hdDRbMTJdID0gdHJhbnNmb3JtWzRdO1xuICBtYXQ0WzEzXSA9IHRyYW5zZm9ybVs1XTtcbiAgcmV0dXJuIG1hdDQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TWF0NH0gW291dF0gbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHJldHVybiB7TWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcnRob2dyYXBoaWMobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIG91dCkge1xuICBvdXQgPSBvdXQgPz8gY3JlYXRlKCk7XG4gIGNvbnN0IGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge01hdDR9IG0gVGhlIG1hdHJpeCB0byBzY2FsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IEhvdyBtdWNoIHRvIHNjYWxlIGluIHRoZSB4IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEhvdyBtdWNoIHRvIHNjYWxlIGluIHRoZSB5IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEhvdyBtdWNoIHRvIHNjYWxlIGluIHRoZSB6IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7TWF0NH0gW291dF0gVGhlIG1hdHJpeCB0byB3cml0ZSB0by5cbiAqIEByZXR1cm4ge01hdDR9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG0sIHgsIHksIHosIG91dCkge1xuICBvdXQgPSBvdXQgPz8gY3JlYXRlKCk7XG4gIG91dFswXSA9IG1bMF0gKiB4O1xuICBvdXRbMV0gPSBtWzFdICogeDtcbiAgb3V0WzJdID0gbVsyXSAqIHg7XG4gIG91dFszXSA9IG1bM10gKiB4O1xuICBvdXRbNF0gPSBtWzRdICogeTtcbiAgb3V0WzVdID0gbVs1XSAqIHk7XG4gIG91dFs2XSA9IG1bNl0gKiB5O1xuICBvdXRbN10gPSBtWzddICogeTtcbiAgb3V0WzhdID0gbVs4XSAqIHo7XG4gIG91dFs5XSA9IG1bOV0gKiB6O1xuICBvdXRbMTBdID0gbVsxMF0gKiB6O1xuICBvdXRbMTFdID0gbVsxMV0gKiB6O1xuICBvdXRbMTJdID0gbVsxMl07XG4gIG91dFsxM10gPSBtWzEzXTtcbiAgb3V0WzE0XSA9IG1bMTRdO1xuICBvdXRbMTVdID0gbVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7TWF0NH0gbSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHggSG93IG11Y2ggdG8gdHJhbnNsYXRlIGluIHRoZSB4IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEhvdyBtdWNoIHRvIHRyYW5zbGF0ZSBpbiB0aGUgeSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0geiBIb3cgbXVjaCB0byB0cmFuc2xhdGUgaW4gdGhlIHogZGlyZWN0aW9uLlxuICogQHBhcmFtIHtNYXQ0fSBbb3V0XSB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybiB7TWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUobSwgeCwgeSwgeiwgb3V0KSB7XG4gIG91dCA9IG91dCA/PyBjcmVhdGUoKTtcbiAgbGV0IGEwMCwgYTAxLCBhMDIsIGEwMywgYTEwLCBhMTEsIGExMiwgYTEzLCBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKG0gPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXTtcbiAgICBvdXRbMTNdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM107XG4gICAgb3V0WzE0XSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XTtcbiAgICBvdXRbMTVdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IG1bMF07XG4gICAgYTAxID0gbVsxXTtcbiAgICBhMDIgPSBtWzJdO1xuICAgIGEwMyA9IG1bM107XG4gICAgYTEwID0gbVs0XTtcbiAgICBhMTEgPSBtWzVdO1xuICAgIGExMiA9IG1bNl07XG4gICAgYTEzID0gbVs3XTtcbiAgICBhMjAgPSBtWzhdO1xuICAgIGEyMSA9IG1bOV07XG4gICAgYTIyID0gbVsxMF07XG4gICAgYTIzID0gbVsxMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuXG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIG1bMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBtWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgbVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIG1bMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geCB4IHRyYW5zbGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgeSB0cmFuc2xhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IHogdHJhbnNsYXRpb24uXG4gKiBAcGFyYW0ge01hdDR9IFtvdXRdIG9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSByZXN1bHRcbiAqIEByZXR1cm4ge01hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRpb24oeCwgeSwgeiwgb3V0KSB7XG4gIG91dCA9IG91dCA/PyBjcmVhdGUoKTtcblxuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB4O1xuICBvdXRbMTNdID0geTtcbiAgb3V0WzE0XSA9IHo7XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG4iLCJpbXBvcnQgKiBhcyBtYXQ0IGZyb20gJy4uL3ZlYy9tYXQ0LmpzJztcblxuLyoqXG4gKiBAbW9kdWxlIG9sL3dlYmdsL0NhbnZhc1xuICovXG5cbmNvbnN0IFZFUlRFWF9TSEFERVIgPSBgXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XG4gIGF0dHJpYnV0ZSB2ZWM0IGFfdGV4Y29vcmQ7XG5cbiAgdW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xuICB1bmlmb3JtIG1hdDQgdV90ZXh0dXJlTWF0cml4O1xuXG4gIHZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xuXG4gIHZvaWQgbWFpbigpIHtcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogYV9wb3NpdGlvbjtcbiAgICB2ZWMyIHRleGNvb3JkID0gKHVfdGV4dHVyZU1hdHJpeCAqIGFfdGV4Y29vcmQpLnh5O1xuICAgIHZfdGV4Y29vcmQgPSB0ZXhjb29yZDtcbiAgfVxuYDtcblxuY29uc3QgRlJBR01FTlRfU0hBREVSID0gYFxuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICB2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcblxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XG5cbiAgdm9pZCBtYWluKCkge1xuICAgIGlmIChcbiAgICAgIHZfdGV4Y29vcmQueCA8IDAuMCB8fFxuICAgICAgdl90ZXhjb29yZC55IDwgMC4wIHx8XG4gICAgICB2X3RleGNvb3JkLnggPiAxLjAgfHxcbiAgICAgIHZfdGV4Y29vcmQueSA+IDEuMFxuICAgICkge1xuICAgICAgZGlzY2FyZDtcbiAgICB9XG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXhjb29yZCk7XG4gIH1cbmA7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gTWF0cml4ICovXG5cbi8qKlxuICogQ2FudmFzLWxpa2Ugb3BlcmF0aW9ucyBpbXBsZW1lbnRlZCBpbiB3ZWJnbC5cbiAqL1xuZXhwb3J0IGNsYXNzIENhbnZhcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQ29udGV4dCB0byByZW5kZXIgaW4uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnbCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsXyA9IGdsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7V2ViR0xQcm9ncmFtfVxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbV8gPSBjcmVhdGVQcm9ncmFtKGdsLCBGUkFHTUVOVF9TSEFERVIsIFZFUlRFWF9TSEFERVIpO1xuXG4gICAgdGhpcy5wb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtXywgJ2FfcG9zaXRpb24nKTtcbiAgICB0aGlzLnRleGNvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW1fLCAnYV90ZXhjb29yZCcpO1xuXG4gICAgdGhpcy5tYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW1fLCAndV9tYXRyaXgnKTtcbiAgICB0aGlzLnRleHR1cmVNYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihcbiAgICAgIHRoaXMucHJvZ3JhbV8sXG4gICAgICAndV90ZXh0dXJlTWF0cml4JyxcbiAgICApO1xuICAgIHRoaXMudGV4dHVyZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbV8sICd1X3RleHR1cmUnKTtcblxuICAgIHRoaXMucG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NpdGlvbkJ1ZmZlcik7XG5cbiAgICB0aGlzLnBvc2l0aW9ucyA9IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAwLCAwLCAxLCAxLCAxXTtcbiAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBvc2l0aW9ucyksXG4gICAgICBnbC5TVEFUSUNfRFJBVyxcbiAgICApO1xuXG4gICAgdGhpcy50ZXhjb29yZEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRleGNvb3JkQnVmZmVyKTtcblxuICAgIHRoaXMudGV4Y29vcmRzID0gWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDAsIDAsIDEsIDEsIDFdO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgICBnbC5BUlJBWV9CVUZGRVIsXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHRoaXMudGV4Y29vcmRzKSxcbiAgICAgIGdsLlNUQVRJQ19EUkFXLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogMmRDb250ZXh0IGRyYXdJbWFnZSBjYWxsIGltcGxlbWVudGVkIGluIHdlYmdsLlxuICAgKiBVbmxpa2UgaW1hZ2VzLCB0ZXh0dXJlcyBkbyBub3QgaGF2ZSBhIHdpZHRoIGFuZCBoZWlnaHQgYXNzb2NpYXRlZFxuICAgKiB3aXRoIHRoZW0gc28gd2UnbGwgcGFzcyBpbiB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCBJbWFnZSB0byBkcmF3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGV4V2lkdGggSW1hZ2Ugd2lkdGguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXhIZWlnaHQgSW1hZ2UgaGVpZ2h0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3JjWCBUb3AtbGVmdCB4LXBvaW50IHRvIHJlYWQgc3JjIGltYWdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3JjWSBUb3AtbGVmdCB5LXBvaW50IHRvIHJlYWQgc3JjIGltYWdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NyY1dpZHRoXSBXaWR0aCBvZiBzb3VyY2UgdG8gcmVhZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzcmNIZWlnaHRdIEhlaWdodCBvZiBzb3VyY2UgdG8gcmVhZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkc3RYXSBUb3AtbGVmdCB4LXBvaW50IG9mIGRlc3RpbmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RzdFldIFRvcC1sZWZ0IHktcG9pbnQgb2YgZGVzdGluYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHN0V2lkdGhdIFdpZHRoIG9mIHdyaXR0ZW4gaW1hZ2UgaW4gZGVzdGluYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHN0SGVpZ2h0XSBIZWlnaHQgb2Ygd3JpdHRlbiBpbWFnZSBpbiBkZXN0aW5hdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gV2lkdGggb2YgY2FudmFzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gSGVpZ2h0IG9mIGNhbnZhcy5cbiAgICovXG4gIGRyYXdJbWFnZShcbiAgICB0ZXgsXG4gICAgdGV4V2lkdGgsXG4gICAgdGV4SGVpZ2h0LFxuICAgIHNyY1gsXG4gICAgc3JjWSxcbiAgICBzcmNXaWR0aCxcbiAgICBzcmNIZWlnaHQsXG4gICAgZHN0WCxcbiAgICBkc3RZLFxuICAgIGRzdFdpZHRoLFxuICAgIGRzdEhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbF87XG5cbiAgICBpZiAoZHN0WCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkc3RYID0gc3JjWDtcbiAgICB9XG4gICAgaWYgKGRzdFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZHN0WSA9IHNyY1k7XG4gICAgfVxuICAgIGlmIChzcmNXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzcmNXaWR0aCA9IHRleFdpZHRoO1xuICAgIH1cbiAgICBpZiAoc3JjSGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNyY0hlaWdodCA9IHRleEhlaWdodDtcbiAgICB9XG4gICAgaWYgKGRzdFdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRzdFdpZHRoID0gc3JjV2lkdGg7XG4gICAgfVxuICAgIGlmIChkc3RIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZHN0SGVpZ2h0ID0gc3JjSGVpZ2h0O1xuICAgIH1cbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2lkdGggPSBnbC5jYW52YXMud2lkdGg7XG4gICAgfVxuICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVpZ2h0ID0gZ2wuY2FudmFzLmhlaWdodDtcbiAgICB9XG5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgpO1xuXG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW1fKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnBvc2l0aW9uQnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5wb3NpdGlvbkxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRleGNvb3JkQnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnRleGNvb3JkTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy50ZXhjb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgLy8gbWF0cml4IGZvciBjb252ZXJ0aW5nIHBpeGVscyB0byBjbGlwIHNwYWNlXG4gICAgbGV0IG1hdHJpeCA9IG1hdDQub3J0aG9ncmFwaGljKDAsIHdpZHRoLCAwLCBoZWlnaHQsIC0xLCAxKTtcbiAgICBtYXRyaXggPSBtYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIGRzdFgsIGRzdFksIDApO1xuICAgIG1hdHJpeCA9IG1hdDQuc2NhbGUobWF0cml4LCBkc3RXaWR0aCwgZHN0SGVpZ2h0LCAxKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMubWF0cml4TG9jYXRpb24sIGZhbHNlLCBtYXRyaXgpO1xuXG4gICAgbGV0IHRleE1hdHJpeCA9IG1hdDQudHJhbnNsYXRpb24oc3JjWCAvIHRleFdpZHRoLCBzcmNZIC8gdGV4SGVpZ2h0LCAwKTtcbiAgICB0ZXhNYXRyaXggPSBtYXQ0LnNjYWxlKFxuICAgICAgdGV4TWF0cml4LFxuICAgICAgc3JjV2lkdGggLyB0ZXhXaWR0aCxcbiAgICAgIHNyY0hlaWdodCAvIHRleEhlaWdodCxcbiAgICAgIDEsXG4gICAgKTtcblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy50ZXh0dXJlTWF0cml4TG9jYXRpb24sIGZhbHNlLCB0ZXhNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm0xaSh0aGlzLnRleHR1cmVMb2NhdGlvbiwgMCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIHRoaXMucG9zaXRpb25zLmxlbmd0aCAvIDIpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFJlbmRlcmluZyBDb250ZXh0LlxuICogQHBhcmFtIHtHTGVudW19IHR5cGUgVHlwZSBvZiBzaGFkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIHNvdXJjZSBvZiBzaGFkZXIuXG4gKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gW3Byb2dhbV0gVGhlIHByb2dyYW0uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcblxuICBpZiAoc2hhZGVyID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgY29tcGlsYXRpb24gZmFpbGVkJyk7XG4gIH1cblxuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuXG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zdCBsb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgaWYgKGxvZyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgaW5mbyBsb2cgY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihsb2cpO1xuICB9XG5cbiAgcmV0dXJuIHNoYWRlcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgUmVuZGVyaW5nIENvbnRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnJhZ21lbnRTb3VyY2UgRnJhZ21lbnQgc2hhZGVyIHNvdXJjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0ZXhTb3VyY2UgVmVydGV4IHNoYWRlciBzb3VyY2UuXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19IFtwcm9nYW1dIFRoZSBwcm9ncmFtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgZnJhZ21lbnRTb3VyY2UsIHZlcnRleFNvdXJjZSkge1xuICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gIGNvbnN0IHZlcnRleFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U291cmNlKTtcbiAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTb3VyY2UpO1xuICBpZiAocHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvZ3JhbSBjcmVhdGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuXG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc3QgbG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XG4gICAgaWYgKGxvZyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtIGluZm8gbG9nIGNyZWF0aW9uIGZhaWxlZCcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcHJvZ3JhbTtcbn1cbiIsIlxuLyoqXG4gKiBSZWFycmFuZ2VzIGl0ZW1zIHNvIHRoYXQgYWxsIGl0ZW1zIGluIHRoZSBbbGVmdCwga10gYXJlIHRoZSBzbWFsbGVzdC5cbiAqIFRoZSBrLXRoIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSAoayAtIGxlZnQgKyAxKS10aCBzbWFsbGVzdCB2YWx1ZSBpbiBbbGVmdCwgcmlnaHRdLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1RbXX0gYXJyIHRoZSBhcnJheSB0byBwYXJ0aWFsbHkgc29ydCAoaW4gcGxhY2UpXG4gKiBAcGFyYW0ge251bWJlcn0gayBtaWRkbGUgaW5kZXggZm9yIHBhcnRpYWwgc29ydGluZyAoYXMgZGVmaW5lZCBhYm92ZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVmdD0wXSBsZWZ0IGluZGV4IG9mIHRoZSByYW5nZSB0byBzb3J0XG4gKiBAcGFyYW0ge251bWJlcn0gW3JpZ2h0PWFyci5sZW5ndGgtMV0gcmlnaHQgaW5kZXhcbiAqIEBwYXJhbSB7KGE6IFQsIGI6IFQpID0+IG51bWJlcn0gW2NvbXBhcmUgPSAoYSwgYikgPT4gYSAtIGJdIGNvbXBhcmUgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0ID0gMCwgcmlnaHQgPSBhcnIubGVuZ3RoIC0gMSwgY29tcGFyZSA9IGRlZmF1bHRDb21wYXJlKSB7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHQgPSBhcnJba107XG4gICAgICAgIGxldCBpID0gbGVmdDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUW119IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSB7bnVtYmVyfSBqXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgY29uc3QgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuIiwiaW1wb3J0IHF1aWNrc2VsZWN0IGZyb20gJ3F1aWNrc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUkJ1c2gge1xuICAgIGNvbnN0cnVjdG9yKG1heEVudHJpZXMgPSA5KSB7XG4gICAgICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG4gICAgfVxuXG4gICAgc2VhcmNoKGJib3gpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjb25zdCB0b0JCb3ggPSB0aGlzLnRvQkJveDtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1NlYXJjaCA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb2xsaWRlcyhiYm94KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5kYXRhO1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0aGlzLnRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc2NyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgY29uc3QgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5zZXJ0KGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLnRvQkJveChpdGVtKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgICAgIGxldCBpLCBwYXJlbnQsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRvQkJveChpdGVtKSB7IHJldHVybiBpdGVtOyB9XG5cbiAgICBjb21wYXJlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbiAgICBjb21wYXJlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfVxuXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYWxsKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKC4uLm5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9idWlsZChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIGNvbnN0IE4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICBsZXQgTSA9IHRoaXMuX21heEVudHJpZXM7XG4gICAgICAgIGxldCBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICBjb25zdCBOMiA9IE1hdGguY2VpbChOIC8gTSk7XG4gICAgICAgIGNvbnN0IE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKTtcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICBjb25zdCByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBfY2hvb3NlU3VidHJlZShiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBsZXQgbWluQXJlYSA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Tm9kZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIF9pbnNlcnQoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuICAgICAgICBjb25zdCBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRoaXMudG9CQm94KGl0ZW0pO1xuICAgICAgICBjb25zdCBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCkge1xuICAgICAgICBjb25zdCBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF07XG4gICAgICAgIGNvbnN0IE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfVxuXG4gICAgX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH1cblxuICAgIF9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBsZXQgbWluT3ZlcmxhcCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgY29uc3QgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXggfHwgTSAtIG07XG4gICAgfVxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSkge1xuICAgICAgICBjb25zdCBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblg7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWTtcbiAgICAgICAgY29uc3QgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpO1xuICAgICAgICBjb25zdCB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9XG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIGNvbnN0IHRvQkJveCA9IHRoaXMudG9CQm94O1xuICAgICAgICBjb25zdCBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpO1xuICAgICAgICBsZXQgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH1cblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAobGV0IGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jb25kZW5zZShwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAobGV0IGkgPSBrOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGIubWF4WCwgYS5tYXhYKSAtIE1hdGgubWluKGIubWluWCwgYS5taW5YKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgY29uc3QgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKTtcbiAgICBjb25zdCBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpO1xuICAgIGNvbnN0IG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIGNvbnN0IHN0YWNrID0gW2xlZnQsIHJpZ2h0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IE1hcCBmcm9tICdvbC9NYXAnO1xuaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNJztcbmltcG9ydCBUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVGlsZSc7XG5pbXBvcnQgVmlldyBmcm9tICdvbC9WaWV3JztcblxuY29uc3QgbWFwID0gbmV3IE1hcCh7XG4gICAgdGFyZ2V0OiAnbWFwJyxcbiAgICBsYXllcnM6IFtcbiAgICAgICAgbmV3IFRpbGVMYXllcih7XG4gICAgICAgICAgICBzb3VyY2U6IG5ldyBPU00oKSxcbiAgICAgICAgfSksXG4gICAgXSxcbiAgICB2aWV3OiBuZXcgVmlldyh7XG4gICAgICAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAgICB6b29tOiAyLFxuICAgIH0pLFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=